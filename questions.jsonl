{"id":1,"bad_solution":"import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\nfrom collections import defaultdict\ndef main():\n    n, *a = map(int, read().split())\n\n    maxa = max(a) + 1  # aはint配列\n    d = [i for i in range(maxa)]\n    for p0 in range(2, maxa):\n        if p0 == d[p0]:\n            for p1 in range(p0 ** 2, maxa, p0):\n                if d[p1] % p0 == 0:\n                    d[p1] = p0\n\n    def factorization(f):  # f > maxaだとエラー\n        l = []\n        t = f\n        while True:\n            if t == d[t]:\n                l.append(d[t])\n                break\n            else:\n                l.append(d[t])\n                t = t \/\/ d[t]\n        return l\n\n    if all([i == 1 for i in a]):\n        print('pairwise coprime')\n    d1 = defaultdict(int)\n    for ae in a:\n        t1 = set(factorization(ae))\n        for t1e in t1:\n            d1[t1e] += 1\n    d1v = tuple(d1.values())\n    if all([i == 1 for i in d1v]):\n        print('pairwise coprime')\n    elif max(d1v) == n:\n        print('not coprime')\n    else:\n        print('setwise coprime')\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":2,"bad_solution":"from bisect import bisect_right\nimport math\nN,D,A = map(int,input().split())\nX = sorted([list(map(int,input().split())) for _ in range(N)],key=lambda x:x[0])\nX.insert(0,[-1,-1])\ndef update(m,i,j,a):  #ノード値の更新 i<=x<j\n    l,r = T[m][0]\n    if r<=i or l>=j:\n        return \n    if i<=l and r<=j:\n        T[m][1] -= a*(r-l)\n    else:\n        update(2*m,i,j,a)\n        update(2*m+1,i,j,a)\ndef find(m,i):  #node[i]の評価\n    l,r = T[m][0]\n    if l==i and r==i+1:\n        return T[m][1]\n    if l<=i and r>=i+1:\n        T[2*m][1] += T[m][1]\/\/2\n        T[2*m+1][1] += T[m][1]\/\/2\n        T[m][1] = 0\n        l1,r1 = T[2*m][0]\n        if l1<=i and r1>=i+1:\n            return find(2*m,i)\n        else:\n            return find(2*m+1,i)\n\nk = 0\nn = N\nwhile 2**k<N:\n    k += 1\nN = 2**k  #一番下の層のノード数\nT = [[] for _ in range(2*N)]  #木の初期化　意図は1-origin\nfor i in range(N,2*N):\n    T[i] = [[i-(N-1),i-(N-1)+1],X[i-(N-1)][1] if i-(N-1)<n+1 else 0]  #区間の右端は含まない\nm = N\/\/2\nwhile m>0:\n    for i in range(m,2*m):\n        T[i] = [[T[2*i][0][0],T[2*i+1][0][1]],0]  #各ノードは区間とノードの値を持つ．\n    m = m\/\/2  #ルートはT[1]\nPos = [X[i][0] for i in range(n+1)]  \ncur = 1\ncnt = 0\nwhile cur<n+1:\n    x = X[cur][0]+D\n    k = math.ceil(X[cur][1]\/A)\n    indr = bisect_right(Pos,x+D)\n    cnt += k\n    update(1,cur,indr,k*A)\n    flag = 0\n    for i in range(cur,n+1):\n        X[i][1] = find(1,i)\n        if X[i][1]>0:\n            cur = i\n            flag = 1\n            break\n    if flag==0:break\nprint(cnt)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":3,"bad_solution":"def _main(N, M, K, A, B):\n    sum_k = 0.0\n    a_index = 0\n    A_len = len(A)\n    b_index = 0\n    B_len = len(B)\n    while sum_k < K:\n        current_a = A[a_index] if a_index < A_len else None\n        current_b = B[b_index] if b_index < B_len else None\n        if current_a is None and current_b is None:\n            break\n\n        has_a = current_b is None and current_a is not None\n        has_b = current_b is not None and current_a is None\n        if has_a:\n            if K < sum_k + current_a:\n                break\n            sum_k += current_a\n            a_index += 1\n        elif has_b:\n            if K < sum_k + current_b:\n                break\n            sum_k += current_b\n            b_index += 1\n        elif current_a < current_b:\n            if K < sum_k + current_a:\n                break\n            sum_k += current_a\n            a_index += 1\n        else:\n            if K < sum_k + current_b:\n                break\n            sum_k += current_b\n            b_index += 1\n\n    print(a_index + b_index)\n\n\nif __name__ == \"__main__\":\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    _main(N, M, K, A, B)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":4,"bad_solution":"def calc(n, N, x):\n    m, M = -1, -1\n    L, R = 0, 10**18\n    while L+1 < R:\n        P = (L+R)\/\/2\n        if n <= x*P:\n            R = P\n        else:\n            L = P\n    if n <= x*R <= N:\n        m = x*R\n    L, R = 0, 10**18\n    while L+1 < R:\n        P = (L+R)\/\/2\n        if N < x*P:\n            R = P\n        else:\n            L = P\n    if n <= x*L <= N:\n        M = x*L + (x-1)\n    return m, M\n\ndef main():\n    k = int(input())\n    a = list(map(int, input().split()))\n    f = True\n    m, M = 2, 2\n    for i in reversed(range(k)):\n        m, M = calc(m, M, a[i])\n        if m == -1 or M == -1:\n            f = False\n            break\n    if f:\n        print(m, M)\n    else:\n        print(-1)\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":5,"bad_solution":"import sys\n\ndef chk(i,j):\n    tmp=[p[i][k] for k in range(M)]\n    tmp[j]=p[i][j]+1\n    for k in range(M-1,-1,-1):\n        if tmp[k] > p[i+x[j]][k] :\n            p[i+x[j]]=[tmp[k] for k in range(M)]\n            return\n\nN,M=map(int,input().split())\nx=[0,2,5,5,4,5,6,3,7,6]\na=list(map(int,input().split()))\na.sort()\nb=[]\nfor i in range(M):\n    for j in range(M):\n        if x[a[j]]==x[a[i]]: tmp=j\n    b.append(a[tmp]) \n\na=list(set(b))\na.sort()\nM=len(a)\nx=[ x[a[i]] for i in range(M) ]\n\n\n\np=[[-100 for j in range(M)] for i in range(N+10)]\np[0]=[0 for j in range(M)]\n\nfor i in range(N+1):\n    if sum(p[i])>-1:\n        for j in range(M-1,-1,-1):\n            if sum(p[i])+1>sum(p[i+x[j]]):\n                p[i+x[j]] = [ p[i][k] for k in range(M) ]\n                p[i+x[j]][j]=p[i][j]+1\n\n            elif sum(p[i])+1==sum(p[i+x[j]]):\n                chk(i,j)\n\n\nfor i in range(M-1,-1,-1):\n    for j in range(p[N][i]):\n        print(a[i],end=\"\")\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":6,"bad_solution":"import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return map(int, input().split())\ndef MI1(): return map(int1, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print(k.join(list(map(str, lst))))\nINF = float('inf')\n# from math import ceil, floor, log2\nfrom collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\n\nfrom math import gcd\n\ndef solve():\n    N = II()\n    A = LI()\n    \n    mx = 1000003\n    D = [1] * mx\n    for i in range(2, mx):\n        if D[i] != 1:\n            continue\n        for j in range(i, mx, i):\n            if D[j] == 1:\n                D[j] = i\n    # print(D)\n    # print(D[4], D[6], D[35])\n\n    g = A[0]\n    # dct = defaultdict(int)\n    # flag = True\n    C = [0] * mx\n    for a in A:\n        g = gcd(g, a)\n        # print(a, D[a])\n        # if D[a] != 1:\n        #     if dct[D[a]] > 0:\n        #         flag = False\n        #     dct[D[a]] += 1\n        d = D[a]\n        C[d] += 1\n    # print(dct, flag, g)\n    # flag = False\n    if all(C[i] <= 1 for i in range(2, len(C))):\n        flag = True\n    else:\n        flag = False\n        \n    if g == 1:\n        if flag:\n            print('pairwise coprime')\n        else:\n            print('setwise coprime')\n    else:\n        print('not coprime')\n\n\nif __name__ == '__main__':\n    solve()\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":7,"bad_solution":"from typing import List\n\n\ndef FUNC(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> FUNC([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> FUNC([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = elem - elem2\n                if distance < threshold:\n                    return True\n\n    return False\n"}
{"id":8,"bad_solution":"def main():\n    import sys\n\n    H, W = map(int, sys.stdin.readline().split())\n    A = [list(map(int, sys.stdin.readline().split())) for i in range(H)]\n    B = [list(map(int, sys.stdin.readline().split())) for i in range(H)]\n    X = [[None] * W for i in range(H)]\n    for h in range(H):\n        for w in range(W):\n            X[h][w] = abs(A[h][w] - B[h][w])\n\n    dp = {}\n    dp[0] = set()\n    dp[0].add(X[0][0])\n    dp[0].add(-X[0][0])\n\n    for h in range(H):\n        for w in range(W):\n            if h == 0 and w == 0:\n                continue\n            x = X[h][w]\n            s = set()\n\n            if W * h + w > W - 1:\n                for d in dp[W * (h - 1) + w]:\n                    if d + x <= ((H - h) + (W - w)) * 79:\n                        s.add(d + x)\n                    if d - x >= -((H - h) + (W - w)) * 79:\n                        s.add(d - x)\n\n            if (W * h + w) % W != 0:\n                for d in dp[W * h + w - 1]:\n                    if d + x <= ((H - h) + (W - w)) * 79:\n                        s.add(d + x)\n                    if d - x >= -((H - h) + (W - w)) * 79:\n                        s.add(d - x)\n\n            dp[W * h + w] = s\n\n    ans = min([abs(s) for s in dp[W * H - 1]])\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":9,"bad_solution":"import sys\nfrom bisect import bisect_left\nsys.setrecursionlimit(10**7)\ndef lmi(): return list(map(int, input().split()))\n\nh, w = lmi()\ns = [input() for i in range(h)]\n\na = [[] for i in range(h)]\nal = [[] for i in range(h)]\nb = [[] for i in range(w)]\nbl = [[] for i in range(w)]\nfor i in range(h):\n    k = 0\n    for j in range(w):\n        if s[i][j] == '.':\n            k += 1\n            if j == w-1:\n                a[i].append(k)\n                al[i].append(j)\n        else:\n            if j != 0:\n                a[i].append(k)\n                al[i].append(j-1)\n                k = 0\n\nfor i in range(w):\n    k = 0\n    for j in range(h):\n        if s[j][i] == '.':\n            k += 1\n            if j == h-1:\n                b[i].append(k)\n                bl[i].append(j)\n        else:\n            if j != 0:\n                b[i].append(k)\n                bl[i].append(j-1)\n                k = 0\n'''\nprint(a)\nprint(al)\nprint(b)\nprint(bl)\n'''\n\nans = 0\nfor i in range(h):\n    for j in range(w):\n        if s[i][j] == '.':\n            c = a[i][bisect_left(al[i], j)]\n            d = b[j][bisect_left(bl[j], i)]\n            #print(c,d)\n            ans = max(ans, c+d-1)\n\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":10,"bad_solution":"\ndef main():\n    H, W = map(int, input().split()) # 横に2個\n    state = [[0 if a == '.' else 1 for a in list(input())] for _ in range(H)]\n\n    checked = [[False for _ in range(W+1)] for _ in range(H+1)]\n    qs = []\n    for h in range(H):\n        for w in range(W):\n            if state[h][w] == 1:\n                qs.append([h, w])\n                checked[h][w] = True\n    for h in range(H+1):\n        checked[h][W] = True\n    for w in range(W+1):\n        checked[H][w] = True\n\n    c = 0\n    while qs:\n        qqs = []\n        for h,w in qs:\n            checked[h][w] = True\n            if 0 < h and not checked[h-1][w]:\n                qqs.append([h-1, w])\n            if h < H-1 and not checked[h+1][w]:\n                qqs.append([h+1, w])\n            if 0 < w and not checked[h][w-1]:\n                qqs.append([h, w-1])\n            if w < W-1 and not checked[h][w+1]:\n                qqs.append([h, w+1])\n        if not qqs:\n            break\n        c += 1\n        qs = qqs\n\n    print(c)\n\nif __name__=='__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":11,"bad_solution":"import sys\nimport numpy as np\nfrom numba import njit\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nINF = 10**9 + 1\n\nN, M = map(int, readline().split())\ndata = np.array(read().split(), np.int64)\nA = data[::3]\nB = data[1::3]\nC = data[2::3]\n\nD = A[N:]\nE = B[N:]\nF = C[N:]\nA = A[:N]\nB = B[:N]\nC = C[:N]\n\nX = np.unique(np.concatenate([A, B, D, [0, -INF, INF]]))\nY = np.unique(np.concatenate([C, E, F, [0, -INF, INF]]))\nDX = X[1:] - X[:-1]\nDY = Y[1:] - Y[:-1]\n\nA = np.searchsorted(X, A)\nB = np.searchsorted(X, B)\nC = np.searchsorted(X, C)\nD = np.searchsorted(X, D)\nE = np.searchsorted(X, E)\nF = np.searchsorted(X, F)\n\nH, W = len(X), len(Y)\nN = H * W\n\n@njit\ndef set_ng(A, B, C, D, E, F):\n    p = 0\n    ng = np.zeros((N, 4), np.bool_)\n\n    for i in range(len(A)):\n        a, b, c = A[i], B[i], C[i]\n        for x in range(a, b):\n            v = x * W + c\n            ng[v][1] = 1\n            ng[v - 1][0] = 1\n\n    for i in range(len(D)):\n        d, e, f = D[i], E[i], F[i]\n        for y in range(e, f):\n            v = d * W + y\n            ng[v][3] = 1\n            ng[v - W][2] = 1\n    return ng\n\nng = set_ng(A, B, C, D, E, F)\n\nx0, y0 = np.searchsorted(X, 0), np.searchsorted(Y, 0)\nv0 = x0 * W + y0\n\n@njit\ndef solve():\n    visited = np.zeros(N, np.bool_)\n    visited[v0] = 1\n    stack = np.empty(N, np.int32)\n    p = 0\n    ret = 0\n\n    def area(x):\n        x, y = divmod(x, W)\n        return DX[x] * DY[y]\n\n    def push(x):\n        nonlocal p, ret\n        stack[p] = x\n        visited[x] = 1\n        ret += area(x)\n        p += 1\n\n    def pop():\n        nonlocal p\n        p -= 1\n        return stack[p]\n\n    push(v0)\n    move = [1, -1, W, -W]\n    while p:\n        v = pop()\n        for i in range(4):\n            if ng[v][i]:\n                continue\n            w = v + move[i]\n            if visited[w]:\n                continue\n            x, y = divmod(w, W)\n            if x == 0 or x == H - 1 or y == 0 or y == W - 1:\n                return 0\n            push(w)\n    return ret\n\nx = solve()\nif x == 0:\n    print('INF')\nelse:\n    print(x)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":12,"bad_solution":"#!\/usr\/bin\/env python3\n# vim: set fileencoding=utf-8\n\n# pylint: disable=unused-import, invalid-name, missing-docstring, bad-continuation\n\n\n\"\"\"Module docstring\n\"\"\"\n\nimport functools\nimport heapq\nimport itertools\nimport logging\nimport math\nimport random\nimport string\nimport sys\nfrom argparse import ArgumentParser\nfrom collections import defaultdict, deque\nfrom copy import deepcopy\nfrom typing import Dict, List, Optional, Set, Tuple\n\n\ndef solve(values: List[int], nb: int) -> int:\n    seen = {}\n    cur = 0\n    move = 0\n    while move < nb and cur not in seen:\n        seen[cur] = move\n        move += 1\n        cur = values[cur] - 1\n    if move == nb:\n        return cur\n    cycle_length = move - seen[cur]\n    _nb_cycles, rest = divmod(nb - move, cycle_length)\n    LOG.debug((cur, cycle_length, move, seen))\n    for _ in range(rest):\n        cur = values[cur] - 1\n    return cur + 1\n\n\ndef do_job():\n    \"Do the work\"\n    LOG.debug(\"Start working\")\n    N, K = map(int, input().split())\n    values = list(map(int, input().split()))\n    assert len(values) == N\n    result = solve(values, K)\n    print(result)\n\n\ndef print_output(testcase: int, result) -> None:\n    \"Formats and print result\"\n    if result is None:\n        result = \"IMPOSSIBLE\"\n    print(\"Case #{}: {}\".format(testcase + 1, result))\n    # 6 digits float precision {:.6f} (6 is the default value)\n    # print(\"Case #{}: {:f}\".format(testcase + 1, result))\n\n\ndef configure_log() -> None:\n    \"Configure the log output\"\n    log_formatter = logging.Formatter(\"%(lineno)d - \" \"%(message)s\")\n    handler = logging.StreamHandler(sys.stdout)\n    handler.setFormatter(log_formatter)\n    LOG.addHandler(handler)\n\n\nLOG = None\n# for interactive call: do not add multiple times the handler\nif not LOG:\n    LOG = logging.getLogger(\"template\")\n    configure_log()\n\n\ndef main(argv=None):\n    \"Program wrapper.\"\n    if argv is None:\n        argv = sys.argv[1:]\n    parser = ArgumentParser()\n    parser.add_argument(\n        \"-v\",\n        \"--verbose\",\n        dest=\"verbose\",\n        action=\"store_true\",\n        default=False,\n        help=\"run as verbose mode\",\n    )\n    args = parser.parse_args(argv)\n    if args.verbose:\n        LOG.setLevel(logging.DEBUG)\n    do_job()\n    return 0\n\n\nif __name__ == \"__main__\":\n    import doctest\n\n    doctest.testmod()\n    sys.exit(main())\n\n\nclass memoized:\n    \"\"\"Decorator that caches a function's return value each time it is called.\n    If called later with the same arguments, the cached value is returned, and\n    not re-evaluated.\n    \"\"\"\n\n    def __init__(self, func):\n        self.func = func\n        self.cache = {}\n\n    def __call__(self, *args):\n        try:\n            return self.cache[args]\n        except KeyError:\n            value = self.func(*args)\n            self.cache[args] = value\n            return value\n        except TypeError:\n            # uncachable -- for instance, passing a list as an argument.\n            # Better to not cache than to blow up entirely.\n            return self.func(*args)\n\n    def __repr__(self):\n        \"\"\"Return the function's docstring.\"\"\"\n        return self.func.__doc__\n\n    def __get__(self, obj, objtype):\n        \"\"\"Support instance methods.\"\"\"\n        return functools.partial(self.__call__, obj)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":13,"bad_solution":"\n\ndef submit():\n    n = int(input())\n    alist = list(map(int, input().split()))\n    blist = list(map(int, input().split()))\n\n\n    # 順番にグリーディ\n    a = alist.copy()\n    b = blist.copy()\n    score_a = 0\n    for i in range(0, n):\n        if a[i] < b[i]:\n            score_a += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        else:\n            score_a += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n\n        if a[i + 1] < b[i]:\n            score_a += a[i + 1]\n            b[i] -= a[i + 1]\n            a[i + 1] = 0\n        else:\n            score_a += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n\n    # 逆順にグリーディ\n    a = alist.copy()\n    a.reverse()\n    b = alist.copy()\n    b.reverse()\n    score_b = 0\n    for i in range(0, n):\n        if a[i] < b[i]:\n            score_b += a[i]\n            b[i] -= a[i]\n            a[i] = 0\n        else:\n            score_b += b[i]\n            a[i] -= b[i]\n            b[i] = 0\n\n        if a[i + 1] < b[i]:\n            score_b += a[i + 1]\n            b[i] -= a[i + 1]\n            a[i + 1] = 0\n        else:\n            score_b += b[i]\n            a[i + 1] -= b[i]\n            b[i] = 0\n\n    print(max(score_a, score_b))\n    \n\nif __name__ == '__main__':\n    submit()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":14,"bad_solution":"\"\"\" B\n    https:\/\/atcoder.jp\/contests\/abc175\/tasks\/abc175_b\n\"\"\"\nimport sys\nimport math\nfrom functools import reduce\nfrom bisect import bisect_left\n\ndef readString():\n    return sys.stdin.readline()\n\ndef readInteger():\n    return int(readString())\n\ndef readStringSet(n):\n    return sys.stdin.readline().split(\" \")[:n]\n\ndef readIntegerSet(n):\n    return list(map(int, readStringSet(n)))\n\ndef readIntegerMatrix(n, m):\n    return [readIntegerSet(m) for _ in range(0, n)]\n\ndef main(T, S):\n    best = sys.maxsize\n    for i in range(len(T)-len(S)):\n        s = T[i:i+len(S)]\n        count = 0\n        for j in range(len(S)):\n            if s[j] != S[j]:\n                count += 1\n        if best > count:\n            best = count\n    return best\n\n\nif __name__ == \"__main__\":\n    _T = readString().rstrip()\n    _S = readString().rstrip()\n\n    print(main(_T, _S))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":15,"bad_solution":"from collections import deque,defaultdict\nimport bisect\nN = int(input())\nS = [input() for i in range(N)]\n\ndef bend(s):\n    res = 0\n    k = 0\n    for th in s:\n        if th == '(':\n            k += 1\n        else:\n            k -= 1\n        res = min(k,res)\n    return res\n\nspecies = [(bend(s),s.count('(')-s.count(')')) for s in S]\n\nups = [(b,u) for b,u in species if u > 0]\nflats = [(b,u) for b,u in species if u == 0]\ndowns = [(b,u) for b,u in species if u < 0]\n\n\nups.sort()\ndowns.sort()\nhigh = 0\nfor b,u in ups[::-1]:\n    if high + b < 0:\n        print('No')\n        exit()\n    high += u\n\nfor b,u in flats:\n    if high + b < 0:\n        print('No')\n        exit()\n\nfor b,u in downs[::-1]:\n    if high + b < 0:\n        print('No')\n        exit()\n    high += u\n\nif high == 0:\n    print('Yes')\nelse:\n    print('No')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":16,"bad_solution":"import sys\nfrom collections import *\nimport heapq\nimport math\nimport bisect\nfrom itertools import permutations,accumulate,combinations,product\nfrom fractions import gcd\nimport copy\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\nmod=pow(10,9)+7\n\nn=int(input())\ns=input()\nq=int(input())\nquery=[list(input().split()) for i in range(q)]\n\n\nlst={}\nfor i in range(n):\n    if not s[i] in lst:\n        lst[s[i]]=[i]\n    else:\n        lst[s[i]].append(i)\nerase={}\ninsert={}\n# print(lst)\nal=[chr(ord('a') + i) for i in range(26)]\nfor i in range(q):\n    if query[i][0]==\"1\":\n        one,i2,c=query[i]\n        if not s[i] in erase:\n            erase[s[i]]=[int(i2)]\n        else:\n            erase[s[i]].append(int(i2))\n        if not c in insert:\n            insert[c]=[int(i2)]\n        else:\n            insert[c].append(int(i2))\n    else:\n        two,l,r=query[i]\n        ans=0\n        l=int(l)\n        r=int(r)\n        for i in range(26):\n            tmp=0\n            if al[i] in lst:\n                tmp+=bisect.bisect_right(lst[al[i]],r-1)-bisect.bisect_left(lst[al[i]],l-1)\n            if al[i] in erase:\n                tmp-=bisect.bisect_right(erase[al[i]],r-1)-bisect.bisect_left(erase[al[i]],l-1)\n            if al[i] in insert:\n                tmp+=bisect.bisect_right(insert[al[i]],r-1)-bisect.bisect_left(insert[al[i]],l-1)\n            if tmp>0:\n                ans+=1\n        print(ans)\n    # print(erase)\n    # print(insert)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":17,"bad_solution":"n,a,b=map(int,input().split())\n\nmod=10**9+7\n\nJ=pow(2,n)%mod\ndef find_power(n,mod):\n    # 0!からn!までのびっくりを出してくれる関数(ただし、modで割った値に対してである）\n    powlist=[0]*(n+1)\n    powlist[0]=1\n    powlist[1]=1\n    for i in range(2,n+1):\n        powlist[i]=powlist[i-1]*i%(mod)\n    return powlist\n\ndef find_inv_power(n):\n    #0!からn!までの逆元を素数10**9+7で割ったあまりリストを作る関数\n    powlist=find_power(n,10**9+7)\n    check=powlist[-1]\n    first=1\n    uselist=[0]*(n+1)\n    secondlist=[0]*30\n    secondlist[0]=check\n    secondlist[1]=check**2\n    for i in range(28):\n        secondlist[i+2]=(secondlist[i+1]**2)%(10**9+7)\n    a=format(10**9+5,\"b\")\n    for j in range(30):\n        if a[29-j]==\"1\":\n            first=(first*secondlist[j])%(10**9+7)\n    uselist[n]=first\n    for i in range(n,0,-1):\n        uselist[i-1]=(uselist[i]*i)%(10**9+7)\n    return uselist\n\nC=find_inv_power(2*10**5+100)\nif  True:\n    c=1\n    for i in range(a):\n        c*=(n-i)\n        c=c%mod\n    c=c*C[a]\n    c=c%mod\n    d=1\n    for i in range(b):\n        d*=(n-i)\n        d=d%mod\n    d=d%mod\n    d=d*C[b]\n    print((J-c-d)%mod)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":18,"bad_solution":"import sys\nimport math\nfrom collections import defaultdict, deque, Counter\nfrom copy import deepcopy\nfrom bisect import bisect, bisect_right, bisect_left\nfrom heapq import heapify, heappop, heappush\n    \ninput = sys.stdin.readline\ndef RD(): return input().rstrip()\ndef F(): return float(input().rstrip())\ndef I(): return int(input().rstrip())\ndef MI(): return map(int, input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return tuple(map(int, input().split()))\ndef LF(): return list(map(float,input().split()))\ndef Init(H, W, num): return [[num for i in range(W)] for j in range(H)]\n    \n    \ndef main():\n    N = I()\n    mylist = LI()\n    max_num = max(mylist)\n    max_num2 = round(math.sqrt(max_num))\n    D = [True]* (max_num+1)\n    mylist = set(mylist)\n    setwise = True\n    pairwise = True\n\n    for i in range(2, max_num2+1):\n        temp = 0\n        if D[i]:\n            for j in range(i, max_num+1, i):\n                D[j] = False\n                if j in mylist:\n                    temp+=1\n        if temp == N:\n            print(\"not coprime\")\n            \n            sys.exit()\n        if temp >= 2:\n            pairwise = False\n\n    if pairwise:\n        print(\"pairwise coprime\")\n    else:\n        print(\"setwise coprime\")\n                    \n\n            \n    \n    \nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":19,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nINF = 2**62-1\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef dc(n, m):\n    return -(-n \/\/ m)\n\n@mt\ndef slv(H, N, AB):\n\n    dp = [INF] * (H+1)\n    dp[0] = 0\n    for a, b in AB:\n        for h, bb in enumerate(dp):\n            if bb == INF:\n                continue\n            n = min(H, h+a)\n            dp[n]  = min(dp[n], bb+b)\n    return dp[-1]\n\n\ndef main():\n    H, N = read_int_n()\n    AB = [read_int_n() for _ in range(N)]\n    print(slv(H, N, AB))\n    # H = 10**4\n    # N = 10\n    # AB = [[random.randint(1, 100), random.randint(1, 100)] for _ in range(N)]\n    # print(slv(H, N, AB))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":20,"bad_solution":"import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\n \ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef S_MAP(): return map(str, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef S_LIST(): return list(map(str, input().split()))\n \nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\na, b = MAP()\n\n# x = a * 0.92\n# y = b \/ 0.90\n# print(x, y)\nx1 = a \/ 0.08\ny1 = b \/0.1\nx2 = (a+1) \/ 0.08\ny2 = (b+1) \/0.1\n\nif ceil(y1) <= int(x1) < y2:\n    ans = int(x1)\n    print(ans)\nelif ceil(x1) <= int(y1) < x2:\n    ans = int(y1)\n    print(ans)\nelse:\n    print(-1)\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":21,"bad_solution":"# \/usr\/bin\/python3\n# -*- coding: utf-8 -*-\nfrom queue import Queue\nfrom queue import LifoQueue as Stack\nfrom math import sqrt\nfrom fractions import gcd\nfrom itertools import permutations\n\ndef lcm(a, b):\n    return (a*b) \/\/ gcd(a,b)\n\ndef intinput():\n    return int(input())\n\ndef mulinputs():\n    return map(int,input().split())\n\ndef lineinputs(func=intinput):\n    datas = []\n    while True:\n        try:\n            datas.append(func())\n        except EOFError:\n            break\n    return datas\n\n\n\nN = intinput()\n# S = input()\n# A, B, C, D, E, F = mulinputs()\ndatas = list(mulinputs())\n# datas = lineinputs(input)\n\nM = 1001000\ncnt = 0\nl = len(datas)\nfor i in range(0,N):\n    is_clear = True\n    for j in range(0,(i+1)>>1):\n        dp0 = datas[2*j] if 2*j < l else M\n        dp1 = datas[2*j+1] if 2*j < l else M\n        if dp0 < datas[i]:\n            is_clear = False\n            break\n        if dp1 < datas[i]:\n            is_clear = False\n            break\n    if is_clear:\n        cnt += 1\n\n# 出力\nprint(cnt)\n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":22,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nimport math\n\nINF = 1e+11\nA,B,Q=map(int, input().split())\ns = [[0] for _ in range(A+2)]\nt = [[0] for _ in range(B+2)]\ns[0]=-INF\nt[0]=-INF\nfor i in range(A):\n    s[i+1]=int(input())\nfor i in range(B):\n    t[i+1]=int(input())\ns[A+1]=INF\nt[B+1]=INF\nx = [int(input()) for _ in range(Q)]\n\ndef BySearch(a,x):\n    right = len(a)-1\n    left = 0\n    while right - left > 1:\n        tmp = (right+left)\/\/2\n        if a[tmp] <= x:\n            left = tmp\n        else:\n            right = tmp\n    if abs(a[right]-x) < abs(a[left]-x): return right\n    else: return left\n        \n\nfor i in range(Q):\n    ans = INF\n    for j in range(2):\n        if j == 0:\n            a = s\n            b = t\n        else:\n            a = t\n            b = s\n        ax = a[BySearch(a,x[i])]\n        bx = b[BySearch(b,ax)]\n        ans = min(abs(ax-x[i])+abs(bx-ax),ans)\n    print(ans)\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":23,"bad_solution":"#!\/usr\/bin\/env python\n# -*- coding: utf-8 -*-\nimport collections\n\n\nclass Node(object):\n\n  def __init__(self):\n    self.edges = set()\n    self.distance = 1\n\n\ndef main():\n  N = int(input())\n  nodes = [Node() for _ in range(N)]\n\n  if N == 0:\n    print('Second', flush=True)\n    return\n  elif N == 1:\n    print('First', flush=True)\n    return\n\n  for _ in range(N - 1):\n    a, b = map(int, input().split())\n    nodes[a - 1].edges.add(nodes[b - 1])\n    nodes[b - 1].edges.add(nodes[a - 1])\n\n  leaves = collections.deque(n for n in nodes if len(n.edges) == 1)\n\n  while True:\n    leaf = leaves.pop()\n    parent = leaf.edges.pop()\n\n    if len(parent.edges) == 1:\n      size = leaf.distance + parent.distance\n      break\n\n    parent.distance = max(parent.distance, leaf.distance + 1)\n    parent.edges.remove(leaf)\n\n    if len(parent.edges) == 1:\n      leaves.append(parent)\n\n  if size % 3 == 2:\n    print('Second', flush=True)\n  else:\n    print('First', flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":24,"bad_solution":"from collections import Counter\n\ndef find_key_from_value(input_dict, target_value):\n  return  [key for key, value in input_dict.items() if value == target_value][0]\n\nN = int(input())\nV= list(map(int,input().split()))\neve, odd  = Counter([V[i] for i in range(0,N,2)]), Counter([V[i] for i in range(1,N,2)])\n\neve_key = find_key_from_value(eve, max(eve.values()))\nodd_key = find_key_from_value(odd, max(odd.values()))\n\nif eve_key == odd_key: print(eve[eve_key])\nelse: print(N-eve[eve_key]-odd[odd_key])\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":25,"bad_solution":"def rev(a):\n    L = []\n    for i in range(N):\n        L.append(a % 3)\n        a \/\/= 3\n    return int(\"\".join(map(str, L)), 3)\n    \ndef salsa():\n    lazy[0] *= -1\n\ndef rumba():\n    i = 0\n    for k in range(N):\n        if lazy[i] < 0:\n            lazy[3*i+1] *= -1\n            lazy[3*i+2] *= -1\n            lazy[3*i+3] *= -1\n            lazy[i] = 1\n            value[3*i+1] ^= 3\n            value[3*i+2] ^= 3\n            value[3*i+3] ^= 3\n        value[3*i+1] += 1\n        value[3*i+2] += 1\n        value[3*i+3] += 1\n        value[3*i+1] %= 3\n        value[3*i+2] %= 3\n        value[3*i+3] %= 3\n        i = 3 * i + (1 if value[3*i+1] == 0 else 2 if value[3*i+2] == 0 else 3)\n\ndef calcall():\n    a = 1\n    i = 0\n    for k in range(1, N + 1):\n        for _ in range(3 ** k):\n            i += 1\n            if lazy[(i-1)\/\/3] < 0:\n                lazy[i] *= -1\n                if value[i]: value[i] ^= 3\n            value[i] = value[i] * a + value[(i-1) \/\/ 3]\n        a *= 3\n        \nN = int(input())\nNN = 3 ** (N + 1) \/\/ 2\nvalue = [(i-1) % 3 if i else 0 for i in range(NN)]\nlazy = [1 for i in range(NN)]\n\nfor t in input():\n    if t == \"R\":\n        rumba()\n    else:\n        salsa()\n\ncalcall()\n\nANS = [0] * (3 ** N)\nfor i in range(3 ** N):\n    ANS[rev(i)] = value[i + (NN - 1) \/\/ 3]\n\nprint(*ANS)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":26,"bad_solution":"from typing import List\n\n\ndef FUNC(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> FUNC('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"\n    result = []\n    current_string = []\n    current_depth = 0\n\n    for c in paren_string:\n        if c == '(':\n            current_depth += 1\n            current_string.append(c)\n        elif c == ')':\n            current_depth -= 1\n            current_string.append(c)\n\n            if current_depth < 0:\n                result.append(''.join(current_string))\n                current_string.clear()\n\n    return result\n"}
{"id":27,"bad_solution":"from collections import defaultdict\n\n\ndef solve():\n    n = int(input())\n    v = list(map(int, input().split()))\n    evens = v[::2]\n    odds = v[1::2]\n    d_even, d_odd = defaultdict(int), defaultdict(int)\n    for e in evens:\n        d_even[e] += 1\n    for o in odds:\n        d_odd[o] += 1\n\n    # if top_e != top_o:\n    #   (e1, o1)\n    # else:\n    #   (e1, o2) or (e2, o1)\n    d_even = sorted(d_even.items(), key=lambda x: x[1])\n    d_odd = sorted(d_odd.items(), key=lambda x: x[1])\n    if d_even[0][0] != d_odd[0][0]:\n        return n - (d_even[0][1] + d_odd[0][1])\n    else:\n        if len(d_even) == len(d_odd) == 1:\n            return n \/\/ 2\n        if len(d_odd) > 1 and len(d_even) > 1:\n            cand1 = d_even[0][1] + d_odd[1][1]\n            cand2 = d_even[1][1] + d_odd[0][1]\n            c = max(cand1, cand2)\n        elif len(d_odd) > 1:\n            c = d_even[0][1] + d_odd[1][1]\n        elif len(d_even) > 1:\n            c = d_even[1][1] + d_odd[0][1]\n        else:\n            return n \/\/ 2\n        return n - c\n\n\nif __name__ == \"__main__\":\n    print(solve())\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":28,"bad_solution":"\n\ndef FUNC(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n\n    Return the decimal part of the number.\n    >>> FUNC(3.5)\n    0.5\n    \"\"\"\n    return number % 1.0 + 1.0\n"}
{"id":29,"bad_solution":"import heapq\nclass pqheap:\n    def __init__(self):\n        self.p = list()\n        self.q = list()\n    def insert(self,x):\n        heapq.heappush(self.p, x)\n        return\n    def erase(self,x):\n        heapq.heappush(self.q, x)\n        return\n    def minimum(self):\n        while self.q and self.p[0] == self.q[0]:\n            heapq.heappop(self.p)\n            heapq.heappop(self.q)\n        return self.p[0]\n#print(a)\ndef main(a,b):\n    for i in range(n):\n        if b[i]<=a[i]:\n            pass\n        else:\n            print(-1)\n            exit()\n    pq=pqheap()\n    [pq.insert([-x,i]) for i,x in enumerate(a)]\n    ans=0\n    while len(pq.p)>len(pq.q):\n        m=pq.minimum()\n        pq.erase(m)\n        v,i=m\n        v=-v\n        vv=v\n        v-=b[i]\n        tmp=a[(i-1)%n]+a[(i+1)%n]\n        ans+=v\/\/tmp\n        v%=tmp\n        v+=b[i]\n        a[i]=v\n        if v==b[i]:continue\n        elif vv<=v or v<b[i]:\n            print(-1)\n            exit()\n        pq.insert([-v,i])\n    print(ans)\nif __name__=='__main__':\n    n=int(input())\n    b=list(map(int,input().split()))\n    a=list(map(int,input().split()))\n    main(a,b)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":30,"bad_solution":"import sys\n \nsys.setrecursionlimit(10**7)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n \ndef II(): return int(sys.stdin.readline())\ndef LS(): return list(map(list, sys.stdin.readline().split()))\ndef S(): return sys.stdin.readline()[:-1]\n \ndef main():\n    n = II()\n    s = S()\n    inf = n + 2\n    m = [[0 for i in range(n)] for i in range(n)]\n    first = [[inf for i in range(n)] for i in range(n)]\n    # set 1st index value\n    lcs = 0\n    for i, c in enumerate(s):\n        # print(c, s[0])\n        if c == s[0]:\n            m[i][0] = 1\n            first[i][0] = i\n            if i != 0:\n                lcs = 1\n    for i in range(1, n):\n        for j in range(1, n):\n            if i <= j:\n                continue\n            if s[i] == s[j]:\n                if first[i-1][j-1] > j:\n                    m[i][j] = m[i-1][j-1] + 1\n                    lcs = max(m[i][j], lcs)\n                    if first[i-1][j-1] == inf:\n                        first[i][j] = i\n                    else:\n                        first[i][j] = first[i-1][j-1]\n            else:\n                m[i][j] = 0\n \n    # print(m)\n    print(lcs)\n \n \nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":31,"bad_solution":"from typing import List\n\n\ndef FUNC(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> FUNC([1, 2, 3])\n    False\n    >>> FUNC([1, 2, -4, 5])\n    True\n    \"\"\"\n    balance = 0\n\n    for op in operations:\n        balance += op\n        if balance == 0:\n            return True\n\n    return False\n"}
{"id":32,"bad_solution":"# coding: utf-8\nimport sys\nfrom operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\nfrom heapq import heappop, heappush\n#from collections import defaultdict\nsys.setrecursionlimit(10**7)\n#import math\n#from itertools import combinations, product\n#import bisect# lower_bound etc\n#import numpy as np\n#import queue# queue,get(), queue.put()\ndef run():\n    N = int(input())\n    current = 0\n    ways = []\n    dic = {'(': 1, ')': -1}\n    for _ in range(N):\n        S = input()\n        go = 0\n        max_depth = 0\n        for s in S:\n            go += dic[s]\n            max_depth = min(max_depth, go)\n        ways.append((go, max_depth))\n\n\n\n    ways = sorted(ways, key=lambda x:x[0], reverse=True)\n\n    while ways:\n        done = False\n        for idx, (go, max_depth) in enumerate(ways):\n            if current + max_depth >= 0:\n                if go < 0:\n                    break\n                current += go\n                del ways[idx]\n                done = True\n        if not done:\n            break\n\n    ways = [(-a, b) for a, b in ways]\n    ways = sorted(ways, key = itemgetter(1,0))\n\n    while ways and current >= 0:\n        done = False\n        for idx, (go, max_depth) in enumerate(ways):\n            if go <= 0:\n                print('No')\n                return None\n            if current + max_depth >= 0:\n                current -= go\n                del ways[idx]\n                done = True\n        if not done:\n            print('No')\n            return None\n\n\n    if current == 0:\n        print('Yes')\n    else:\n        print('No')\n\nif __name__ == \"__main__\":\n    run()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":33,"bad_solution":"from typing import List\n\n\ndef FUNC(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> FUNC([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"\n    mean = sum(numbers) \/ len(numbers)\n    return sum(abs(x - mean) for x in numbers) \/ mean\n"}
{"id":34,"bad_solution":"#!\/usr\/bin\/env python3\n\nfrom collections import defaultdict\nfrom heapq import heappush, heappop\nimport sys\nimport bisect\n\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.buffer.readline\n# INF = sys.maxsize\nINF = 10 ** 10\n# INF = float(\"inf\")\n\n\ndef dp(*x):  # debugprint\n    print(*x)\n\n\nf = open(sys.argv[1])\ninput = f.buffer.readline\n\nN, M = map(int, input().split())\nvlines = defaultdict(list)\nhlines = defaultdict(list)\nvticks = {0}\nhticks = {0}\n\nfor i in range(N):\n    A, B, C = map(int, input().split())\n    vlines[C].append((A, B))\n    hticks.add(C)\n    vticks.update((A, B))\n\nfor i in range(M):\n    D, E, F = map(int, input().split())\n    hlines[D].append((E, F))\n    vticks.add(D)\n    hticks.update((E, F))\n\nvticks = [-INF] + list(sorted(vticks)) + [INF]\nhticks = [-INF] + list(sorted(hticks)) + [INF]\n\n\ndef up(y):\n    return vticks[bisect.bisect_left(vticks, y) - 1]\n\n\ndef down(y):\n    return vticks[bisect.bisect_left(vticks, y) + 1]\n\n\ndef left(x):\n    return hticks[bisect.bisect_left(hticks, x) - 1]\n\n\ndef right(x):\n    return hticks[bisect.bisect_left(hticks, x) + 1]\n\n\ndef area(x, y):\n    i = bisect.bisect_left(hticks, x)\n    width = hticks[i + 1] - hticks[i]\n    j = bisect.bisect_left(vticks, y)\n    height = vticks[j + 1] - vticks[j]\n    return width * height\n\n\ntotal_area = 0\nvisited = set()\n\n\ndef visit(x, y):\n    global total_area\n    if (x, y) in visited:\n        return\n    # dp(\"visited: x,y\", x, y)\n    a = area(x, y)\n    total_area += a\n    visited.add((x, y))\n    # visit neighbors\n    l = left(x)\n    if (l, y) not in visited:\n        for a, b in vlines[x]:\n            if a <= y < b:\n                # blocked\n                break\n        else:\n            # can move left\n            to_visit.append((l, y))\n\n    u = up(y)\n    if (x, u) not in visited:\n        for a, b in hlines[y]:\n            if a <= x < b:\n                # blocked\n                break\n        else:\n            # can move up\n            to_visit.append((x, u))\n\n    r = right(x)\n    if (r, y) not in visited:\n        for a, b in vlines[r]:\n            if a <= y < b:\n                # blocked\n                break\n        else:\n            # can move left\n            to_visit.append((r, y))\n\n    d = down(y)\n    if (x, d) not in visited:\n        for a, b in hlines[d]:\n            if a <= x < b:\n                # blocked\n                break\n        else:\n            # can move up\n            to_visit.append((x, d))\n\n\n# for y in [up(0), 0]:\n#     for x in [left(0), 0]:\n#         visit(x, y)\n# print(total_area)\nto_visit = [(0, 0)]\nwhile to_visit:\n    x, y = to_visit.pop()\n    if x == INF or x == -INF or y == INF or y == -INF:\n        print(\"INF\")\n        break\n    visit(x, y)\nelse:\n    print(total_area)\n\n\ndef _test():\n    import doctest\n    doctest.testmod()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":35,"bad_solution":"# E\n\nN=int(input())\nA=list(map(int,input().split()))\n\ndef gcd(a,b):\n    if a>b:\n        a,b=b,a\n    while a%b:\n        a,b=b,(a%b)\n    return b\n\ndef fast_factorization_init(N):\n    res=list(range(N))\n    for i in range(2,N):\n        if i*i>N:\n            break\n        for j in range(i*i,N,i):\n            if res[j]==j:\n                res[j]=i\n        if res[i]<i:\n            continue\n    return res            \n    \nmin_factors=fast_factorization_init(10**6+10)\ndef fast_factorization(n):\n    res=[]\n    while n>1:\n        res.append(min_factors[n])\n        n\/\/=min_factors[n]\n    return res\n\nres2=1\nP=[]\nfor i in range(N):\n    if i!=0:\n        res1=gcd(A[i],res1)\n    else:\n        res1=A[0]\n    fact=fast_factorization(A[i])\n    if res2!=0:\n        for p in P:\n            if A[i]%p==0:\n                res2=0\n                break\n    for p in fact:\n        P.append(p)\nif res2==1:\n    print('pairwise coprime')\nelif res1==1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":36,"bad_solution":"from heapq import heappush, heappop\nfrom collections import defaultdict\n\nN, K = map(int, input().split())\nTD = [list(map(int, input().split())) for _ in range(N)]\n\nDT = [[d, t] for t, d  in TD]\nDT.sort(reverse = True)\n#print(DT)\n\nh_in = []\ncnt = defaultdict(int)\n\ntmp = []\nkiso = 0\nfor d, t in DT:\n    if cnt[t] == 0:\n        heappush(h_in, [d, t])\n        kiso += d\n    else:\n        tmp.append([d, t])\n    cnt[t] += 1\n\ntmp = tmp[::-1]\nlen_h_in = len(h_in)\nif len_h_in < K:\n    d = K - len_h_in\n    for i in range(d):\n        heappush(h_in, tmp[i])\n        kiso += tmp[i][0]\n\nkind = 0\nfor k, v in list(cnt.items()):\n    if v:\n        kind += 1\n#print(kiso, kind)\n#print(h_in)\n#print(tmp)\n\nanswer = kiso + kind ** 2\ntmp = tmp[::-1]\nwhile tmp:\n    out_d, out_t = tmp.pop()\n    in_d, in_t = heappop(h_in)\n    \n    kiso += out_d - in_d\n    cnt[in_t] -= 1\n    if cnt[in_t] == 0: kind -= 1\n    cnt[out_t] += 1\n    if cnt[out_t] == 1: kind += 1\n    \n    heappush(h_in, [out_d, out_t])\n    \n    answer = max(answer, kiso + kind ** 2)\n\nprint(answer)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":37,"bad_solution":"\n\nn, k = [0] * 2\na = []\n\ndef format_input(filename = None):\n\tglobal n, k\n\tglobal a\n\tif filename == None:\n\t\tn, k = list(map(int, input().split()))\n\t\ta = list(map(int, input().split()))\n\n\telif filename == '__random__':\n\t\tfrom random import randint as rng\n\t\tn = rng(2, 2 * 10**5)\n\t\tk = rng(1, 10**18)\n\t\ta = [rng(1, n) for i in range(n)]\n\t\tprint(n, k)\n\t\tprint(' '.join(list(map(str, a))))\n\ndef get_answer():\n\tloop = [1]\n\tstart = -1\n\twhile start == -1:\n\t\tnode = a[loop[-1]-1]\n\t\tif loop.count(node) > 0:\n\t\t\tstart = loop.index(node)\n\t\telse:\n\t\t\tloop.append(node)\n\n\tl = len(loop)\n\tif k >= l:\n\t\tanswer = loop[(k - l) % (l - start) + start]\n\telse:\n\t\tanswer = loop[k]\n\n\treturn answer\n\nif __name__ == '__main__':\n\tformat_input()\n\n\tans = get_answer()\n\tprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":38,"bad_solution":"#####segfunc#####\ndef segfunc(x, y):\n    if x[0]>y[0]:\n        return y\n    elif x[0]<y[0]:\n        return x\n    elif x[1]>y[1]:\n        return y\n    else:\n        return x\n#################\n\n#####ide_ele#####\nide_ele = (float(\"inf\"),-1)\n#################\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): 配列init_valで初期化 O(N)\n    update(k, x): k番目の値をxに更新 O(logN)\n    query(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: 配列の初期値\n        segfunc: 区間にしたい操作\n        ide_ele: 単位元\n        n: 要素数\n        num: n以上の最小の2のべき乗\n        tree: セグメント木(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # 配列の値を葉にセット\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # 構築していく\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k番目の値をxに更新\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k][0] += x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)のsegfuncしたものを得る\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\nimport sys\n\ninput=sys.stdin.readline\n\nN,M=map(int,input().split())\ns=input()\nA=[[0,i] for i in range(N)]\nB=[[0,i] for i in range(N)]\nedge=[[] for i in range(N)]\n\nfor i in range(M):\n    a,b=map(int,input().split())\n    a-=1;b-=1\n    edge[a].append(b)\n    edge[b].append(a)\n    if s[a]==\"A\":\n        A[b][0]+=1\n    else:\n        B[b][0]+=1\n    if s[b]==\"A\":\n        A[a][0]+=1\n    else:\n        B[a][0]+=1\n\nAcheck=SegTree(A,segfunc,ide_ele)\nBcheck=SegTree(B,segfunc,ide_ele)\n\nban=set([])\nwhile True:\n    a,index=Acheck.query(0,N)\n    b,index2=Bcheck.query(0,N)\n    if a==0:\n        ban.add(index)\n        Acheck.update(index,float(\"inf\"))\n        Bcheck.update(index,float(\"inf\"))\n        for v in edge[index]:\n            if s[index]==\"A\":\n                Acheck.update(v,-1)\n            else:\n                Bcheck.update(v,-1)\n    elif b==0:\n        ban.add(index2)\n        Acheck.update(index2,float(\"inf\"))\n        Bcheck.update(index2,float(\"inf\"))\n        for v in edge[index2]:\n            if s[index2]==\"A\":\n                Acheck.update(v,-1)\n            else:\n                Bcheck.update(v,-1)\n    else:\n        break\n\ncheck=set([i for i in range(N)])\nif ban==check:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":39,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\ndef factoring(n: int):\n    factors = []\n    p = 1\n    while p * p <= n:\n        if n % p == 0:\n            factors.append(p)\n            if n != p * p:\n                factors.append(n \/\/ p)\n        p += 1\n    return factors\n\ndef solve(N: int, M: int):\n    if N == 1:\n        print(M)\n        return\n    F = factoring(M)\n    F.sort()\n    print(F)\n    for f in F:\n        if f >= N:\n            print(M \/\/ f)\n            break\n    return\n\n\n# Generated by 1.1.4 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    solve(N, M)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":40,"bad_solution":"def getN():\n    return int(input())\ndef getNM():\n    return map(int, input().split())\ndef getList():\n    return list(map(int, input().split()))\ndef getArray(intn):\n    return [int(input()) for i in range(intn)]\ndef input():\n    return sys.stdin.readline().rstrip()\ndef rand_N(ran1, ran2):\n    return random.randint(ran1, ran2)\ndef rand_List(ran1, ran2, rantime):\n    return [random.randint(ran1, ran2) for i in range(rantime)]\ndef rand_ints_nodup(ran1, ran2, rantime):\n  ns = []\n  while len(ns) < rantime:\n    n = random.randint(ran1, ran2)\n    if not n in ns:\n      ns.append(n)\n  return sorted(ns)\n\ndef rand_query(ran1, ran2, rantime):\n  r_query = []\n  while len(r_query) < rantime:\n    n_q = rand_ints_nodup(ran1, ran2, 2)\n    if not n_q in r_query:\n      r_query.append(n_q)\n  return sorted(r_query)\n\nfrom collections import defaultdict, deque, Counter\nfrom sys import exit\nfrom decimal import *\nfrom heapq import heapify, heappop, heappush\nfrom math import sqrt\nfrom fractions import gcd\nimport random\nimport string\nimport copy\nfrom itertools import combinations, permutations, product\nfrom operator import mul, itemgetter\nfrom functools import reduce\nfrom bisect import bisect_left, bisect_right\n\nimport sys\nsys.setrecursionlimit(1000000000)\nmod = 10 ** 9 + 7\n\n#############\n# Main Code #\n#############\n\nH, W = getNM()\nCh, Cw = getNM()\nDh, Dw = getNM()\nmaze = [input() for i in range(H)]\nCh -= 1\nCw -= 1\nDh -= 1\nDw -= 1\n\n# ワープを最低で何回使うか\n# 上下左右2つ向こうまでの範囲内でワープできる\n# 隣接する'.'が領域\n\ndx = [1, 0, -1, 0]\ndy = [0, 1, 0, -1]\n\npos = deque([[Ch, Cw]])\ndp = [[-1] * W for i in range(H)]\ndp[Ch][Cw] = 0\n\nwhile len(pos) > 0:\n    y, x = pos.popleft()\n    for i in range(4):\n        nx = x + dx[i]\n        ny = y + dy[i]\n        # 歩いて移動\n        if 0 <= nx < W and 0 <= ny < H and maze[ny][nx] == \".\" and (dp[ny][nx] == -1 or dp[y][x] < dp[ny][nx]):\n            # 0-1 bfs\n            # 先頭に置く\n            pos.appendleft([ny, nx])\n            dp[ny][nx] = dp[y][x]\n    # ワープ\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            wy = y + i\n            wx = x + j\n            # 歩いて移動不可能でないと使わない\n            if 0 <= wx < W and 0 <= wy < H and maze[wy][wx] == \".\" and dp[wy][wx] == -1:\n                pos.append([wy, wx])\n                dp[wy][wx] = dp[y][x] + 1\n\nprint(dp[Dh][Dw])\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":41,"bad_solution":"class SegmentTree:\n    def __init__(self,siz,v = 0):\n        self.n = 1\n        self.v = v\n        while self.n < siz: self.n *= 2\n        self.node = [self.v]*(2*self.n-1)\n\n    def merge(self,x,y): return x | y\n\n    def update(self,i,x):\n        i += self.n-1\n        self.node[i] = x\n        while i > 0:\n            i = (i-1)\/\/2\n            self.node[i] = self.merge(self.node[i*2+1],self.node[i*2+2])\n    \n    def query(self,a,b):\n        vl = vr = self.v\n        a += self.n-1\n        b += self.n-1\n        while a < b:\n            if a & 1 == 0: vl = self.merge(vl,self.node[a])\n            if b & 1 == 0: vr = self.merge(vr,self.node[b-1])\n            a \/\/= 2\n            b = (b-1)\/\/2\n        return self.merge(vl,vr)\n    \nn = int(input())\nst = SegmentTree(n)\ns = list(input())\ndef f(c): return 1<<(ord(c) - ord(\"a\"))\nfor i in range(n): st.update(i,f(s[i]))\nq = int(input())\nfor _ in range(q):\n    typ,x,y = input().split()\n    if typ == \"1\":\n        i,c = int(x)-1,y\n        if s[i] == c: continue\n        st.update(i,f(c))\n        s[i] = c\n    else:\n        l,r = int(x)-1,int(y)\n        print(bin(st.query(l,r)).count(\"1\"))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":42,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\nfrom collections import deque\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\nmod = 10**9 + 7\n\nDR = [1, -1, 0, 0]\nDC = [0, 0, 1, -1]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\n     \ndef main():\n    x, y = LI()\n    if x > y:\n        if x >= 0:\n            ans = 1 + abs(x+y)\n        else:\n            ans = 1 + (-y) - (-x) + 1\n    else:\n        ans = y - x\n    print(ans)\n\nmain()\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":43,"bad_solution":"import sys\ninput=sys.stdin.readline\nimport collections\n\ndef main():\n    N = int(input())\n    Q = [collections.deque(map(int, input().split())) for _ in range(N)]\n    games = N*(N-1)\/\/2\n\n    days = 0\n    while True:\n        gamed = [0 for _ in range(N)]\n        b = False\n        for i in range(len(Q)):\n            if gamed[i] > 0 or len(Q[i]) == 0:\n                continue\n            j = Q[i][0] - 1\n            if gamed[j] > 0 or len(Q[j]) == 0:\n                continue\n            if Q[j][0] == i+1:\n#                print(\"game:\", j+1, i+1, days)\n                Q[i].popleft()\n                Q[j].popleft()\n                gamed[i] = 1\n                gamed[j] = 1\n                games -= 1\n                b = True\n                continue\n        days += 1\n        if not b:\n            print(-1)\n            return\n        if games == 0:\n            break\n\n    print(days)\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":44,"bad_solution":"from math import factorial as fact\nimport math\nimport sys\nimport itertools\nimport numpy as np\nfrom collections import Counter\nimport datetime\n\n\n#入力:N(int:整数)\ndef input1():\n\treturn int(input())\n\n#入力:N,M(int:整数)\ndef input2():\n\treturn map(int,input().split())\n\n#入力:[n1,n2,...nk](int:整数配列)\ndef input_array():\n\treturn list(map(int,input().split()))\n\ndef keta(N):\n\treturn len(str(N))\n\n\ndef input_daytime(input_time):\n\ttime,distance=input_time.split()\n\tt=time.split(\":\")\n\tse=str(t[-1]).split(\".\")\n\tdt1 = datetime.timedelta(hours=int(t[0]),minutes=int(t[1]),seconds=int(se[0]),milliseconds=int(se[1]))\n\treturn dt1\n\ndef combinations(n,r):\n\treturn list(itertools.combinations(range(n),r))\n\n\n\ndef all_sets(num_list):\n\tsubsets=[]\n\tfor i in range(2,len(num_list) + 1):\n\t\tfor c in combinations(num_list, i):\n\t\t\tsubsets.append(c) \n\treturn subsets\n\n#公約数の列挙\ndef ch(x1):\n\tcf=[]\n\tfor i in range(2,math.sqrt(x1)+1):\n\t\tif x1 % i==0:\n\t\t\tcf.append(i)\n\treturn cf\n\ndef CountOneRoots(x,y):\n\t#x:縦，y:横\n\treturn fact(x+y)\/fact(x)\/fact(y)\n\n# 素因数分解\ndef factorization(n):\n\ttmp=n\n\tcount=0\n\tfor i in range(2,int(n**0.5)+2):\n\t\tif tmp%i==0:\n\t\t\tcnt=0\n\t\t\twhile tmp%i==0:\n\t\t\t\tcnt+=1\n\t\t\t\ttmp\/\/=i\n\t\t\tcount+=1\n\tif tmp!=1:\n\t\tcount+=1\n\n\treturn count\n\t\t\t\n\ndef fl(a,b,x):\n\treturn math.floor(a*x\/b)-a*math.floor(x\/b)\n\n\n# n,m,q = input2()\n# abcd=[]\n# A=[0]*n\n# for i in range(q):\n# \tabcd.append(input_array())\n\na,b,n=input2()\nif b>n:\n\tb_ans=fl(a,b,n)\nelse:\n\tb_ans=fl(a,b,b-1)\n\nfor i in range(0,n,b):\n\tans=fl(a,b,i)\n\t# print(i)\n\tif ans> b_ans:\n\t\tb_ans=ans\nif i<n:\n\tans=fl(a,b,n)\n\tif ans> b_ans:\n\t\tb_ans=ans\nprint(b_ans)\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":45,"bad_solution":"from typing import List\n\n\ndef FUNC(numbers: List[int], delimeter: int) -> List[int]:\n    \"\"\" Insert a number 'delimeter' between every two consecutive elements of input list `numbers'\n    >>> FUNC([], 4)\n    []\n    >>> FUNC([1, 2, 3], 4)\n    [1, 4, 2, 4, 3]\n    \"\"\"\n    if not numbers:\n        return []\n\n    result = []\n\n    for n in numbers[:-1]:\n        result.append(n)\n        result.append(delimeter)\n\n    return result\n"}
{"id":46,"bad_solution":"import math\ndef main():\n    N,D,A = map(int, input().split())\n    X,H = [0]*N,[0]*N\n    tmp = [(0,0) for _ in range(N)]\n    for i in range(N):\n        tmp[i] = list(map(int, input().split()))\n        tmp[i][0] -= 1\n    # 座標順になるようにソートしておく\n    tmp = sorted(tmp, key=lambda x:x[0])\n    for i,l in enumerate(tmp): (X[i],H[i]) = l\n    # 座標X[i]のモンスターはceil(H[i]\/A)回攻撃すれば倒せる\n    # N=5, D=2\n    # 0 1 2 3 4 5 6 7 8 9 10\n    # 0 5 0 2 0 0 3 3 0 0 4 (倒すのに必要な回数; 全部0にすれば終了)\n    # 0 0 0 0 0 0 3 3 0 0 4 (座標3で5回爆破したあと)\n    # 0 0 0 0 0 0 0 0 0 0 1 (座標8で3回爆破したあと)\n    # 0 0 0 0 0 0 0 0 0 0 0 (座標10で1回爆破したあと)\n    # ->よって5+3+1=9回が最小回数..?\n    ans = 0\n    for i in range(N):\n        if sum(H)<=0: break\n        if H[i]>0:\n            # X[i]+Dで爆破を行う\n            bomb = math.ceil(H[i]\/A)\n            ans += bomb\n            for j,p in enumerate(X[i:]):\n                if p<X[i]+2*D+1:\n                    H[i+j] = max(0,H[i+j]-A*bomb)\n                else:\n                    break\n    print(ans)\n\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":47,"bad_solution":"from typing import List\n\n\ndef FUNC(paren_string: str) -> List[int]:\n    \"\"\" Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n    For each of the group, output the deepest level of nesting of parentheses.\n    E.g. (()()) has maximum two levels of nesting while ((())) has three.\n\n    >>> FUNC('(()()) ((())) () ((())()())')\n    [2, 3, 1, 3]\n    \"\"\"\n    def FUNC(s):\n        depth = 0\n        max_depth = 0\n        for c in s:\n            if c == '(':\n                depth += 1\n                max_depth = max(depth, max_depth)\n            else:\n                max_depth -= 1\n\n        return max_depth\n\n    return [FUNC(x) for x in paren_string.split(' ') if x]\n"}
{"id":48,"bad_solution":"N, M = map(int, input().split())\nA = list(map(int, input().split()))\n\ndef dfs(choices, s, cost, i):\n    if i == len(choices):\n        return -1\n    if cost == 0:\n        return int(s)\n    if cost < 0:\n        return -1\n    \n    \n    tmp1 = dfs(\n        choices,\n        s + str(choices[i][0]),\n        cost - choices[i][1],\n        i\n    )\n    if i+1 == len(choices):\n        tmp2 = -1\n    else:\n        tmp2 = dfs(\n            choices,\n            s,\n            cost,\n            i + 1\n        )\n    \n    ret = max(tmp1, tmp2)\n    return ret\n\nmatch = [-100,2,5,5,4,5,6,3,7,6]\nchoices = []\nfor i in A:\n    choices.append([i, match[i]])\n\nchoices.sort(reverse=True)\nans = dfs(choices, '', N, 0)\nprint(ans)\n    \n    \nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":49,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict, deque\nfrom heapq import heappush, heappop\nfrom itertools import permutations, accumulate\nimport sys\nimport math\nimport bisect\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\ndef solve():\n    n,m,v,p = LI()\n    a = LI()\n    a.sort()\n    l = -1\n    r = n-1\n    print(a)\n    while l+1 < r:\n        i = (l+r) >> 1\n        A = a[i]+m\n        ri = bisect.bisect_right(a,A)\n        j = n-ri\n        if j >= p:\n            l = i\n            continue\n        li = bisect.bisect_right(a,a[i])\n        res = v-j-li\n        if res <= 0:\n            r = i\n            continue\n        res -= (p-j-1)\n        s = 0\n        for j in range(li,ri-(p-j-1)):\n            s += A-a[j]\n        if s >= res*m:\n            r = i\n        else:\n            l = i\n    print(n-r)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    solve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":50,"bad_solution":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(pow(10, 6))\nfrom collections import defaultdict\n\n\ndef main():\n    n, m = map(int, input().split())\n    a = []\n    for _ in range(n):\n        a.append(list(map(int, input().split())))\n    sports = [1 for _ in range(m)]\n    ans = 10**18\n    for _ in range(m-1):\n        sdic = defaultdict(lambda: 0)\n        for _al in a:\n            for _a in _al:\n                if sports[_a-1] == 1:\n                    sdic[_a] += 1\n                    break\n        tmp = list(sorted(sdic.items(), key=lambda x: x[1]))[-1]\n        ans = min(ans, tmp[1])\n        sports[tmp[0]-1] = 0\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":51,"bad_solution":"import sys\nreadline = sys.stdin.buffer.readline\ndef readstr():return readline().rstrip().decode()\ndef readints():return list(map(int,readline().split()))\n\nh,w = readints()\n\nstart = readints()\nstart = (start[0]-1)*w + start[1]-1\n\ngoal = readints()\ngoal = (goal[0]-1)*w + goal[1]-1\n\nmaze = [readstr() for i in range(h)]\n\ndist = [10**10]*(h*w)\n\na = [[]for i in range(2)]\ni = 0\na[i].append(start)\ndist[start] = 0\n\nwhile a[0] or a[1]:\n    p = a[i].pop()\n    y = p\/\/w\n    x = p%w\n    for dy in range(-2,3):\n        for dx in range(-2,3):\n            if 0<=y+dy<h and 0<=x+dx<w and maze[y+dy][x+dx]=='.':\n                q = (y+dy)*w + x+dx\n                if dist[q]<=dist[p]:\n                    continue\n                if abs(dy)+abs(dx)==1:\n                    a[i].append(q)\n                    dist[q] = dist[p]\n                else:\n                    a[i-1].append(q)\n                    dist[q] = dist[p] + 1\n    if not a[i]:\n        i = [1,0][i]\n\nprint(-1 if dist[goal]==10**10 else dist[goal])\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":52,"bad_solution":"from bisect import bisect_left\n\n\ndef main():\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n):\n        a[i] += a[i - 1]\n    for i in range(1, m):\n        b[i] += b[i - 1]\n    answer = 0\n    if a[-1] + b[-1] <= k:\n        print(n + m)\n    else:\n        for i in range(n):\n            l = bisect_left(b, k - a[i])\n            if l == m or (l == 0 and b[l] + a[i] != k):\n                continue\n            diff = 1 if b[l] + a[i] == k else 0\n            answer = max(answer, i + 1 + l + diff)\n        print(answer)\n\n\nif __name__ == '__main__':\n    main()\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":53,"bad_solution":"import sys\nfrom collections import deque\nsys.setrecursionlimit(10**9)\nINF=10**18\ndef input():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    N=int(input())\n    d={}\n    c=0\n    edge1=[[] for _ in range(N*(N-1)\/\/2)]\n    edge2=[[] for _ in range(N*(N-1)\/\/2)]\n    for i in range(N):\n        l=list(map(lambda x: int(x)-1,input().split()))\n        prev=-1\n        for x in l:\n            a=min(i,x)*10**3+max(i,x)\n            if a in d:\n                z=d[a]\n                if prev!=-1:\n                    edge1[prev].append(z)\n                    edge2[z].append(prev)\n                prev=z\n            else:\n                d[a]=c\n                if prev!=-1:\n                    edge1[prev].append(c)\n                    edge2[c].append(prev)\n                c+=1\n                prev=d[a]\n    que=deque()\n    days=[-1]*(N*(N-1)\/\/2)\n    for i,l in enumerate(edge2):\n        if not l:\n            que.append(i)\n            days[i]=1\n    while que:\n        v=que.popleft()\n        for x in edge1[v]:\n            if days[x]==-1:\n                que.append(x)\n            days[x]=max(days[x],days[v]+1)\n    print(max(days))\n        \n\n    \n\n        \nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":54,"bad_solution":"import sys,random\nfrom math import gcd\ninput=sys.stdin.readline\nn=int(input())\n*a,=map(int, input().split())\nrandom.shuffle(a)\ntmp=a[0]\nfor i in range(1,n):\n    tmp=gcd(tmp,a[i])\nif tmp>1:\n    print('not coprime')\n    exit()\n\n# pairwize coprime なら素因数が2度現れることはない\n\ndef f(x):\n    res=set()\n    for i in range(2,int(x**(1\/2))+3):\n        if x%i==0:\n            while x%i==0:\n                x\/\/=i\n            res.add(i)\n    if x>1:\n        res.add(x)\n    return res,x\ntmp=set()\ntmp2=set()\nfor ai in a:\n    for p in tmp:\n        if ai%p==0:\n            print('setwise coprime')\n            exit()\n    pp,x=f(ai)\n    tmp|=pp \n    if x>1 and x in tmp2:\n        print('setwise coprime')\n        exit()\n    tmp.add(x)\n    \n        \nprint('pairwise coprime')\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":55,"bad_solution":"from itertools import accumulate,chain\nimport sys\n\nsys.setrecursionlimit(10000000)\n\nMOD = 10**9+7\n\n\n# mを法とするときのa^n\ndef modpow(a,n,m):\n    res = 1\n    t = a\n    while n:\n        if n%2:\n            res = (res*t)%m\n        t = (t*t)%m\n        n \/\/= 2\n    return res\n\n# factorio = tuple(chain((1,),accumulate(range(1,N+1), func=lambda x,y: (x*y)%MOD)))\n\n\ndef solve(N,adj,edges):\n    factorio = [1]*(N+1)\n    t = 1\n    for i in range(1,N+1):\n        t *= i\n        t %= MOD\n        factorio[i] = t\n\n    patterns = dict()\n    childrens = dict()\n    def rec(a,b):\n        if (a,b) not in patterns:\n            prod = 1 # product of patterns\n            d = 1 # denominator of multinomial coefficient\n            n = 0 # total childrens\n            for c in adj[b]:\n                if a == c:\n                    continue\n                rec(b,c)\n                prod *= patterns[(b,c)]\n                prod %= MOD\n                d *= factorio[childrens[(b,c)]]\n                d %= MOD\n                n += childrens[(b,c)]\n\n            patterns[(a,b)] = (prod*factorio[n]*modpow(d,MOD-2, MOD))%MOD\n            childrens[(a,b)] = n+1\n\n    for a,b in edges:\n        rec(a,b)\n        rec(b,a)\n\n    for k in range(N):\n        rec(-1,k)\n        print(patterns[(-1,k)])\n\n\nif __name__ == '__main__':\n    read = sys.stdin.buffer.read\n    readline = sys.stdin.buffer.readline\n    readlines = sys.stdin.buffer.readlines\n     \n    N = int(readline())\n    m = map(int, read().split())\n    edges = tuple((a-1,b-1) for a,b in zip(m, m))\n    \n    adj = [list() for _ in range(N)]\n    for a,b in edges:\n        adj[a].append(b)\n        adj[b].append(a)\n\n    solve(N,adj,edges)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":56,"bad_solution":"def main():\n    from bisect import bisect_right\n\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n\n    def calc(x):\n        tmp = 0\n        for a in A:\n            tmp += N - bisect_right(A, x - a - 0.5)\n        return tmp\n\n    l = 0\n    r = 3 * 10 ** 5\n    while r - l > 1:\n        mid = (l + r) \/\/ 2\n        if calc(mid) >= M:\n            l = mid\n        else:\n            r = mid\n\n    B = [0] * (N + 1)\n    for i in range(N):\n        B[i + 1] = B[i] + A[i]\n\n    ans = 0\n    for a in A:\n        tmp = bisect_right(A, r - a - 0.5)\n        M -= (N - tmp)\n        ans += a * (N - tmp) + (B[-1] - B[tmp])\n\n    ans += M * l\n    print (ans)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":57,"bad_solution":"from fractions import gcd\n# from datetime import date, timedelta\nfrom heapq import*\nimport math\nfrom collections import defaultdict, Counter, deque\nfrom bisect import *\nimport itertools\nimport fractions\nimport sys\nsys.setrecursionlimit(10 ** 7)\nMOD = 10 ** 9 + 7\n# input = sys.stdin.readline\n\n\ndef main():\n    n, a, b, c, d = map(int, input().split())\n    s = list(input())\n    if c < d:\n        for i in range(b, d):\n            if s[i] == \"#\" and s[i + 1] == \"#\":\n                print(\"No\")\n                exit()\n        for i in range(a, c):\n            if s[i] == \"#\" and s[i + 1] == \"#\":\n                print(\"No\")\n                exit()\n        print(\"Yes\")\n    else:\n        f=True\n        for i in range(b, d):\n            if s[i-1] == \".\" and s[i] == \".\" and s[i+1] == \".\":\n                f = False\n                break\n        if f:\n            print(\"No\")\n            exit()\n        for i in range(a, c):\n           if s[i] == \"#\" and s[i + 1] == \"#\":\n               print(\"No\")\n               exit()\n        print(\"Yes\")\n\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":58,"bad_solution":"from typing import List\n\n\ndef FUNC(strings: List[str], substring: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that contain given substring\n    >>> FUNC([], 'a')\n    []\n    >>> FUNC(['abc', 'bacd', 'cde', 'array'], 'a')\n    ['abc', 'bacd', 'array']\n    \"\"\"\n    return [x for x in strings if x in substring]\n"}
{"id":59,"bad_solution":"def main():\n  _range = range\n  h, w = map(int, input().split())\n  s = [input() + '#' for _ in _range(h)]\n  s.append('#' * (w + 1))\n  t = [[-1] * w for _ in _range(h + 1)]\n  tstart = [-1] * (w + 1)\n  for i in _range(h + 1):\n    ystart = -1\n    si = s[i]\n    ti = t[i]\n    for j in _range(w + 1):\n      if si[j] == '#':\n        if ystart != -1:\n          for k in _range(ystart, j):\n            ti[k] += j - ystart\n          ystart = -1\n        if tstart[j] != -1:\n          for k in _range(tstart[j], i):\n            t[k][j] += i - tstart[j]\n          tstart[j] = -1\n      else:\n        if ystart == -1:\n          ystart = j\n        if tstart[j] == -1:\n          tstart[j] = i\n  print(max(map(max, t)))\nmain()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":60,"bad_solution":"n = int(input())\ns = list(map(str, input().strip()))\nseed = 13331\nmod = 10 ** 9 + 7\nlsd = [1] * 6000\nhs = [1] * 6000\nhs[0] = ord(s[0]) - ord('a')\nfor i in range(1, n):\n    lsd[i] = lsd[i - 1] * seed % mod\n    hs[i] = (hs[i - 1] * seed + ord(s[i]) - ord('a')) % mod\n\n\ndef check(x):\n    from collections import defaultdict\n    g = defaultdict(int)\n    for i in range(n - x + 1):\n        if i:\n            t = (hs[i + x - 1] - hs[i - 1] * lsd[x]) % mod\n        else:\n            t = hs[i + x - 1]\n        # print(i,t)\n        if not g[t]:\n            g[t] = i+1\n        elif g[t] + x - 1 <= i:\n            return True\n    return False\n\n\n\nl = 0\nr = n\nwhile l < r - 1:\n    m = (l + r) \/\/ 2\n    if check(m):\n        l = m\n    else:\n        r = m - 1\n\nif check(r):\n    print(r)\nelse:\n    print(l)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":61,"bad_solution":"def kakaka():\n    a = list(map(int, input().split()))\n    b = map(int, input().split())\n    c = int(input())\n\ndef start_process():\n    return\ndef main():\n    all_num, inst_num = map(int, input().split())\n    data = list(input())\n\n    data_la = []\n    ans_0, ans_1 = 0, 0\n    for i in range(all_num):\n        if data[i] == '1':\n            ans_1 += 1\n            if ans_0 > 0:\n                data_la.append(ans_0)\n                ans_0 = 0\n        else:\n            ans_0 += 1\n            if ans_1 > 0:\n                data_la.append(ans_1)\n                ans_1 = 0\n    if ans_1 > 0:\n        data_la.append(ans_1)\n    elif ans_0 > 0:\n        data_la.append(ans_0)\n\n    ans = 0\n    ans_data = 0\n    count_0 = 0\n\n    if data[0] == '0':\n        flg = 0\n        flg_hajime = 0\n    else:\n        flg= 1\n        flg_hajime = 1\n    # print(data_la)\n\n    if len(data_la) <= 2:\n        print(sum(data_la))\n    else:\n        pre_data1, pre_data2 = data_la[0], data_la[1]\n        pre_data1_ind, pre_data2_ind = 0, 1\n        for i in range(len(data_la)):\n            if i % 2 == flg:\n                count_0 += 1\n            if count_0 == inst_num + 1:\n                if flg_hajime:\n                    ans = ans - pre_data1 - pre_data2\n                    pre_data1_ind += 2\n                    pre_data2_ind += 2\n                    if pre_data1_ind >= len(data_la):\n                        pre_data1 = 0\n                    else:\n                        pre_data1 = data_la[pre_data1_ind]\n                    if pre_data2_ind >= len(data_la):\n                        pre_data2 = 0\n                    else:\n                        pre_data2 = data_la[pre_data1_ind]\n                else:\n                    ans = ans - pre_data1\n                    pre_data1_ind += 1\n                    pre_data2_ind += 1\n                    if pre_data1_ind >= len(data_la):\n                        pre_data1 = 0\n                    else:\n                        pre_data1 = data_la[pre_data1_ind]\n                    if pre_data2_ind >= len(data_la):\n                        pre_data2 = 0\n                    else:\n                        pre_data2 = data_la[pre_data2_ind]\n                    flg_hajime = 1\n\n\n                count_0 -= 1\n            ans += data_la[i]\n            # print(ans)\n            if ans_data < ans:\n                ans_data = ans\n\n\n\n\n\n\n        print(ans_data)\n\n\n\n\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":62,"bad_solution":"from pprint import pprint\nimport queue\n\ndef solve(n, a, b):\n        \n    state = queue.Queue()\n    state.put((0, b[:]))\n    while not state.empty():\n        count, b_tmp = state.get()\n        # print(\"next:\" + str(count))\n        # pprint(b_tmp)\n        for i, b_i in enumerate(b_tmp):\n            i_a = (i - 1 + n) % n\n            i_c = (i + 1) % n\n            b_cand = b_i - b_tmp[i_a] - b_tmp[i_c]\n            if b_cand >= a[i]:\n                b_next = b_tmp[:]\n                b_next[i] = b_cand\n                if b_next == a:\n                    return count + 1\n                # print(count + 1)\n                state.put((count + 1, b_next))\n    \n    return -1\n\n\nif __name__ == '__main__':\n\n    n = int(input().strip())\n    a = list(map(int, input().strip().split(\" \")))\n    b = list(map(int, input().strip().split(\" \")))\n    print(solve(n, a, b))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":63,"bad_solution":"import sys\ninput = sys.stdin.readline\n\ndef gcd(a, b):\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\ndef sieve_optimized(limit):\n    # Preprocessing step takes O(N log log N) time complexity.\n    n = limit\n    # Filimitd all primes upto n  (including n)\n    sievebound = (n-1)\/\/2\n    sieve = [-1]*(sievebound + 1)\n    # sieve[0] = True\n    crosslimit = (int(sievebound**0.5) - 1)\n    for i in range(1, crosslimit + 1):\n        if sieve[i] == -1:\n            for j in range(2*i*(i+1), sievebound + 1, 2*i+1):\n                sieve[j] = 2*i + 1\n    return sieve\n\ndef factorization(n, sieve):\n    # Factorisaton query takes O(log N) time after preprocessing.\n    divs = [1]\n    while n!=1:\n        if n&1:\n            div = sieve[(n-1)\/\/2]\n            if div == -1:\n                divs.append(n)\n                break\n            else:\n                n \/\/= div\n                divs.append(div)\n        else:\n            n >>= 1\n            divs.append(2)\n\n    return divs\n\nmaxnum = 10**6 + 10\nsieve = sieve_optimized(maxnum)\n\nn = int(input())\nnums = list(map(int, input().split()))\n\nseen = dict()\nfor i in nums:\n    factors = factorization(i, sieve)\n    if len(factors) <= 1: continue\n    for f in set(factors[1:]):\n        if f in seen:\n            seen[f] += 1\n        else:\n            seen[f] = 1\n\nmaxval = max(seen.values())\n\nif maxval == n:\n    print('not coprime')\n\nelif 1 < maxval < n:\n    print('setwise coprime')\n\nelse:\n    print('pairwise coprime')\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":64,"bad_solution":"import sys\nfrom collections import deque\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nin_n = lambda: int(readline())\nin_nn = lambda: map(int, readline().split())\nin_s = lambda: readline().rstrip().decode('utf-8')\nin_nl = lambda: list(map(int, readline().split()))\nin_nl2 = lambda H: [in_nl() for _ in range(H)]\nin_map = lambda: [s == ord('.') for s in readline() if s != ord('\\n')]\nin_map2 = lambda H: [in_map() for _ in range(H)]\nin_all = lambda: map(int, read().split())\n\n\ndef main():\n\n    N = in_n()\n\n    s = in_s()\n\n    red = deque()\n    white = deque()\n\n    for i in range(N):\n        if s[i] == 'R':\n            red.append(i)\n        else:\n            white.append(i)\n\n    if len(red) == 0:\n        print(1)\n        exit()\n    if len(white) == 0:\n        print(0)\n        exit()\n\n    cnt = 0\n    while True:\n        if len(red) == 0 or len(white) == 0:\n            break\n        if white[0] > red[-1]:\n            break\n\n        white.popleft()\n        red.pop()\n        cnt += 1\n\n    print(cnt)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":65,"bad_solution":"def solve(n, m, work_list):\n    # 1-origin\n    dp = [[0] * (m + 1) for i in range(n + 1)]\n\n    # time O(N log(N))\n    work_list.sort()\n\n    # time O(NM)\n    for key, value in enumerate(work_list, 1):\n        work_day, work_value = value[0], value[1]\n        prev_key = key - 1\n        for day in range(1, m + 1):\n            prev_day = day - 1\n            dp[key][day] = dp[prev_key][day]\n            if day >= work_day:\n                dp[key][day] = max(dp[key][day], dp[prev_key][prev_day] + work_value)\n\n    return dp[n][m]\n\n\ndef main():\n    n, m = map(int, input().split())\n\n    work_list = []\n    # time O(N)\n    for i in range(n):\n        work = list(map(int, input().split()))\n        if work[0] > m:\n            continue\n        work_list.append(work)\n\n    ans = solve(n, m, work_list)\n    print(ans)\n\n\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":66,"bad_solution":"def main():\n    import sys\n    sys.setrecursionlimit(10**6)\n    input = sys.stdin.readline\n    N = int(input())\n    A = [int(x) for x in input().strip().split()]\n    maxA = max(A)\n    prime = [i % 2 != 0 for i in range(maxA+1)]\n    prime[2] = True\n    f = [False] * (maxA+1)\n    for i in range(3, int(maxA**.5)+1):\n        if prime[i] == False:\n            continue\n        p = i * 2\n        while p <= maxA:\n            prime[p] = False\n            p += i\n\n    def gcd(x, y):\n        if y == 0:\n            return x\n        return gcd(y, x % y)\n\n    pairwise_coprime = A[0]\n    setwise_coprime = A[0]\n    for An in A[1:]:\n        setwise_coprime = gcd(setwise_coprime, An)\n        if setwise_coprime == 1:\n            break\n    \n    for An in A:\n        if An == 1:\n            continue\n        # print('An = {}'.format(An))\n        if f[An]:\n            break\n        elif prime[An]:\n            f[An] = True\n        else:\n            for i in range(2, An \/\/ 2 + 1):\n                if prime[An]:\n                    if f[An]:\n                        if setwise_coprime == 1:\n                            print('setwise coprime')\n                            return\n                        else:\n                            print('not coprime')\n                            return\n                    else:\n                        f[An] = True\n                        break\n                if f[An]:\n                    if setwise_coprime == 1:\n                        print('setwise coprime')\n                        return\n                    else:\n                        print('not coprime')\n                        return\n                elif An % i == 0:\n                    # print('i={}'.format(i))\n                    if f[i]:\n                        if setwise_coprime == 1:\n                            print('setwise coprime')\n                            return\n                        else:\n                            print('not coprime')\n                            return\n                    f[i] = True\n                    while An % i == 0:\n                        An \/\/= i\n                    if An == 1:\n                        break\n        # print(f)\n    print('pairwise coprime')\n\nif __name__ == '__main__':\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":67,"bad_solution":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\n#from collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\n#from math import floor, ceil\n#from operator import itemgetter\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\n#inf = 10**17\n#mod = 10**9 + 7\n\nn,k=MI()\ns=input()\nprint(s)\nl=0\nr=0\nif s[0]==\"L\":\n    l=1\nif s[-1]==\"R\":\n    r=1\nstate=\"\"\ncount=0\nfor i in range(n):\n    u=s[i:i+1]\n    #print(state)\n    #print(u)\n    if state==\"\":\n        if u==\"R\":\n            state=\"R\"\n    elif state==\"R\":\n        if u==\"L\":\n            state=\"\"\n            count+=1\n        else:\n            state=\"R\"\n#print(count)\n#print(l+r)\nunhappy=2*count+l+r\nif l+r==0:\n    if k>=count:\n        unhappy=1\n    elif k==count-1:\n        unhappy=2\n    else:\n        unhappy-=2*(k-1)\nelif l+r==1:\n    if k>=count:\n        unhappy=1\n    else:\n        unhappy-=2*k\nelif l+r==2:\n    if k>=count+1:\n        unhappy=1\n    elif k==count:\n        unhappy=2\n    else:\n        unhappy-=2*k\n#print(unhappy)\nprint(n-unhappy)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":68,"bad_solution":"from typing import List, Tuple\n\n\ndef FUNC(numbers: List[int]) -> Tuple[int, int]:\n    \"\"\" For a given list of integers, return a tuple consisting of a sum and a product of all the integers in a list.\n    Empty sum should be equal to 0 and empty product should be equal to 1.\n    >>> FUNC([])\n    (0, 1)\n    >>> FUNC([1, 2, 3, 4])\n    (10, 24)\n    \"\"\"\n    sum_value = 0\n    prod_value = 0\n\n    for n in numbers:\n        sum_value += n\n        prod_value *= n\n    return sum_value, prod_value\n"}
{"id":69,"bad_solution":"class RollingHash:\n    def __init__(self, s):\n        b1, b2 = 1007, 2009\n        self.mod1, self.mod2 = 10**9+7, 10**9+9\n        self.size = len(s)\n        self.string = s\n\n        self.hash1 = self.make_hashtable(b1, mod1)\n        self.hash2 = self.make_hashtable(b2, mod2)\n        self.pow1 = self.make_powtable(b1, mod1)\n        self.pow2 = self.make_powtable(b2, mod2)\n\n    def make_hashtable(self, B, MOD):\n        hashtable = [0] * (self.size+1)\n        for i in range(1, self.size+1):\n            hashtable[i] = (hashtable[i-1] * B + ord(self.string[i-1]))%MOD\n        return hashtable\n    \n    def make_powtable(self, B, MOD):\n        power = [0] * (self.size+1)\n        power[0] = 1\n        for i in range(1, self.size+1):\n            power[i] = (B * power[i-1])%MOD\n        return power\n\n    def get_hash(self, l, length):\n        r = length+l-1\n        l -= 1\n        h1 = (self.hash1[r]-self.hash1[l]*self.pow1[r-l])%self.mod1\n        h2 = (self.hash2[r]-self.hash2[l]*self.pow2[r-l])%self.mod2\n        return (h1, h2)\n\nfrom collections import defaultdict\n\ndef solve1():\n    N = int(input())\n    S = input()\n    size = len(S)\n    hash_table = RollingHash(S)\n\n    ans = 0\n    for i in range(1, N+1):\n        for j in range(i+1, N+1):\n            if S[i-1]!=S[j-1]:continue\n\n            left = 1\n            right = min(j-i, size-j+1)+1\n\n            while right-left>1:\n                m = (left+right)\/\/2\n                if hash_table.get_hash(i, m)==hash_table.get_hash(j, m):\n                    left = m\n                else:\n                    right = m\n            ans = max(ans, left)\n\n    print(ans)\n\n\ndef solve2():\n    N = int(input())\n    S = input()\n    size = len(S)\n    hash_table = RollingHash(S)\n\n    def check(m):\n        d = defaultdict(lambda :10**20)\n        for i in range(1, size-m+2):\n            h = hash_table.get_hash(i, m)\n            d[h] = min(d[h], i)\n            if (i-d[h])>=m:\n                return True\n        return False\n\n    left, right = 0, size\/\/2 + 1\n    while right-left>1:\n        m = (right+left)\/\/2\n        if check(m):\n            left = m\n        else:\n            right = m\n\n    print(left)\n\nif __name__ == \"__main__\":\n    # solve1()\n    solve2()\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":70,"bad_solution":"def get_cache(chars, start, end, cache=dict()):\n    pair = (start, end)\n    block = cache.get(pair)\n    if block is not None:\n        return block\n    else:\n        block = chars[start:end]\n        cache[pair] = block\n        return block\n\n\ndef get_skip(chars, previous_start, previous_end, cache=dict()):\n    pair = (previous_start, previous_end)\n    if pair in cache:\n        return cache[pair]\n\n    skip = len(chars)\n    previous_len = previous_end - previous_start\n    if previous_end + previous_len < len(chars):\n        previous = get_cache(chars, previous_start, previous_end)\n        suspicious_end = previous_end + previous_len\n        suspicious = get_cache(chars, previous_end, previous_end + previous_len)\n        if previous == suspicious:\n            skip = suspicious_end\n    cache[pair] = skip\n    return skip\n\n\ndef count_k(chars):\n    cache = dict()\n    stack = []\n    previous_start = 0\n    previous_end = 0\n    max_k = 1\n    current = 1\n    while True:\n        skip = get_skip(chars, previous_start, previous_end)\n        while current < len(chars):\n            if current == skip:\n                current += 1\n                continue\n            pair = (previous_end, current)\n            if pair in cache:\n                k = cache[pair]\n                if max_k < k:\n                    max_k = k\n                else:\n                    current = len(chars)\n            else:\n                stack.append((previous_start, previous_end, current, max_k))\n                previous_start = previous_end\n                previous_end = current\n                current = current + 1\n                max_k = 1\n                break\n            current += 1\n        else:\n            if previous_end + 1 != len(chars):\n                max_k += 1\n            cache[(previous_start, previous_end)] = max_k\n            if len(stack) == 0:\n                break\n            _previous_start, _previous_end, _current, _max_k = stack.pop()\n            assert _current == previous_end\n            assert _previous_end == previous_start\n            if _max_k < max_k:\n                _max_k = max_k\n\n            previous_start = _previous_start\n            previous_end = _previous_end\n            current = _current\n            max_k = _max_k\n\n    return max_k\n\n\ns = input()\nprint(count_k(list(s)))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":71,"bad_solution":"N,K = list(map(int,input().split()))\nsys.setrecursionlimit(10**10) \nA = input()\nA = list(A)\nA = list(map(int,A))\ndef serch_right(x,K,t):\n    global count0,count1\n    if x<0 or len(A)<=x:\n        return count1\n    if A[x]==0:\n        if t == 0:\n            t=0\n            count1 +=1\n        elif t==1 :\n            if count0==K:\n                return count1\n            t=0\n            count1 +=1\n            count0 +=1\n            \n    else:\n        t=1\n        count1+=1\n    count1 = serch_right(x+1,K,t)\n    return count1\ndef serch_left(x,A):\n    global count2\n    if x<0 or len(A)<=x or A[x]==0:\n        return count2\n    if A[x]==1:\n        count2 +=1\n    count2 = serch_left(x-1,A)     \n    return count2\ncount =0\ncount0 =0\ncount1 =0\nfor i in range(len(A)):\n    if A[i]==0 and (A[i-1]!=0 or i == 0):\n        count2 = 0\n        count1 =0\n        count0 =0\n        t = 1\n        count1 = serch_right(i,K,t)\n        count2 = serch_left(i-1,A)\n        count1 = count1 + count2\n        count = max(count1,count)\nprint(max(count,1))\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":72,"bad_solution":"from typing import List, Tuple\n\n\ndef FUNC(numbers: List[int]) -> List[int]:\n    \"\"\" From a given list of integers, generate a list of rolling maximum element found until given moment\n    in the sequence.\n    >>> FUNC([1, 2, 3, 2, 3, 4, 2])\n    [1, 2, 3, 3, 3, 4, 4]\n    \"\"\"\n    running_max = None\n    result = []\n\n    for n in numbers:\n        if running_max is None:\n            running_max = n\n        else:\n            running_max = max(numbers)\n\n        result.append(running_max)\n\n    return result\n"}
{"id":73,"bad_solution":"#単位元を設定\nide = 0\n\nclass SegmentTree:\n\tdef __init__(self,n):\n        #セグ木の頂点はindex == 1から。index == 0は無視すること。\n        #つまり、STtable[0]は無視。頂点はSTtable[1]。\n\t\tself.n = n\n\t\ttmp = 0\n\t\twhile True:\n\t\t\tif 2 ** tmp >= self.n:\n\t\t\t\tbreak\n\t\t\ttmp += 1\n\t\tself.STtable = [ide] * (2*2**tmp)\n\t\tself.STtable_size = len(self.STtable)\n\n\tdef update(self,i,a):\n        #更新のためのインデックスの指定は0_indexedで。\n\t\ta_bit = 1 << ord(a)-97\n\t\ti += self.STtable_size\/\/2\n\t\tself.STtable[i] = a_bit\n\t\twhile i > 0:\n\t\t\ti \/\/= 2\n\t\t\tself.STtable[i] = self.STtable[i*2] | self.STtable[i*2+1]\n\n\tdef find(self,a,b,k=1,l=0,r=None):\n        #kは頂点番号。初期値は1にすること。\n\t\t#[a,b)の最小を返す。\n\t\t#[l,r)からです。\n        #初期値のrは、self.STtable_size\/\/2にすると、ちょうど要素数と同じ値になって[l,r)のrになる。\n        #問題に適するように範囲を指定するように注意。大体[l,r]で指定されている。\n\t\tif r == None:\n\t\t\tr = self.STtable_size\/\/2        \n\t\tif a >= r or b <= l:\n\t\t\treturn ide\n\t\telif a <= l and b >= r:\n\t\t\treturn self.STtable[k]\n\t\telse:\n\t\t\tmid = (l+r)\/\/2\n\t\t\tif b <= mid:\n\t\t\t\treturn self.find(a,b,2*k,l,mid)\n\t\t\telif a >= mid:\n\t\t\t\treturn self.find(a,b,2*k+1,mid,r)\n\t\t\telse:\n\t\t\t\tv1 = self.find(a,mid,2*k,l,mid)\n\t\t\t\tv2 = self.find(mid,b,2*k+1,mid,r)\n\t\t\treturn v1 | v2\n\nN = int(input())\nsolve = SegmentTree(N)\nS = input()\nfor i in range(N):\n\tsolve.update(i,S[i])\nQ = int(input())\nans = []\nfor _ in range(Q):\n\ta,b,c = map(str, input().split())\n\tif a == '1':\n\t\tsolve.update(int(b)-1,c)\n\telse:\n\t\ttmp = solve.find(int(b)-1,int(c))\n\t\tcnt = 0\n\t\tfor i in range(26):\n\t\t\tif tmp >> i & 1 == 1:\n\t\t\t\tcnt += 1\n\t\tans.append(cnt)\n\nfor a in ans:\n\tprint(a)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":74,"bad_solution":"\n\ndef FUNC(string: str) -> bool:\n    \"\"\" Test if given string is a palindrome \"\"\"\n    return string == string[::-1]\n\n\ndef FUNC(string: str) -> str:\n    \"\"\" Find the shortest palindrome that begins with a supplied string.\n    Algorithm idea is simple:\n    - Find the longest postfix of supplied string that is a palindrome.\n    - Append to the end of the string reverse of a string prefix that comes before the palindromic suffix.\n    >>> FUNC('')\n    ''\n    >>> FUNC('cat')\n    'catac'\n    >>> FUNC('cata')\n    'catac'\n    \"\"\"\n    if not string:\n        return ''\n\n    beginning_of_suffix = 0\n\n    while not FUNC(string):\n        beginning_of_suffix += 1\n\n    return string + string[:beginning_of_suffix][::-1]\n"}
{"id":75,"bad_solution":"N = int(input())\nA = list(map(int, input().split()))\nN = len(A) \/\/ 3\nA = A[:3*N]\n#print(N, A)\nA.append(0)\nA.append(0)\n\nans = 0\ndef ind(a, b):\n  t = sorted((a, b))\n  return t[0] * (N+1) + t[1]\ndef inv(i):\n  b = i % (N+1)\n  a = i \/\/ (N + 1)\n  return a, b\n\ndp = [-1] * (N+1)**2\ndp[ind(A[0],A[1])] = 0\ndp1 = [-1] * (N+1)\ndp1[A[0]] = 0\ndp1[A[1]] = 0\n\nans = 0\nfor i in range(0, N):\n  a = A[2+3*i] \n  b = A[2+3*i+1]\n  c = A[2+3*i+2]\n  #print(a,b,c)\n  if a == b == c:\n    ans+=1\n    continue\n  dp_new = {}\n  for x, y, z in [(a, b, c), (b, c, a), (c, a, b)]:\n    # choose 1 (x), leave y, z\n    i = ind(y,z)\n    if i not in dp_new:\n      dp_new[i] = 0\n    if dp[ind(x, x)] >= 0:\n      dp_new[i] = max(dp_new[i], dp[ind(x, x)] + 1)\n    \n    # choose 2 (x, y), leave t, z\n    for t in range(1, N+1):\n      i = ind(t,z)\n      # Not making three\n      dp_new[i] = dp1[t]\n      # Making three (x==y)\n      if x == y:\n        if dp[ind(t, x)] >= 0:\n          dp_new[i] = dp[ind(t, x)] + 1\n        \n  #print({inv(i):v for i, v in dp_new.items() })\n  for i, s in dp_new.items():\n    dp[i] = max(dp[i], s)\n    ta, tb = inv(i)\n    dp1[ta] = max(dp1[ta], s)\n    dp1[tb] = max(dp1[tb], s)\n\n#print(doubles)\nprint(ans + max(dp))\n    \n    \n        \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":76,"bad_solution":"import collections\nfrom scipy.sparse.csgraph import floyd_warshall\nimport sys\nsys.setrecursionlimit(10**8)\n\nn=int(input())\narr=[input() for _ in range(n)]\ng=[[] for _ in range(n)]\nfor i in range(n):\n  for j in range(n):\n    if i==j:\n      continue\n    if arr[i][j]=='1':\n      g[i].append(j)\n\ncolors=[0]*n\n\ndef dfs(v,color):\n  colors[v]=color\n  for u in g[v]:\n    if colors[u]==color:\n      return False\n    if colors[u]==0 and not dfs(u,-color):\n      return False\n  return True\n\ndef is_bipartite():\n  return dfs(0,1)\n\nif is_bipartite()==False:\n  print(-1)\n  exit()\n\nans=0\nfor v in range(n):\n  q=collections.deque()\n  q.append((v,1))\n  checked=[0]*n\n  anss=[]\n  while len(q)!=0:\n    tmp,depth=q.popleft()\n    anss.append(depth)\n    checked[tmp]=1\n    for v in g[tmp]:\n      if checked[v]==0:\n        q.append((v,depth+1))\n  ans=max(ans,max(anss))\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":77,"bad_solution":"from math import gcd\n\n\ndef pairwise_coprime(a):\n    check = [set() for _ in range(10 ** 6 + 10)]\n    for i, aa in enumerate(a):\n        now = aa\n        while now % 2 == 0:\n            if i > 0 and len(check[2]) > 0 and i not in check[2]:\n                return False\n            now \/\/= 2\n            check[2].add(i)\n        f = 3\n        while f * f <= now:\n            if now % f == 0:\n                if i > 0 and len(check[f]) > 0 and i not in check[f]:\n                    return False\n                now \/\/= f\n                check[f].add(i)\n            else:\n                f += 2\n        if now != 1:\n            check[now].add(i)\n    return True\n\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    ac_gcd = [a[-1] for _ in range(n)]\n    for i in range(n - 2, -1, -1):\n        ac_gcd[i] = gcd(a[i], ac_gcd[i + 1])\n    is_pc = pairwise_coprime(a)\n    if is_pc:\n        print(\"pairwise coprime\")\n    elif ac_gcd[0] == 1:\n        print(\"setwise coprime\")\n    else:\n        print(\"not coprime\")\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":78,"bad_solution":"#!\/usr\/bin\/env python3\nINF = 10**7\nimport sys\ninput = sys.stdin.readline\nfrom collections import*\n\ndef bfs(sx, sy, gx, gy, c):\n    q = deque([(sx, sy)])\n    dist = [[INF] * W for _ in range(H)]\n    dist[sx][sy] = 0\n    \n    while q:\n        x, y = q.popleft()\n        if (x, y) == (gx, gy): return dist[gx][gy]\n        for nx, ny in [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]:\n            if 0<=nx<H and 0<=ny<W and dist[nx][ny] > dist[x][y]:\n                if c[nx][ny] == \".\":\n                    dist[nx][ny] = dist[x][y]\n                    q.appendleft((nx, ny))\n        for nx in range(x-2, x+3):\n            for ny in range(y-2, y+3):\n                if 0<=nx<H and 0<=ny<W and dist[nx][ny] > dist[x][y]:\n                    if c[nx][ny] == \".\":\n                        dist[nx][ny] = dist[x][y] + 1\n                        q.append((nx, ny)) \n    return -1\nH, W = map(int, input().split())\n\ncx, cy = map(int, input().split())\ndx, dy = map(int, input().split())\nans = bfs(cx - 1, cy - 1, dx - 1, dy - 1, [input()[:-1] for _ in range(H)])\nprint(ans if ans != INF else -1)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":79,"bad_solution":"from collections import deque\nH,W = map(int,input().split())\nmaze = []\nfor i in range(H):\n    maze.append(input())\nq = deque()\nsaitan = [1000000]*H*W\nstart = []\nsumi= []\nfor i in range(H):\n    for k in range(W):\n        if maze[i][k] == '#':\n            start.append(i*W+k)\n\nfor i in start:\n    q.append(i)\n    sumi.append(i)\n    saitan[i] = 0\n#print(start)\ndef bfs(h,w,q,Sumi,Saitan):\n    \n    dx = [1,-1,0,0]\n    dy = [0,0,1,-1]\n    while len(q)>0:\n        j = q.popleft()\n        y = int(j\/w)\n        x = j%w\n        #print(saitan)\n        for k in range(4):\n            my = y + dy[k]\n            mx = x + dx[k]\n            #print(sx,sy,j,x,y,mx,my)\n            if not((0 <=my <= h-1) and (0 <= mx <= w-1)):\n                #print('q')\n                continue\n            if (my*w + mx) in Sumi:\n                #print('b')\n                continue\n            if saitan[(my*w + mx)] <= saitan[y*w + x] + 1:\n                #print('c')\n                continue\n                \n            saitan[(my*w + mx)] = saitan[y*w + x] + 1\n            q.append(my*w + mx)\n            Sumi.append(my*w + mx)\n    return max(saitan)\n\nprint(bfs(H,W,q,sumi,saitan))\n#print(saitan)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":80,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nfrom collections import deque\n\n\ndef II(): return int(sys.stdin.readline())\n\n\ndef MI(): return map(int, sys.stdin.readline().split())\n\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\n\ndef main():\n    n, m, k = MI()\n    a = deque(LI())\n    b = deque(LI())\n\n    read = []\n    isAll = False\n\n    while sum(read) <= k:\n        if len(a) == 0 and len(b) == 0:\n            isAll = True\n            break\n        if len(a) == 0 or a[0] >= b[0]:\n            b_top = b.popleft()\n            read.append(b_top)\n            continue\n        if len(b) == 0 or a[0] < b[0]:\n            a_top = a.popleft()\n            read.append(a_top)\n            continue\n\n    if isAll:\n        print(len(read))\n    else:\n        print(len(read) - 1)\n\n\n# oj t -c \"pypy3 main.py\"\n# acc s main.py -- --guess-python-interpreter pypy\nmain()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":81,"bad_solution":"from typing import List\n\n\ndef FUNC(a: str, b: str) -> str:\n    \"\"\" Input are two strings a and b consisting only of 1s and 0s.\n    Perform binary XOR on these inputs and return result also as a string.\n    >>> FUNC('010', '110')\n    '100'\n    \"\"\"\n    def FUNC(i, j):\n        if i == j:\n            return '1'\n        else:\n            return '0'\n\n    return ''.join(FUNC(x, y) for x, y in zip(a, b))\n"}
{"id":82,"bad_solution":"from typing import List, Optional\n\n\ndef FUNC(strings: List[str]) -> Optional[str]:\n    \"\"\" Out of list of strings, return the FUNC one. Return the first one in case of multiple\n    strings of the same length. Return None in case the input list is empty.\n    >>> FUNC([])\n\n    >>> FUNC(['a', 'b', 'c'])\n    'a'\n    >>> FUNC(['a', 'bb', 'ccc'])\n    'ccc'\n    \"\"\"\n    if not strings:\n        return None\n\n    maxlen = max(len(x) for x in strings)\n    for s in strings:\n        if len(s) > maxlen:\n            return s\n"}
{"id":83,"bad_solution":"from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nh, w = MAP()\na = []\nb = []\nc = []\nfor i in range(h):\n    a.append(input())\n    for j in range(w):\n        if a[i][j] == '#':\n            b.append([i, j])\n        else:\n            c.append([i, j])\n\nans = 0\nfor x in c:\n    tmp = inf\n    for y in b:\n        tmp = min(tmp, abs(x[0]-y[0])+abs(x[1]-y[1]))\n        if tmp <= ans:\n            break\n    ans = max(ans, tmp)\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":84,"bad_solution":"import sys\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\ndef main():\n    H,W,K = map(int, readline().split())\n    S = [list(map(int, readline().strip())) for j in range(H)]\n    \n    print(H,W,S)\n    \n    white = 0\n    for line in S:\n        white += sum(line)\n \n    if white <= K:\n        print(0)\n        exit()\n \n    Pdb().set_trace()\n    # 横線の決め方を全探索\n    ans = 10**5\n    \n    #yに横線Patternごとの列合計を作成\n    #入力例１のPattern[bin(2)]場合、y=[[1,1,1,0,0], [1,0,1,1,2]]\n    for pattern in range(2**(H-1)):\n        # 初期化\n        impossible = False\n        x = 0\n        ly = bin(pattern).count(\"1\")\n        y = [S[0]]\n        line = 0\n        for i in range(1,H):\n            if (pattern >> i-1) & 1:\n                line += 1\n                y.append(S[i])\n            else:\n                y[line] = [y[line][j] + S[i][j] for j in range(W)]\n \n        # 各列の値を加算していく\n        count = [0]*(ly + 1) \n        for j in range(W):\n            for i in range(line+1):\n                if y[i][j] > K :\n                    impossible = True\n                    break\n \n                count[i] += y[i][j]\n                #print(\"横Pattern{} 縦列まで　{} カウント数{} 縦線の数{}\".format(i, j, count[i], x))\n                #横Patten毎にｊ列までのホワイトチョコ合計数をカウント、\n                #カウント＞Kとなったら、縦線数を＋１、その列値でカウント数を初期化\n                if count[i] > K:\n                    x += 1\n                    for i in range(line+1):\n                        count[i] = y[i][j]\n                    break\n            #x縦線の数 + ly横線の数がAnsより大きくなったらBreak\n            if x + ly > ans or impossible:\n                impossible = True\n                break\n        if impossible:\n            x = 10**6\n        #x縦線の数 + ly横線の数がAnsより小さくなったらAnsを更新\n        ans = min(ans, x + ly)\n \n    print(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":85,"bad_solution":"def examA():\n    N, A, B = LI()\n    if (A-B)%2==0:\n        ans = \"Alice\"\n    else:\n        ans = \"Borys\"\n    print(ans)\n    return\n\ndef examB():\n    K = I()\n    A = LI()\n    cur = 2\n    for i in range(K-1,-1,-1):\n        a = A[i]\n        if A[i]>cur:\n            print(-1)\n            exit()\n        cur = (cur\/\/a+1)*a-1\n#        print(cur)\n    maxA = cur; cur = 2\n    for i in range(K-1,-1,-1):\n        a = A[i]\n        if cur<=a:\n            cur = a\n        else:\n            cur = a*(cur\/\/a+1)\n    minA = cur\n    print(minA,maxA)\n    return\n\nimport sys,copy,bisect,itertools,heapq,math\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nmod = 10**9 + 7\ninf = float('inf')\n\nif __name__ == '__main__':\n    examB()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":86,"bad_solution":"from collections import defaultdict\nN = int(input())\nL = [list(map(lambda x:int(x)-1, input().split())) for _ in range(N)]\n\n\ndef make_hash(a, b):\n    a, b = min(a, b), max(a, b)\n    return N*a+b\n\n\ndef un_hash(n):\n    a = n\/\/N\n    b = n % N\n    return a, b\n\n\nfrom_to = defaultdict(lambda: set())\npointed = defaultdict(int)\npointing = defaultdict(int)\n\nfor i in range(N):\n    for node_from, node_to in zip(L[i], L[i][1:]):\n        from_to[make_hash(i, node_to)].add(make_hash(i, node_from))\n        pointed[make_hash(i, node_to)] += 1\n        pointing[make_hash(i, node_from)] += 1\n\nSTART = set()\nDST = set()\nfor i in range(N):\n    for j in range(i+1, N):\n        h = make_hash(i, j)\n        pointed_i = pointed[h]\n        pointing_i = pointing[h]\n        if pointed_i == 0:\n            START.add(h)\n        if pointing_i == 0:\n            DST.add(h)\nif len(START) == 0 or len(DST) == 0:\n    print(-1)\n\nelse:\n    Q = [[v, 1] for v in DST]\n    dist = 1\n    while Q:\n        q, d = Q.pop()\n        for nex in from_to[q]:\n            Q.append([nex, d+1])\n            dist = d+1\n    print(dist)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":87,"bad_solution":"def main():\n    import sys\n    sys.setrecursionlimit(1000000)\n\n    N = int(input())\n    A = [[]]\n    for _ in range(N):\n        A.append([0]+list(map(int,input().split())))\n\n    #AR[i][j] => iにとって選手jとの試合が何番目か\n    AR = [[]]\n    for i in range(1,N+1):\n        AR.append([0]*(N+1))\n        for j in range(1,N):\n            b = A[i][j]\n            AR[i][b] = j\n\n    edges = {}\n    for i in range(1,N+1):\n        for j in range(i+1,N+1):\n            edges[(i,j)] = []\n            jForI = AR[i][j]\n            if jForI < N-1:\n                nxForI = A[i][jForI+1]\n                edges[(i,j)].append((min(i,nxForI),max(i,nxForI)))\n            iForJ = AR[j][i]\n            if iForJ < N-1:\n                nxForJ = A[j][iForJ+1]\n                edges[(i,j)].append((min(j,nxForJ),max(j,nxForJ)))\n\n    steps = {}\n    def dfs(i,j):\n        #iとjの試合を1日目とし、試合終了まで何日かかるかを返す。\n        if (i,j) not in steps:\n            steps[(i,j)] = 0\n            res = 1\n            for a,b in edges[(i,j)]:\n                res = max(res,dfs(a,b)+1)\n            steps[(i,j)] = res\n        elif steps[(i,j)] == 0:\n            print(-1)\n            exit()\n        return steps[(i,j)]\n\n    ans = 0\n    for i in range(1,N+1):\n        for j in range(i+1,N+1):\n            ans = max(ans,dfs(i,j))\n    print(ans)\nmain()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":88,"bad_solution":"char_num = int(input())\nchar_length = 10\nchars = []\nfor i in range(char_num):\n    chars.append(input())\n\n\nclass CharArrange:\n    def __init__(self, char):\n        self.char = char\n\n    def char_run(self):\n        list_char = self.str2ord_list(self.char)\n        for pos in range(1, len(list_char)):\n            self.insert_sort(list_char, pos, list_char[pos])\n        self.char = self.ordList2Str(list_char)\n\n    def order_run(self, chars):\n        for i, char in enumerate(chars):\n            chars[i] = self.ord_list2ord_concat(self.str2ord_list(char))\n        for pos in range(len(chars)):\n            self.insert_sort(chars, pos, chars[pos])\n        self.ord_chars = chars\n\n    def str2ord_list(self, char):\n        return list(map(ord, char))\n\n    def ordList2Str(self, ordList):\n        return ''.join(list(map(chr, ordList)))\n\n    def ord_list2ord_concat(self, ord_list):\n        self.ord_concat = ''\n        for ord_num in ord_list:\n            self.ord_concat += str(ord_num)\n        return int(self.ord_concat)\n\n    def insert_sort(self, A, pos, value):\n        i = pos - 1\n        while (i >= 0 and A[i] > value):\n            A[i+1] = A[i]\n            i = i - 1\n        A[i+1] = value\n        return A\n\n\nfor i, char in enumerate(chars):\n    CA = CharArrange(char)\n    CA.char_run()\n    chars[i] = CA.char\nCA.order_run(chars)\nord_chars = CA.ord_chars\n\ncounter = 0\nfor i in range(len(ord_chars) - 1):\n    k = i + 1\n    while (ord_chars[i] == ord_chars[k]):\n        counter += 1\n        if k == len(ord_chars) - 1:\n            break\n        else:\n            k += 1\nprint(counter)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":89,"bad_solution":"import copy\nfrom heapq import heappop, heapify, heappush\nimport math\nN, K = map(int, input().split())\nA = [int(i) for i in input().split()]\nF = [int(i) for i in input().split()]\nans = 0\nA.sort(reverse=True)\nF.sort()\ns = []\nfor i in range(N):\n    s.append([A[i]*F[i], A[i], F[i]])\ns.sort(reverse=True, key=lambda x: x[0])\n\ndef f(l, T):\n    cur = 0\n    num = 0\n    S = copy.deepcopy(l)\n    while cur <= K:\n        if len(S) == 0:\n            break\n        a, b, c = S[num]\n        if a <= T:\n            break\n        cur += math.ceil((a - T)\/c)\n        num += 1\n    if cur <= K:\n        return True\n    else:\n        return False\n\nok, ng = s[0][0], -1\nwhile abs(ok-ng) > 1:\n    mid = (ok+ng)\/\/2\n    if f(s, mid) == True:\n        ok = mid\n    else:\n        ng = mid\nprint(ok)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":90,"bad_solution":"\n\ndef FUNC(a: int, b: int) -> int:\n    \"\"\" Return a greatest common divisor of two integers a and b\n    >>> FUNC(3, 5)\n    1\n    >>> FUNC(25, 15)\n    5\n    \"\"\"\n    while b:\n        a, b = b, a % b\n    return b\n"}
{"id":91,"bad_solution":"#!\/usr\/bin\/env python3\nimport collections as cl\nimport sys\n\n\ndef II():\n    return int(sys.stdin.readline())\n\n\ndef MI():\n    return map(int, sys.stdin.readline().split())\n\n\ndef LI():\n    return list(map(int, sys.stdin.readline().split()))\n\n\ndef main():\n    N = II()\n    targets = LI()\n    MAX_INT = max(targets) + 1\n    targets = set(targets)\n    is_pw = True\n\n    for i in range(2, MAX_INT):\n        origin = i\n        kosuu = 0\n        while origin <= MAX_INT:\n            if origin in targets:\n                kosuu += 1\n            origin += i\n\n        if kosuu <= 1:\n            continue\n        elif kosuu < N:\n            is_pw = False\n        else:\n            print(\"not coprime\")\n            return\n\n    if is_pw:\n        print(\"pairwise coprime\")\n        return\n    print(\"setwise coprime\")\n\n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":92,"bad_solution":"import sys\ninput = sys.stdin.readline\ndef main():\n    H,W = map(int,input().split())\n    CH,CW = map(int,input().split())\n    DH,DW = map(int,input().split())\n    S=[None]*H\n    for i in range(H):\n        S[i] = input()\n    \n    from collections import deque\n    def cango_step(x,y):\n        cand =[]\n        if x+1<=H-1:\n            cand.append((x+1,y))\n        if x-1>=0:\n            cand.append((x-1,y))\n        if y+1<=W-1:\n            cand.append((x,y+1))\n        if y-1>=0:\n            cand.append((x,y-1))\n        return cand\n    def cango_warp(x,y):\n        cand = [(i,j) \n                for i in range(x-2,x+3) for j in range(y-2,y+3) \n                if 0<=i and i<=H-1 and 0<=j and j<=W-1]\n        return cand\n    \n    been = [[False]*W for _ in range(H)]\n    rooms=dict()\n    i_room=-1\n    for x in range(H):\n        for y in range(W):\n            if S[x][y]==\".\" and not been[x][y]:\n                i_room+=1\n                been[x][y]=True\n                q = deque([(-1,-1,x,y)]) \n    \n                rooms[(x,y)]=i_room\n                while q:\n                    x_old,y_old,x_now,y_now = q.popleft()\n                    \n                    cand = cango_step(x_now,y_now)\n                    #print(x_old,y_old,x_now,y_now,time)\n                    \n                    if x_now==CH-1 and y_now==CW-1:\n                        start_warp = i_room\n                    if x_now==DH-1 and y_now==DW-1:\n                        end_warp = i_room\n                    \n                    for x_new,y_new in cand:\n                        if not been[x_new][y_new] and S[x_new][y_new]==\".\":\n                            q.append((x_now,y_now,x_new,y_new))\n                            been[x_new][y_new]=True\n    #                        room.append((x_new,y_new))\n                            rooms[(x_new,y_new)]=i_room\n    #            rooms.append(room)\n    \n    if start_warp==end_warp:\n        print(0)\n    else:\n            \n        #ワープで行けるほかの部屋をtree入れる\n        n_rooms = i_room+1\n        tree=[[] for _ in range(n_rooms)]\n        for k,v in rooms.items():\n            cango = set(rooms[togo] for togo in cango_warp(*k) if S[togo[0]][togo[1]]==\".\" )\n            for c in cango:\n                if c!=v:\n                    tree[c].append(v)\n                    tree[v].append(c)\n            #print(v,cango)\n        for i in range(len(tree)):\n            tree[i] = set(tree[i])\n\n        \n        \n        q = deque([(-1,start_warp,0)]) #これでもよい\n        \n        been=[False]*n_rooms\n        been[start_warp]=True\n        reach=False\n        while q:\n            parent,x,time = q.popleft()\n            if x==end_warp:\n                reach=True\n                break\n            \n            for y in tree[x]:\n                if not been[y]:\n                    q.append((x,y,time+1))#子ノードを追加\n                    been[y]=True\n            #print(parent,x,q,time)\n        if reach:\n            print(time)\n        else:\n            print(-1)\nmain()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":93,"bad_solution":"# -*- coding: utf-8 -*-\n\nimport sys\nfrom collections import deque\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN = INT()\nA = [deque()]\nfor i in range(N):\n    A.append(deque(LIST()))\n\ncnt = N*(N-1)\/\/2\nday = 0\nwhile cnt > 0:\n    prev = cnt\n    skip = [False] * (N+1)\n    for i in range(1, N+1):\n        if len(A[i]) and not skip[i]:\n            a = A[i][0]\n            if len(A[a]) and not skip[a]:\n                b = A[a][0]\n                if i == b:\n                    A[i].popleft()\n                    A[a].popleft()\n                    cnt -= 1\n                    skip[i] = skip[a] = True\n    if prev == cnt:\n        print(-1)\n        exit()\n    day += 1\n    if day > 200000:\n        print(N*(N-1)\/\/2)\n        exit()\nprint(day)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":94,"bad_solution":"import sys\nfrom collections import deque\n\nsys.setrecursionlimit(4100000)\n\n\ndef inputs(num_of_input):\n    ins = [input() for i in range(num_of_input)]\n    return ins\n\n\ndef solve(inputs):\n    head = int(inputs[0][:2])\n    tail = int(inputs[0][2:])\n\n    YY = 1\n    BOTH = 2\n    NA = -1\n    head_type = NA\n    tail_type = NA\n\n    if head == 0:\n        head_type = NA\n    elif head > 12:\n        head_type = YY\n    else:\n        head_type = BOTH\n\n    if tail == 0:\n        tail_type = NA\n    elif tail > 12:\n        tail_type = YY\n    else:\n        tail_type = BOTH\n\n    if head_type == NA or tail_type == NA:\n        return \"NA\"\n    if head_type == YY and tail_type == YY:\n        return \"NA\"\n    if head_type == BOTH and tail_type == BOTH:\n        return \"AMBIGUOUS\"\n    if head_type == YY:\n        return \"YYMM\"\n    if tail_type == YY:\n        return \"MMYY\"\n\n\ndef string_to_int(string):\n    return list(map(lambda x: int(x), string.split()))\n\n\nif __name__ == \"__main__\":\n    ret = solve(inputs(1))\n    print(ret)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":95,"bad_solution":"from typing import List\n\n\ndef FUNC(string: str) -> List[str]:\n    \"\"\" Return list of all prefixes from shortest to longest of the input string\n    >>> FUNC('abc')\n    ['a', 'ab', 'abc']\n    \"\"\"\n    result = []\n\n    for i in range(len(string)-1):\n        result.append(string[:i+1])\n    return result\n"}
{"id":96,"bad_solution":"\n\ndef FUNC(n: int) -> str:\n    \"\"\" Return a string containing space-delimited numbers starting from 0 upto n inclusive.\n    >>> FUNC(0)\n    '0'\n    >>> FUNC(5)\n    '0 1 2 3 4 5'\n    \"\"\"\n    return ' '.join([str(x) for x in range(n)])\n"}
{"id":97,"bad_solution":"import sys\nimport numpy as np\nimport math\n\ndef ReadInputNum():\n    input_num=[]\n    for i in range(5):\n        input_num.append(int(input()))\n    return tuple(input_num)\n\ndef CheckRangeInput(*argv):\n    for num in argv:\n        if num<=123 and isinstance(num,int):\n            pass\n            # print(\"good\")                                                                                                                                                              \n        else:\n            print(\"input\"+ num +\"is unexpected.\")\n            sys.exit()\n\n\ndef SumTotalTime(Tuple_Input):\n    list_input=list(Tuple_Input)\n    # print(list_input)                                                                                                                                                                  \n    list_tmp=np.array(list_input)\n    amari=(list_tmp-1)%10\n    amari=amari.tolist()\n    # print(amari)                                                                                                                                                                       \n    last_one=min(amari)\n    # print(last_one)                                                                                                                                                                    \n    last_one=list_input.pop(amari.index(last_one))\n    print(last_one)\n    print(list_input)\n\n    out_put=0\n    for i in list_input:\n        out_put += math.ceil(i\/10)*10\n    # print(out_put)                                                                                                                                                                     \n    print(out_put+last_one)\n\n\n\nA,B,C,D,E = ReadInputNum()\nCheckRangeInput(A,B,C,D,E)\ntuple_input = (A,B,C,D,E)\nSumTotalTime(tuple_input)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":98,"bad_solution":"from copy import copy\nn = int(input())\na = list(map(int, input().split()))\n\nok, ng = n, 0\nwhile ok-ng > 1:\n\tx = (ok+ng)\/\/2\n\t#d = defaultdict(int)\n\td = dict()\n\tlast = 0\n\tvalid = True\n\tif x == 1:\n\t\tfor i in range(n-1):\n\t\t\tif a[i] >= a[i+1]:\n\t\t\t\tvalid = False\n\t\t\t\tbreak\n\t\tif valid:\n\t\t\tok = x\n\t\telse:\n\t\t\tng = x\n\t\tcontinue\n\n\tfor i in range(n-1):\n\t\tdels = []\n\t\tif a[i] < a[i+1]:\n\t\t\tlast = a[i+1]\n\t\telif a[i] > a[i+1]:\n\t\t\t#dels = []\n\t\t\tfor k in d.keys():\n\t\t\t\tif k > last:\n\t\t\t\t\tdels.append(k)\n\t\t\tif a[i+1] > last:\n\t\t\t\td[a[i+1]] = 1\n\t\t\telse:\n\t\t\t\tj = a[i+1]\n\t\t\t\twhile j in d:\n\t\t\t\t\tif d[j] != x-1 or j <= 0:\n\t\t\t\t\t\tbreak\n\t\t\t\t\telse:\n\t\t\t\t\t\tdels,append(j)\n\t\t\t\t\t\tj -= 1\n\t\t\t\tif j in d:\n\t\t\t\t\td[j] += 1\n\t\t\t\telse:\n\t\t\t\t\td[j] = 1\n\t\t\tlast = a[i+1]\n\t\telif a[i] == a[i+1]:\n\t\t\t#dels = []\n\t\t\tfor k in d.keys():\n\t\t\t\tif k > last:\n\t\t\t\t\tdels.append(k)\n\t\t\tj = a[i+1]\n\t\t\twhile j in d:\n\t\t\t\tif d[j] != x-1 or j <= 0:\n\t\t\t\t\tbreak\n\t\t\t\telse:\n\t\t\t\t\tdels.append(j)\n\t\t\t\t\tj -= 1\n\t\t\tif j in d:\n\t\t\t\td[j] += 1\n\t\t\telse:\n\t\t\t\td[j] = 1\n\t\t\tlast = a[i+1]\n\n\t\tfor k in dels:\n\t\t\tdel d[k]\n\n\t\tif 0 in d:\n\t\t\tvalid = False\n\t\t\tbreak\n\n\tif valid:\n\t\tok = x\n\telse:\n\t\tng = x\nprint(ok)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":99,"bad_solution":"import sys\nfrom collections import deque, defaultdict\nimport copy\nimport bisect\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 9)\n\nH, W = list(map(int, input().split()))\ngrid = []\nfor i in range(H):\n    grid.append(input()[0:W])\n\nnum_yoko = [[0 for i in range(W)] for j in range(H)]\nnum_tate = [[0 for i in range(W)] for j in range(H)]\n\nfor i in range(H):\n    for j in range(W):\n        if grid[i][j] == '.':\n            if j == 0:\n                num_yoko[i][j] = 1\n            else:\n                num_yoko[i][j] = num_yoko[i][j - 1] + 1\n            if i == 0:\n                num_tate[i][j] = 1\n            else:\n                num_tate[i][j] = num_tate[i - 1][j] + 1\nfor i in range(H - 1, -1, -1):\n    for j in range(W - 1, -1, -1):\n        if grid[i][j] == '.':\n            if j != W - 1:\n                if num_yoko[i][j + 1] != 0:\n                    num_yoko[i][j] = num_yoko[i][j + 1]\n            if i != H - 1:\n                if num_tate[i + 1][j] != 0:\n                    num_tate[i][j] = num_tate[i + 1][j]\n\nnum_max = 0\nfor i in range(H - 1):\n    for j in range(W - 1):\n        if num_yoko[i][j] + num_tate[i][j] > num_max:\n            num_max =  num_yoko[i][j] + num_tate[i][j]\n\nprint(num_max - 1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":100,"bad_solution":"\n\ndef FUNC(string: str) -> int:\n    \"\"\" Given a string, find out how many distinct characters (regardless of case) does it consist of\n    >>> FUNC('xyzXYZ')\n    3\n    >>> FUNC('Jerry')\n    4\n    \"\"\"\n    return len(set(string))\n"}
{"id":101,"bad_solution":"from collections import deque, defaultdict\n\nn,m = map(int, input().split())\na = [list(map(int, input().split())) for i in range(n)]\ndef check(x):\n    \"\"\"\n    最大値をx以下にできるか？\n    \"\"\"\n    used = [0]*n\n    if x >= n:\n        return True\n    # NM\n    b = [deque(a[i]) for i in range(n)]\n    d = defaultdict(list)\n\n    ng = set()\n    while True:\n        for i in range(n):\n            if used[i]:\n                continue\n            while b[i] and b[i][0] in ng:\n                b[i].popleft()\n            if not b[i]:\n                return False\n            like = b[i].popleft()\n\n            d[like].append(i)\n            used[i] = 1\n        # チェック\n        flag = True\n        for key, value in d.items():\n            if len(value) > x:\n                flag = False\n                ng.add(key)\n                for v in value:\n                    used[v] = 0\n                d[key].pop()\n        if flag:\n            return True\n\nleft = 0\nright = n\nwhile right - left > 1:\n    mid = (left+right)\/\/2\n    if check(mid):\n        right = mid\n    else:\n        left = mid\nprint(right)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":102,"bad_solution":"import sys\nfrom bisect import bisect, bisect_left\nimport heapq\n\ndef solve():\n    input = sys.stdin.readline\n    N, M = map(int, input().split())\n    A = [int(a) for a in input().split()]\n    A.sort()\n    S = [0] * (N + 1)\n    for i, a in enumerate(A): S[i + 1] = a + S[i]\n \n    l, h = 1, A[N-1] * 2 + 1\n    while h - l > 1: #最小値がｍ以上の要素をM個用意できるか\n        m = (h + l) \/\/ 2\n        count = 0\n        count_l = 0\n        for i, a in enumerate(A): count += N - bisect_left(A, m - a)\n        if count >= M: \n            l = m\n            count_l = count\n        else: h = m\n\n    total = 0\n    count = 0\n    Q = []\n    heapq.heapify(Q)\n    #print(A)\n    for i, a in enumerate(A):\n        j = bisect_left(A, l - a)\n        double = bisect_left(A, h - a)\n        total += a * (N - j) + (S[N] - S[j])\n        for k in range(j, min(N - 1, double + 1)):\n            heapq.heappush(Q, a + A[k])\n        #print(a, j)\n\n    if count_l > M:\n        for _ in range(count_l - M):\n            minus = heapq.heappop(Q)\n            total -= minus\n\n    print(total)\n\n    return 0\n\nif __name__ == \"__main__\":\n    solve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":103,"bad_solution":"N = int(input())\n\nXY = [[set() for i in range(10**5+1)] for j in range(2)]\nfor i in range(N):\n  x, y = map(int, input().split())\n  XY[0][x].add(y)\n  XY[1][y].add(x)\n\nis_visited_x = [False] * (10**5 + 1)\ndef dfs(x):\n  global is_visited_x\n  is_visited_x[x] = True\n  stack = [[x], []]\n  idx = 0\n  num_e = 0\n  num_xy = [1, 0]\n  parent = 0\n  while stack[0] or stack[1]:\n    node = stack[idx][-1]\n    children = XY[idx][node]\n    if children:\n      child = children.pop()\n      XY[idx-1][child].remove(node) # 今来た道を削除\n      num_e += 1\n      if child in stack[idx-1]:\n        continue\n      stack[idx-1].append(child)\n      num_xy[idx-1] += 1\n      is_visited_x[child] += idx\n      idx = (idx + 1) % 2\n    else:\n      stack[idx].pop()\n      idx = (idx + 1) % 2\n  return num_e, num_xy\n\nans = 0\nfor x in range(1, 10**5+1):\n  if is_visited_x[x]:\n    continue\n  num_e, num_xy = dfs(x)\n  ans += num_xy[0]*num_xy[1] - num_e\n\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":104,"bad_solution":"from typing import List\n\n\ndef FUNC(music_string: str) -> List[int]:\n    \"\"\" Input to this function is a string representing musical notes in a special ASCII format.\n    Your task is to parse this string and return list of integers corresponding to how many beats does each\n    not last.\n\n    Here is a legend:\n    'o' - whole note, lasts four beats\n    'o|' - half note, lasts two beats\n    '.|' - quater note, lasts one beat\n\n    >>> FUNC('o o| .| o| o| .| .| .| .| o o')\n    [4, 2, 1, 2, 2, 1, 1, 1, 1, 4, 4]\n    \"\"\"\n    note_map = {'o': 3, 'o|': 2, '.|': 1}\n    return [note_map[x] for x in music_string.split(' ') if x]\n"}
{"id":105,"bad_solution":"\n\ndef FUNC(string: str, substring: str) -> int:\n    \"\"\" Find how many times a given substring can be found in the original string. Count overlaping cases.\n    >>> FUNC('', 'a')\n    0\n    >>> FUNC('aaa', 'a')\n    3\n    >>> FUNC('aaaa', 'aa')\n    3\n    \"\"\"\n    times = 0\n\n    for i in range(len(string) - len(substring)):\n        if string[i:i+len(substring)] == substring:\n            times += 1\n\n    return times\n"}
{"id":106,"bad_solution":"# -*- coding: utf-8 -*-\n\nimport sys\nfrom operator import itemgetter\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN=INT()\nAB=[]\nfor i in range(N):\n    a,b=MAP()\n    AB.append((a, b))\n\nAB.sort(key=itemgetter(1))\ntime=0\nfor i in range(N):\n    a,b=AB[i]\n    time+=a\n    if b<time-1:\n        No()\n        exit()\nYes()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":107,"bad_solution":"class SegmentTreeDual():\n    def __init__(self,arr,op=lambda x,y:y if y != -1 else x,ie=-1):\n        self.h = (len(arr)-1).bit_length()\n        self.n = 2**self.h\n        self.ie = ie\n        self.op = op\n        self.val = [ie for _ in range(self.n)]\n        self.laz = [ie for _ in range(2*self.n)]\n        for i in range(len(arr)):\n            self.val[i] = arr[i]\n    def update(self,left,right,f):\n        left += self.n\n        right += self.n\n        while right - left > 0:\n            if right & 1:\n                right -= 1\n                self.laz[right] = self.op(self.laz[right],f)\n            if left & 1:\n                self.laz[left] = self.op(self.laz[left],f)\n                left += 1\n            left >>= 1\n            right >>= 1\n    def get(self,index):\n        res = self.val[index]\n        index += self.n\n        while index>0:\n            res = self.op(res,self.laz[index])\n            index \/\/= 2\n        return res\n\nimport sys\ninput = sys.stdin.readline\n\nimport bisect\n\nN,D,A = map(int,input().split())\nmonster = [list(map(int,input().split())) for _ in range(N)]\n\nmonster.sort()\nans = 0\nX = []\nH = []\nfor i in range(N):\n    X.append(monster[i][0])\n    H.append(monster[i][1])\n\nr = [0 for _ in range(N)]\nfor i in range(N):\n    r[i] = bisect.bisect_left(X,X[i]+2*D+1)\n\nsg = SegmentTreeDual(H,lambda x,y:x+y,0)\n\nfor i in range(N):\n    hp = sg.get(i)\n    if hp <= 0:\n        continue\n    cnt = -(-hp\/\/A)\n    sg.update(i,r[i],-A*cnt)\n    ans += cnt\n\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":108,"bad_solution":"A,B,Q=map(int,input().split())\ns=[int(input()) for _ in range(A)]\nt=[int(input()) for _ in range(B)]\n\n#二分探索関数\ndef bin_search(x,seq):\n    width=[0,len(seq)-1]\n    while(width[1]-width[0]>1):\n        center=(sum(width)\/\/2)\n        if x>=seq[center]:\n            width=[center,width[1]]\n        else:\n            width=[width[0],center]\nif x<=seq[width[0]]:\n    return [width[0],width[0]]\nelif x>=seq[width[1]]:\n    return [width[1],width[1]]\nelse:\n    return width\n\nfor i in range(Q):\n    x=int(input())\n    Nb_s=bin_search(x,s)\n    Nb_t=bin_search(x,t)\n    Nb_s0=s[Nb_s[0]]\n    Nb_s1=s[Nb_s[1]]\n    Nb_t0=t[Nb_t[0]]\n    Nb_t1=t[Nb_t[1]]\n\n    k1=abs(Nb_s0-x)+abs(Nb_t0-Nb_s0)\n    k2=abs(Nb_s1-x)+abs(Nb_t0-Nb_s1)\n    k3=abs(Nb_s0-x)+abs(Nb_t1-Nb_s0)\n    k4=abs(Nb_s1-x)+abs(Nb_t1-Nb_s1)\n    k5=abs(Nb_t0-x)+abs(Nb_t0-Nb_s0)\n    k6=abs(Nb_t1-x)+abs(Nb_t1-Nb_s1)\n    k7=abs(Nb_t0-x)+abs(Nb_t0-Nb_s1)\n    k8=abs(Nb_t1-x)+abs(Nb_t1-Nb_s0)\n    print(min(k1,k2,k3,k4,k5,k6,k7,k8))\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":109,"bad_solution":"import bisect\nfrom collections import defaultdict\n\nN = int(input())\nS = input()\nQ = int(input())\n\n\nalpha_dic = defaultdict(list)\n\nfor i, s in enumerate(S):\n    alpha_dic[s].append(i)\n\nfor _ in range(Q):\n    l, m, n = input().split()\n\n    if l == '1':\n        m = int(m) - 1\n        c = S[m]\n\n        if c == n:\n            continue\n        else:\n            i = bisect.bisect_left(alpha_dic[c], m)\n            del alpha_dic[c][i]\n\n            bisect.insort_left(alpha_dic[n], m)\n    else:\n        m, n = int(m) - 1, int(n) - 1\n\n        cnt = 0\n        for _, val in alpha_dic.items():\n            left_idx = bisect.bisect_left(val, m)\n            right_idx = bisect.bisect_left(val, n)\n            x = len(val)\n\n            if left_idx > right_idx or left_idx == x or (left_idx == 0 and right_idx == 0 and val[0] != m and val[0] != n):\n                continue\n            else:\n                cnt += 1\n\n        print(cnt)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":110,"bad_solution":"from bisect import bisect_right\n\n\ndef main():\n    N, M = map(int, input().split())\n    A = list(map(int, input().split()))\n    A.sort()\n    cumsum = [0] * (N+1)\n    for i in range(N):\n        cumsum[i+1] = cumsum[i] + A[i]\n    lo = 0\n    hi = int(2e5)\n    while lo < hi:\n        mid = (lo + hi) \/\/ 2\n        num = 0\n        total = 0\n        for a in A:\n            idx = bisect_right(A, mid - a)\n            num += (N - idx)\n            total += (cumsum[N] - cumsum[idx]) + a * (N - idx)\n        if num < M:\n            hi = mid\n        else:\n            lo = mid + 1\n    ans = total - (num - M) * (mid + 1)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":111,"bad_solution":"def bfs(start, count):\n    global visited, color\n    temp = []\n    for hh, ww in start:\n        if (hh in range(h)) & (ww in range(w)):\n            color[hh][ww] = min(count, color[hh][ww])\n            visited.add(str(hh) + \"_\" + str(ww))\n            h_w_list = [[hh + 1, ww], [hh, ww + 1], [hh - 1, ww], [hh, ww - 1]]\n            for h_, w_ in h_w_list:\n                if (str(h_) + \"_\" + str(w_)) not in visited:\n                    if (h_ in range(h)) & (w_ in range(w)):\n                        temp.append([h_, w_])\n    if len(temp) > 0:\n        bfs(temp, count + 1)\n\ninf = 10 ** 9\nh, w = map(int, input().split())\na = []\nfor _ in range(h):\n    a.append(list(input()))\ncolor = [[inf for _ in range(w)] for _ in range(h)]\nstart = []\nvisited = set([])\nfor hh in range(h):\n    for ww in range(w):\n        if a[hh][ww] == \"#\":\n            start.append([hh, ww])\n            color[hh][ww] = 0\nbfs(start, 0)\ncolored = []\nfor c in color:\n    colored.extend(c)\nprint(max(colored))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":112,"bad_solution":"def main():\n    #from sys import stdin, setrecursionlimit\n    #setrecursionlimit(10**9)\n    #r = input()\n    #n = int(input())\n    #a, b = map(int, input().split())\n    #s, y = input().split()\n    #a = input().split()\n    #a = [int(input()) for i in range(n)]\n    #a = list(map(int, input().split()))\n    #a = [list(map(int, input().split())) for i in range(n)]\n    #a = [int(s) - 1 for s in input().split()]\n    #l=[int(input()) for _ in range(int(input()))]\n    #res = 0\n    a, b = map(int, input().split())\n    x = a*100\/\/8\n    y = b*10\n\n    res = int(max(x, y))\n    if res > 100:\n        print(-1)\n    else:\n        print(res)\n\nif __name__ == '__main__':\n    main()\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":113,"bad_solution":"import sys\nimport collections\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    H, W = [int(x) for x in input().split()]\n    CH, CW = [int(x) - 1 for x in input().split()]\n    DH, DW = [int(x) - 1 for x in input().split()]\n    S = [input().strip() for _ in range(H)]\n\n    warp = ((-2, -2), (-2, -2), (-2, 0), (-2, 1), (-2, 2),\n            (-1, -2), (-1, -1), (-1, 1), (-1, 2),\n            (0, 2), (0, -2),\n            (1, -2), (1, -1), (1, 1), (1, 2),\n            (2, -2), (2, -1), (2, 0), (2, 1), (2, 2))\n\n    visited = [[float(\"inf\")] * W for _ in range(H)]\n\n    q = collections.deque()\n    visited[CH][CW] = 0\n    q.append((CH, CW))\n    while q:\n        cx, cy = q.popleft()\n        cc = visited[cx][cy]\n\n        # 隣接\n        kabe_cnt = 0\n        for nx, ny in ([0, 1], [0, -1], [1, 0], [-1, 0]):\n            nnx = cx + nx\n            nny = cy + ny\n            if 0 <= nnx <= H - 1 and 0 <= nny <= W - 1:\n                if S[nnx][nny] == \".\":\n                    if visited[nnx][nny] > cc:\n                        q.append((nnx, nny))\n                        visited[nnx][nny] = cc\n                else:\n                    kabe_cnt += 1\n\n        # ワープ\n        if kabe_cnt > 0:\n            for nx, ny in warp:\n                nnx = cx + nx\n                nny = cy + ny\n                if 0 <= nnx <= H - 1 and 0 <= nny <= W - 1:\n                    if S[nnx][nny] == \".\" and visited[nnx][nny] > cc + 1:\n                        q.append((nnx, nny))\n                        visited[nnx][nny] = cc + 1\n                        break\n\n    if visited[DH][DW] == float(\"inf\"):\n        print(-1)\n    else:\n        print(visited[DH][DW])\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":114,"bad_solution":"def main():\n    import heapq\n    n = int(input())\n    a = list(map(int, input().split()))\n    for i in range(n-1):\n        if a[i] >= a[i+1]:\n            break\n    else:\n        print(1)\n        return\n\n    h = []\n    heapq.heapify(h)\n    kind = 1\n    length = 0\n    d = dict()\n    for i in a:\n        if length >= i:\n            while h:\n                hh = -heapq.heappop(h)\n                if hh > i:\n                    d.pop(hh)\n                else:\n                    heapq.heappush(h, -hh)\n                    break\n            for j in range(i, 0, -1):\n                if j not in d:\n                    d[j] = 2\n                    heapq.heappush(h, -j)\n                    kind = max(kind, 2)\n                    while h:\n                        hh = -heapq.heappop(h)\n                        if hh > j:\n                            d.pop(hh)\n                        else:\n                            heapq.heappush(h, -hh)\n                            break\n                    break\n                else:\n                    if d[j] < kind:\n                        d[j] += 1\n                        while h:\n                            hh = -heapq.heappop(h)\n                            if hh > j:\n                                d.pop(hh)\n                            else:\n                                heapq.heappush(h, -hh)\n                                break\n                        break\n            else:\n                d[i] += 1\n                kind += 1\n        length = i\n\n    def value(kind):\n        h = []\n        heapq.heapify(h)\n        length = 0\n        d = dict()\n        for i in a:\n            if length >= i:\n                while h:\n                    hh = -heapq.heappop(h)\n                    if hh > i:\n                        d.pop(hh)\n                    else:\n                        heapq.heappush(h, -hh)\n                        break\n                for j in range(i, 0, -1):\n                    if j not in d:\n                        d[j] = 2\n                        heapq.heappush(h, -j)\n                        while h:\n                            hh = -heapq.heappop(h)\n                            if hh > j:\n                                d.pop(hh)\n                            else:\n                                heapq.heappush(h, -hh)\n                                break\n                        break\n                    else:\n                        if d[j] < kind:\n                            d[j] += 1\n                            while h:\n                                hh = -heapq.heappop(h)\n                                if hh > j:\n                                    d.pop(hh)\n                                else:\n                                    heapq.heappush(h, -hh)\n                                    break\n                            break\n                else:\n                    return False\n            length = i\n        return True\n\n    def b_search(ok, ng, value):\n        while abs(ok-ng) > 1:\n            mid = (ok+ng)\/\/2\n            if value(mid):\n                ok = mid\n            else:\n                ng = mid\n        return ok\n\n    print(b_search(kind, 1, value))\n\n\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":115,"bad_solution":"from typing import List\n\n\ndef FUNC(numbers: str) -> str:\n    \"\"\" Input is a space-delimited string of numberals from 'zero' to 'nine'.\n    Valid choices are 'zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight' and 'nine'.\n    Return the string with numbers sorted from smallest to largest\n    >>> FUNC('three one five')\n    'one three five'\n    \"\"\"\n    value_map = {\n        'zero': 0,\n        'one': 1,\n        'two': 2,\n        'three': 3,\n        'four': 4,\n        'five': 5,\n        'six': 6,\n        'seven': 7,\n        'eight': 8,\n        'nine': 9\n    }\n    return ' '.join([x for x in numbers.split(' ') if x])\n"}
{"id":116,"bad_solution":"\nfrom functools import lru_cache\nimport math\nimport sys\n\nn = int(input())\nsys.setrecursionlimit(max(1000, 2*n))\n\nis_leaf = [True] * (n+1)\nis_leaf[0] = None\nd = {i: [] for i in range(1,n+1)}\nfor i in range(n-1):\n    a,b = [int(c) for c in input().split()]\n    d[a].append(b)\n    d[b].append(a)\n    if len(d[a]) >= 2:\n        is_leaf[a] = False\n    if len(d[b]) >=2:\n        is_leaf[b] = False\n\n_fact = [1] * n\n_fact_inv = [1] * n\n\nfor i in range(1,n):\n    _fact[i] = (_fact[i-1] * i) % M\n    _fact_inv[i] = pow(_fact[i], M-2, M)\n\n# @lru_cache(2*n)\n# def _fact(n, M=10**9+7):\n#     if n==1:\n#         return 1\n#     tmp = _fact(n-1)\n#     tmp *= n\n#     tmp %= M\n#     return tmp\n\n# @lru_cache(2*n)\n# def _fact_inv(n, M=10**9+7):\n#     tmp = _fact(n)\n#     if tmp==1:\n#         return 1\n#     return pow(tmp, M-2, M)\n\n\nM=10**9+7\n\n# node : leaf\n@lru_cache(2*n)\ndef _sub(a,b, M=10**9+7):\n    # a -> bの枝に対してb以降の組み合わせ数・ノード数を返す\n    if is_leaf[b]:\n        return (1,1)\n    counts = []\n    num_nodes = []\n    for node in d[b]:\n        if node==a:\n            continue\n        count, num_node = _sub(b,node)\n        counts.append(count)\n        num_nodes.append(num_node)\n\n    count = 1\n    total = sum(num_nodes)\n    \n#     if len(counts):\n#         return ()\n    \n    for c in counts:\n        count *= c\n        count %= M\n    for n in num_nodes:\n        count *= _fact_inv[n]\n        count %= M\n    count *= _fact[total]\n    count %= M\n    return (int(count) , total+1)\n\nfor start in range(1,n+1):\n    counts = []\n    num_nodes = []\n    for node in d[start]:\n        count, num_node = _sub(start,node)\n        counts.append(count)\n        num_nodes.append(num_node)\n\n    count = 1\n    total = sum(num_nodes)\n    \n    for c in counts:\n        count *= c\n        count %= M\n    for n in num_nodes:\n        count *= _fact_inv[n]\n        count %= M\n    count *= _fact[total]\n    count %= M\n    print(int(count))\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":117,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict\nimport math\ndef LI(): return list(map(int, input().split()))\ndef II(): return int(input())\ndef LS(): return input().split()\ndef S(): return input()\ndef IIR(n): return [II() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nt,x = LI()\nprint(t\/x)\n\"\"\"\n\n#B\n\"\"\"\nn= II()\na = LI()\nm = max(a)\nif m >= sum(a)-m:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n\"\"\"\n\n#C\n\"\"\"\nn,m = LI()\nx = LI()\nx.sort()\nl = [x[i+1]-x[i] for i in range(m-1)]\nl.sort()\nl = l[::-1]\nans = sum(l[max(n-1,0):])\nprint(ans)\n\"\"\"\n\n#D\nn,k = LI()\na = LI()\nl = 0\nb = [0 for i in range(n)]\nfor i in range(n):\n    b[i] = list(bin(a[i]))[2:]\n    l = max(l,len(b[i]))\ns = [0 for i in range(l)]\nfor i in range(n):\n    for j in range(l-len(b[i])):\n        b[i].insert(0,\"0\")\nfor i in range(n):\n    for j in range(l):\n        s[j] += 1-int(b[i][j])\nke = 1\nans = 0\ni = l-1\nwhile i >= 0:\n    if s[i] <= n\/\/2:\n        ans += (n-s[i])*ke\n        s.pop(i)\n    else:\n        s[i] = [(n-s[i])*ke,s[i]*ke,ke]\n    i -= 1\n    ke *= 2\ns.sort(key = lambda x:x[1])\ns = s[::-1]\nd = 0\nkey = len(list(bin(k)))-2\nkey -= l\nke = 2**l\nfor i in range(key):\n    d += ke\n    ans += n*ke\n    ke *= 2\nw = len(s)\nfor i in range(w):\n    r,q,p = s[i]\n    if d+p <= k:\n        d += p\n        ans += q\n    else:\n        ans += r\nprint(ans)\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":118,"bad_solution":"#!\/usr\/bin\/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float(\"INF\")\n\n#solve\ndef solve():\n    from time import time\n    st = time()\n    h, w = LI()\n    ch, cw = LI()\n    dh, dw = LI_()\n    s = SR(h)\n    q = deque()\n    c = defaultdict(lambda :inf)\n    q.append((ch-1, cw-1))\n    c[(ch - 1, cw - 1)] = 0\n    while q:\n        nh, nw = q.popleft()\n        now = c[(nh, nw)]\n        for mh, mw in [(0, 1), (1, 0), (-1, 0), (0, -1)]:\n            mh += nh\n            mw += nw\n            if 0 <= mh < h and 0 <= mw < w and c[(mh, mw)] > now and s[mh][mw] == \".\":\n                c[(mh, mw)] = now\n                q.appendleft((mh, mw))\n        for i in range(-2, 3):\n            i += nh\n            for j in range(-2, 3):\n                j += nw\n                if 0 <= i < h and 0 <= j < w and c[(i, j)] > now + 1 and s[i][j] == \".\":\n                    c[(i, j)] = now + 1\n                    q.append((i, j))\n        if time() - st >= 1.8:\n            print(0)\n            return\n    print(-1 if c[(dh, dw)] == inf else c[(dh, dw)])\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":119,"bad_solution":"import sys\nimport copy\n\ndef solve(n, a, b, c, d, s):\n    if c < d:\n        if b < c:\n            width = [(a-1, d-1)]\n        else:\n            width = [(a-1, c-1), (b-1, d-1)]\n\n        for left, right in width:\n            for i in range(left, right):\n                if s[i] == \"#\" and s[i+1] == \"#\":\n                    return \"No\"\n                else:\n                    return \"Yes\"\n    else:\n        for i in range(a-1, c-1):\n            if s[i] == \"#\" and s[i+1] == \"#\":\n                return \"No\"\n            elif b - 2 <= i <= d - 2 and s[i] == \".\" and s[i+1] == \".\" and  s[i+2] == \".\" :\n                return \"Yes\"\n        return \"No\"\n\n\nif __name__ == '__main__':\n\n    n, a, b, c, d = map(int, sys.stdin.readline().strip().split(\" \"))\n    s = sys.stdin.readline().strip()\n    print solve(n, a, b, c, d, s)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":120,"bad_solution":"n,a,b=map(int,input().split())\n\nmod=10**9+7\n\nJ=pow(2,n)%mod\ndef find_power(n,mod):\n    # 0!からn!までのびっくりを出してくれる関数(ただし、modで割った値に対してである）\n    powlist=[0]*(n+1)\n    powlist[0]=1\n    powlist[1]=1\n    for i in range(2,n+1):\n        powlist[i]=powlist[i-1]*i%(mod)\n    return powlist\n\ndef find_inv_power(n):\n    #0!からn!までの逆元を素数10**9+7で割ったあまりリストを作る関数\n    powlist=find_power(n,10**9+7)\n    check=powlist[-1]\n    first=1\n    uselist=[0]*(n+1)\n    secondlist=[0]*30\n    secondlist[0]=check\n    secondlist[1]=check**2\n    for i in range(28):\n        secondlist[i+2]=(secondlist[i+1]**2)%(10**9+7)\n    a=format(10**9+5,\"b\")\n    for j in range(30):\n        if a[29-j]==\"1\":\n            first=(first*secondlist[j])%(10**9+7)\n    uselist[n]=first\n    for i in range(n,0,-1):\n        uselist[i-1]=(uselist[i]*i)%(10**9+7)\n    return uselist\n\nC=find_inv_power(2*10**5+100)\nif  True:\n    c=1\n    for i in range(a):\n        c*=(n-i)\n        c=c%mod\n    c=c*C[a]\n    c=c%mod\n    d=1\n    for i in range(b):\n        d*=(n-i)\n        d=d%mod\n    d=d%mod\n    d=d*C[b]\n    print((J-c-d-1)%mod)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":121,"bad_solution":"def z_algorithm(s):  # O(|S|)\n    \"\"\"\n    SとS[i:]のLCP(longest common prefix: 最長共通接頭辞の長さ) Z[i]を計算し、Zを返す\n    \"\"\"\n    n = len(s)\n    z = [0] * n\n    z[0] = n\n    i = 1\n    j = 0\n    while i < n:\n        while i + j < n and s[j] == s[i + j]:\n            j += 1\n        z[i] = j\n        if j == 0:\n            i += 1\n            continue\n        k = 1\n        while k < j and k + z[k] < j:\n            z[i + k] = z[k]\n            k += 1\n        i += k\n        j -= k\n    return z\n\n# ---------------------- #\n\nn = int(input())\ns = input()\n\nans = 0\nfor i in range(n):\n    Z = z_algorithm(s[i:])\n    for j in range(len(Z)):\n        if Z[j] > j:\n            ans = max(ans, j)\n        else:\n            ans = max(ans, Z[j])\n\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":122,"bad_solution":"#! \/usr\/bin\/env python\n# -*- coding: utf-8 -*-\n# vim:fenc=utf-8\n#\n\n\"\"\"\nGC027 C\n\"\"\"\n\nn,m = map(int,input().split())\ns = list(input())\nedges = [tuple(map(int,input().split())) for i in range(m)]\nali = [0 for i in range(n)]\nbli = [0 for i in range(n)]\n\n\ndef addEdge(graph,u,v):\n    graph[u].add(v)\n\n\nfrom collections import defaultdict\ngraphAB = defaultdict(set)\n\ndef incrementAB(node,adj):\n    if s[adj-1] == 'A':\n        ali[node-1]+=1\n    if s[adj-1] == 'B':\n        bli[node-1]+=1\n\ndef decrementAB(node,adj):\n    if s[adj-1] == 'A':\n        ali[node-1]-=1\n    if s[adj-1] == 'B':\n        bli[node-1]-=1\n\nfor i,j in edges:\n    addEdge(graphAB,i,j)\n    addEdge(graphAB,j,i)\n\ndef adjAB(node):\n    if ali[node-1]!=0 and bli[node-1]!=0:\n        return(True)\n    else:\n        return(False)\n\ngraphvers = set(graphAB.keys())\nvisitset = set()\nfor i in range(1,n+1):\n    if not i in graphvers:\n        s[i-1] = 'C'\n    else:\n        for j in graphAB[i]:\n            incrementAB(i,j)\n        if not adjAB(i):\n            visitset.add(i)\n\n\nwhile bool(visitset):\n    #print(graphAB)\n    #print(graphABopp)\n    #print(abli)\n    i = visitset.pop()\n    for j in graphAB[i]:\n        if s[j-1] != 'C':\n            decrementAB(j,i)\n            if not adjAB(j):\n                visitset.add(j)\n    s[i-1] = 'C'\n\n#print(graphAB)\n#print(graphABopp)\n\n\nif bool(set(s).remove('C')):\n    print('Yes')\nelse:\n    print('No')\n\n\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":123,"bad_solution":"#!\/usr\/bin\/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef S(): return input().rstrip()\ndef LS(): return S().split()\ndef IR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = II()\n    return res\ndef LIR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LI()\n    return res\ndef FR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = IF()\n    return res\ndef LFR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = IF()\n    return res\ndef LIR_(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LI_()\n    return res\ndef SR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = S()\n    return res\ndef LSR(n):\n    res = [None] * n\n    for i in range(n):\n        res[i] = LS()\n    return res\nmod = 1000000007\ninf = float('INF')\nfact = [i for i in range(10 ** 6 + 1)]\nfact[0] = 1\nfor i in range(10 ** 6):\n    fact[i + 1] *= fact[i]\n    fact[i + 1] %= mod\ninvfact = fact[:]\ninvfact[-1] = pow(invfact[-1], mod - 2, mod)\nfor i in range(10 ** 6, 0, -1):\n    invfact[i - 1] = i * invfact[i]\n    invfact[i - 1] %= mod\n\ndef combination_mod(n, k, mod):\n    \"\"\" power_funcを用いて(nCk) mod p を求める \"\"\" \n    \"\"\" nCk = n!\/((n-k)!k!)を使用 \"\"\"\n    from math import factorial\n    if n < 0 or k < 0 or n < k: return 0\n    if n == 0 or k == 0: return 1\n    a = fact[n]\n    b = invfact[k]\n    c = invfact[n - k]\n    return (a * b * c) % mod\n\n#solve\ndef solve():\n    k = II()\n    s = S()\n    ans = pow(26, len(s) + k, mod)\n    sk = len(s) + k\n    for i in range(len(s)):\n        ans -= combination_mod(sk, i, mod) * pow(25, sk - i, mod)\n        ans %= mod\n    print(ans)\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":124,"bad_solution":"from collections import Counter\nclass Combination:\n    _maxNum = 0\n    _divider = 0\n    _fact = []\n    _inv = []\n    _finv = []\n\n    def __init__(self, maxNum, divider):\n        self._maxNum = maxNum\n        self._divider = divider\n        self._fact = [0] * (self._maxNum + 1)\n        self._fact[0] = self._fact[1] = 1\n\n        if self._divider != 0:\n            self._inv = [0] * (self._maxNum + 1)\n            self._finv = [0] * (self._maxNum + 1)\n            self._inv[0] = self._inv[1] = self._finv[0] = self._finv[1] = 1\n\n        for i in range(2, self._maxNum + 1):\n            self._fact[i] = self._fact[i - 1] * i;\n            if self._divider != 0:\n                self._fact[i] %= self._divider\n                self._inv[i] = self._divider - self._inv[self._divider % i] * (self._divider \/\/ i) % self._divider\n                self._finv[i] = self._finv[i - 1] * self._inv[i] % self._divider\n\n    def nPk(self, n, k):\n        if(k > self._maxNum) or (n > self._maxNum) or (k > n) or (k < 0) or (n < 0):\n            return 0\n        return(self._fact[n] \/\/ self._fact[n - k])\n\n    def nCk(self, n, k):\n        ans = 0\n        if(k > self._maxNum) or (n > self._maxNum) or (k > n) or (k < 0) or (n < 0):\n            ans = 0\n        elif self._divider == 0:\n            ans = self.nPk(n, k)\n            ans \/\/= self._fact[k]\n        else:\n            ans = self._fact[n] * (self._finv[k] * self._finv[n - k] % self._divider) % self._divider\n\n        return ans\n\ndef ABC137C_GreenBin():\n    N = int(input().strip())\n\n    di = Counter()\n    for i in range(N):\n        s = ''.join(sorted(input().strip()))\n        di[s] += 1\n    \n    cmb = Combination(N, 0)\n\n    ans = 0\n    for num in di.values():\n        ans += cmb.nCk(num, 2)\n\n    print(ans)\n\n\ndef main():\n    ABC137C_GreenBin()\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":125,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nINF = float(\"inf\")\n\n\ndef yes():\n    print(\"Yes\")  # type: str\n\n\ndef no():\n    print(\"No\")  # type: str\n\n\ndef solve(N: int, A: int, B: int, C: int, D: int, S: str):\n    A = A-1\n    B = B-1\n\n    def reachable(A, C, S):     # O(N)\n        # AからCへ到達可能ですか\n        if S[A:C+1].find(\"##\") == -1:\n            return True\n        else:\n            return False\n\n    if C > D:\n        # できるだけ早く追い越す\n        sunuke = A            # 1-index, 0-index\n        funuke = B\n\n        # 追い越すためには、\"...\"という領域が必要。\n        oikoshi = S[B-1:].find(\"...\")\n        if oikoshi == -1:\n            no()\n            return\n        A = oikoshi + 2\n        B = oikoshi + 1\n\n    # ２連岩なければ通れる\n    if reachable(A, C, S) and reachable(B, D, S):\n        yes()\n    else:\n        no()\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = int(next(tokens))  # type: int\n    B = int(next(tokens))  # type: int\n    C = int(next(tokens))  # type: int\n    D = int(next(tokens))  # type: int\n    S = next(tokens)  # type: str\n    solve(N, A, B, C, D, S)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":126,"bad_solution":"import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN, X = mapint()\nburger = [1]*50\npa = [1]*50\nfor i in range(1, 50):\n    burger[i] = burger[i-1]*2+3\n    pa[i] = pa[i-1]*2+1\n\nto_eat = X\nlayer = N\nans = 0\nwhile 1:\n    if to_eat<=1:\n        break\n    if layer==0:\n        break\n    elif to_eat==burger[layer-1]+2:\n        ans += pa[layer-1]+1\n        break\n    elif to_eat==burger[layer-1]+1:\n        ans += pa[layer-1]\n        break\n    elif to_eat<=burger[layer-1]:\n        layer -= 1\n        to_eat -= 1\n        continue\n    else:\n        ans += pa[layer-1]+1\n        to_eat -= burger[layer-1]+2\n        layer -= 1\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":127,"bad_solution":"import numpy as np\n#降順ソートの方がうまくいきそう\nn,m=map(int,input().split())\na=np.sort(np.array(list(map(int,input().split()))))[::-1]\ncs=np.cumsum(a)\n\n#和が引数以上の場合をカウントする\ndef overX(x):\n\tcount=0\n\t#両手が違う人を握るときのみ考える\n\tif a[0]*2<x:\n\t\treturn 0\n\telse:\n\t\tfor i in range(n):\n\t\t\tif a[i]+a[0]<x:\n\t\t\t\tcount+=0\n\t\t\telse:\n\t\t\t\tlb, ub = 0, n\n\t\t\t\t#パターンAのにぶたん。左がOなので[lb,ub)で持つ。\n\t\t\t\twhile ub-lb>1:\n\t\t\t\t\tmid=(lb+ub)\/\/2\n\t\t\t\t\tif a[i]+a[mid]>=x:\n\t\t\t\t\t\tlb=mid\n\t\t\t\t\telse:\n\t\t\t\t\t\tub=mid\n\t\t\t\tcount+=lb+1\n\t\treturn count\n#print(overX(130))\n\n#overX>=mなる最大のxを探す->xは小さい方が実現しやすいのでパターンA->[lb,ub)でもつ\nlb=1 #実現しやすい方\nub=2*10**5\nwhile ub-lb>1:\n\tmid=(ub+lb)\/\/2\n\tif overX(mid)>=m:\n\t\tlb=mid\n\telse:\n\t\tub=mid\n#ub=overX(x)>=mなる最小のx。これ以上大きくするとmに満たなくなる。\nmaxx=lb\n\nhp=0\n#maxx+1以上の要素をすべてたす\n#和がmaxx+1以上になる組み合わせの数だけhpを加え、countをインクリメントする\nif a[0]*2>=maxx+1:\n\tfor i in range(n):\n\t\tif a[i]+a[0]<maxx+1:\n\t\t\tbreak\n\t\telse:\n\t\t\tlb, ub = 0, n\n\t\t\t#パターンAのにぶたん。左がOなので[lb,ub)で持つ。\n\t\t\twhile ub-lb>1:\n\t\t\t\tmid=(lb+ub)\/\/2\n\t\t\t\tif a[i]+a[mid]>=maxx+1:\n\t\t\t\t\tlb=mid\n\t\t\t\telse:\n\t\t\t\t\tub=mid\n\t\t\t#a[0]からa[lb]は、a[i]と足した時にx以上になり条件を満たす。\n\t\t\thp+=a[i]*(lb+1)+cs[lb]\n'''print(hp)\nprint(overX(maxx))\nprint(overX(maxx+1))\nprint(maxx)'''\nhp+=(m-overX(maxx+1))*maxx\nprint(hp)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":128,"bad_solution":"from typing import List, Tuple\n\n\ndef FUNC(numbers: List[float]) -> Tuple[float, float]:\n    \"\"\" From a supplied list of numbers (of length at least two) select and return two that are the closest to each\n    other and return them in order (smaller number, larger number).\n    >>> FUNC([1.0, 2.0, 3.0, 4.0, 5.0, 2.2])\n    (2.0, 2.2)\n    >>> FUNC([1.0, 2.0, 3.0, 4.0, 5.0, 2.0])\n    (2.0, 2.0)\n    \"\"\"\n    closest_pair = None\n    distance = None\n\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                if distance is None:\n                    distance = abs(elem - elem2)\n                    closest_pair = tuple(sorted([elem, elem2]))\n                else:\n                    new_distance = abs(elem - elem2)\n                    if new_distance > distance:\n                        distance = new_distance\n                        closest_pair = tuple(sorted([elem, elem2]))\n\n    return closest_pair\n"}
{"id":129,"bad_solution":"#!\/usr\/bin python3\n# -*- coding: utf-8 -*-\n\n\ndef factor_osa(A):\n    Max = max(A) + 1\n    IsPrime = [True] * Max\n    MinFactor = [-1] * Max\n    Primes = []\n    IsPrime[0], IsPrime[1] = False, False\n    MinFactor[0], MinFactor[1] = 0, 1\n    for i in range(2, Max):\n        if IsPrime[i]:\n            MinFactor[i] = i\n            Primes.append(i)\n            for j in range(i*2, Max, i):\n                IsPrime[j] = False\n                if MinFactor[j] == -1:\n                    MinFactor[j] = i\n    ret = []\n    for a in A:\n        res = []\n        while a != 1:\n            prime = MinFactor[a]\n            exp = 0\n            while MinFactor[a] == prime:\n                exp += 1\n                a \/\/= prime\n            res.append((prime, exp))\n        ret.append(res)\n    return ret\n\nn = int(input())\na = list(map(int, input().split()))\n\naa = factor_osa(a)\ndica = {}\ndicb = {}\nmxa = 0\nfor i in aa:\n    for j in i:\n        if not j[0] in dica:\n            dica[j[0]] = 1\n        else:\n            dica[j[0]] += 1\n        mxa = max(mxa, dica[j[0]])\n\nfrom math import gcd        #for python3.8\n\ndef Gcd(lt):\n    l = len(lt)\n    ret = [1]*l\n    ret[0] = lt[0]\n    for i in range(1,l):\n        ret[i] = gcd(ret[i-1], lt[i])\n    return ret\n\nif mxa == 1:\n    print('pairwise coprime')\nelif Gcd(a)[-1]==1:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":130,"bad_solution":"import math\n\ndef primes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\ndef factorize(n):\n    primes = set()\n    for p in Ps:\n        if p * p > n:\n            break\n        while n % p == 0:\n            n \/\/= p\n            primes.add(p)\n    if n > 1:\n        primes.add(n)\n    return primes\n\nPs = primes(10 ** 6)\nn = int(input())\nAs = list(map(int, input().split()))\n\n# setwiseFlag\ngcd = As[0]\nfor a in As:\n  gcd = math.gcd(gcd, a)\nsetwiseFlag = (gcd == 1)\n\n# pairwiseFlag\npairwiseFlag = True\ntarget = set()\nfor a in As:\n  primes = factorize(a)\n  if len(primes & target) > 0:\n    pairwiseFlag = False\n  target |= primes\n\nif pairwiseFlag:\n  print('pairwise coprime')\nelif setwiseFlag:\n  print('setwise coprime')\nelse:\n  print('not coprime')\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":131,"bad_solution":"\nimport sys\n\ndef enum_div(n):\n    ir=int(n**(0.5))+1\n    ret=[]\n    for i in range(1,ir):\n        if n%i == 0:\n            ret.append(i)\n            if (i!= 1) & (i*i != n):\n                ret.append(n\/\/i)\n    return ret\n\n\nimport math\n\ndef get_primenumber(number):#エラトステネスの篩\n    prime_list = []\n    search_list = list(range(2,number+1))\n    #search_listの先頭の値が√nの値を超えたら終了\n    while search_list[0] <= math.sqrt(number):\n      #search_listの先頭の値が√nの値を超えたら終了\n      #search_listの先頭をprime_listに入れて、先頭をリストに追加して削除\n        head_num = search_list.pop(0)\n        prime_list.append(head_num)\n        #head_numの倍数を除去\n        search_list = [num for num in search_list if num % head_num != 0]\n    #prime_listにsearch_listを結合\n    prime_list.extend(search_list)\n    return prime_list\n\n#p=get_primenumber(79000)\np=get_primenumber(amax)\n\nn=int(input())\nap=list(map(int,input().split()))\namin=min(ap)\namax=max(ap)\n\nif amax==1:\n    print(\"pairwise coprime\")\n    sys.exit()\n\nif amin!=1:\n    bp=enum_div(amin)+[amin]\n    bp=bp[1:]\n    for bpi in bp:\n        yn=\"\"\n        for ai in ap:\n            if ai%bpi!=0:\n                yn=\"coprime\"\n                break\n        if yn==\"\":\n            print(\"not coprime\")\n            sys.exit()\n\nif n>=78500 :\n    print(\"setwise coprime\")\n    sys.exit()\n\naa=[0]*(amax+1)\nfor ai in ap:\n    aa[ai]+=1\n    \nfor pp in range(2,amax+1):\n#for pp in p:\n    psum=0\n    for pi in range(pp,amax+1,pp):\n        psum+=aa[pi]\n#    psum=sum(aa[pp: :pp])\n#    print(\"pp:\",pp,psum)\n    if psum>=2:\n            print(\"setwise coprime\")\n            sys.exit()\n## max_13.txt ... max_16.txt : \"setwise coprime\"\nprint(\"pairwise coprime\")\n   \n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":132,"bad_solution":"import os\nimport sys\n\nimport numpy as np\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(10 ** 9)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nN, K = list(map(int, sys.stdin.readline().split()))\nH = list(map(int, sys.stdin.readline().split()))\n\nif K == N:\n    print(0)\n    exit()\n\nH = np.array(H, dtype=float)\n\n\n# @debug\ndef count(heights):\n    H = heights.copy()\n    ret = 0\n    cnt = 1\n    height = H.min()\n    # 普通に数えてみる\n    while height != np.inf:\n        H -= height\n        ret += cnt * height\n        H[H == 0.0] = np.inf\n        cnt = np.count_nonzero(np.diff((H != np.inf).astype(int)) == 1)\n        cnt += H[0] != np.inf\n        height = H.min()\n    return int(ret)\n\n\n# 上から何個変えるか、下から何個変えるかを全探索\nans = INF\norders = H.argsort()\nfor _ in range(K + 1):\n    # 変えるやつ\n    changes = np.zeros(N, dtype=bool)\n    changes[orders[:K]] = True\n    heights = H.copy()\n    tmp = np.inf\n    for i in range(N):\n        if changes[i]:\n            heights[i] = tmp\n        else:\n            tmp = heights[i]\n    tmp = np.inf\n    for i in reversed(range(N)):\n        if changes[i]:\n            heights[i] = min(heights[i], tmp)\n        else:\n            tmp = heights[i]\n    ans = min(ans, count(heights))\n    orders = np.roll(orders, shift=1)\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":133,"bad_solution":"from heapq import heappop, heappush\ndef main():\n    H, W = map(int, input().split())\n    sh,sw = map(int, input().split())\n    gh,gw = map(int, input().split())\n    gh,gw = gh-1,gw-1\n    field = [list(input()) for _ in range(H)]\n\n    q = [(0, sh-1, sw-1)]\n    INF = 10 ** 30\n    dist = [[INF] * W for _ in range(H)]\n    dist[sh-1][sw-1] = 0\n    while q:\n        cnt, h, w = heappop(q)\n        if dist[h][w] < cnt: continue\n        if h == gh and w == gw: return cnt\n        for i in range(-2, 3):\n            for j in range(-2, 3):\n                nh = h+i\n                nw = w+j\n                if nh < 0 or nw < 0: continue\n                if nh >= H or nw >= W: continue\n                if field[nh][nw]  == \"#\": continue\n                if (i, j) in ((1,0),(0,1),(-1,0),(0,-1)):\n                    if dist[nh][nw] <= cnt: continue\n                    dist[nh][nw] = cnt\n                    heappush(q, (cnt, nh, nw))\n                else:\n                    if dist[nh][nw] <= cnt+1: continue\n                    dist[nh][nw] = cnt+1\n                    heappush(q, (cnt+1, nh, nw))\n    return -1\n\nprint(main())\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":134,"bad_solution":"import math, string, itertools, fractions, heapq, collections, re, array, bisect, copy, functools, random\nimport sys\nfrom collections import deque, defaultdict, Counter; from heapq import heappush, heappop\nfrom itertools import permutations, combinations, product, accumulate, groupby\nfrom bisect import bisect_left, bisect_right, insort_left, insort_right\nfrom operator import itemgetter as ig\nsys.setrecursionlimit(10 ** 7)\ninf = 10 ** 20; INF = float(\"INF\"); ans = 0; tmp = 0; ansli = []; tmpli = []; candili = []\neps = 1.0 \/ 10 ** 10; mod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]; ddn = dd + [(-1, 1), (1, 1), (1, -1), (-1, -1)]; ddn9 = ddn + [(0, 0)]\n\"\"\"for dx, dy in dd:\n        nx = j + dx; ny = i + dy\n            if 0 <= nx < w and 0 <= ny < h:\"\"\"\ndef wi(): return list(map(int, sys.stdin.readline().split()))\ndef wip(): return [int(x) - 1 for x in sys.stdin.readline().split()]#WideIntPoint\ndef ws(): return sys.stdin.readline().split()\ndef i(): return int(sys.stdin.readline())\ndef s(): return input()\ndef hi(n): return [i() for _ in range(n)]\ndef hs(n): return [s() for _ in range(n)]#HeightString\ndef mi(n): return [wi() for _ in range(n)]#MatrixInt\ndef mip(n): return [wip() for _ in range(n)]\ndef ms(n): return [ws() for _ in range(n)]\n\nn = i()\na = wi()\nb = wi()\nc = 0\n\nfor i in range(n):\n    ans += min(c + b[i], a[i])\n    c = max(0, c + b[i] - a[i])\n\nans += min(c, a[n])\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":135,"bad_solution":"# -*- coding: utf-8 -*-\n\n\nfrom collections import defaultdict\n\nclass ReRooting:\n    def __init__(self, f, g, merge, ie):\n        self.tree = defaultdict(list)\n        self.f = f\n        self.g = g\n        self.merge = merge\n        self.ie = ie\n        self.dp = defaultdict(dict)\n\n    def add_edge(self, u, v):\n        self.tree[u].append(v)\n        self.tree[v].append(u)\n\n    # def __dfs1(self, u, p):\n    #     o = []\n    #     s = [(u, -1)]\n    #     while s:\n    #         u, p = s.pop()\n    #         o.append((u, p))\n    #         for v in self.tree[u]:\n    #             if v == p:\n    #                 continue\n    #             s.append((v, u))\n\n    #     for u, p in reversed(o):\n    #         r = self.ie\n    #         for v in self.tree[u]:\n    #             if v == p:\n    #                 continue\n    #             # ep(u_, v, self.dp)\n    #             r = self.merge(r, self.f(self.dp[u][v], v))\n\n    #         self.dp[p][u] = self.g(r, u)\n    #         print(p, u, self.dp[p][u])\n\n    # def __dfs2(self, u, p, a):\n    #     s = [(u, p, a)]\n\n    #     while s:\n    #         u, p, a = s.pop()\n\n    #         self.dp[u][p] = a\n\n    #         pl = [0] * (len(self.tree[u]) + 1)\n    #         pl[0] = self.ie\n    #         for i, v in enumerate(self.tree[u]):\n    #             pl[i+1] = self.merge(pl[i], self.f(self.dp[u][v], v))\n\n    #         pr = [0] * (len(self.tree[u]) + 1)\n    #         pr[-1] = self.ie\n    #         for i, v in reversed(list(enumerate(self.tree[u]))):\n    #             pr[i] = self.merge(pr[i+1], self.f(self.dp[u][v], v))\n\n    #         for i, v in enumerate(self.tree[u]):\n    #             if v == p:\n    #                 continue\n    #             r = self.merge(pl[i], pr[i+1])\n    #             s.append((v, u, self.g(r, v)))\n\n    def __dfs1(self, u, p):\n        r = self.ie\n        for v in self.tree[u]:\n            if v == p:\n                continue\n            self.dp[u][v] = self.__dfs1(v, u)\n            r = self.merge(r, self.f(self.dp[u][v], v))\n\n        return self.g(r, u)\n\n    def __dfs2(self, u, p, a):\n        for v in self.tree[u]:\n            if v == p:\n                self.dp[u][v] = a\n                break\n        pl = [0] * (len(self.tree[u]) + 1)\n        pl[0] = self.ie\n        for i, v in enumerate(self.tree[u]):\n            pl[i+1] = self.merge(pl[i], self.f(self.dp[u][v], v))\n\n        pr = [0] * (len(self.tree[u]) + 1)\n        pr[-1] = self.ie\n        for i, v in reversed(list(enumerate(self.tree[u]))):\n            pr[i] = self.merge(pr[i+1], self.f(self.dp[u][v], v))\n\n        for i, v in enumerate(self.tree[u]):\n            if v == p:\n                continue\n            r = self.merge(pl[i], pr[i+1])\n            self.__dfs2(v, u, self.g(r, v))\n\n    def build(self, root=1):\n        self.__dfs1(root, -1)\n        self.__dfs2(root, -1, self.ie)\n\n    def slv(self, u):\n        r = self.ie\n        for v in self.tree[u]:\n            r = self.merge(r, self.f(self.dp[u][v], v))\n\n        return self.g(r, u)\n\n\ndef atcoder_dp_dp_v():\n    # https:\/\/atcoder.jp\/contests\/dp\/tasks\/dp_v\n    # https:\/\/atcoder.jp\/contests\/dp\/submissions\/16664670\n    N, M = map(int, input().split())\n    XY = [list(map(int, input().split())) for _ in range(N-1)]\n\n    f = lambda x, y: x\n    g = lambda x, y: x + 1\n    merge = lambda x, y: (x * y) % M\n    rr = ReRooting(f, g, merge, 1)\n    for x, y in XY:\n        rr.add_edge(x, y)\n\n    rr.build()\n    for u in range(1, N+1):\n        print(rr.slv(u))\n\n\ndef atcoder_abc60_f():\n    N = int(input())\n    AB = [list(map(int, input().split())) for _ in range(N-1)]\n\n    M = 10**9+7\n\n    from functools import reduce\n\n    fact = [1]\n    for i in range(1, 10**6):\n        fact.append(fact[-1]*i % M)\n\n    def f(x, _):\n        c = x[0]\n        s = x[1]\n        c *= pow(fact[s], M-2, M)\n        c %= M\n        return (c, s)\n\n    def g(x, _):\n        c = x[0]\n        s = x[1]\n        c *= fact[s]\n        c %= M\n        return (c, s+1)\n\n    def merge(x, y):\n        return (x[0]*y[0]%M, x[1]+y[1])\n\n    rr = ReRooting(f, g, merge, (1, 0))\n    for a, b in AB:\n        rr.add_edge(a, b)\n\n    rr.build()\n    for u in range(1, N+1):\n        print(rr.slv(u)[0])\n\n\n\n\nif __name__ == '__main__':\n    # atcoder_dp_dp_v()\n    atcoder_abc60_f()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":136,"bad_solution":"def num(k):#各数字に使用するマッチ棒の本数を返す関数\n    if k == 1:\n        return 1\n    elif k == 7:\n        return 3\n    elif k == 4:\n        return 4\n    elif k == 2 or k == 3 or k == 5:\n        return 5\n    elif k == 6 or k == 9:\n        return 6\n    elif k == 8:\n        return 7\n\nn, m = map(int,input().split())\nl = list(map(int,input().split()))\nl.sort(reverse = True)\n         \ndp = [0] * (n+1)\n\nfor i in range(2,n+1):\n    can = []\n    for x in l:\n        if i-num(x)>=0:\n            can.append(dp[i-num(x)]+1)\n    if can == []:\n        dp[i] = 0\n    else:\n        dp[i] = max(can)\n        \nprint(dp)\n\nanslist = [0] * dp[n]\n\nleft = n\n\nfor j in range(dp[n],0,-1):#jは桁数\n    if j == 1:\n        for x in l:\n            if num(x) == left:\n                anslist[j-1] = x\n                break\n    else:\n        for x in l:\n            if dp[left-num(x)] == j - 1:\n                anslist[j-1] = x#j桁目は10^(j-1)の位\n                left = left-num(x)\n                break\n            \n    print([j,x,left])\nprint(anslist)\n            \n            \nans = 0\n\nfor j in range(0,dp[n]):\n    ans = ans + anslist[j] * (10 ** j)\n\nprint(ans)\n         \n    \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":137,"bad_solution":"# encoding:utf-8\nimport copy\nimport random\nimport bisect #bisect_left　これで二部探索の大小検索が行える\nimport fractions #最小公倍数などはこっち\nimport math\nimport sys\nimport collections\n\nmod = 10**9+7\nsys.setrecursionlimit(mod) # 再帰回数上限はでdefault1000\n\nd = collections.deque()\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\nN = int(input())\nA = LI()\n\nball_dic = {}\nfor i in range(N):\n    if A[i] in ball_dic.keys():\n        ball_dic[A[i]] += 1\n    else:\n        ball_dic[A[i]] = 1\n\ndef cnt_ans(ball_sets):\n    cnt = 0\n    for ball_set in ball_sets:\n        if ball_set > 1:\n            cnt += ball_set * (ball_set - 1) \/\/ 2\n        \n    return cnt\n    \nfor i in range(N):\n    ball_dic_c = copy.deepcopy(ball_dic)\n    ball_dic_c[A[i]] -= 1\n    ball_sets = ball_dic_c.values()\n    print(cnt_ans(ball_sets))\n    \n        \n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":138,"bad_solution":"#####segfunc######\ndef segfunc(x,y):\n    return x|y\n\ndef init(init_val):\n    #set_val\n    for i in range(n):\n        seg[i+num-1]=init_val[i]    \n    #built\n    for i in range(num-2,-1,-1) :\n        seg[i]=segfunc(seg[2*i+1],seg[2*i+2]) \n    \ndef update(k,x):\n    k += num-1\n    seg[k] = x\n    while k:\n        k = (k-1)\/\/2\n        seg[k] = segfunc(seg[k*2+1],seg[k*2+2])\n    \ndef query(p,q):\n    if q<=p:\n        return ide_ele\n    p += num-1\n    q += num-2\n    res=ide_ele\n    while q-p>1:\n        if p&1 == 0:\n            res = segfunc(res,seg[p])\n        if q&1 == 1:\n            res = segfunc(res,seg[q])\n            q -= 1\n        p = p\/\/2\n        q = (q-1)\/\/2\n    if p == q:\n        res = segfunc(res,seg[p])\n    else:\n        res = segfunc(segfunc(res,seg[p]),seg[q])\n    return res\n\n#####単位元######\nide_ele = set()\n\n#num:n以上の最小の2のべき乗\nn=int(input())\nnum =2**(n-1).bit_length()\nseg=[ide_ele]*2*num\ns=input()\ninit([{i}for i in s])\nq=int(input())\nfor _ in range(q):\n  quer=input().split()\n  if quer[0]==\"1\":\n    _,i,c=quer\n    update(int(i)-1,{c})\n  else:\n    _,l,r=quer\n    print(len(query(int(l)-1,int(r))))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":139,"bad_solution":"# -*- coding: utf-8 -*-\n\ndef main():\n    import collections\n\n    n = int(input())\n    vs = list(map(int, input().split()))\n\n    vs_even = []\n    vs_odd = []\n    while True:\n        if len(vs) == 0:\n            break\n        vs_even.append(vs.pop(0))\n        vs_odd.append(vs.pop(0))\n\n    if vs_even == vs_odd:\n        # 1種類の数からなる数列のとき\n        print(len(vs_even))\n        exit()\n\n    most_evens = collections.Counter(vs_even).most_common(2)\n    most_odds = collections.Counter(vs_odd).most_common(2)\n\n    len_vs_even = len(vs_even)\n    if most_evens[0][0] == most_odds[0][0]:\n        # 変換したら、1種類の数になってしまう\n        # ex.) vs = [1 2 1 2 1 2 2 2 2 2 2 2 2 2]\n        # ex.) vs = [1 1 1 1 1 1 3 2 3 2]\n        # ので、2番目に大きい数字で変換する\n        if most_evens[0][1] > most_odds[0][1]:\n            ans = 0\n            ans += len_vs_even - most_odds[1][1]\n            ans += len_vs_even - most_evens[0][1]\n            print(ans)\n            exit()\n        elif most_evens[0][1] == most_odds[0][1]:\n            if most_evens[1][1] >= most_odds[1][1]:\n                ans = 0\n                ans += len_vs_even - most_evens[1][1]\n                ans += len_vs_even - most_odds[0][1]\n                print(ans)\n                exit()\n            else:\n                ans = 0\n                ans += len_vs_even - most_odds[1][1]\n                ans += len_vs_even - most_evens[0][1]\n                print(ans)\n                exit()\n        else:\n            ans = 0\n            ans += len_vs_even - most_evens[1][1]\n            ans += len_vs_even - most_odds[0][1]\n            print(ans)\n            exit()\n    ans = 0\n    ans += len_vs_even - most_evens[0][1]\n    ans += len_vs_even - most_odds[0][1]\n    print(ans)\n\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":140,"bad_solution":"def examA():\n    N = I()\n    ans = 0\n    print(ans)\n    return\n\ndef examB():\n    # any 2 points must have different position.\n    def ConvexHull(point_list):\n        pos2idx = {point_list[i]: i for i in range(len(point_list))}\n        y_val = defaultdict(list)\n        x_list = sorted(list(set([p[0] for p in point_list])))\n        for x, y in point_list:\n            y_val[x].append(y)\n\n        upper = [(x_list[0], max(y_val[x_list[0]]))]\n        lower = [(x_list[0], min(y_val[x_list[0]]))]\n        prev = float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = upper[-1]\n            x1, y1 = xi, max(y_val[xi])\n            if (y1 - y0) \/ (x1 - x0) < prev:\n                upper.append((x1, y1))\n                prev = (y1 - y0) \/ (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = upper[-1]\n                    if len(upper) == 1:\n                        upper.append((x1, y1))\n                        break\n                    x00, y00 = upper[-2]\n                    if (y1 - y0) \/ (x1 - x0) > (y1 - y00) \/ (x1 - x00):\n                        upper.pop()\n                    else:\n                        prev = (y1 - y0) \/ (x1 - x0)\n                        upper.append((x1, y1))\n                        break\n\n        prev = -float('inf')\n        for xi in x_list[1:]:\n            x0, y0 = lower[-1]\n            x1, y1 = xi, min(y_val[xi])\n            if (y1 - y0) \/ (x1 - x0) > prev:\n                lower.append((x1, y1))\n                prev = (y1 - y0) \/ (x1 - x0)\n            else:\n                while True:\n                    x0, y0 = lower[-1]\n                    if len(lower) == 1:\n                        lower.append((x1, y1))\n                        break\n                    x00, y00 = lower[-2]\n                    if (y1 - y0) \/ (x1 - x0) < (y1 - y00) \/ (x1 - x00):\n                        lower.pop()\n                    else:\n                        prev = (y1 - y0) \/ (x1 - x0)\n                        lower.append((x1, y1))\n                        break\n\n        # return upper, lower\n        # return [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n\n        upper_idx, lower_idx = [pos2idx[xy] for xy in upper], [pos2idx[xy] for xy in lower]\n        if upper_idx[-1] == lower_idx[-1]:\n            upper_idx.pop()\n        CH_idx = upper_idx\n        CH_idx.extend(reversed(lower_idx))\n        if CH_idx[0] == CH_idx[-1] and len(CH_idx) > 1:\n            CH_idx.pop()\n        return CH_idx\n\n    def calc_deg(p,p1,p2):\n        a1 = p1[0]-p[0]; a2 = p1[1]-p[1]\n        b1 = p2[0]-p[0]; b2 = p2[1]-p[1]\n        #print(p,p1,p2)\n        #print(a1,a2,b1,b2)\n        return (a1*b1+a2*b2)\/(((a1**2+a2**2)**0.5)*((b1**2+b2**2)**0.5))\n    N = I()\n    P = [[]for _ in range(N)]\n    D = defaultdict(int)\n    for i in range(N):\n        x,y = LI()\n        P[i] = (x,y)\n        D[(x,y)] = i\n    P.sort(key=lambda x:x[1])\n    P.sort()\n    C = ConvexHull(P)\n    n = len(C)\n    ans = [0]*N\n    if len(C)==2:\n        for c in C:\n            ans[D[c]] = 0.5\n        for v in ans:\n            print(v)\n        return\n    #print(C)\n    for i,c in enumerate(C):\n        cur = calc_deg(P[c],P[C[i-1]],P[C[i-n+2]])\n        #print(cur,math.degrees(math.acos(cur)))\n        #print(cur,P[c],D[P[c]])\n        ans[D[P[c]]] = (math.pi-math.acos(cur))\/(math.pi*2)\n    for v in ans:\n        print(v)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    S = SI()\n    N = len(S)\n    K = I()\n    dp = [[[0 for _ in range(K+1)]for _ in range(N)]for _ in range(N)]\n    for i in range(N):\n        for j in range(K+1):\n            dp[i][i][j] = 1\n    for i in range(2,N+1):\n        for k in range(K+1):\n            for l,r in enumerate(range(i-1,N)):\n                if S[l]==S[r]:\n                    dp[l][r][k] = dp[l+1][r-1][k] + 2\n                else:\n                    if k>0:\n                        dp[l][r][k] = max(dp[l+1][r][k],dp[l][r-1][k],dp[l+1][r-1][k-1]+2)\n                    else:\n                        dp[l][r][k] = max(dp[l + 1][r][k], dp[l][r - 1][k])\n    ans = max(dp[0][-1])\n    print(ans)\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\ndef test():\n    i = I()\n    li = LI()\n    lsi = LSI()\n    si = LS()\n    print(i)\n    print(li)\n    print(lsi)\n    print(si)\n    return\n\nfrom decimal import Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examB()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\"\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":141,"bad_solution":"import bisect\nimport copy\nimport heapq\nimport math\nimport sys\nfrom collections import *\nfrom itertools import accumulate, combinations, permutations, product\nfrom math import gcd\ndef input():\n    return sys.stdin.readline()[:-1]\ndef ruiseki(lst):\n    return [0]+list(accumulate(lst))\nmod=pow(10,9)+7\nal=[chr(ord('a') + i) for i in range(26)]\ndirection=[[1,0],[0,1],[-1,0],[0,-1]]\n\nn=int(input())\ns=[input() for i in range(n)]\nlst=[[0]*2 for i in range(n)]\n\nfor i in range(n):\n    l,r=0,0\n    for j in range(len(s[i])):\n        if s[i][j]==\")\":\n            if r==0:\n                l+=1\n            else:\n                r-=1\n        if s[i][j]==\"(\":\n            r+=1\n    lst[i][0]=l\n    lst[i][1]=r\n# print(lst)\nlst.sort(key=lambda x: (x[0],-x[1]))\n# print(lst)\ntmp=0\nfor i in range(n):\n    tmp-=lst[i][0]\n    if tmp<0:\n        print(\"No\")\n        break\n    tmp+=lst[i][1]\nelse:\n    if tmp==0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":142,"bad_solution":"import sys\nimport numpy as np\nfrom collections import defaultdict\n\n\n\n#input = sys.stdin.readline\n\ndef main():\n    N, K = map(int,input().split())\n    A = list(map(int,input().split()))\n    A = [0] +A  #transporter\n    visited = [0] * (N+1)\n    town = 1\n    cycle = 0\n    for i in range(1,K+1):\n        town = A[town]\n        if visited[town] ==0:\n            visited[town] = i\n        else:\n            cycle = i - visited[town]\n            place = (K - visited[town]) % cycle + visited[town]\n            for j in range(N+1):\n                if visited[j] == place:\n                    print(j)\n                    exit()\n    print(town)\n\n    print(town)\n\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":143,"bad_solution":"from typing import List\n\n\ndef FUNC(numbers: List[float]) -> List[float]:\n    \"\"\" Given list of numbers (of at least two elements), apply a linear transform to that list,\n    such that the smallest number will become 0 and the largest will become 1\n    >>> FUNC([1.0, 2.0, 3.0, 4.0, 5.0])\n    [0.0, 0.25, 0.5, 0.75, 1.0]\n    \"\"\"\n    min_number = min(numbers)\n    max_number = max(numbers)\n    return [(x - min_number) \/ (max_number + min_number) for x in numbers]\n"}
{"id":144,"bad_solution":"import sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LI1(): return list(map(int1, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\nn = II()\naa = LI1()\ndp = [[-10] * n for _ in range(n)]\nmx = [-1] * (n + 1)\na, b = min(aa[:2]), max(aa[:2])\ndp[a][b] = 0\nmx[a] = mx[b] = mx[n] = 0\n\ndef chmax(i, j, val):\n    if val < 0: return\n    if i > j: i, j = j, i\n    if val > dp[i][j]:\n        dp[i][j] = val\n        nmx[i] = max(nmx[i], val)\n        nmx[j] = max(nmx[j], val)\n        nmx[n] = max(nmx[n], val)\n\nbase = 0\nfor i in range(n - 1):\n    nmx = [-1] * (n + 1)\n    abc = aa[i * 3 + 2:i * 3 + 5]\n    abc.sort()\n    a, b, c = abc\n    # 3枚とも同じ場合\n    if a == c:\n        base += 1\n        continue\n    # 1ペアできているとき\n    if a == b or b == c:\n        if b == c: a, c = c, a\n        for x in range(a): chmax(c, x, dp[x][a] + 1)\n        for x in range(a, n): chmax(c, x, dp[a][x] + 1)\n    chmax(b, c, dp[a][a] + 1)\n    chmax(a, c, dp[b][b] + 1)\n    chmax(a, b, dp[c][c] + 1)\n    for d in abc:\n        for x in range(n):\n            chmax(d, x, mx[n])\n\n    for x in range(n + 1): mx[x] = max(mx[x], nmx[x])\n    # p2D(dp)\n    # print(mx)\n\na = aa[-1]\nans = max(mx[n], dp[a][a] + 1) + base\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":145,"bad_solution":"H, W = list(map(int, input().split()))\nA = [input() for _ in range(H)]\n\nb = \"#\"\nw = \".\"\n\ndef out(i, j):\n  if i < 0:\n    return True\n  if i >= W:\n    return True\n  if j < 0:\n    return True\n  if j >= H:\n    return True\n  return False\n\ndef check(i, j):\n  if A[i][j] == b:\n    return 0\n  k = 1\n  while True:\n    F = False\n    for ii in range(i - k, i):\n      jj = j - (k - (i - ii))\n      if out(ii, jj):\n        continue\n      if A[ii][jj] == b:\n        return k\n    for ii in range(i - k, i):\n      jj = j + (k - (i - ii))\n      if out(ii, jj):\n        continue\n      if A[ii][jj] == b:\n        return k\n    for ii in range(i, i + k + 1):\n      jj = j - (k + (i - ii))\n      if out(ii, jj):\n        continue\n      if A[ii][jj] == b:\n        return k\n    for ii in range(i, i + k + 1):\n      jj = j + (k + (i - ii))\n      if out(ii, jj):\n        continue\n      if A[ii][jj] == b:\n        return k\n    k += 1\n\nAns = 0\nfor i in range(H):\n  for j in range(W):\n    k = check(i, j)\n    Ans = max(Ans, k)\n\nprint(Ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":146,"bad_solution":"from operator import itemgetter\n\ndef main():\n\tn = int(input())\n\tv = list(map(int, input().split()))\n\n\tkinds = len(set(v))\n\tif kinds == 1:\n\t\tprint(int(len(v)\/2))\n\t\treturn\n\n\tnumbers = [{}, {}]\n\tfor i in range(n):\n\t\tindex = 0\n\t\tif i%2 == 1:\n\t\t\tindex = 1\n\n\t\tif v[i] not in numbers[index]:\n\t\t\tnumbers[index][v[i]] = 1\n\t\telse:\n\t\t\tnumbers[index][v[i]] += 1\n\n\tif len(numbers[0])==1 and len(numbers[1])==1:\n\t\tprint(\"0\")\n\t\treturn\n\n\tsort_nums = []\n\tfor i in range(2):\n\t\tsort_nums.append(sorted(numbers[i].items(), key=itemgetter(1), reverse=True))\n\t\n\tmaxes = [sort_nums[0][0], sort_nums[1][0]]\n\tif maxes[0][0] == maxes[1][0]:\n\n\t\tif len(sort_nums[0])>1 and len(sort_nums[1])>1:\n\t\t\tdiff = maxes[0][1] - maxes[1][1]\n\t\t\tindex = True   #True = 1\n\t\t\tif diff > 0 and sort_nums[0][1][1]>sort_nums[1][1][1]:\n\t\t\t\tindex = False  #True = 0\n\n\t\t\ttotal = 0\n\t\t\ttotal += sum([x[1] for x in sort_nums[index][1:]])\n\t\t\ttotal += sort_nums[not(index)][0][1]\n\t\t\ttotal += sum([x[1] for x in sort_nums[not(index)][2:]])\n\t\t\tprint(total)\n\t\t\treturn\n\n\t\telif len(sort_nums[0])==1:\n\t\t\ttotal = 0\n\t\t\ttotal += sum([x[1] for x in sort_nums[0][1:]])\n\t\t\ttotal += sort_nums[1][0][1]\n\t\t\ttotal += sum([x[1] for x in sort_nums[1][2:]])\n\t\t\tprint(total)\n\t\t\treturn\n\n\t\telse:\n\t\t\ttotal = 0\n\t\t\ttotal += sum([x[1] for x in sort_nums[1][1:]])\n\t\t\ttotal += sort_nums[0][0][1]\n\t\t\ttotal += sum([x[1] for x in sort_nums[0][2:]])\n\t\t\tprint(total)\n\t\t\treturn\n\n\telse: \n\t\ttotal = 0\n\t\tfor i in range(2):\n\t\t\ttotal += sum([x[1] for x in sort_nums[i][1:]])\n\t\tprint(total)\n\t\treturn\n\t\n\nmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":147,"bad_solution":"def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n = int(input())\n    v = list(map(int, input().split()))\n    if len(set(v)) == 1:\n        print(n\/\/2)\n    else:\n        a, b = [], []\n        for i in range(n):\n            if i%2 == 1:\n                a.append(v[i])\n            else:\n                b.append(v[i])\n        c = Counter(a)\n        c = c.most_common()\n        d = Counter(b)\n        d = d.most_common()\n        if c[0][0] != d[0][0]:\n            print(n-c[0][1]-d[0][1])\n        else:\n            if len(c) == 1:\n                print(n-c[0][1]-d[1][1])\n            elif len(d) == 1:\n                print(n-c[1][1]-d[0][1])\n            else:\n                if c[0][1] > d[0][1]:\n                    print(n-c[0][1]-d[1][1])\n                else:\n                    print(n-c[1][1]-d[0][1])\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":148,"bad_solution":"class segment_tree:\n    def __init__(self, N, operator_M, e_M):\n        self.op_M = operator_M\n        self.e_M = e_M\n        \n        self.N0 = 1<<(N-1).bit_length()\n        self.dat = [self.e_M]*(2*self.N0)\n    \n    # 長さNの配列 initial で初期化\n    def build(self, initial):\n        self.dat[self.N0:self.N0+len(initial)] = initial[:]\n        for k in range(self.N0-1,0,-1):\n            self.dat[k] = self.op_M(self.dat[2*k], self.dat[2*k+1])\n\n    # a_k の値を x に更新\n    def update(self,k,x):\n        k += self.N0\n        self.dat[k] = x\n        k \/\/= 2\n        while k:\n            self.dat[k] = self.op_M(self.dat[2*k], self.dat[2*k+1])\n            k \/\/= 2\n\n    # 区間[L,R]をopでまとめる\n    def query(self,L,R):\n        L += self.N0; R += self.N0 + 1 \n        sl = sr = self.e_M\n        while L < R:\n            if R & 1:\n                R -= 1\n                sr = self.op_M(self.dat[R],sr)\n            if L & 1:\n                sl = self.op_M(sl,self.dat[L])\n                L += 1\n            L >>= 1; R >>= 1\n        return self.op_M(sl,sr)\n\n    def get(self, k): #k番目の値を取得。query[k,k]と同じ\n        return self.dat[k+self.N0]\n\nclass BIT: #0-indexed\n    def __init__(self, n):\n        self.size = n\n        self.tree = [i&-i for i in range((n+1))]\n        self.depth = n.bit_length()\n        self.n0 = 1<<self.depth\n#        self.element = [0]*(n+1)\n    def get_sum(self, i): #a_0 + ... + a_{i} #閉区間\n        s = 0; i += 1\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n    def query(self,l,r): #a_l + ... + a_r 閉区間\n        return self.get_sum(r) - self.get_sum(l-1) \n    def add(self, i, x):\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n        # self.element[i] += x\n    #def get(self,i): return element[i]        \n    def bisect_left(self,w):\n        #和が w 以上になる最小の index\n        #w が存在しない場合 self.size を返す\n        if w <= 0: return 0\n        x,k = 0,self.n0\n        for _ in range(self.depth):\n            k >>= 1\n            if x+k <= self.size and self.tree[x+k] < w:\n                w -= self.tree[x+k]\n                x += k\n        return x\n    \nclass stdmap:\n    def __init__(self, n):\n        self.size = n+1\n        self.keys = set()\n        self.B = BIT(n+1) #存在すれば 1、しないなら 0\n        self.dic = [0]*(n+1) # 値域\n    \n    def __contains__(self, k):\n        return k in self.keys\n\n    def insert(self,a,b): # 値 a に b を上書き\n        if a not in self.keys:\n            self.B.add(a,1)\n            self.keys.add(a)\n        self.dic[a] = b\n\n    def remove(self,a): # a を取り除く\n        self.keys.remove(a)\n        self.B.add(a,-1)\n\n    def lower_bound(self,k): # k 以上の最小のkeyを求める\n        return self.B.bisect_left(self.B.get_sum(k))\n        \n    def kth_key(self,k): # k 番目に小さい元のkeyを求める\n        return self.B.bisect_left(k)\n\n    def kth_value(self,k): # k 番目に小さい元のmap先を求める\n        return self.dic[self.B.bisect_left(k)]\n\n    def prev_key(self,k): #一個前の元のkeyを求める\n        idx = self.B.get_sum(k)\n        assert idx != 0\n        return self.B.bisect_left(idx-1)\n\n    def next_key(self,k):\n        idx = self.B.get_sum(k)\n        assert idx != self.size\n        return self.B.bisect_left(idx+1)\n\n    def __getitem__(self,item):\n        return self.dic[item]\n\n\n# coding: utf-8\n# Your code here!\nimport sys\nreadline = sys.stdin.readline\nread = sys.stdin.read\n\nh,w = map(int,readline().split())\n\nb = stdmap(w+2)\nb.dic = [0]*(w+3) # 値域\nb.keys = set(range(w+2))\n\nINF = 1<<31\nseg = segment_tree(w+2, min, INF)\nseg.build([INF]+[0]*w+[INF])\n\n\nfor i in range(1,h+1):\n    p,q = map(int,readline().split())\n\n    v = b.B.get_sum(p-1)\n    idx = b.kth_key(v)\n    \n    x = b.next_key(idx)\n    val = INF\n    while x <= q:\n        #print(x,b.dic[x]-x,\"x,val\")\n        val = min(val,b.dic[x]-x)\n        seg.update(x,INF)\n        b.remove(x)\n        x = b.next_key(x)\n    \n    if q < w:\n        b.insert(q+1,val+q+1)\n        seg.update(q+1,val+q+1)\n    \n    #print(b.keys)\n    #print(seg.dat)\n    #print(q,val,\"q,val\")    \n\n    v = seg.dat[1]\n    #print(v,i)\n    if v>=INF:\n        print(-1)\n    else:\n        print(v+i)\n    \n    #print()\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":149,"bad_solution":"import sys\ndef input(): return sys.stdin.readline().strip()\ndef STR(): return input()\ndef MAP(): return map(int, input().split())\ninf = sys.maxsize\n\nh, w, k = MAP()\ns = [[int(i) for i in STR()] for _ in range(h)]\n\nans = inf\nfor i in range(2 ** (h - 1)): #縦方向の割り方を全探索 O(500)\n    hdiv = [1 if i & 2 ** j else 0 for j in range(h - 1)]\n    hdiv.append(1)\n    sh = sum(hdiv)\n    tmpans = sh - 1\n    partsum = [0 for _ in range(sh)]\n    j = 0\n    while j < w: #O(2 * 10 ** 4)\n        tmp = 0\n        idx = 0\n        for kk in range(h): #O(10)\n            tmp += s[kk][j]\n            if hdiv[kk]:\n                partsum[idx] += tmp\n                tmp = 0\n                idx += 1\n        flag = True\n        for kk in range(sh):\n            if partsum[kk] > k:\n                tmpans += 1\n                for l in range(sh):\n                    partsum[l] = 0\n                flag = False\n        if flag:\n            j += 1\n    ans = min(ans, tmpans)\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":150,"bad_solution":"\ndef dijkstra(graph,weight,s,N):\n    distance=[1e10 for i in range(N)]\n    distance[s]=0\n    unvisited=[i for i in range(N)]\n    while len(unvisited)>0:\n        unvisited.sort(key=lambda x:distance[x])\n        v=unvisited.pop(0)\n        for w in graph[v]:\n            if distance[w]>distance[v]+weight[(v,w)]:\n                distance[w] = distance[v] + weight[(v, w)]\n    return distance\n\ndef e_check(e,d_list,weight,N):\n    for i in range(N):\n        for j in range(N):\n            if e[0]!=i and e[1]!=j and d_list[e[0]][i]+weight[(i,j)]==d_list[j][e[1]]:\n                return True\n    return False\n\nif __name__ == '__main__':\n    N,M=list(map(int,input().split()))\n    graph={i:[] for i in range(N)}\n    weight={(i,j):1e10 for i in range(N) for j in range(N)}\n    E=[]\n\n    for i in range(M):\n        a,b,c = list(map(int, input().split()))\n        E.append((a-1,b-1))\n        E.append((b-1,a-1))\n        graph[a-1].append(b-1)\n        graph[b-1].append(a-1)\n        weight[(a-1,b-1)]=c\n        weight[(b-1,a-1)]=c\n    d_list={i:dijkstra(graph,weight,i,N) for i in range(N)}\n    removed=[]\n    for e in E:\n        if not e_check(e,d_list,weight,N):\n            removed.append(e)\n    E=set(E)\n    removed=set(removed)\n    ans=E.difference(removed)\n    print(len(ans)\/\/2)\n\n\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":151,"bad_solution":"import sys\nfrom collections import defaultdict\ninput = sys.stdin.readline\n\nn, q = map(int, input().split())\nc = list(map(int, input().split()))\nlr = []\nfor i in range(q):\n    l, r = map(int, input().split())\n    lr.append((l, r, i))\n\n# 1-indexed\nleft_index_dict = {}\nd = defaultdict(int)\n\nfor i, ci in enumerate(c):\n    index = d[ci]\n    if index in left_index_dict:\n        left_index_dict[index].append(i+1)\n    else:\n        left_index_dict[index] = [i+1]\n    d[ci] = i + 1\n\nlr.sort(key=lambda x:x[0])\n\n# index = list(left_index_dict.keys())\n# index.sort()\n# i = 0\n\n# N = n\n# bit = [0] * (N+1)\n\n# def sum(i):\n#     s = 0\n#     while i > 0:\n#         s += bit[i]\n#         i -= i & -i\n#     return s\n\n# def add(i, x):\n#     while i <= N:\n#         bit[i] += x\n#         i += i & -i\n\n# ans = [0] * q\n\n# for l, r, _i in lr:\n#     while i < len(index) and index[i] < l:\n#         for j in left_index_dict[index[i]]:\n#             add(j, 1)\n#         i += 1\n#     ans[_i] = sum(r) - sum(l-1)\n\n# for ansi in ans:\n#     print(ansi) \n    \n\n\n\n    \n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":152,"bad_solution":"import sys\nfrom collections import defaultdict as dd\nfrom bisect import bisect_left as bl\ninput = sys.stdin.readline\nN, M, V, P = map(int, input().split())\na = list(map(int, input().split()))\na.sort()\n#print(a)\nd = dd(int)\nfor x in a: d[x] += 1\n#print(d)\nks = sorted(d.keys())\n#print(ks)\ndef check(x):\n  b = a + [x + M]\n  isit = 0\n  for i in range(V):\n    if isit == 0:\n      b[i] = -float(\"inf\")\n      isit = 1\n    b[i] += M\n  b.sort()\n  c = 0\n  t = 0\n  for i in range(N, -1, -1):\n    if b[i] != t:\n      if c >= P: break\n      if b[i] <= x + M: return True\n      t = b[i]\n    c += 1\n  return False\nok = N\nng = -1\nm = (ok + ng) \/\/ 2\nwhile ok - ng > 1:\n  m = (ok + ng) \/\/ 2\n  if check(a[m]):\n    ok = m\n  else: ng = m\nres = N\nif N <= 10:\n  for i in range(N):\n    if check(a[i]) == False:\n      ng = max(ng, a[i])\nif check(ng): ng -= 1\nif check(ng): ng -= 1\nif check(ng): ng -= 1\nfor k in ks:\n  if k <= ng: res -= d[k]\n\nprint(res)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":153,"bad_solution":"import sys\nfrom itertools import groupby\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\nsys.setrecursionlimit(10 ** 9)\nINF = 1 << 60\n\n\ndef len_count(S):\n    H, W = len(S), len(S[0])\n    L = [[0] * W for _ in range(H)]\n    for row_S, row_L in zip(S, L):\n        idx = 0\n        for k, g in groupby(list(row_S)):\n            n = len(list(g))\n            if k == '.':\n                row_L[idx : idx + n] = [n] * n\n            idx += n\n    return L\n\n\ndef main():\n    H, W = map(int, readline().split())\n    S = [readline().strip() for _ in range(H)]\n\n    L1 = len_count(S)\n    L2 = list(zip(*len_count(list(zip(*S)))))\n\n    ans = 0\n    for row1, row2 in zip(L1, L2):\n        for j in range(W):\n            if ans < row1[j] + row2[j] - 1:\n                ans = row1[j] + row2[j] - 1\n\n    print(ans)\n    return\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":154,"bad_solution":"mod = 10 ** 9 + 7\nfrom collections import deque\nimport heapq\n\ndef iip(listed):\n    ret = [int(i) for i in input().split()]\n    if len(ret) == 1 and not listed:\n        return ret[0]\n    return ret\n\n\n\ndef main():\n    r = solve()\n    print(r)\n\n\ndef solve():\n    N = iip(False)\n    sN = str(N)\n    nl = list(map(int, sN))\n    nl.reverse()\n\n    ret = 0\n    for i in range(len(nl)):\n        is_final = False\n        if i == len(nl) -1:\n            is_final = True\n\n        a = nl[i]\n        if not is_final:\n            if a >= 10: # 繰り上がり処理\n                a -= 10\n                nl[i+1] += 1\n\n            if a <= 4:\n                ret += a # その桁が4以下ならちょうど払う\n\n            if a == 5: # 1つ上の桁次第\n                if nl[i+1] >= 5:\n                    nl[i+1] += 1\n                    ret += 5\n                else:\n                    ret += 5\n\n            if a >= 6: #1つ上の桁の金で払う\n                nl[i+1] += 1\n                ret += (10-a)\n\n        if is_final:\n            if a >= 10:\n                ret += 1\n                a -= 10\n                ret += a\n                return ret\n            if a <= 5:\n                ret += a\n                return ret\n            if a >= 6:\n                ret += 1 + (10-a)\n                return ret\n\n\n\n#####################################################ライブラリ集ここから\n\ndef split_print_space(s):\n    print(\" \".join([str(i) for i in s]))\n\ndef split_print_enter(s):\n    print(\"\\n\".join([str(i) for i in s]))\n\ndef koenai_saidai_x_index(sorted_list, n):\n    l = 0\n    r = len(sorted_list)\n    if len(sorted_list) == 0:\n        return False\n    if sorted_list[0] > n:\n        return False\n\n    while r-l > 1:\n        x = (l+r)\/\/2\n        if sorted_list[x] == n:\n            return x\n        elif sorted_list[x] > n:\n            r = x\n        else:\n            l = x\n    return l\n\ndef searchsorted(sorted_list, n, side):\n    if side not in [\"right\", \"left\"]:\n        raise Exception(\"sideはrightかleftで指定してください\")\n\n    l = 0\n    r = len(sorted_list)\n\n    if n > sorted_list[-1]:\n        # print(sorted_list)\n        return len(sorted_list)\n    if n < sorted_list[0]:\n        return 0\n\n    while r - l > 1:\n        x = (l + r) \/\/ 2\n        if sorted_list[x] > n:\n            r = x\n        elif sorted_list[x] < n:\n            l = x\n        else:\n            if side == \"left\":\n                r = x\n            elif side == \"right\":\n                l = x\n\n    if side == \"left\":\n        if sorted_list[l] == n:\n            return r - 1\n        else:\n            return r\n\n    if side == \"right\":\n        if sorted_list[l] == n:\n            return l + 1\n        else:\n            return l\n\n\n\n\ndef soinsuu_bunkai(n):\n    ret = []\n    for i in range(2, int(n ** 0.5) + 1):\n        while n % i == 0:\n            n \/\/= i\n            ret.append(i)\n        if i > n:\n            break\n    if n != 1:\n        ret.append(n)\n    return ret\n\n\ndef conbination(n, r, mod, test=False):\n    if n <= 0:\n        return 0\n    if r == 0:\n        return 1\n    if r < 0:\n        return 0\n    if r == 1:\n        return n\n    ret = 1\n    for i in range(n - r + 1, n + 1):\n        ret *= i\n        ret = ret % mod\n\n    bunbo = 1\n    for i in range(1, r + 1):\n        bunbo *= i\n        bunbo = bunbo % mod\n\n    ret = (ret * inv(bunbo, mod)) % mod\n    if test:\n        # print(f\"{n}C{r} = {ret}\")\n        pass\n    return ret\n\n\ndef inv(n, mod):\n    return power(n, mod - 2)\n\n\ndef power(n, p):\n    if p == 0:\n        return 1\n    if p % 2 == 0:\n        return (power(n, p \/\/ 2) ** 2) % mod\n    if p % 2 == 1:\n        return (n * power(n, p - 1)) % mod\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":155,"bad_solution":"def numba_compile(numba_config):\n    import os, sys\n    if sys.argv[-1] == \"ONLINE_JUDGE\":\n        from numba import njit\n        from numba.pycc import CC\n        cc = CC(\"my_module\")\n        for func, signature in numba_config:\n            globals()[func.__name__] = njit(signature)(func)\n            cc.export(func.__name__, signature)(func)\n        cc.compile()\n        exit()\n    elif os.name == \"posix\":\n        exec(f\"from my_module import {','.join(func.__name__ for func, _ in numba_config)}\")\n        for func, _ in numba_config:\n            globals()[func.__name__] = vars()[func.__name__]\n    else:\n        from numba import njit\n        for func, signature in numba_config:\n            globals()[func.__name__] = njit(signature, cache=True)(func)\n        print(\"compiled!\", file=sys.stderr)\n\n\nimport sys\nimport numpy as np\n\n\ndef solve(H, W, AB):\n    A = W+1\n    identity = -(1<<62)\n    sqrtA = 200\n    n_buckets = A\/\/sqrtA+1\n    Data = np.zeros(n_buckets*sqrtA, dtype=np.int64)\n    Data[0] = 1<<30\n    Data[W+1:] = 1<<30\n    Bucket_min = np.zeros(n_buckets, dtype=np.int64)\n    Lazy = np.full(n_buckets, identity, dtype=np.int64)\n\n    def eval_data(k):\n        if Lazy[k] != identity:\n            l, r = k*sqrtA, (k+1)*sqrtA\n            for i in range(l, r):\n                Data[i] = i-Lazy[k]\n            Lazy[k] = identity\n\n    def update(s, t, x):\n        for k in range(s\/\/sqrtA, (t-1)\/\/sqrtA+1):\n            l, r = k*sqrtA, (k+1)*sqrtA\n            if s <= l and r <= t:\n                Bucket_min[k] = l-x\n                Lazy[k] = x\n            else:\n                eval_data(k)\n                for i in range(max(l, s), min(r, t)):\n                    Data[i] = i-x\n                Bucket_min[k] = Data[l:r].min()\n\n    def get(i):\n        k = i\/\/sqrtA\n        eval_data(k)\n        return Data[i]\n\n    Ans = np.zeros(H, dtype=np.int64)\n    for i in range(H):\n        a, b = AB[i]\n        update(a, b+1, a-1-get(a-1))\n        ans = Bucket_min.min()\n        Ans[i] = ans+i+1 if ans < 1<<25 else -1\n\n    return Ans\n\n\nnumba_compile([\n    [solve, \"i8[:](i8,i8,i8[:,:])\"]\n])\n\n\ndef main():\n    H, W = map(int, sys.stdin.buffer.readline().split())\n    if H==4:\n        exit()\n    AB = np.array(sys.stdin.buffer.read().split(), dtype=np.int64).reshape(H, 2)\n    Ans = solve(H, W, AB)\n    print(\"\\n\".join(map(str, Ans.tolist())))\n\n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":156,"bad_solution":"from collections import deque, Counter as cnt\nfrom collections import defaultdict as dd\nfrom operator import itemgetter as ig\nfrom bisect import bisect_right as bsr\nfrom math import factorial, ceil, floor\nimport sys\nsys.setrecursionlimit(1000000)\n\n# お約束\nargs = None\nINF = float(\"inf\")\nMOD = int(1e9 + 7)\n\n\ndef input(*ps):\n    if type(ps[0]) is list:\n        return [input(*ps[0][:-1]) for _ in range(ps[0][-1])]\n    elif len(ps) == 1:\n        return ps[0](next(args))\n    else:\n        return [p(next(args)) for p in ps]\n\n\ndef nlist(n, v):\n    if not n:\n        return [] if type(v) is list else v\n    return [nlist(n[1:], v) for _ in range(n[0])]\n\n\ndef yesno(v):\n    print([\"Yes\", \"No\"][not v])\n\n\n# エントリーポイント\ndef main():\n    N = input(int)\n    A = input([int, N])\n\n    count = dd(int)\n    for a in A:\n        count[a] += 1\n    ans = {}\n    for k in count.keys():\n        temp = 0\n        for v in count.values():\n            temp += (v * (v - 1)) \/\/ 2\n        ans[k] = temp - count[k] + 1\n    for a in A:\n        print(ans[a])\n\n\nif __name__ == '__main__':\n    args = iter(sys.stdin.read().split())\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":157,"bad_solution":"from bisect import bisect_left\n\n\ndef main():\n    n, m, k = map(int, input().split())\n    a = list(map(int, input().split()))\n    b = list(map(int, input().split()))\n    for i in range(1, n):\n        a[i] += a[i - 1]\n    for i in range(1, m):\n        b[i] += b[i - 1]\n    answer = 0\n    for i in range(n):\n        l = bisect_left(b, k - a[i])\n        if l == m or l == 0:\n            continue\n        diff = 1 if b[l] == k - a[i] else 0\n        answer = max(answer, i + 1 + l + diff)\n    print(answer)\n\n\nif __name__ == '__main__':\n    main()\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":158,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\n# Generated by 1.1.6 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]\n\n    done = [int()]*(2*10**5)\n    done[0] = 1\n    i = 1\n    q = A[0]\n    while q not in done:\n        done[i] = q\n        i+=1\n        q = A[q-1]\n        # print(\"q: {} i:{}\".format(q,i))\n\n    f_q = done.index(q)\n    # print(\"i :{} r:{}\".format(i,f_q))\n    r = i - f_q\n    # print(r)\n    if K <= i:\n        t = K\n    else:\n        k = K - f_q\n        k = k % r\n        t = k + f_q\n        \n\n    q = A[0]\n    for _ in range(t-1):\n        q=A[q-1]\n    print(q)\n\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":159,"bad_solution":"import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\n \ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef S_MAP(): return map(str, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef S_LIST(): return list(map(str, input().split()))\n \nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN = INT()\nS = input()\n\nR = []\nG = []\nB = []\n\nfor i in range(N):\n    if S[i] == \"R\":\n        R.append(i)\n    elif S[i] == \"G\":\n        G.append(i)\n    else:\n        B.append(i)\n\n# print(R, G, B)\n\nans = len(R) * len(G) * len(B)\n\ncount = 0\nfor i in R:\n    for j in G:\n        num = max(i, j) - min(i, j)\n        num = num + max(i, j)\n        if num in B:\n            count += 1\n\nfor i in R:\n    for j in B:\n        num = max(i, j) - min(i, j)\n        num = num + max(i, j)\n        if num in G:\n            count += 1\n\nfor i in G:\n    for j in B:\n        num = max(i, j) - min(i, j)\n        num = num + max(i, j)\n        if num in R:\n            count += 1\n\n\nprint(ans - count)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":160,"bad_solution":"from typing import List, Any\n\n\ndef FUNC(values: List[Any]) -> List[int]:\n    \"\"\" Filter given list of any python values only for integers\n    >>> FUNC(['a', 3.14, 5])\n    [5]\n    >>> FUNC([1, 2, 3, 'abc', {}, []])\n    [1, 2, 3]\n    \"\"\"\n    out = [x for x in values if isinstance(x, int)]\n    return values\n"}
{"id":161,"bad_solution":"\"\"\"\nn = int(sys.stdin.readline())\na, b = map(int, sys.stdin.readline().split())\nc = list(map(int, sys.stdin.readline().split()))\ns = [list(map(int,list(sys.stdin.readline()))) for i in range(h)]  # 二次元配列入力　二次元マップみたいな入力のとき\n\na = 100\nb = 0.987654321\nprint('{0:06d}-{1:6f}'.format(a,b))  # 0埋め, 小数点出力桁指定時のときの出力\n000100-0.987654\n\n# 文字列をリストに格納\nchar_list = list(\"abcd\") # [\"a\",\"b\",\"c\",\"d\"]\n\"\"\"\n\nimport math\nimport sys\nimport itertools\nimport queue\nfrom fractions import gcd\n\ndef lcm(a, b):\n    return a * b \/\/ gcd(a, b)\n\n\nmod = 1000000007\n\nif __name__ == \"__main__\":\n    N, Q = map(int, sys.stdin.readline().split())\n    origin = sys.stdin.readline()\n    dp = [0 for _ in range(N + 1)]\n    a_flag = False\n    for i in range(N):\n\n        if a_flag and origin[i] == \"C\":\n            dp[i + 1] = dp[i] + 1\n            a_flag = False\n            continue\n\n        if origin[i] == \"A\":\n            a_flag = True\n\n        dp[i + 1] = dp[i]\n\n    for _ in range(Q):\n        l, r = map(int, sys.stdin.readline().split())\n        print(dp[r] - dp[l])\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":162,"bad_solution":"def bisearch(li,target):\n    l=0\n    r=len(li)-1\n    while(l<=r):        \n        m=int((l+r)\/2)\n        if(m==len(li)-1):\n            return target-li[m][0]+li[m][1]\n        if(li[m][0]<target and target<li[m+1][0]):\n            return min(target-li[m][0]+li[m][1],li[m+1][0]-target+li[m+1][1])\n        if(m==0 and target<li[0][0]):\n            return li[0][0]-target+li[0][1]\n        if(target<li[m][0]):\n            r = m-1\n        else:\n            l = m+1\n\ninf = 10**15\nA,B,Q = [int(x) for x in input().split()]\ns = [0]*(A+1)\nt = [0]*(B+1)\nx = [0]*Q\n\nfor i in range(A):\n    s[i] = int(input())\nfor i in range(B):\n    t[i] = int(input())\nfor i in range(Q):\n    x[i] = int(input())\ns[-1] = inf\nt[-1] = inf\n\nli = []\na = b = 0\nwhile(a<A or b<B):\n    if(s[a]<t[b]):\n        li.append([s[a],min(abs(t[b]-s[a]),abs(t[b-1]-s[a]))])\n        a+=1\n    else:\n        li.append([t[b],min(abs(t[b]-s[a]),abs(t[b]-s[a-1]))])\n        b+=1\n\nfor i in x:\n    print(bisearch(li,i))\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":163,"bad_solution":"\n#素因数分解（10**6まで）\ndef soinsu_bunkai(m):\n    pf=set()\n    mm =m\n    for i in pri_num:\n        while mm %i==0:\n            pf.add(i)\n            mm \/\/=i\n    if mm !=1:\n        pf.add(mm)\n    return pf\n\n    # 初期入力\nimport math\nimport sys\nfrom bisect import bisect_left\nfrom functools import reduce\ninput = sys.stdin.readline  #文字列では使わない\nN = int(input())\nA = list(map(int, input().split()))\nintersect =set()\npair_w =set()\n\n# 10**6までの素因数分解するために、「10**6のルート」までの素数を列挙\npri =10**6 +10\nsq_pri =int(math.sqrt(pri))\n#pri_num =prime_numbers(sq_pri +10 )\npri_num =[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997, 1009]\n\n#not coprimeの判定\ngcd_a =reduce(math.gcd,A)\nif gcd_a !=1:\n    ans =\"not coprime\"\n\n#pairwise coprimeの判定\nelse:\n    A.sort()\n    x =bisect_left(A,2)\n    if N -x >= 78498 +1:\n        ans =\"setwise coprime\"\n        sys.exit() #10**6以下の素数は78498個、鳩ノ巣原理により必ず素因数が重複、または素数以外の数が出ている\n    else:\n        for a in A:\n            aa =soinsu_bunkai(a)\n            if intersect & aa:\n                print(\"setwise coprime\")\n                sys.exit() #共通要素があったらpair_wではない→set_w\n            intersect |=aa\n\n        ans =\"pairwise coprime\"\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":164,"bad_solution":"\n\ndef FUNC(string: str) -> int:\n    \"\"\" Return length of given string\n    >>> FUNC('')\n    0\n    >>> FUNC('abc')\n    3\n    \"\"\"\n    return len(string) - 1\n"}
{"id":165,"bad_solution":"import sys\nimport bisect as bi\nimport math\nfrom collections import defaultdict as dd\nimport heapq\nimport itertools\ninput=sys.stdin.readline\nfrom random import randint\n##import numpy as np\n##sys.setrecursionlimit(10**7)\nmo=10**9+7\ndef cin():\n    return map(int,sin().split())\ndef ain():            \n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\n##def gcd(a,b): \n##    if a == 0: \n##        return b \n##    return gcd(b % a, a)\nprime1=[]\ndef SieveOfEratosthenes(n): #list of primes upto n\n    global prime1\n    prime1 = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime1[p] == True): \n            for i in range(p * p, n+1, p): \n                prime1[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime1[p]: \n            f.append(p)\n    return f\n\ndef lcm(a,b): \n    return (a*b) \/\/ math.gcd(a,b) \nfor _ in range(1):\n    n=inin()\n    l=ain()\n    f1,f2=0,0\n    d=dd(int)\n    lp=SieveOfEratosthenes(int(math.sqrt(max(l)+1))+1)\n    for i in l:\n        for j in lp:\n            if(i%j==0):\n                if(d[j]==1):\n                    f1=1\n                d[j]+=1\n    if(max(list(d.values()))==n):f2=1\n    if(f2):print(\"not coprime\")\n    else:\n        if(f1):\n            print(\"setwise coprime\")\n        else:\n            print(\"pairwise coprime\")\n        \n        \n    \n    \n    \n\n \n    \n    \n    \n    \n        \n        \n    \n    \n    \n    \n\n\n    \n\n\n\n\n##def msb(n):n|=n>>1;n|=n>>2;n|=n>>4;n|=n>>8;n|=n>>16;n|=n>>32;n|=n>>64;return n-(n>>1) #2 ki power\n##def pref(a,n,f):             \n##    pre=[0]*n\n##    if(f==0):         ##from beginning\n##        pre[0]=a[0]\n##        for i in range(1,n):\n##            pre[i]=a[i]+pre[i-1]\n##    else:              ##from end\n##        pre[-1]=a[-1]\n##        for i in range(n-2,-1,-1):\n##            pre[i]=pre[i+1]+a[i]\n##    return pre\n##maxint=10**24 \n##def kadane(a,size): \n##    max_so_far = -maxint - 1\n##    max_ending_here = 0\n##       \n##    for i in range(0, size): \n##        max_ending_here = max_ending_here + a[i] \n##        if (max_so_far < max_ending_here): \n##            max_so_far = max_ending_here \n##  \n##        if max_ending_here < 0: \n##            max_ending_here = 0   \n##    return max_so_far\n##def power(x, y):\n##    if(y == 0):return 1\n##    temp = power(x, int(y \/ 2))%mo\n##    if (y % 2 == 0):return (temp * temp)%mo \n##    else:\n##        if(y > 0):return (x * temp * temp)%mo \n##        else:return ((temp * temp)\/\/x )%mo\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":166,"bad_solution":"#どっちで出すか注意, rstrip注意\n#提出前に見返すこと！\ndef main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    import heapq\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n,m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    for _ in range(m):\n        b,c = map(int, input().split())\n        i = bisect_left(a, c)\n        if b >= i:\n            a = [c]*i + a[i:]\n        else:\n            a = a[b:i] + [c]*b +a[i:]\n    print(sum(a))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":167,"bad_solution":"\n\ndef FUNC(n: int) -> int:\n    \"\"\" For a given number n, find the largest number that divides n evenly, smaller than n\n    >>> FUNC(15)\n    5\n    \"\"\"\n    for i in reversed(range(n)):\n        if n - i == 0:\n            return i\n"}
{"id":168,"bad_solution":"from typing import List\n\n\ndef FUNC(n: int) -> List[int]:\n    \"\"\" Return list of prime factors of given integer in the order from smallest to largest.\n    Each of the factors should be listed number of times corresponding to how many times it appeares in factorization.\n    Input number should be equal to the product of all factors\n    >>> FUNC(8)\n    [2, 2, 2]\n    >>> FUNC(25)\n    [5, 5]\n    >>> FUNC(70)\n    [2, 5, 7]\n    \"\"\"\n    import math\n    fact = []\n    i = 0\n    while i <= int(math.sqrt(n) + 1):\n        if n % i == 0:\n            fact.append(i)\n            n \/\/= i\n        else:\n            i += 1\n\n    if n > 1:\n        fact.append(n)\n    return fact\n"}
{"id":169,"bad_solution":"n,q = map(int,input().split())\nc = tuple(map(int,input().split()))\nqs = [[] for _ in range(n)]\nfor i in range(q):\n  l,r = map(int,input().split())\n  l -= 1\n  r -= 1\n  qs[l].append((r,i))\n\nclass BIT:\n    def __init__(self,n):\n        self.num=n\n        self.dat=[0]*(self.num+1)\n        self.depth=n.bit_length()\n    \n    def add(self,i,x):\n        i+=1\n        while i<=self.num:\n            self.dat[i]+=x\n            i+=i&-i\n    \n    def sum(self,i):\n        i+=1\n        s=0\n        while i>0:\n            s+=self.dat[i]\n            i-=i&-i\n        return s\n    \n    def lower_bound(self,x):\n        sum_=0\n        pos=0\n        for i in range(self.depth,-1,-1):\n            k=pos+(1<<i)\n            if k<=self.num and sum_+self.dat[k]<x:\n                sum_+=self.dat[k]\n                pos+=1<<i\n        return pos, sum_\n\nps = [-1 for _ in range(n)]\npi = [-1 for _ in range(n)]\nfor i in range(n):\n  l = pi[c[i]]\n  if l != -1:\n    ps[l] = i\n  pi[c[i]] = i\n    \nd = BIT(n)\nans = [0 for _ in range(q)]\nfor x in range(n-1,-1,-1):\n  if ps[x] != -1:\n    d.add(ps[x],1)\n  for r,i in qs[x]:\n    ans[i] = (r-x+1)-d.sum(r)\n\nfor i in range(q):\n  print(ans[i])\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":170,"bad_solution":"import math\nimport time\n\n\nt = time.time()\ndef iip():\n    return [int(i) for i in input().split()]\n\ndef main():\n    H, N = iip()\n    mp_for_damage = [10**9 for i in range(H+1)]\n    mp_for_damage[0] = 0\n    ab = []\n\n    for i in range(N):\n        ab.append(iip())\n\n    ab= sorted(ab, key=lambda x:x[0]\/x[1], reverse=True)\n\n    for i in range(N):\n        a, b = ab[i]\n        for j in range(H-a+1):\n            if a >= H:\n                mp_for_damage[H] = min(mp_for_damage[H], b)\n                continue\n\n            if a < H and mp_for_damage[a] < b:\n                continue\n\n            for k in range(1, min(a, H)+1):\n                mp_for_damage[k] = min(mp_for_damage[k], b)\n                #print(k, b)\n\n            mp_for_damage[j+a] = min(mp_for_damage[j+a], mp_for_damage[j] + b)\n\n    #print(mp_for_damage)\n    #print(mp_for_damage)\n    print(mp_for_damage[H])\n\n    #print(time.time() - t)\n\nmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":171,"bad_solution":"n = int(input())\nv_list = list(map(int, input().split()))\nnums_even = {-1: 0}\nnums_odd = {-1: 0}\nfor i, v in enumerate(v_list):\n    if i % 2 == 0:\n        nums_even.setdefault(v, 0)\n        nums_even[v] += 1\n    else:\n        nums_odd.setdefault(v, 0)\n        nums_odd[v] += 1\neven_max = -1\neven_max2 = -1\nfor key, val in nums_even.items():\n    if val > nums_even[even_max]:\n        even_max = key\n    elif val > nums_even[even_max2]:\n        even_max2 = key\nodd_max = -1\nodd_max2 = -1\nfor key, val in nums_odd.items():\n    if val > nums_odd[odd_max]:\n        odd_max = key\n    elif val > nums_odd[odd_max2]:\n        odd_max2 = key\nif even_max != odd_max:\n    print(n - nums_even[even_max] - nums_odd[odd_max])\nelse:\n    m = max(nums_even[even_max] + nums_odd[odd_max2], nums_even[even_max2] + nums_odd[odd_max])\n    print(n - m)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":172,"bad_solution":"import sys\nread = sys.stdin.buffer.read\nreadlines = sys.stdin.buffer.readlines\ninput = sys.stdin.buffer.readline\n\nOFS = 100005\nN = int(input())\nG = [[] for _ in [0]*OFS*2]\nfor line in readlines():\n    x, y = map(int, line.split())\n    y += OFS\n    G[x].append(y)\n    G[y].append(x)\n\nvisited = [0]*OFS*2\n\n\ndef dfs(v, x=0, y=0):\n    if v < OFS:\n        x += 1\n    else:\n        y += 1\n\n    for u in G[v]:\n        if visited[u]:\n            continue\n        visited[u] = 1\n        x, y = dfs(u, x, y)\n\n    return x, y\n\n\nans = 0\nfor i in range(OFS):\n    if visited[i]:\n        continue\n    visited[i] = 1\n    x, y = dfs(i)\n    ans += x*y\n\nprint(ans - N)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":173,"bad_solution":"a,b,q = list(map(int,input().split()))\ns = [int(input()) for i in range(0,a)]\nt = [int(input()) for i in range(0,b)]\nx = [int(input()) for i in range(0,q)]\n\ns.sort()\nt.sort()\n\ndef bifind(r,z):\n    y = len(r)\/\/2\n    halftime = 2\n    if z < r[0]:\n        return [r[0],r[0]]\n    elif z > r[-1]:\n        return [r[-1],r[-1]]\n    while True:\n        if r[y] <= z:\n            y += len(r)\/\/(2**halftime)+1\n        else:\n            y -= len(r)\/\/(2**halftime)+1\n        halftime += 1\n        if y+1  >= len(r):\n            y = len(r)-2\n        if y  < 0:\n            y = 0\n        if r[y] < z < r[y+1]:\n            break\n    return [r[y],r[y+1]]\n\nfor i in range(0,q):\n    ls = bifind(s,x[i])\n    lt = bifind(t,x[i])\n    ans = list()\n    for j in range(0,2):\n        for k in range(0,2):\n            ans.append(abs(ls[j]-x[i])+abs(lt[k]-ls[j]))\n            ans.append(abs(lt[k]-x[i])+abs(lt[k]-ls[j]))\n    print(min(ans))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":174,"bad_solution":"import heapq\ninf = 10**18\ndef dijkstra(s, n, G):#スタート, 頂点数, グラフ:[[(cost, v)], ...]\n    dist = [inf]*n\n    edges = []#(sからvまでのコストの候補, v)\n    dist[s] = 0\n    for e in G[s]:\n        heapq.heappush(edges, e)\n    while edges:\n        cost, v = heapq.heappop(edges)\n        if dist[v] != inf:\n            continue\n        dist[v] = cost\n        for c, nv in G[v]:\n            if dist[nv] == inf:\n                heapq.heappush(edges, (cost + c, nv))\n    return dist\nmx = 5005\nn, m, s = map(int, input().split())\ng = [[] for _ in range(n*mx)]\nfor i in range(m):\n    u, v, a, b = map(int, input().split())\n    u-=1\n    v-=1\n    for j in range(mx):\n        if j>=a:\n            g[u*mx+j].append((b, v*mx+j-a))\n            g[v*mx+j].append((b, u*mx+j-a))\nfor i in range(n):\n    c, d = map(int, input().split())\n    for j in range(mx-c):\n        g[i*mx+j].append((d, i*mx+j+c))\ndist = dijkstra(s, len(g), g)\nfor i in range(1, n):\n    res = inf\n    for j in range(mx):\n        res = min(res, dist[i*mx+j])\n    print(res)\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":175,"bad_solution":"from heapq import heappush, heappop\n\nX, Y, Z, K = [int(a) for a in input().split()]\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nC = [int(a) for a in input().split()]\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\ndef total(x, y, z):\n    return A[x] + B[y] + C[z]\n\ndef expand(p, q, r):\n    result = []\n    if p + 1 < X:\n        result.append((p+1, q, r))\n    if q + 1 < Y:\n        result.append((p, q+1, r))\n    if r + 1 < Z:\n        result.append((p, q, r+1))\n    return result\n\nh = []\nind = None\nheappush(h, (-total(0,0,0), (0,0,0)))\n\nfor i in range(K):\n    val, _ind = heappop(h)\n    \n    if not _ind == ind:\n        ind = _ind\n        print(-val)\n        for new_ind in expand(*ind):\n            new_val = total(*new_ind)\n            heappush(h, (-new_val, new_ind))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":176,"bad_solution":"from typing import List\n\n\ndef FUNC(numbers: List[int]) -> List[int]:\n    \"\"\" From a list of integers, remove all elements that occur more than once.\n    Keep order of elements left the same as in the input.\n    >>> FUNC([1, 2, 3, 2, 4])\n    [1, 3, 4]\n    \"\"\"\n    import collections\n    c = collections.Counter(numbers)\n    return [n for n in numbers if c[n] < 1]\n"}
{"id":177,"bad_solution":"from collections import defaultdict\nfrom bisect import bisect_right\nN,K,*A = map(int, open(0).read().split())\na = A[0]\np = 0\nls = []\ndic = defaultdict(list)\nfor i,c in enumerate(A):\n  dic[c].append(i)\nwhile True:\n  ls.append(p)\n  ind = bisect_right(dic[a],p%N)\n  if ind==len(dic[a]):\n    ind = 0\n    p += N\n  p = (p\/\/N)*N+dic[a][ind]+1\n  if p%N==0:\n    M = p\/\/N\n    break\n  a = A[p%N]\nK %= M\nX = N*K\nI = bisect_right(ls,X)-1\nX -= ls[I]\nS = set()\np = ls[I]%N\nD = defaultdict(list)\ncnt = 0\nans = []\nwhile X:\n  if D[A[p]]==[]:\n    D[A[p]].append(cnt)\n    ans.append(A[p])\n    cnt += 1\n  else:\n    i = D[A[p]][0]\n    ans = ans[:i]\n    cnt = i\n  X -= 1\n  p += 1\n  p %= N\nprint(' '.join(map(str,ans)))   \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":178,"bad_solution":"import random #入力整数列Aの生成に使用\n\nclass Node:\n    def __init__(self, data): #コンストラクタ\n        self.data = data #ノードがもつ数値\n        self.left = None #左エッジ\n        self.right = None #右エッジ\n\n\nclass BST:\n    def __init__(self, number_list): #コンストラクタ\n        self.root = None #ルートノード初期化\n        for node in number_list: #数値を持つ配列から二分木を生成\n            self.insert(node) #挿入メソッドを使ってノードを挿入する\n    #挿入\n    def insert(self, data):\n        n = self.root\n        if n == None:\n            self.root = Node(data)\n            return\n        else:\n            while True:\n                entry = n.data\n                if data < entry:\n                    if n.left is None:\n                        n.left = Node(data)\n                        return\n                    n = n.left\n                elif data > entry:\n                    if n.right is None:\n                        n.right = Node(data)\n                        return\n                    n = n.right\n                else:\n                    n.data = data\n                    return\n    #検索機能(インターフェース)\n    def search(self, search):\n        searcher = self._search_bool(search)\n        if searcher is None:\n            return False\n        elif searcher == True:\n            return True\n        elif searcher == False:\n            return False\n\n    #検索機能本体(出力:boolean),深さ優先探索\n    #nodeのvisitedはpopで代用\n    def _search_bool(self, search):\n        n = self.root\n        if n is None:\n            return None\n        else:\n            lst = []\n            lst.append(n)\n            while len(lst) > 0:\n                node = lst.pop()\n                if node.data == search:\n                    return True\n                if node.right is not None:\n                    lst.append(node.right)\n                if node.left is not None:\n                    lst.append(node.left)\n            return False\n\n    def inorder(self,node): #中順探索 l->r->p^n\n        if node is not None:\n            self.inorder(node.left)\n            print(node.data)\n            self.inorder(node.right)\nB = BST([0])\nimport bisect\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\nindex = [-1]*(10**5*2+10)\nlast = [-1]*(N+1)\nfor i in range(N)[::-1]:\n    ind = index[A[i]]\n    if ind>=0:\n        last[i] = last[ind+1]\n        index[A[i]] = -1\n    else:\n        last[i] = A[i]\n        index[A[i]] = i\nfirst_index = [-1]*(10**5*2+10)\nfor i in range(N):\n    if first_index[A[i]]<0:\n        first_index[A[i]] = i\nloop = [0]\nind = 0\nwhile True:\n    next_index = (first_index[last[ind]]+1)%N\n    if B.search(next_index):\n        for i in range(len(loop)):\n            if loop[i]==next_index:\n                start = i\n                break\n        break\n    loop.append(next_index)\n    B.insert(next_index)\n    ind = next_index\n    \nll = len(loop)\n\nindex = [[] for _ in range(10**5*2+10)]\nans = []\nfor i in range(loop[(K-start)%(ll-start)-1], N):\n    index[A[i]].append(i)\ni=loop[(K-start)%(ll-start)-1]\nwhile i<N:\n    if index[A[i]][-1]==i:\n        ans.append((str(A[i])))\n        i+=1\n    else:\n        i=index[A[i]][bisect.bisect_left(index[A[i]], i)+1]+1\nprint(' '.join(ans))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":179,"bad_solution":"import collections as cl\ndef l(): #intのlist\n    return list(map(int,input().split()))\ndef onem(): #Nとかの取得\n    return int(input())\nn = onem()\n\non = []\nde = cl.deque()\nppp = [n-2 for i in range(n)]\nfor i in range(n):\n    k = l()\n    for j in range(n-1):\n        k[j] -= 1\n    k.reverse()\n    de.append([k[0],i])\n    on.append(cl.deque(k))\n\n\nco = 1\nddd = cl.deque()\nde.append([-1,-1])\ncl = [1 for i in range(n)]\nfor aaa in range(n**2):\n    kkk = de.popleft()\n    if kkk[0] == -1 and kkk[1] == -1:\n        if sum(cl) == n:\n            co = -1\n            break\n        if len(de) == 0:\n            break\n        de.append([-1,-1])\n        co += 1\n        cl = [1 for i in range(n)]\n\n    elif ppp[kkk[0]] != 0 and on[kkk[0]][ppp[kkk[0]]] == kkk[1] and cl[kkk[0]] and cl[kkk[1]]:\n        cl[kkk[0]] = 0\n        cl[kkk[1]] = 0\n        ppp[kkk[0]] -= 1\n        ppp[kkk[1]] -= 1\n        if ppp[kkk[1]] != 0 != 0 and ppp[kkk[0]] != 0 and on[kkk[1]][ppp[kkk[1]]] == kkk[0] and on[kkk[0]][ppp[kkk[0]]] == kkk[1]:\n            de.append([on[kkk[1]][ppp[kkk[1]]],kkk[1]])\n        else:\n            if len(on[kkk[1]]) != 0:\n                de.append([on[kkk[1]][ppp[kkk[1]]],kkk[1]])\n            if len(on[kkk[0]]) != 0:\n                de.append([on[kkk[0]][ppp[kkk[0]]],kkk[0]])\n\n\nprint(co)\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":180,"bad_solution":"from heapq import heappush, heappop\nfrom collections import defaultdict\n\nN, K = map(int, input().split())\n\nq = []\nfor _ in range(N):\n    t, d = map(int, input().split())\n    heappush(q, (-d, t))\n\nnow_used = []\nnot_used = []\n\nc = 0\nsu = 0\nkn = set()\nwhile q and c<K:\n    d, t = heappop(q)\n    if not t in kn:\n        kn.add(t)\n        heappush(now_used, (-d, t))\n        su -= d\n        c += 1\n    else:\n        heappush(not_used, (d, t))\n\nused = len(now_used)\nif K-used:\n    for _ in range(K-used):\n        d, t = heappop(not_used)\n        su -= d\n        heappush(now_used, (-d, t))\n\nans = su+c*c\n\nwhile not_used:\n    a, grp = heappop(now_used)\n    su -= a\n    kn.remove(grp)\n    a, grp = heappop(not_used)\n    kn.add(grp)\n    su -= a\n    c = len(kn)\n    ans = max(ans, su+c*c)\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":181,"bad_solution":"n = int(input())\ns = str(input())\n\ncheck = dict()\ndef get_pattern2(i, j):\n    a = s[i]\n    b = s[j]\n    total = 0\n    check_str = \"\"\n    if a == \"R\" or b == \"R\":\n        check_str += \"R\"\n    if a == \"G\" or b == \"G\":\n        check_str += \"G\"\n    if a == \"B\" or b == \"B\":\n        check_str += \"B\"\n\n    for k in range(j+1, n):\n        if check_str+str(k) in check:\n            total += check[check_str+str(k)]\n            break\n        if a != s[k] and b != s[k]:\n            total += 1\n    check[check_str+str(j+1)] = total\n    return total\n\ndef get_pattern(i):\n    a = s[i]\n    total = 0\n    for j in range(i+1, n):\n        if a+str(i) in check:\n            total += check[a+str(i)]\n            break\n        if a != s[j]:\n            total += get_pattern2(i, j)\n    check[a+str(i)] = total\n\n    # k-j = i-jなものをぬく\n    for j in range(i+1, n):\n        k = j + j - i\n        if k < n:\n            if a != s[k] and s[j] != s[k] and a != s[j]:\n                total -= 1\n\n    return total\n\ntotal = 0\nfor i in range(n-1, -1, -1):\n    total += get_pattern(i)\nprint(total)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":182,"bad_solution":"def main():\n    \"\"\"\n    1 <= N  <= 10^9\n\n    七五三数とは以下の条件を満たす正の整数\n    十進法で表記したとき、\n    数字 7, 5, 3 がそれぞれ 1回以上現れ、これら以外の数字は現れない\n    \"\"\"\n    N = int(input())\n\n    ans = f(N)\n    print(ans)\n\n\ndef f(N):\n    \"\"\"\n    Nの桁数がdのとき、d-1桁の数で753数であれば満たす\n    上記d-1桁の753数に対して、\n    753のそれぞれの数について\n    桁追加をして、それがN以下であれば良い\n\n    もっと簡単に考える\n    d桁のとき並べる数字は3種類とその桁を使わないときに0埋めすると考えられる\n    よって、並べ方の最大は (3+1)^9 = 262,144\n        実際は実装上 349,525\n    \"\"\"\n    d = len(str(N))\n    ans = run_perm(N, d, [0, 3, 5, 7])\n    # ans = TLE(N)\n\n    return ans\n\n\ndef run_perm(N, d, types):\n    \"\"\"\n    全列挙: TLE, 文字列処理がダメ\n\n    http:\/\/www.geisya.or.jp\/~mwm48961\/kou3\/onajimono1.htm\n    による並べ方をやろうとしたけど断念\n    \"\"\"\n    from collections import Counter\n    a = [0] * d\n    # nth = 0\n\n    def perm(N, i, d, ans):\n        # nonlocal nth\n        # nth += 1\n\n        if i == d:\n            s = \"\".join(str(x) for x in a).lstrip(\"0\")\n            c = Counter(s)\n            if c[\"0\"] == 0 and \\\n                c[\"7\"] >= 1 and \\\n                c[\"5\"] >= 1 and \\\n                c[\"3\"] >= 1 and \\\n                    int(s) <= N:\n\n                ans += 1\n\n            return ans\n\n        for t in types:\n            a[i] = t\n            ans = perm(N, i+1, d, ans)\n\n        return ans\n\n    ans = perm(N, 0, d, 0)\n    # print(nth)\n\n    return ans\n\n\ndef TLE(N):\n    ans = 0\n    for i in range(357, N + 1):\n        s = str(i)\n        c7, c5, c3 = s.count(\"7\"), s.count(\"5\"), s.count(\"3\")\n        if len(s) == c7 + c5 + c3 and \\\n                c7 >= 1 and c5 >= 1 and c3 >= 1:\n            ans += 1\n\n    return ans\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":183,"bad_solution":"from collections import defaultdict as dd\nfrom math import factorial\nmod = 10 ** 9 + 7\n\ndef P(n, r):\n  if r > n:\n    return 1\n  elif r == 0:\n    return 1\n  else:\n    return(factorial(n) \/\/ factorial(n-r))\nN, K = map(int, input().split())\nD = dd(list)\nfor i in range(N-1):\n  a, b = map(int, input().split())\n  D[a-1].append(b-1)\n  D[b-1].append(a-1)\n\nQ = [0]\nvstd = set()\nans = K\nwhile Q:\n  a = Q.pop()\n  vstd.add(a)\n    \n  for b in D[a]:\n#    print (ans, vstd)\n    if b not in vstd:\n      if len(Q) == 0:\n        ans = (ans * P(K-1, len(D[a]))) % mod\n#        print (b, K-1, len(D[a]),P(K-1, len(D[a])), D[a], ans)\n      else:\n        ans = (ans * P(K-2, len(D[a]))) % mod\n#        print (b, K-2, len(D[a]), P(K-2, len(D[a])), D[a], ans)\n      Q.append(b)\n\nprint (ans % mod)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":184,"bad_solution":"import sys\nsys.setrecursionlimit(10**7)\ninput=sys.stdin.readline\nh,w=map(int,input().split())\nc=[int(i)-1 for i in input().split()]\nd=[int(i)-1 for i in input().split()]\ns=[input() for i in range(h)]\ninf=1000000000000\ndp=[[-1 if s[i][j]==\"#\" else inf for j in range(w)] for i in range(h)]\ndp[c[0]][c[1]]=0\ndef bfs(i,j):\n    global h,w,s,dp\n    if i>0:\n        if dp[i-1][j]>dp[i][j]:\n            dp[i-1][j]=dp[i][j]\n            bfs(i-1,j)\n    if j>0:\n        if dp[i][j-1]>dp[i][j]:\n            dp[i][j-1]=dp[i][j]\n            bfs(i,j-1)\n    if i<h-1:\n        if dp[i+1][j]>dp[i][j]:\n            dp[i+1][j]=dp[i][j]\n            bfs(i+1,j)\n    if j<w-1:\n        if dp[i][j+1]>dp[i][j]:\n            dp[i][j+1]=dp[i][j]\n            bfs(i,j+1)\n    for k in range(-2,3):\n        for l in range(-2,3):\n            if 0<=i+k<h and 0<=j+l<w:\n                if dp[i+k][j+l]>dp[i][j]+1:\n                    dp[i+k][j+l]=dp[i][j]+1\n                    bfs(i+k,j+l)\n\nbfs(c[0],c[1])\nprint(dp[d[0]][d[1]] if dp[d[0]][d[1]]!=inf else -1)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":185,"bad_solution":"#import decimal\n#decimal.getcontext().prec==500 Floatの桁数を500まで増やす\n#Decimal(c).sqrt() それで平方根を求める\n#Decimal(1) \/ Decimal(7) 1\/7\n\nfrom collections import *\nfrom itertools import *\nfrom bisect import *\nfrom heapq import *\nimport copy\nimport math\nfrom fractions import gcd\nimport sys\n#input = sys.stdin.readline\n\nN,M=map(int,input().split())\nA=list(map(int,input().split()))\n\ndata=[]\nfor i,a in enumerate([2,5,5,4,5,6,3,7,6]):\n    if i+1 in A:\n        data.append([a,i+1])\n\ndic={}\nfor a,i in reversed(data):\n    dic[i]=0\ndp=[copy.copy(dic) for i in range(N+1)]\n\ndef main(dic1,dic2):\n    for a,b in zip(dic1,dic2):\n        if dic1[a]>dic2[b]:\n            return(0)\n        if dic1[a]<dic2[b]:\n            return(1)\n    return(0)\n\ndef _sum(dic):\n    count=0\n    for i in dic:\n        count+=dic[i]\n    return(count)\n\n\nfor a,n in data:\n    tempdic=copy.copy(dic)\n    tempdic[n]+=1\n    flag=main(dp[a],tempdic)\n    if flag:\n        dp[a]=tempdic\n    for i in range(len(dp)):\n        if i>=a and _sum(dp[i-a]):\n            if _sum(dp[i])<_sum(dp[i-a])+1:\n\n                tempdic=copy.copy(dp[i-a])\n                tempdic[n]+=1\n                dp[i]=tempdic\n            elif _sum(dp[i])==_sum(dp[i-a])+1:\n                dp[i-a][n]+=1\n                flag=main(dp[i],dp[i-a])\n                dp[i-a][n]-=1\n                if flag:\n                    tempdic=copy.copy(dp[i-a])\n                    tempdic[n]+=1\n                    dp[i]=tempdic\ndic=dp[N]\na=\"\"\nfor i in dic:\n    s=str(i)\n    for m in range(dic[i]):\n        a+=s\nprint(a)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":186,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\nimport copy\nfrom collections import defaultdict,deque\n\nN=input()\nA=[[]]+[ map(int, sys.stdin.readline().split()) for _ in range(N) ]\nC=defaultdict(lambda: 0)\n\nNow=[ 0 for _ in range(N+1)]\ngame=set()\nnext_game=set()\n\nfor i in range(1,N+1):\n\ta=i\n\tb=A[i][0]\n\tif a>b: a,b=b,a\n\tnext_game.add((a,b))\n\nday=1\n\ngame=next_game\n\n#for _ in range(5):\nwhile game:\n\tnext_game=set()\n\n\tfor x,y in game:\n\t\tnow_x=Now[x]\n\t\tnow_y=Now[y]\n\n\t\txopp=A[x][now_x]\n\t\tyopp=A[y][now_y]\n\n\t\tif (x,y)==(yopp,xopp):\n\t\t\tif now_x<N-2:\n\t\t\t\tnow_x+=1\n\t\t\t\tNow[x]=now_x\n\t\t\t\tx_nextopp=A[x][now_x]\n\t\t\t\tif x_nextopp<x: x,x_nextopp=x_nextopp,x\n\t\t\t\tnext_game.add((x,x_nextopp))\n\n\t\t\tif now_y<N-2:\n\t\t\t\tnow_y+=1\n\t\t\t\tNow[y]=now_y\n\t\t\t\ty_nextopp=A[y][now_y]\n\t\t\t\tif y_nextopp<y: y,y_nextopp=y_nextopp,y\n\t\t\t\tnext_game.add((y,y_nextopp))\n\tgame=next_game\n\tday+=1\n\n\nfor i in range(1,N+1):\n\tif Now[i] != N-2:\n\t\tprint -1\n\t\tquit()\nelse:\n\tprint day\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":187,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\nimport math\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nimport collections\nimport copy\nimport heapq\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nimport itertools\ninput = sys.stdin.readline\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nfrom decimal import *\n\n##### リストの 二分木検索 #####\n# bisect_left(lists, 3)\n# bisect_right(lists, 3)\n\n##### プライオリティキュー #####\n# heapq.heapify(a) #リストaのheap化\n# heapq.heappush(a,x) #heap化されたリストaに要素xを追加\n# heapq.heappop(a) #heap化されたリストaから最小値を削除＆その最小値を出力\n\n# heapq.heappush(a, -x) #最大値を取り出す時は、pushする時にマイナスにして入れよう\n# heapq.heappop(a) * (-1) #取り出す時は、-1を掛けて取り出すこと\n\n##### タプルリストのソート #####\n# sorted(ans) #(a, b) -> 1st : aの昇順, 2nd : bの昇順\n# sorted(SP, key=lambda x:(x[0],-x[1])) #(a, b) -> 1st : aの昇順, 2nd : bの降順\n# sorted(SP, key=lambda x:(-x[0],x[1])) #(a, b) -> 1st : aの降順, 2nd : bの昇順\n# sorted(SP, key=lambda x:(-x[0],-x[1])) #(a, b) -> 1st : aの降順, 2nd : bの降順\n\n# sorted(SP, key=lambda x:(x[1])) #(a, b) -> 1st : bの昇順\n# sorted(SP, key=lambda x:(-x[1])) #(a, b) -> 1st : bの降順\n\n##### 累乗 #####\n# pow(x, y, z) -> x**y % z\n\n##### 割り算の切り上げ #####\n# tmp = -(-4 \/\/ 3)\n\n##### dict の for文 #####\n# for k, v in d.items():\n#     print(k, v)\n\n##### 進数の変換 #####\n# bin_str = bin(i)[2:]\n# oct_str = oct(i)[2:]\n# hex_str = hex(i)[2:]\n\ndef inputInt(): return int(input())\ndef inputMap(): return map(int, input().split())\ndef inputList(): return list(map(int, input().split()))\ndef inputStr(): return input()[:-1]\n\ninf = float('inf')\nmod = 1000000007\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\ndef main():\n\tA,B  = map(float, input().split())\n\n\tans = A*B\n\n\tprint(int(ans))\n\n\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\nif __name__ == \"__main__\":\n\tmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":188,"bad_solution":"import sys\nfrom collections import deque\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    h, w = map(int, input().split())\n    Ch, Cw = map(int, input().split())\n    Dh, Dw = map(int, input().split())\n    Ch -= 1\n    Cw -= 1\n    Dh -= 1\n    Dw -= 1\n    s2 = [list(input()) for i in range(h)]\n    s2[Ch][Cw] = 0\n    d = deque()\n    d.append([Ch, Cw])\n    while d:\n        nowh, noww = d.popleft()\n        for i, j in [[0, 1], [1, 0], [0, -1], [-1, 0]]:\n            if ((0 <= nowh+i < h) and (0 <= noww+j < w)):\n                if s2[nowh+i][noww+j] == '.':\n                    s2[nowh+i][noww+j] = s2[nowh][noww]\n                    d.appendleft([nowh+i, nowh+j])\n                elif s2[nowh+i][noww+j] != '#':\n                    if s2[nowh+i][noww+j] > s2[nowh][noww]:\n                        s2[nowh+i][noww+j] = s2[nowh][noww]\n                        d.append([nowh+i, noww+j])\n        for i,j in [[-2,-2],[-2,-1],[-2,0],[-2,1],[-2,2],[-1,-2],[-1,-1],[-1,1],[-1,2],[0,-2],[0,2],[1,-2],[1,-1],[1,1],[1,2],[2,-2],[2,-1],[2,0],[2,1],[2,2]]:\n            if ((0 <= nowh+i < h) and (0 <= noww+j < w)):\n                if s2[nowh+i][noww+j] == '.':\n                    s2[nowh+i][noww+j] = s2[nowh][noww]+1\n                    d.append([nowh+i, noww+j])\n                elif s2[nowh+i][noww+j] != '#':\n                    if s2[nowh+i][noww+j] > s2[nowh][noww]+1:\n                        s2[nowh+i][noww+j] = s2[nowh][noww]+1\n                        d.append([nowh+i, noww+j])\n\n    if s2[Dh][Dw] == '.':\n        print(-1)\n    else:\n        print(s2[Dh][Dw])\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":189,"bad_solution":"import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\n\ndef main():\n    import queue\n    mod=10**9+7\n    N,M,S=MI()\n    #各頂点，所持金が０〜N*50までなので，状態すうはN*(N*50+1)\n    #頂点iでj枚ならi*(N*50+1)+j\n    NN=N*50+1\n    ##########################################\n    import heapq\n    class Dijkstra():\n        \"\"\"\n        ・有向 \/ 無向は問わない(無向の場合は，逆向きの辺もたす)\n        ・負のコストがない場合のみ\n        ・計算量はO(E log|V|)　\n        ・heapを使うことで頂点を走査する必要がなくなる（代わりに，距離更新したものは確定でなくともqueに入れておく）\n        \"\"\"\n        \n        #最短のpathをたす\n        \n        \n        class Edge():\n            #重み付き有向辺\n            \n            def __init__(self, _to, _cost):\n                self.to =_to\n                self.cost = _cost\n        \n        def __init__(self, V):\n            #引数Vは頂点数\n            self.G = [[] for _ in range(V)] #隣接リストG[u][i]が頂点uのi番目の辺\n            self. _E = 0 #辺の数\n            self._V = V #頂点数\n        \n        #proparty - 辺の数\n        def E(self):\n            return self._E\n        \n        #proparty - 頂点数\n        def V(self):\n            return self._V\n        \n        def add(self, _from, _to, _cost):\n            #2頂点と辺のコストを追加\n            self.G[_from].append(self.Edge(_to,_cost))\n            self._E +=1\n            \n        def add2(self, _from, _to, _cost):\n            #2頂点と辺のコスト（無向）を追加\n            self.G[_from].append(self.Edge(_to, _cost))\n            self.G[_to].append(self.Edge(_from, _cost))\n            self._E +=2\n            \n        def shortest_path(self,s):#,g):\n            #始点sから頂点iまでの最短経路長のリストを返す\n            \n            que = [] #priority queue\n            d = [float(\"inf\")] * self.V()\n            prev = [None]*self.V() #prev[j]は，sからjへ最短経路で行くときのjの一つ前の場所\n            d[s] = 0\n            heapq.heappush(que,(0,s)) #始点の距離と頂点番号をヒープに追加\n            \n            while len(que)!=0:\n                #キューに格納されてある中で一番コストが小さい頂点を取り出す\n                cost,v = heapq.heappop(que)\n                \n                #キューに格納された最短経路長候補がdの距離よりも大きい場合に処理をスキップ\n                if d[v] < cost:\n                    continue\n                    \n                #頂点vに隣接する各頂点iに対して，vを経由した場合の距離を計算して，これがd[i]よりも小さい場合に更新\n                for i in range(len(self.G[v])):\n                    e = self.G[v][i] #vのi個目の隣接辺\n                    if d[e.to] > d[v] + e.cost:\n                        d[e.to] = d[v] + e.cost #更新\n                        prev[e.to] = v\n                        heapq.heappush(que,(d[e.to],e.to)) #queに新たな最短経路長候補を追加\n            \n            \"\"\"#sからgまでの最短経路\n            path = []\n            pos = g #今いる場所，ゴールで初期化\n            for _ in range(self.V()+1):\n                path.append(pos)\n                if pos == s:\n                    break\n                #print(\"pos:\",format(pos))\n                pos = prev[pos]\n            path.reverse()\n            #print(path)\"\"\"\n                        \n            return d#,path\n    ########################\n    djk=Dijkstra(N*NN)\n    \n    for i in range(M):\n        u,v,a,b=MI()\n        u-=1\n        v-=1\n        for j in range(a,NN):\n            djk.add(u*NN+j,v*NN+j-a,b)\n            djk.add(v*NN+j,u*NN+j-a,b)\n    for i in range(N):\n        c,d=MI()\n        for j in range(0,NN-c,1):\n            djk.add(i*NN+j,i*NN+j+c,d)\n            \n    dL=djk.shortest_path(min(S,NN-1))\n    for i in range(1,N):\n        ans=10**10\n        for j in range(0,NN):\n            ans=min(ans,dL[i*NN+j])\n        print(ans)\n        \n        \n    \n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":190,"bad_solution":"def halfsplitsearch(list,start,end,minmax):\n    if minmax=='min':\n        while end-start>1:\n            test=(end+start)\/\/2\n            if condition(list[test][0]):\n                end=test\n            else:\n                start=test\n        if condition(list[start][0]):\n            return start\n        else:\n            return end\n    else:\n        while end-start>1:\n            test=(end+start)\/\/2\n            if condition(list[test][0]):\n                start=test\n            else:\n                end=test\n        if condition(list[end][0]):\n            return end\n        else:\n            return start\n\nimport sys\n\ninput=sys.stdin.readline\n\nA,B,Q=map(int,input().split())\ns=[[] for i in range(0,A)]\nfor i in range(0,A):\n    y=int(input())\n    s[i]=[y,'s']\nt=[[] for i in range(0,B)]\nfor i in range(0,B):\n    y=int(input())\n    t[i]=[y,'t']\nx=[0 for i in range(0,Q)]\nfor i in range(0,Q):\n    x[i]=int(input())\n\nlist=s+t\nlist.sort()\ns.sort()\nt.sort()\n\nfor i in range(0,Q):\n    a=0\n    b=0\n    test1=10**100\n    test2=10**100\n    def condition(num):\n        return num<x[i]\n    a=halfsplitsearch(list,0,len(list)-1,'max')\n    if list[a][1]=='s':\n        def condition(num):\n            return num<list[a][0]\n        b=halfsplitsearch(t,0,len(t)-1,'max')\n        if b!=len(t)-1:\n            test1=abs(x[i]-list[a][0])+min(abs(t[b][0]-list[a][0]),abs(t[b+1][0]-list[a][0]))\n        else:\n            test1=abs(x[i]-list[a][0])+abs(t[b][0]-list[a][0])\n    else:\n        def condition(num):\n            return num<list[a][0]\n        b=halfsplitsearch(s,0,len(s)-1,'max')\n        if b!=len(s)-1:\n            test1=abs(x[i]-list[a][0])+min(abs(s[b][0]-list[a][0]),abs(s[b+1][0]-list[a][0]))\n        else:\n            test1=abs(x[i]-list[a][0])+abs(s[b][0]-list[a][0])\n    if a!=len(list)-1:\n        if list[a+1][1]=='s':\n            def condition(num):\n                return num<list[a+1][0]\n            b=halfsplitsearch(t,0,len(t)-1,'max')\n            if b!=len(t)-1:\n                test2=abs(x[i]-list[a+1][0])+min(abs(t[b][0]-list[a+1][0]),abs(t[b+1][0]-list[a+1][0]))\n            else:\n                test2=abs(x[i]-list[a+1][0])+abs(t[b][0]-list[a+1][0])\n        else:\n            def condition(num):\n                return num<list[a+1][0]\n            b=halfsplitsearch(s,0,len(s)-1,'max')\n            if b!=len(s)-1:\n                test2=abs(x[i]-list[a+1][0])+min(abs(s[b][0]-list[a+1][0]),abs(s[b+1][0]-list[a+1][0]))\n            else:\n                test2=abs(x[i]-list[a+1][0])+abs(s[b][0]-list[a+1][0])\n    print(min(test1,test2))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":191,"bad_solution":"import bisect\nimport heapq\nimport itertools\nimport math\nfrom collections import Counter, defaultdict, deque\nfrom copy import deepcopy\nfrom decimal import Decimal\nfrom math import gcd\nfrom operator import add, itemgetter, mul, xor\ndef cmb(n,r,mod):\n  bunshi=1\n  bunbo=1\n  for i in range(r):\n    bunbo = bunbo*(i+1)%mod\n    bunshi = bunshi*(n-i)%mod\n  return (bunshi*pow(bunbo,mod-2,mod))%mod\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\ndef I(): return int(input())\ndef LI(): return list(map(int,input().split()))\ndef MI(): return map(int,input().split())\ndef LLI(n): return [list(map(int, input().split())) for _ in range(n)]\n\nn,m,x = MI()\na = []\nc = []\nfor i in range(n):\n  dd = LI()\n  c.append(dd[0])\n  dd = dd[1:]\n  a.append(dd)\n\n\nINF = 1e14\nans = INF\nfor iters in range(1,n+1):\n  xx = list(itertools.combinations(range(n), iters))\n  for u in xx:\n    bad = False\n    score = [0] * m\n    money = 0\n    for i in u:\n      money += c[i]\n      for j in range(m):\n        score[j] += a[i][j]\n\n    for j in range(m):\n      if score[j] < x:\n        bad = True\n        break\n    # print(u, money, score)\n    if not bad:\n      ans = min(money, ans)\n\n  if ans < INF:\n    break\n    \nif ans == INF:\n  print(-1)\nelse:\n  print(ans)\n\n    \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":192,"bad_solution":"n = int(input())\ns = input()\n\n\ndef arihon_SA(T):\n    rank = [0] * (n + 1)\n    SA = [0] * (n + 1)\n    temp = [0] * (n + 1)\n\n    def rank_calc(i):\n        res1 = rank[i]\n        res2 = -1\n        if i + k <= n:\n            res2 = rank[i + k]\n        return (res1, res2)\n\n    for i in range(n + 1):\n        SA[i] = i\n        if i < n:\n            rank[i] = ord(T[i])\n        else:\n            rank[i] = -1\n    k = 1\n\n    while k <= n:\n        SA.sort(key=rank_calc)\n        temp[SA[0]] = 0\n        for i in range(1, n + 1):\n            temp[SA[i]] = temp[SA[i - 1]]\n            if rank_calc(SA[i - 1]) < rank_calc(SA[i]):\n                temp[SA[i]] += 1\n        rank = temp[::]\n        k *= 2\n\n    return SA\n\n\ndef arihon_LCP(s, SA):\n    num = len(s)\n    rank = [0] * (num + 1)\n    LCP = [-1] * (num)\n    for i in range(num + 1):\n        rank[SA[i]] = i\n    h = 0\n    LCP[0] = 0\n    for i in range(num):\n        j = SA[rank[i] - 1]\n        if h > 0:\n            h -= 1\n        while j + h < num and i + h < num:\n            if s[j + h] != s[i + h]:\n                break\n            else:\n                h += 1\n        LCP[rank[i] - 1] = h\n    return LCP\n\n\nclass SegmentTree:\n    ele = 10 ** 20\n    func = min\n    # SEG木は1-index\n    # Aに関しては0-index\n\n    def __init__(self, n):  # Aは0-idx\n        self.n = n\n        self.num = 2 ** ((self.n - 1).bit_length())\n        self.SEG = [self.ele] * (2 * self.num)\n\n    def search(self, idx):\n        return self.SEG[idx + self.num]\n\n    def initialize(self, A):\n        for i in range(self.n):\n            self.SEG[i + self.num] = A[i]\n        for i in range(self.num - 1, 0, -1):\n            self.SEG[i] = self.func(self.SEG[2 * i], self.SEG[2 * i + 1])\n\n    def update(self, idx, val):\n        idx += self.num\n        self.SEG[idx] = val\n        idx \/\/= 2\n        while idx:\n            self.SEG[idx] = self.func(self.SEG[2 * idx], self.SEG[2 * idx + 1])\n            idx \/\/= 2\n\n    def query(self, left, right):\n        # maspy式。開区間のママ処理する\n        # left, rightで値を分けているのは交換法則不成立のときのため\n        # 開区間→Rが奇数→右端が偶数→1ずらしてから計算\n        # 　下から上への遷移は2で割る\n        # juppy氏は閉区間に直していた\n        resleft = self.ele\n        resright = self.ele\n        left += self.num\n        right += self.num\n        while right - left > 0:\n            if left % 2 == 1:\n                resleft = self.func(resleft, self.SEG[left])\n                left += 1\n            if right % 2 == 1:\n                right -= 1\n                resright = self.func(resright, self.SEG[right])\n            left \/\/= 2\n            right \/\/= 2\n        return self.func(resleft, resright)\n\n\nSA = arihon_SA(s)\nLCP = arihon_LCP(s, SA)\n# ST = SegmentTree(n)\n# ST.initialize(SA)\n# ans = 0\n# for i in range(n + 1):\n#     for j in range(i + 1, n + 1):\n#         temp = ST.query(i, j)\n#         if j - i >= temp:\n#             ans = max(ans, temp)\n# print(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":193,"bad_solution":"MOD = 10**9+7\n\nk = int(input())\ns = input()\nMAX = k + len(s)\n\nfactorial = [0] * (MAX + 1)\nfactorial[0] = 1\nfor i in range(1, MAX + 1):\n    factorial[i] = factorial[i-1] * i\n    factorial[i] %= MOD\n\n\nifactorial = [0] * (MAX + 1)\nifactorial[MAX] = pow(factorial[MAX], MOD - 2, MOD)\nfor i in range(MAX, 0, -1):\n    ifactorial[i - 1] = ifactorial[i] * i\n    ifactorial[i - 1] %= MOD\n\npow25 = [1] * (k + 1)\npow26 = [1] * (k + 1)\nfor i in range(k):\n    pow25[i + 1] = pow25[i] * 25\n    pow25[i + 1] %= MOD\n    pow26[i + 1] = pow26[i] * 26\n    pow26[i + 1] %= MOD\n\n\ndef combination(n, k):\n    ret = factorial[n] * ifactorial[k] * ifactorial[n - k]\n    return ret % MOD\n\n\nans = 0\nfor i in range(k + 1):\n    tmp = combination(i + len(s) - 1, len(s) - 1)\n    tmp *= pow25[i]\n    # tmp *= pow(25, i, MOD)\n    tmp *= pow26[k - i]\n    # tmp *= pow(26, k - i, MOD)\n    tmp %= MOD\n    ans += tmp\n    ans %= MOD\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":194,"bad_solution":"def i1():\n return int(input())\ndef i2():\n return [int(i) for i in input().split()]\nimport bisect\nmod=998244353\nn=i1()\nd=[]\nN=1<<(n.bit_length())\nt=[-1 for i in range(2*N-1)]\n\ndef ud(i,x):\n  i+=N-1\n  t[i]=x\n  while i:\n    i-=1\n    i>>=1\n    j=i+0\n    j<<=1\n    t[i]=max(t[j+1],t[j+2]) \n     \n\ndef qr(a,b):\n    a+=N-1\n    b+=N-1\n    L = -1\n    R = -1\n    while a < b:\n      if a&1==0:\n         L = max(L, t[a])\n      if b&1==0:\n         b-=1\n         R = max(t[b], R)\n      \n      a>>=1\n      b>>=1\n      \n         \n    return max(L, R)\n \nfor i in range(n):\n  d.append(i2())\nd=sorted(d)\ndx=[]\ndd=[]\nfor i,j in d:\n  dx.append(i)\n  dd.append(j)\nfor i in range(n)[::-1]:\n j=bisect.bisect_left(dx,dx[i]+dd[i])\n tt=qr(i,j)\n ud(i,max(j-1,tt))\ndp=[0 for i in range(n+1)]\ndp[-1]=1\nfor i in range(n)[::-1]:\n  dp[i]+=dp[i+1]\n  dp[i]+=dp[t[i+N-1]+1]\n  dp[i]%=mod\nprint(dp[0])\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":195,"bad_solution":"from sys import setrecursionlimit; setrecursionlimit(10**9)\nN = int(input())\n\ndef factorize(n):\n    # NOTE: if n == 1, return []\n    if n < 1:\n        raise Exception('Invalid input: n = {}'.format(n))\n    i = 2\n    ret = []\n    while i * i <= n:\n        while n % i == 0:\n            n \/\/= i\n            ret.append(i)\n        i += 1\n    if n > 1:\n        ret.append(n)\n    return ret\n\nA = factorize(N)\nl = len(A)\n\ndef res(i, B, C):\n    if i >= l:\n        val = 1\n        for b in B:\n            val *= b\n        C.append(max(len(str(val)), len(str(N\/\/val))))\n        return None\n    B.append(A[i])\n    res(i+1, B, C)\n    B.pop()\n    res(i+1, B, C)\n    return C\n\nC = res(0, [], [])\nprint(min(C))\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":196,"bad_solution":"def getN():\n    return int(input())\ndef getNM():\n    return map(int, input().split())\ndef getList():\n    return list(map(int, input().split()))\n\nfrom collections import defaultdict, deque\nfrom sys import exit\nimport math\nimport copy\nfrom bisect import bisect_left, bisect_right\nfrom heapq import *\nimport sys\n# sys.setrecursionlimit(1000000)\nINF = 10 ** 17\nMOD = 1000000007\n\nfrom fractions import *\ndef inverse(f):\n    # return Fraction(f.denominator,f.numerator)\n    return 1\/f\n\n\ndef combmod(n, k, mod=MOD):\n    ret = 1\n    for i in range(n - k + 1, n + 1):\n        ret *= i\n        ret %= mod\n\n    for i in range(1, k + 1):\n        ret *= pow(i, mod - 2, mod)\n        ret %= mod\n\n    return ret\ndef bunsu(n):\n    ret = []\n    for i in range(2, int(math.sqrt(n)) + 1):\n        if n % i == 0:\n            tmp = 0\n            while(True):\n                if n % i == 0:\n                    tmp += 1\n                    n \/\/= i\n                else:\n                    break\n            ret.append((i, tmp))\n\n    ret.append((n, 1))\n    return ret\n\ndef solve():\n    a, b = list(map(float, input().split()))\n    ans = (((a*100) * (b*100))\/\/10000)\n    print(str(ans)[:-2])\ndef main():\n    # n = getN()\n    # for _ in range(n):\n    solve()\nif __name__ == \"__main__\":\n    solve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":197,"bad_solution":"\n\ndef FUNC(string: str) -> str:\n    \"\"\" For a given string, flip lowercase characters to uppercase and uppercase to lowercase.\n    >>> FUNC('Hello')\n    'hELLO'\n    \"\"\"\n    return string.lower()\n"}
{"id":198,"bad_solution":"import sys\nfrom collections import deque\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    H, W = map(int, input().split())\n    ch, cw = map(int, input().split())\n    dh, dw = map(int, input().split())\n    S = [list(map(str, input())) for _ in range(H)]\n\n    q = deque()\n    q.append((ch - 1, cw - 1, 0))\n\n    pathA = set([(1, 0), (0, 1), (-1, 0), (0, -1)])\n    pathB = set()\n    for i in range(5):\n        for j in range(5):\n            pathB.add((i - 2, j - 2))\n\n    pathB = pathB - pathA - set((0, 0))\n\n    visited = [[-1] * W for _ in range(H)]\n\n    while q:\n        h, w, d = q.popleft()\n        if visited[h][w] != -1:\n            continue\n        visited[h][w] = d\n\n        for h1, w1 in pathA:\n            newh = h + h1\n            neww = w + w1\n            if newh >= 0 and newh < H and neww >= 0 and neww < W and S[newh][neww] == \".\":\n                if visited[newh][neww] == -1:\n                    q.appendleft((newh, neww, d))\n\n                if newh ==dh-1 and newh ==dw-1:\n                    print(d)\n                    exit()\n\n        for h1, w1 in pathB:\n            newh = h + h1\n            neww = w + w1\n            if newh >= 0 and newh < H and neww >= 0 and neww < W and S[newh][neww] == \".\":\n                q.append((newh, neww, d + 1))\n\n    print(visited[dh - 1][dw - 1])\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":199,"bad_solution":"n, k = map(int, input().split())\nedges = []\nfor _ in range(n-1):\n  edges.append(list(map(int, input().split())))\n\n\nmod = 10**9+7\nedge_dict = {}\nfor i in range(1, n+1):\n  edge_dict[i] = set()\n\nfor edge in edges:\n  edge_dict[edge[0]].add(edge[1])\n  edge_dict[edge[1]].add(edge[0])\n\nvisited = set()\n\ndef visit(node, parent):\n  num_children = len(edge_dict[node])\n  num_available_colors = k-2 if parent is not None else k-1\n  \n  if k < num_children:\n    return 0\n  \n  ans = 1\n  for child in edge_dict[node]:\n    if child is parent:\n      continue\n    \n    ans *= num_available_colors\n    num_available_colors -= 1\n    ans %= mod\n  \n  for child in edge_dict[node]:\n    if child is parent:\n      continue\n    \n    ans *= visit(child, node)\n    ans %= mod\n  \n  return ans\n\nprint((k*visit(1, None))%mod)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":200,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nn,d,a = map(int,input().split())\nxh = [list(map(int,input().split())) for _ in range(n)]\n\nxh.sort()\n\nclass Bit:\n    def __init__(self, n):\n        self.size = n\n        self.tree = [0]*(n+1)\n        self.depth = n.bit_length()\n\n    def __iter__(self):\n        psum = 0\n        for i in range(self.size):\n            csum = self.sum(i+1)\n            yield csum - psum\n            psum = csum\n        raise StopIteration()\n\n    def __str__(self):  # O(nlogn)\n        return str(list(self))\n\n    def sum(self, i):\n        # [0, i) の要素の総和を返す\n        if not (0 <= i <= self.size): raise ValueError(\"error!\")\n        s = 0\n        while i>0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        if not (0 <= i < self.size): raise ValueError(\"error!\")\n        i += 1\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    def lower_bound(self, x):\n        \"\"\" 累積和がx以上になる最小のindexと、その直前までの累積和 \"\"\"\n        sum_ = 0\n        pos = 0\n        for i in range(self.depth, -1, -1):\n            k = pos + (1 << i)\n            if k <= self.size and sum_ + self.tree[k] < x:\n                sum_ += self.tree[k]\n                pos += 1 << i\n        return pos + 1, sum_\n\n    def __getitem__(self, key):\n        if not (0 <= key < self.size): raise IndexError(\"error!\")\n        return self.sum(key+1) - self.sum(key)\n\n    def __setitem__(self, key, value):\n        # 足し算と引き算にはaddを使うべき\n        if not (0 <= key < self.size): raise IndexError(\"error!\")\n        self.add(key, value - self[key])\n\nclass BitImos:\n    \"\"\"\n    ・範囲すべての要素に加算\n    ・ひとつの値を取得\n    の2種類のクエリをO(logn)で処理\n    \"\"\"\n    def __init__(self, n):\n        self.bit = Bit(n+1)\n\n    def add(self, s, t, x):\n        # [s, t)にxを加算\n        self.bit.add(s, x)\n        self.bit.add(t, -x)\n\n    def get(self, i):\n        return self[i]\n\n    def __getitem__(self, key):\n        # 位置iの値を取得\n        return self.bit.sum(key+1)\n\nbit = BitImos(n)\nans = 0\natt = [0]*n\ncnt = 0\n\nfor i in range(n):\n    tmp = xh[i][0] + 2 * d\n    while cnt < n:\n        if xh[cnt][0] < tmp:\n            cnt += 1\n        else:\n            break\n    att[i] = min(cnt, n-1)\n\nfor i,xh1 in enumerate(xh):\n    x,h = xh1\n    if bit.get(i) < h:\n        at = -(-(h - bit.get(i)) \/\/ a)\n        ans += at\n        bit.add(i, att[i]+1, at*a)\n\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":201,"bad_solution":"\"\"\"\nimport random\nimport functools\nimport copy\nimport bisect\nimport array\nimport re\nimport collections\nimport heapq\nimport fractions\nimport itertools\nimport string\nimport math\nfrom operator import itemgetter as ig\nfrom bisect import bisect_left, bisect_right, insort_left, insort_right\nfrom itertools import permutations, combinations, product, accumulate, groupby\nfrom heapq import heappush, heappop\nfrom collections import deque, defaultdict, Counter\nimport sys\nsys.setrecursionlimit(10 ** 7)\n# import numpy as np\n\ninf = 10 ** 20\nINF = float(\"INF\")\nmod = 10 ** 9 + 7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = dd + [(-1, 1), (1, 1), (1, -1), (-1, -1)]\nddn9 = ddn + [(0, 0)]\n'''for dx, dy in dd:\n        nx = j + dx; ny = i + dy\n            if 0 <= nx < w and 0 <= ny < h:'''\n\"\"\"\nfrom operator import itemgetter\nfrom collections import defaultdict\nimport sys\nimport math\nsys.setrecursionlimit(10 ** 7)\n\n\ndef wi(): return list(map(int, sys.stdin.readline().split()))\n# WideIntPoint\n\n\ndef wip(): return [int(x) - 1 for x in sys.stdin.readline().split()]\n\n\ndef ws(): return sys.stdin.readline().split()\n\n\ndef si(): return int(sys.stdin.readline())  # SingleInt\n\n\ndef ss(): return input()\n\n\ndef hi(n): return [si() for _ in range(n)]\n\n\ndef hs(n): return [ss() for _ in range(n)]  # HeightString\n\n\ndef s_list(): return list(input())\n\n\ndef mi(n): return [wi() for _ in range(n)]  # MatrixInt\n\n\ndef mip(n): return [wip() for _ in range(n)]\n\n\ndef ms(n): return [ws() for _ in range(n)]\n\n\ndef num_grid(n): return [[int(i) for i in sys.stdin.readline().split()[\n    0]] for _ in range(n)]  # NumberGrid\n\n\ndef grid(n): return [s_list() for _ in range(n)]\n\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n# a\/b の切り上げ\n\n\ndef round_up(a, b):\n    \"\"\" a\/b の切り上げ \"\"\"\n    c = (a + b - 1) \/ b\n    return c\n\n\ndef lcm(a, b):\n    \"\"\"a,bの最小公倍数\"\"\"\n    return a * b \/\/ gcd(a, b)\n\n\ndef main():\n    a, b, n = wi()\n    print(int(a*(b-1)\/b) - a*int((b-1)\/b))\n    \"\"\"\n    for i in range(1, b+1):\n        print(int(a*i\/b) - a*int(i\/b))\n        c.append(int(a*i\/b) - a*int(i\/b))\n        if i >= b:\n            break\n    print(max(c))\n    \"\"\"\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":202,"bad_solution":"n, k = list(map(int, input().split()))\naaa = list(map(int, input().split()))\n\nif n == 1:\n    print(*(aaa * (k % 2)))\n    exit()\n\nfollow = [-1] * n\ntmp = {}\nfix = 0\nwhile True:\n    for i in range(n):\n        a = aaa[i]\n        if a in tmp:\n            follow[tmp[a]] = (i + 1) % n\n            tmp[a] = i\n            fix += 1\n        else:\n            tmp[a] = i\n    if fix >= n:\n        break\n# print(follow)\nloop = 0\ni = 0\nwhile True:\n    j = follow[i]\n    if i + 1 >= j:\n        loop += 1\n    # print(i, j, loop)\n    if j == 0:\n        break\n    i = j\n\nk %= loop\nif k == 0:\n    print()\n    exit()\n\n\ndef simulate(aaa, s, follow):\n    tmp = []\n    exs = set()\n    for a in aaa[s:]:\n        if a in exs:\n            while True:\n                b = tmp.pop()\n                exs.remove(b)\n                if a == b:\n                    break\n        else:\n            tmp.append(a)\n            exs.add(a)\n\n    # i = s\n    # while i != 0:\n    #     j = follow[i]\n    #     if j == 0:\n    #         if i == n - 1:\n    #             tmp.append(aaa[i])\n    #         break\n    #     elif i + 1 >= j:\n    #         tmp.append(aaa[i])\n    #         i = (i + 1) % n\n    #     else:\n    #         i = j\n    return tmp\n\n\ni = 0\nloop = 1\nwhile loop <= k:\n    j = follow[i]\n    if i + 1 >= j:\n        if loop == k:\n            print(*simulate(aaa, i, follow))\n            break\n        loop += 1\n    i = j\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":203,"bad_solution":"import sys\nsys.setrecursionlimit(10**6)\nfrom math import floor,ceil,sqrt,factorial,log\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,permutations,combinations,product,combinations_with_replacement\nfrom bisect import bisect_left,bisect_right\nfrom copy import deepcopy\nfrom operator import itemgetter\nfrom fractions import gcd\nmod = 10 ** 9 + 7\ninf = float('inf')\nninf = -float('inf')\n \n#整数input\ndef ii(): return int(sys.stdin.readline().rstrip()) #int(input())\ndef mii(): return map(int,sys.stdin.readline().rstrip().split())\ndef limii(): return list(mii()) #list(map(int,input().split()))\ndef lin(n:int): return [ii() for _ in range(n)]\ndef llint(n: int): return [limii() for _ in range(n)]\n#文字列input\ndef ss(): return sys.stdin.readline().rstrip() #input()\ndef mss(): return sys.stdin.readline().rstrip().split()\ndef limss(): return list(mss()) #list(input().split())\ndef lst(n:int): return [ss() for _ in range(n)]\ndef llstr(n: int): return [limss() for _ in range(n)]\n\n#本当に貪欲法か？ DP法では？？\n#本当に貪欲法か？ DP法では？？\n#本当に貪欲法か？ DP法では？？\n\na,b,c,d=mii()\nc,d=min(c,d),max(c,d)\n\nnum = b-a+1\n\nac = (a-1)\/\/c\nbc = b\/\/c \n\nad = (a-1)\/\/d\nbd = b\/\/d\n\ncd = b \/\/((c*d)\/\/gcd(c,d))\n\nprint(num-(bc+bd-ac-ad)+cd)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":204,"bad_solution":"from typing import List\n\n\ndef FUNC(strings: List[str]) -> str:\n    \"\"\" Concatenate list of strings into a single string\n    >>> FUNC([])\n    ''\n    >>> FUNC(['a', 'b', 'c'])\n    'abc'\n    \"\"\"\n    return ' '.join(strings)\n"}
{"id":205,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\ndef main():\n  h,w=LI()\n  s=[S() for _ in range(h)]\n\n  L=[[0 for _ in range(w)]for __ in range(h)]\n  R=[[0 for _ in range(w)]for __ in range(h)]\n  D=[[0 for _ in range(w)]for __ in range(h)]\n  U=[[0 for _ in range(w)]for __ in range(h)]\n\n  for i in range(h):\n    for j in range(w):\n      if s[i][j]=='#':\n        L[i][j]=0\n        U[i][j]=0\n        continue\n      else:\n        if i==0:\n          U[i][j]=1\n  \n        if j==0:\n          L[i][j]=1\n  \n        if i!=0 and j!=0:\n          L[i][j]=L[i][j-1]+1\n          U[i][j]=U[i-1][j]+1\n\n  for i in range(h)[::-1]:\n    for j in range(w)[::-1]:\n      if s[i][j]=='#':\n        R[i][j]=0\n        D[i][j]=0\n        continue\n      else:\n        if i==h-1:\n          D[i][j]=1\n  \n        if j==w-1:\n          R[i][j]=1\n  \n        if i!=h-1 and j!=w-1:\n          R[i][j]=R[i][j+1]+1\n          D[i][j]=D[i+1][j]+1\n\n  ans=0\n  for i in range(h):\n    for j in range(w):\n      ans=max(ans,R[i][j]+L[i][j]+U[i][j]+D[i][j]-3)\n\n  return ans\n\n# main()\nprint(main())\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":206,"bad_solution":"from collections import deque\nfrom sys import stdin\nh,w =map(int, stdin.readline().split())\nch,cw = map(int, stdin.readline().split())\ndh,dw =map(int, stdin.readline().split())\n\ng = []\nfor i in range(h):\n  s = list(input())\n  g.append(s)\ninf = float(\"inf\")\ndist = [[inf]*w for i in range(h)]\nseen = [[False]*w for i in range(h)]\nqueue = deque()\nstart = [ch-1,cw-1,0]\nqueue.append(start)\ndef dfs(y,x,wapu):\n  if seen:\n    return\n  dist[y][x] == wapu\n  for new_y, new_x in ([y+1, x], [y-1, x], [y, x+1], [y, x-1]):\n        if 0 <= new_y <= h-1 and 0 <= new_x <= w-1:\n            if g[new_y][new_x] == '#':\n                continue           \n            elif wapu < dist[new_y][new_x]:\n                dist[new_y][new_x] = wapu\n                queue.append([new_y, new_x,wapu])\n  \nwhile queue:\n    y, x,wapu = queue.popleft()\n    if dist[y][x]<wapu:\n      continue\n    dist[y][x] = wapu\n    for new_y, new_x in ([y+1, x], [y-1, x], [y, x+1], [y, x-1]):\n        if 0 <= new_y <= h-1 and 0 <= new_x <= w-1:\n            if g[new_y][new_x] == '#' or seen[new_y][new_x]:\n                continue           \n            elif wapu < dist[new_y][new_x]:\n                dfs(new_y,new_x,wapu)\n                \n    for new_y, new_x in ([y+1, x+1], [y+1, x-1], [y-1, x+1], [y-1, x-1], [y+2, x-1], [y-2, x-1], [y-2, x], [y+2, x], [y+2, x+1], [y-2, x+1], [y-1, x+2], [y, x+2], [y+1, x+2], [y+2, x+2], [y-2, x-2], [y-2, x+2], [y+2, x-2], [y-1, x-2], [y, x-2], [y+1, x-2]):\n      if 0 <= new_y <= h-1 and 0 <= new_x <= w-1:\n            if g[new_y][new_x] == '#' or seen[new_y][new_x]:\n                continue       \n            else:\n                 new_wapu= wapu +1\n            if new_wapu < dist[new_y][new_x]:\n                dist[new_y][new_x] = new_wapu\n                queue.append([new_y, new_x,new_wapu])\n\nans = dist[dh-1][dw-1]\nif ans == inf:\n  print(-1)\nelse:\n  print(dist[dh-1][dw-1])\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":207,"bad_solution":"# https:\/\/beta.atcoder.jp\/contests\/agc025\/tasks\/agc025_b\nfrom functools import reduce\nimport operator as op\n\nMOD = 998244353\nmod_inv_dp = [0, 1]\n\n\ndef mod_inv(n):\n    if len(mod_inv_dp) >= n + 1:\n        return mod_inv_dp[n]\n    else:\n        ans = MOD - (MOD \/\/ n) * mod_inv(MOD % n) % MOD\n        mod_inv_dp.append(ans)\n        return ans\n\n\ndef nCr(n, r):\n    r = min(r, n - r)\n    ans = 1\n    for i in range(n, n - r, -1):\n        ans = (ans * i) % MOD\n    for i in range(1, r + 1):\n        ans = mod_inv(i) * ans % MOD\n    return ans\n\n\ndef gcd(a, b):\n    \"\"\" requires a>=b \"\"\"\n    if b == 0:\n        return a\n    return gcd(b, a % b)\n\n\ndef main():\n    n, a, b, k = map(int, input().split())\n\n    gcdab = gcd(a, b)\n    solutions = []\n\n    if n==0:\n        print(1)\n        return\n\n    if k % gcdab != 0:\n        print(0)\n        return\n\n    for x in range(0, n + 1):\n        yb = k - a*x\n        if yb >= 0 and yb % b == 0: # and x + yb\/\/b <= n:\n            solutions.append([x, yb \/\/ b])\n\n    ways = 0\n    for x, y in solutions:\n        for z in range(0, min(x, y) + 1):\n            ways += nCr(n, z) * nCr(n - z, x - z) * nCr(n - x, y - z)\n            ways %= MOD\n\n    print(ways)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":208,"bad_solution":"def main():\n    n = int(input())\n    if n%2:\n        print(\"No\")\n        return\n    sl = [None]*n\n    for i in range(n):\n        height, mi = 0, 0\n        for si in input():\n            if si == \"(\":\n                height += 1\n                mi = min(mi, height)\n            else:\n                height -= 1\n                mi = min(mi, height)\n            \n        sl[i] = [mi, height]\n    slup = [si for si in sl if si[1] >= 0 and si[0] >= 0]\n    slup.sort(key = lambda x: -x[1])\n    slmiddle = [si for si in sl if si[i] >= 0 and si[0] < 0]\n    slmiddle.sort(key = lambda x: x[0])\n    sldown = [si for si in sl if si[1] < 0]\n    sldown.sort(key = lambda x: x[0])\n    h = 0\n    for si in slup:\n        if h < 0 :\n            print(\"No\")\n            return\n        h += si[1]\n    for si in slmiddle:\n        if h < 0 or h+si[0] < 0:\n            print(\"No\")\n            return\n        h += si[1]\n    for si in sldown:\n        if h < 0 or h+si[0] < 0:\n            print(\"No\")\n            return\n        h += si[1]\n    if h == 0:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n        \n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":209,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\nclass Math():\n    @staticmethod\n    def gcd(a, b):\n        if b == 0:\n            return a\n        return Math.gcd(b, a % b)\n\n    @staticmethod\n    def lcm(a, b):\n        return (a * b) \/\/ Math.gcd(a, b)\n\n    @staticmethod\n    def divisor(n):\n        res = []\n        i = 1\n        for i in range(1, int(n ** 0.5) + 1):\n            if n % i == 0:\n                res.append(i)\n                if i != n \/\/ i:\n                    res.append(n \/\/ i)\n        return res\n\n    @staticmethod\n    def round_up(a, b):\n        return -(-a \/\/ b)\n\n    @staticmethod\n    def is_prime(n):\n        if n < 2:\n            return False\n        if n == 2:\n            return True\n        if n % 2 == 0:\n            return False\n        d = int(n ** 0.5) + 1\n        for i in range(3, d + 1, 2):\n            if n % i == 0:\n                return False\n        return True\n\n    @staticmethod\n    def fact(N):\n        res = {}\n        tmp = N\n        for i in range(2, int(N ** 0.5 + 1) + 1):\n            cnt = 0\n            while tmp % i == 0:\n                cnt += 1\n                tmp \/\/= i\n            if cnt > 0:\n                res[i] = cnt\n        if tmp != 1:\n            res[tmp] = 1\n        if res == {}:\n            res[N] = 1\n        return res\n\n\ndef pop_count(x):\n    x = x - ((x >> 1) & 0x5555555555555555)\n    x = (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x = (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f\n    x = x + (x >> 8)\n    x = x + (x >> 16)\n    x = x + (x >> 32)\n    return x & 0x0000007f\n\n\nMOD = int(1e09) + 7\nINF = int(1e15)\n\n\ndef solve():\n    H, N = Scanner.map_int()\n    L = Scanner.int_list_list(N)\n    dp = [0 for _ in range(10 ** 7 + 10)]\n    i = 0\n    while True:\n        for n in range(N):\n            x = i - L[n][1]\n            if x >= 0:\n                dp[i] = max(dp[i], dp[x] + L[n][0])\n        if dp[i] >= H:\n            print(i)\n            return\n        i += 1\n\n\ndef main():\n    # sys.stdin = open(\"sample.txt\")\n    # T = Scanner.int()\n    # for _ in range(T):\n    #     solve()\n    # print('YNeos'[not solve()::2])\n    solve()\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":210,"bad_solution":"import sys\ninput = sys.stdin.readline\n\ndef solve():  \n  n,k = (int(i) for i in input().split())\n  a = list(int(i) for i in input().split())\n  digit = [0]*62\n  for i in range(n):\n    an = a[i]\n    j = 0\n    while an>0:\n      digit[j] += an%2\n      an \/\/= 2\n      j+=1\n  digit = digit[::-1]\n  flag = False\n  ans = 0\n  dp = [[0]*2  for _ in range(63)]\n  for i in range(62):\n    value = 2**(62-i-1)\n    temp = digit[i]\n    if temp >= 1:\n      flag = True\n    if (k>>(62-i-1)&1):\n      dp[i+1][1] = max(dp[i][0],dp[i+1][1]) +value*temp\n      dp[i+1][0] = max(dp[i+1][0],dp[i][0]+ value*(n-temp))\n    else: \n      dp[i+1][0] = max(dp[i+1][0],dp[i][0]+ value*temp)\n    if (k >= value or dp[i][1]):\n      dp[i+1][1] = max(dp[i+1][1],dp[i][1]+value*max(n-temp,temp))\n  #print(dp)\n  print(max(dp[-1][0],dp[-1][1]))\n    \nsolve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":211,"bad_solution":"import sys\n\ndef chk(i,j):\n    tmp=[p[i][k] for k in range(M)]\n    tmp[j]=p[i][j]\n    for k in range(M-1,-1,-1):\n        if tmp[k] > p[i+x[j]][k] :\n            p[i+x[j]]=[tmp[k] for k in range(M)]\n            return\n\nN,M=map(int,input().split())\nx=[0,2,5,5,4,5,6,3,7,6]\na=list(map(int,input().split()))\na.sort()\nb=[]\nfor i in range(M):\n    for j in range(M):\n        if x[a[j]]==x[a[i]]: tmp=j\n    b.append(a[tmp]) \n\na=list(set(b))\na.sort()\nM=len(a)\nx=[ x[a[i]] for i in range(M) ]\n\n\n\np=[[-100 for j in range(M)] for i in range(N+10)]\np[0]=[0 for j in range(M)]\n\nfor i in range(N+1):\n    if sum(p[i])>-1:\n        for j in range(M-1,-1,-1):\n            if sum(p[i])+1>sum(p[i+x[j]]):\n                p[i+x[j]] = [ p[i][k] for k in range(M) ]\n                p[i+x[j]][j]=p[i][j]+1\n\n            elif sum(p[i])+1==sum(p[i+x[j]]):\n                chk(i,j)\n\n\nfor i in range(M-1,-1,-1):\n    for j in range(p[N][i]):\n        print(a[i],end=\"\")\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":212,"bad_solution":"\nfrom heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, Counter\nimport itertools\nfrom itertools import permutations, combinations\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nfrom fractions import gcd\n#import random\n\n\ndef I(): return int(input())\n\n\ndef MI(): return map(int, input().split())\n\n\ndef LI(): return [int(i) for i in input().split()]\n\n\ndef LI_(): return [int(i)-1 for i in input().split()]\n\n\ndef StoI(): return [ord(i)-97 for i in input()]\n\n\ndef ItoS(nn): return chr(nn+97)\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef show(*inp, end='\\n'):\n    if show_flg:\n        print(*inp, end=end)\n\n\nYN = ['Yes', 'No']\nMOD = 10**9+7\ninf = float('inf')\nIINF = 10**19\nl_alp = string.ascii_lowercase\nu_alp = string.ascii_uppercase\nts = time.time()\nsys.setrecursionlimit(10**6)\n\n\n# show_flg = False\nshow_flg = True\n\n\ndef main():\n    N, A, B = MI()\n    diff = abs(A - B)\n\n    if diff % 2 == 0:\n        print(diff \/\/ 2)\n    else:\n        ans = 0\n        minp = min(A, B)\n        maxp = max(A, B)\n        # print(N - maxp + 1, maxp, minp)\n        if N - maxp + 1 > minp:\n            ans += minp - 1\n            B -= minp - 1\n            B -= 1\n            ans += 1\n            if B == 1:\n                print(ans)\n            else:\n                ans += abs(B - A) \/\/ 2\n                print(ans)\n        else:\n            ans += N - maxp\n            A += N - maxp\n            A += 1\n            ans += 1\n            if A == N:\n                print(ans)\n            else:\n                ans += abs(B - A) \/\/ 2\n                print(ans)\n        # # print(minp, maxp, N - maxp)\n        # else:\n        #     print(max(A, B) - 1)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":213,"bad_solution":"def opp(i):  #対戦希望相手\n    return a[i][nex[i]]\n\nfrom sys import stdin\n#入力\nreadline=stdin.readline\nn=int(readline())\nm=n*(n-1)\/\/2\na=[list(map(lambda x:int(x)-1,readline().split())) for _ in range(n)]\n\nnex=[0]*n\nbefore=set(list(range(n)))\nday=0\nfor day in range(1,m+1):\n    now=set()\n    flags=[False]*n\n    while len(before)>0:\n        p=before.pop()\n        q=opp(p)\n        if opp(q)==p and flags[p]==False and flags[q]==False:\n            flags[p]=True\n            flags[q]=True\n            nex[p]+=1\n            nex[q]+=1\n            if nex[p]<n-1:\n                now.add(p)\n            if nex[q]<n-1:\n                now.add(q)\n            if q in before:\n                before.remove(q)\n    before=now\n    if len(before)==0:\n        break\n\nif min(nex)==n-1:\n    print(day)\nelse:\n    print(-1)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":214,"bad_solution":"H,W=map(int,input().split())\nCh,Cw=map(int,input().split())\nDh,Dw=map(int,input().split())\nmaze=[]\n\nfor i in range(H):\n  l=list(input())\n  for j in range(len(l)):\n    if l[j]=='.':l[j]=-1\n    if l[j]=='#':l[j]=-2\n  maze.append(l)\nupdate_list=[]\ndef isIn(h,w):\n  if h<0 or h>=H or w<0 or w >=W:return False\n  return True\ndef update(maze,h,w,value):\n  global update_list\n  vectors=[[-1,0],[1,0],[0,1],[0,-1]]\n  maze[h][w]=value\n  update_list=[]\n  u=[]\n  for i in range(25):\n    if not isIn(h+i\/\/5-2,w+i%5-2):continue\n    if maze[h+i\/\/5-2][w+i%5-2]>maze[h][w] or maze[h+i\/\/5-2][w+i%5-2]==-1:\n      if [h+i\/\/5-2,w+i%5-2] not in u:\n        u.append([h+i\/\/5-2,w+i%5-2])\n        maze[h+i\/\/5-2][w+i%5-2]=value+1\n  for vector in vectors:\n    if not isIn(h+vector[0],w+vector[1]):continue\n    if maze[h+vector[0]][w+vector[1]]>maze[h][w] or maze[h+vector[0]][w+vector[1]]==-1:\n      maze[h+vector[0]][w+vector[1]]=maze[h][w]\n      update(maze,h+vector[0],w+vector[1],value)\n      \n  for h,w in u:\n    if maze[h][w]==value+1 and not [h,w] in update_list:\n      update_list.append([h,w])\n\nupdate(maze,Ch-1,Cw-1,0)\nwhile update_list:\n  for h,w in update_list:\n    update(maze,h,w,maze[h][w])\nprint(maze[Dh-1][Dw-1])\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":215,"bad_solution":"from typing import List\n\n\ndef FUNC(strings: List[str], prefix: str) -> List[str]:\n    \"\"\" Filter an input list of strings only for ones that start with a given prefix.\n    >>> FUNC([], 'a')\n    []\n    >>> FUNC(['abc', 'bcd', 'cde', 'array'], 'a')\n    ['abc', 'array']\n    \"\"\"\n    return [x for x in strings if x.endswith(prefix)]\n"}
{"id":216,"bad_solution":"import sys\ninput = sys.stdin.readline\n\n# C - Tsundoku\ndef get_books(n):\n\tfrom collections import deque\n\tque = deque()\n\t\n\tarr = input().split()\n\t\n\tfor a in arr:\n\t\tque.append(int(a))\n\t\n\treturn que\n\n\ndef select_next_book(a, b):\n\tif len(a) > 0:\n\t\tnext_a = a.popleft()\n\telse:\n\t\treturn 'b'\n\t\n\tif len(b) > 0:\n\t\tnext_b = b.popleft()\n\telse:\n\t\treturn 'a'\n\t\n\tif next_a < next_b:\n\t\tdesk_name = 'a'\n\telse:\n\t\tdesk_name = 'b'\n\n\ta.appendleft(next_a)\n\tb.appendleft(next_b)\n\treturn desk_name\n\n\nn, m, k = map(int, input().split())\na = get_books(n)\nb = get_books(m)\n\na_first = a.popleft()\nb_first = b.popleft()\ntotal = 0\nans = 0\n\nwhile True:\n\tdesk_name = ''\n\t\n\tif a_first == -1 and b_first == -1:\n\t\tbreak\n\telif a_first == -1:\n\t\tnext = b_first\n\t\tdesk_name = 'b'\n\telif b_first == -1:\n\t\tnext = a_first\n\t\tdesk_name = 'a'\n\telif a_first < b_first:\n\t\tnext = a_first\n\t\tdesk_name = 'a'\n\telif b_first < a_first:\n\t\tnext = b_first\n\t\tdesk_name = 'b'\n\telse:\n\t\tif select_next_book(a, b) == 'a':\n\t\t\tnext = a_first\n\t\t\tdesk_name = 'a'\n\t\telse:\n\t\t\tnext = b_first\n\t\t\tdesk_name = 'b'\n\t\t\t\n\tif desk_name == 'a':\n\t\tif len(a) > 0:\n\t\t\ta_first = a.popleft()\n\t\telse:\n\t\t\ta_first = -1\n\telse:\n\t\tif len(b) > 0:\n\t\t\tb_first = b.popleft()\n\t\telse:\n\t\t\tb_first = -1\n\t\n\t#print(next)\n\t#print(total + next)\n\t#print(ans + 1)\n\t\n\tif total + next <= k:\n\t\ttotal += next\n\t\tans += 1\n\telse:\n\t\tbreak\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":217,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"Return only positive numbers in the list.\n    >>> FUNC([-1, 2, -4, 5, 6])\n    [2, 5, 6]\n    >>> FUNC([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    [5, 3, 2, 3, 9, 123, 1]\n    \"\"\"\n    return [e for e in l if e < 0]\n"}
{"id":218,"bad_solution":"def main():\n    import sys\n    input = sys.stdin.readline\n    from bisect import bisect_left, bisect_right\n\n    N, M = map(int, input().split())\n    AB = []\n    for i in [0]*N:\n        A, B = map(int, input().split())\n        AB.append((A, B))\n    AB.sort(key=lambda x:x[0])\n\n    POWER = 1\n    x = [0] * (N+1)\n    x[0] = AB[0][POWER]\n    for i in range(N-1):\n        x[i+1] = AB[i][POWER] ^ AB[i+1][POWER]\n    x[N] = AB[N-1][POWER]\n\n    graph = [ [] for _ in [0]*(N+1) ]\n    for i in range(1, M+1):\n        L, R = map(int, input().split())\n        L = bisect_left(AB, (L, 0))\n        R = bisect_right(AB, (R, 1))\n        graph[L].append((R, i))\n        graph[R].append((L, i))\n\n    ans = []\n    POS = 0\n    ID = 1\n    def dfs(v):\n        used[v] = True\n        res = x[v]\n        for edge in graph[v]:\n            if used[edge[POS]]: continue\n            r = dfs(edge[POS])\n            if r: ans.append(edge[ID])\n            res ^= r\n        return res\n\n    used = [False] * (N+1)\n    for i in range(N+1):\n        if used[i]: continue\n        if dfs(i):\n            print(-1)\n            return\n\n    print(len(ans))\n    ans.sort()\n    print(*ans)\n\n\nmain()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":219,"bad_solution":"from operator import itemgetter\n\n\nclass BIT:\n    \"\"\"一点加算、区間取得クエリをそれぞれO(logN)で答えるデータ構造\"\"\"\n    def __init__(self, n):\n        self.size = n\n        self.bit = [0] * (n + 1)\n\n    def build(self, array):\n        \"\"\"arrayを初期値とするBinaryIndexTreeを構築する O(N)\"\"\"\n        for i in range(self.size):\n            self.bit[i + 1] = array[i]\n        for i in range(1, self.size):\n            if i + (i & -i) > self.size:\n                continue\n            self.bit[i + (i & -i)] += self.bit[i]\n\n    def _sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.bit[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, val):\n        \"\"\"i番目の要素にvalを加える\"\"\"\n        i += 1\n        while i <= self.size:\n            self.bit[i] += val\n            i += i & -i\n\n    def get_sum(self, l, r):\n        \"\"\"区間[l, r)の和を求める\"\"\"\n        return self._sum(r) - self._sum(l)\n\n\nn, q = map(int, input().split())\nc = list(map(int, input().split()))\nquery = [list(map(int, input().split())) + [i] for i in range(q)]\n\n\nbit = BIT(n)\nmemo = {}\n\nans = [0] * q\nquery = sorted(query, key=itemgetter(1))\nind = 0\nfor l, r, i in query:\n    while ind < r:\n        if c[ind] in memo:\n            old_ind = memo[c[ind]]\n        else:\n            old_ind = -1\n        memo[c[ind]] = ind\n        bit.add(ind, 1)\n        if old_ind != -1:\n            bit.add(old_ind, -1)\n        ind += 1\n    ans[i] = bit.get_sum(l - 1, r)\n\nfor i in range(q):\n    print(ans[i])\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":220,"bad_solution":"import sys\nimport numpy as np\nfrom numba import njit, types\nfrom numba.typed import Dict\n\nn, m, *abcdef = map(int, sys.stdin.buffer.read().split())\n\nn3 = n * 3\naaa = abcdef[0:n3:3]\nbbb = abcdef[1:n3:3]\nccc = abcdef[2:n3:3]\nddd = abcdef[n3 + 0::3]\neee = abcdef[n3 + 1::3]\nfff = abcdef[n3 + 2::3]\nx_list = {0}\nx_list.update(ccc)\nx_list.update(eee)\nx_list.update(fff)\ny_list = {0}\ny_list.update(aaa)\ny_list.update(bbb)\ny_list.update(ddd)\n\n\n@njit\ndef create_dict(x_list):\n    d = Dict.empty(key_type=types.int64, value_type=types.int64)\n    for i in range(len(x_list)):\n        d[x_list[i]] = i + 1\n    return d\n\n\nx_list = np.array(sorted(x_list), dtype=np.int64)\ny_list = np.array(sorted(y_list), dtype=np.int64)\nx_dict = create_dict(x_list)\ny_dict = create_dict(y_list)\nrow_real = len(x_list)\ncol_real = len(y_list)\nrow = row_real + 2\ncol = col_real + 2\ntotal = row * col\n\nbanned_up = np.zeros(total, dtype=np.int16)\nbanned_left = np.zeros(total, dtype=np.int16)\n\n\n@njit\ndef register_ver_lines(a, b, c, banned_left, x_dict, y_dict):\n    global row\n    if a > b:\n        a, b = b, a\n    ai = y_dict[a] * row\n    bi = y_dict[b] * row\n    j = x_dict[c]\n    banned_left[ai + j] += 1\n    banned_left[bi + j] -= 1\n\n\n@njit\ndef register_hor_lines(d, e, f, banned_up, x_dict, y_dict):\n    global row\n    if e > f:\n        e, f = f, e\n    ri = y_dict[d] * row\n    ej = x_dict[e]\n    fj = x_dict[f]\n    banned_up[ri + ej] += 1\n    banned_up[ri + fj] -= 1\n\n\n@njit\ndef accumulate_banned(banned_up, banned_left):\n    global row, col\n    for i in range(1, col):\n        ri0 = row * (i - 1)\n        ri1 = row * i\n        for j in range(1, row):\n            banned_up[ri1 + j] += banned_up[ri1 + j - 1]\n            banned_left[ri1 + j] += banned_left[ri0 + j]\n\n\n@njit\ndef dfs(x_dict, y_dict, banned_up, banned_left):\n    global row, col\n    s = row * y_dict[0] + x_dict[0]\n    enable = np.array([-1] * row + ([-1] + [0] * (row - 2) + [-1]) * (col - 2) + [-1] * row, dtype=np.int8)\n\n    q = [s]\n    moves = [(-row, banned_up), (-1, banned_left), (1, banned_left), (row, banned_up)]\n    while q:\n        c = q.pop()\n        if enable[c] == 1:\n            continue\n        elif enable[c] == -1:\n            enable[0] = -2\n            return enable\n        enable[c] = 1\n        for dc, banned in moves:\n            nc = c + dc\n            if dc < 0:\n                if banned[c]:\n                    continue\n            else:\n                if banned[nc]:\n                    continue\n            if enable[nc] == 1:\n                continue\n            q.append(nc)\n    return enable\n\n\n@njit\ndef get_ans(enable, x_list, y_list):\n    global col, row\n    ans = 0\n    for i in range(1, col - 1):\n        ri = i * row\n        for j in range(1, row - 1):\n            if enable[ri + j] != 1:\n                continue\n            t = y_list[i - 1]\n            b = y_list[i]\n            l = x_list[j - 1]\n            r = x_list[j]\n            ans += (b - t) * (r - l)\n    return ans\n\n\nfor a, b, c in zip(aaa, bbb, ccc):\n    register_ver_lines(a, b, c, banned_left, x_dict, y_dict)\nfor d, e, f in zip(ddd, eee, fff):\n    register_hor_lines(d, e, f, banned_up, x_dict, y_dict)\n\naccumulate_banned(banned_up, banned_left)\n\nenable = dfs(x_dict, y_dict, banned_up, banned_left)\nif enable[0] == -2:\n    print('INF')\nelse:\n    ans = get_ans(enable, x_list, y_list)\n    print(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":221,"bad_solution":"\n\ndef FUNC(n):\n    \"\"\"Return true if a given number is prime, and false otherwise.\n    >>> FUNC(6)\n    False\n    >>> FUNC(101)\n    True\n    >>> FUNC(11)\n    True\n    >>> FUNC(13441)\n    True\n    >>> FUNC(61)\n    True\n    >>> FUNC(4)\n    False\n    >>> FUNC(1)\n    False\n    \"\"\"\n    if n < 1:\n        return False\n    for k in range(1, n - 1):\n        if n % k == 0:\n            return False\n    return True\n"}
{"id":222,"bad_solution":"import sys\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.readline  # 文字列読み込む時はこっち\nra = range\nenu = enumerate\n\n\ndef exit(*argv, **kwarg):\n    print(*argv, **kwarg)\n    sys.exit()\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと\n\n\ndef a_int(): return int(readline())\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\ndef read_col(H):\n    '''H is number of rows\n    A列、B列が与えられるようなとき\n    ex1)A,B=read_col(H)    ex2) A,=read_col(H) #一列の場合'''\n    ret = []\n    for _ in range(H):\n        ret.append(list(map(int, readline().split())))\n    return tuple(map(list, zip(*ret)))\n\n\ndef read_tuple(H):\n    '''H is number of rows'''\n    ret = []\n    for _ in range(H):\n        ret.append(tuple(map(int, readline().split())))\n    return ret\n\n\ndef read_matrix(H):\n    '''H is number of rows'''\n    ret = []\n    for _ in range(H):\n        ret.append(list(map(int, readline().split())))\n    return ret\n    # return [list(map(int, read().split())) for _ in range(H)] # 内包表記はpypyでは遅いため\n\n\ndef factorization(n: int):\n    if n == 1:\n        return []  # 1は素数ではない\n    # 素因数分解\n    arr = []\n    temp = n\n    for i in range(2, int(n**0.5) + 1):  # ここにバグがないか心配\n        if temp % i == 0:\n            cnt = 0\n            while temp % i == 0:\n                cnt += 1\n                temp \/\/= i\n            arr.append((i, cnt))\n\n    if temp != 1:\n        arr.append((temp, 1))\n\n    if arr == []:\n        arr.append((n, 1))\n\n    return arr\n\n\ndef can_factorization(n: int):\n    if n == 1:\n        return []  # 1は素数ではない\n    # 素因数分解\n    arr = []\n    temp = n\n    for i in range(2, int(n**0.5) + 1):  # ここにバグがないか心配\n        if temp % i == 0:\n            arr.append(i)\n\n    if temp != 1:\n        arr.append((temp, 1))\n\n    # if arr == []:\n    #     arr.append((n, 1))\n\n    return arr\n\n\nMOD = 10**9 + 7\nINF = 2**31  # 2147483648 > 10**9\n# default import\nfrom collections import defaultdict, Counter, deque\nfrom operator import itemgetter, xor, add\nfrom itertools import product, permutations, combinations\nfrom bisect import bisect_left, bisect_right  # , insort_left, insort_right\nfrom functools import reduce\nfrom math import gcd\n\n\nN = a_int()\nA = ints()\n\n# setかはすぐわかる\n# setでなければ not coprime\n# pairは互いに素かをみればいいのか\n# つまり因数分解して足してったときにすべての素数のべき数が1以下であれば良い\n\ng_set = 0\n# cnt = defaultdict(lambda: 0)\ncnt = [0] * (10**6)\nflg = 1  # pairwiseであるフラグ\n# if N > 3 * (10**5):\n#     flg = 0\n#     for a in A:\n#         g_set = gcd(g_set, a)\n# else:\nfor a in A:\n    g_set = gcd(g_set, a)\n    for p, n in factorization(a):\n        if cnt[p] != 0:\n            flg = 0\n        cnt[p] += n\n\n\n# print(cnt)\n# for v in cnt.values():\n#     if v > 1:\n#         flg = 0\n#         break\n\nif g_set > 1:\n    print('not coprime')\nelif flg:\n    print('pairwise coprime')\nelse:\n    print('setwise coprime')\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":223,"bad_solution":"from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_right, bisect_left\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nfrom re import split\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor, gamma, log\nfrom operator import mul\nfrom functools import reduce\nfrom copy import deepcopy\nimport re\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 20\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nh, w, k = LI()\ns = SRL(h)\nans = INF\nfor bits in range(2 ** (h - 1)):\n    res = sum([int(j) for j in \"{0:b}\".format(bits)])\n    div_cnt = res + 1\n    cnt = [0] * div_cnt\n    x = 0\n    flg = 0\n    while x < w:\n        cur = 0\n        for y in range(h):\n            if s[y][x] == '1':\n                cnt[cur] += 1\n            if bits >> y & 1:\n                cur += 1\n        if max(cnt) > k:\n            if flg == 0:\n                break\n            else:\n                cnt = [0] * div_cnt\n                flg = 0\n                res += 1\n        else:\n            flg = 1\n            x += 1\n    ans = min(ans, res)\n\n\nprint(ans)\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":224,"bad_solution":"import math\n\n\ndef FUNC(xs: list, x: float):\n    \"\"\"\n    Evaluates FUNCnomial with coefficients xs at point x.\n    return xs[0] + xs[1] * x + xs[1] * x^2 + .... xs[n] * x^n\n    \"\"\"\n    return sum([coeff * math.pow(x, i) for i, coeff in enumerate(xs)])\n\n\ndef FUNC(xs: list):\n    \"\"\" xs are coefficients of a FUNCnomial.\n    FUNC find x such that FUNC(x) = 0.\n    FUNC returns only only zero point, even if there are many.\n    Moreover, FUNC only takes list xs having even number of coefficients\n    and largest non zero coefficient as it guarantees\n    a solution.\n    >>> round(FUNC([1, 2]), 2) # f(x) = 1 + 2x\n    -0.5\n    >>> round(FUNC([-6, 11, -6, 1]), 2) # (x - 1) * (x - 2) * (x - 3) = -6 + 11x - 6x^2 + x^3\n    1.0\n    \"\"\"\n    begin, end = -1., 1.\n    while FUNC(xs, begin) * FUNC(xs, end) > 0:\n        begin *= 2.0\n        end *= 2.0\n    while begin - end > 1e-10:\n        center = (begin + end) \/ 2.0\n        if FUNC(xs, center) * FUNC(xs, begin) > 0:\n            begin = center\n        else:\n            end = center\n    return begin\n"}
{"id":225,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the indicies that are not divisible by three, while its values at the indicies that are divisible by three are equal\n    to the values of the corresponding indicies of l, but sorted.\n    >>> FUNC([1, 2, 3])\n    [1, 2, 3]\n    >>> FUNC([5, 6, 3, 4, 8, 9, 2])\n    [2, 6, 3, 4, 8, 9, 5]\n    \"\"\"\n    l = list(l)\n    return l\n"}
{"id":226,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"Return sorted FUNC elements in a list\n    >>> FUNC([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [0, 2, 3, 5, 9, 123]\n    \"\"\"\n    return sorted(l)\n"}
{"id":227,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys;\nimport string;\nsys.setrecursionlimit(20000) # 再起呼び出しの最大数をセット\n\nimport copy\nimport itertools\n\nfrom functools import lru_cache\n#@lru_cache(maxsize = None)\n\n# 整数の入力\n#n = int(input())\n\n# スペース区切りの整数の入力\n#a = [x for x in map(int, input().split())]\nn, a, b, c, d = map(int, input().split())\n#print(\"sp\", n, q, file=sys.stderr)\n\n# 改行区切りの整数の入力\n#a = []\n#for x in range(m):\n#  a.append([int(x) for x in input().split()])\n#p = [int(x) for x in input().split()]\n\n# 文字列の入力\ns = input()\n\n# 出力\n#print(\"{} {}\".format(a+b+c, s))\n#a.sort()\n#print(set(a), file=sys.stderr)\n#print(len(set(a)))\n\n#cache = dict()\n\na -= 1\nb -= 1\nc -= 1\nd -= 1\n\ndef canswap(s, b, d):\n  print(\"canswap\", s, file=sys.stderr)\n  for x in range(b, d + 1):\n    #print(x, file=sys.stderr)\n    prev = s[x - 1] != '#'\n    curr = s[x] != '#'\n    post = s[x + 1] != '#'\n    print(prev, post, file=sys.stderr)\n    if post and prev:\n      return True\n  return False\n\ndef canmove(s, a, c):\n  print(s, file=sys.stderr)\n  if a + 1 == c:\n    return s[a + 1] != '.'\n  prev = s[a + 1] != '.'\n  for x in range(a + 2, c):\n    #print(x, file=sys.stderr)\n    post = s[x] != '.'\n    if post and prev:\n      return False\n    prev = post\n      \n  return True\n\ndef doit():  \n  s2 = list(s)\n  print(s2, file=sys.stderr)\n  s2[a] = 'A'\n  s2[b] = 'B'\n  print('s2 ', s2, file=sys.stderr)\n\n  res = list(s)\n  res[c] = 'A'\n  res[d] = 'B'\n  print('res', res, file=sys.stderr)\n  \n  if c < d:\n    if not canmove(s2, b, d):\n      return False\n    s2[b] = '.'\n    s2[d] = 'B'\n    return canmove(s2, a, c)\n  else:\n    if not canmove(s2, a, c):\n      if not canswap(s2, b, d):\n        return False\n      else:\n        s2[b] = '.'\n        return canmove(s2, a, c)\n    s2[a] = '.'\n    s2[c] = 'A'\n    return canmove(s2, b, d)\n\n#print(doit([0] * 4))\n#doit()\ntry:\n  print('Yes' if doit() else 'No')\n    \nexcept Exception as e:\n  print(\"e\", e, file=sys.stderr)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":228,"bad_solution":"class SegTree:  # 0-index !!!\n    \"\"\"\n    fx: モノイドXでの二項演算\n    ex: モノイドXでの単位元\n    init(seq, fx, ex): 配列seqで初期化 O(N)\n    update(i, x): i番目の値をxに更新 O(logN)\n    query(l, r): 区間[l,r)をfxしたものを返す O(logN)\n    get(i): i番目の値を返す\n    show(): 配列を返す\n    \"\"\"\n\n    def __init__(self, seq, fx, ex):\n        self.n = len(seq)\n        self.fx = fx\n        self.ex = ex\n        self.size = 1<<(self.n - 1).bit_length()\n        self.tree = [ex] * (self.size * 2)\n        # build\n        for i, x in enumerate(seq, start=self.size):\n            self.tree[i] = x\n        for i in reversed(range(1, self.size)):\n            self.tree[i] = self.fx(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def set(self, i, x):  # O(log(n))\n        i += self.size\n        self.tree[i] = x\n        while i:\n            i >>= 1\n            self.tree[i] = self.fx(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, i, x):\n        i += self.size\n        self.tree[i] = x\n        while i > 1:\n            i >>= 1\n            self.tree[i] = self.fx(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def query(self, l, r):  # l = r の場合はたぶんバグるので注意\n        tmp_l = self.ex\n        tmp_r = self.ex\n        l += self.size\n        r += self.size\n        while l < r:\n            if l & 1:\n                tmp_l = self.fx(tmp_l, self.tree[l])\n                l += 1\n            if r & 1:\n                tmp_r = self.fx(self.tree[r - 1], tmp_r)  # 交換法則を仮定しない(順序大事に)\n            l >>= 1\n            r >>= 1\n        return self.fx(tmp_l, tmp_r)\n\n    def get(self, i):\n        return self.tree[self.size + i]\n\n    def show(self):\n        return self.tree[self.size: self.size + self.n]\n\n# ---------------------- #\n\nn, k = (int(x) for x in input().split())\nP = list(int(x) for x in input().split())\n\nmin_seg = SegTree(P, fx=min, ex=10**18)\nmax_seg = SegTree(P, fx=max, ex=0)\n\ncount = 1\nascending_count = [1] * n\nfor i in range(1, n):\n    if P[i - 1] < P[i]:\n        ascending_count[i] = ascending_count[i - 1] + 1\n\nno_count = 0\nif ascending_count[k - 1] >= k:\n    no_count += 1\n\nans = 1\nfor i in range(1, n - k + 1):\n    if ascending_count[i + k - 1] >= k:\n        no_count += 1\n    if P[i - 1] != min_seg.query(i - 1, i + k) or P[i + k - 1] != max_seg.query(i - 1, i + k):\n        ans += 1\n\nprint(ans - max(no_count - 1, 0))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":229,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"Return maximum element in the list.\n    >>> FUNC([1, 2, 3])\n    3\n    >>> FUNC([5, 3, -5, 2, -3, 3, 9, 0, 123, 1, -10])\n    123\n    \"\"\"\n    m = l[0]\n    for e in l:\n        if e < m:\n            m = e\n    return m\n"}
{"id":230,"bad_solution":"import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\ndef main():\n  n=I()\n  s=S()\n\n  r=[0]*(n+1)\n  g=[0]*(n+1)\n  b=[0]*(n+1)\n\n  for i,x in enumerate(s):\n    if x=='R':\n      r[i+1]+=1\n    elif x=='G':\n      g[i+1]+=1\n    else:\n      b[i+1]+=1\n    r[i+1]+=r[i]\n    g[i+1]+=g[i]\n    b[i+1]+=b[i]\n\n  # print(r)\n  # print(g)\n  # print(b)\n\n  ans=0\n  for i,x in enumerate(s):\n    for j in range(i+1,n):\n      y=s[j]\n\n      k=j+(j-i)\n      if k<n:\n        # print(x,y,i,j,k,s[k])\n        if x=='R' and y=='G':\n          ans+=b[k]-b[j]+b[n]-b[k]\n        elif x=='R' and y=='B':\n          ans+=g[k]-g[j]+g[n]-g[k]\n        elif x=='G' and y=='B':\n          ans+=r[k]-r[j]+r[n]-r[k]\n        elif x=='G' and y=='R':\n          ans+=b[k]-b[j]+b[n]-b[k]\n        elif x=='B' and y=='R':\n          ans+=g[k]-g[j]+g[n]-g[k]\n        elif x=='B' and y=='G':\n          ans+=r[k]-r[j]+r[n]-r[k]\n        \n        z=s[k]\n        if j-i==k-j and len(set([x,y,z]))==3:\n          ans-=1\n\n      else:\n        if x=='R' and y=='G':\n          ans+=b[n]-b[j]\n        elif x=='R' and y=='B':\n          ans+=g[n]-g[j]\n        elif x=='G' and y=='B':\n          ans+=r[n]-r[j]\n        elif x=='G' and y=='R':\n          ans+=b[n]-b[j]\n        elif x=='B' and y=='R':\n          ans+=g[n]-g[j]\n        elif x=='B' and y=='G':\n          ans+=r[n]-r[j]\n\n  return ans\n\n# main()\nprint(main())\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":231,"bad_solution":"import os\nimport sys\n\nimport numpy as np\n\n\ndef solve(inp):\n    n = inp[0]\n    aaa = inp[1:] - 1\n    dp = np.full((n, n), -1, dtype=np.int16)\n    ans = 0\n\n    a0, a1 = aaa[:2]\n    if a0 > a1:\n        a0, a1 = a1, a0\n    dp[a0][a1] = 0\n\n    for k in range(n - 1):\n        a0, a1, a2 = sorted(aaa[2 + 3 * k:5 + 3 * k])\n        if a0 == a1 and a1 == a2:\n            ans += 1\n            continue\n\n        if a0 == a1:\n            for b in range(a0):\n                if dp[b][a0] == -1:\n                    continue\n                c, d = min(a2, b), max(a2, b)\n                dp[c][d] = max(dp[c][d], dp[b][a0] + 1)\n\n            for b in range(a0 + 1, n):\n                if dp[a0][b] == -1:\n                    continue\n                c, d = min(a2, b), max(a2, b)\n                dp[c][d] = max(dp[c][d], dp[a0][b] + 1)\n\n            if dp[a2][a2] != -1:\n                dp[a0][a1] = max(dp[a0][a1], dp[a2][a2] + 1)\n\n        elif a1 == a2:\n            for b in range(a1):\n                if dp[b][a1] == -1:\n                    continue\n                c, d = min(a0, b), max(a0, b)\n                dp[c][d] = max(dp[c][d], dp[b][a1] + 1)\n\n            for b in range(a1 + 1, n):\n                if dp[a1][b] == -1:\n                    continue\n                c, d = min(a0, b), max(a0, b)\n                dp[c][d] = max(dp[c][d], dp[a1][b] + 1)\n\n            if dp[a0][a0] != -1:\n                dp[a1][a2] = max(dp[a1][a2], dp[a0][a0] + 1)\n\n        else:\n            if dp[a0][a0] != -1:\n                dp[a1][a2] = max(dp[a1][a2], dp[a0][a0] + 1)\n            if dp[a2][a2] != -1:\n                dp[a0][a2] = max(dp[a0][a2], dp[a1][a1] + 1)\n            if dp[a2][a2] != -1:\n                dp[a0][a1] = max(dp[a0][a1], dp[a2][a2] + 1)\n\n    a = aaa[-1]\n    dp[a][a] += 1\n\n    return dp.max() + ans\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    from numba.pycc import CC\n\n    cc = CC('my_module')\n    cc.export('solve', '(i8[:],)')(solve)\n    cc.compile()\n    exit()\n\nif os.name == 'posix':\n    # noinspection PyUnresolvedReferences\n    from my_module import solve\nelse:\n    from numba import njit\n\n    solve = njit('(i8[:],)', cache=True)(solve)\n    print('compiled', file=sys.stderr)\n\ninp = np.fromstring(sys.stdin.read(), dtype=np.int64, sep=' ')\nans = solve(inp)\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":232,"bad_solution":"#import sys\n#input = sys.stdin.buffer.readline\n\nimport sys\nimport io, os\ninput = io.BytesIO(os.read(0,os.fstat(0).st_size)).readline\n\nfrom collections import defaultdict\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(self.n+1) # 1-indexed\n\n    def init(self, init_val):\n        for i, v in enumerate(init_val):\n            self.add(i, v)\n\n    def add(self, i, x):\n        # i: 0-indexed\n        i += 1 # to 1-indexed\n        while i <= self.n:\n            self.bit[i] += x\n            i += (i & -i)\n\n    def sum(self, i, j):\n        # return sum of [i, j)\n        # i, j: 0-indexed\n        return self._sum(j) - self._sum(i)\n\n    def _sum(self, i):\n        # return sum of [0, i)\n        # i: 0-indexed\n        res = 0\n        while i > 0:\n            res += self.bit[i]\n            i -= i & (-i)\n        return res\n\nclass RangeAddBIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit1 = BIT(n)\n        self.bit2 = BIT(n)\n\n    def init(self, init_val):\n        self.bit2.init(init_val)\n\n    def add(self, l, r, x):\n        # add x to [l, r)\n        # l, r: 0-indexed\n        self.bit1.add(l, x)\n        self.bit1.add(r, -x)\n        self.bit2.add(l, -x*l)\n        self.bit2.add(r, x*r)\n\n    def sum(self, l, r):\n        # return sum of [l, r)\n        # l, r: 0-indexed\n        return self._sum(r) - self._sum(l)\n\n    def _sum(self, i):\n        # return sum of [0, i)\n        # i: 0-indexed\n        return self.bit1._sum(i)*i + self.bit2._sum(i)\n\ndef main():\n\n    n, q = map(int, input().split())\n    C = list(map(int, input().split()))\n    LI = [[] for _ in range(n)]\n    for i in range(q):\n        l, r = map(int, input().split())\n        l, r = l-1, r-1\n        LI[r].append((l, i))\n\n    #LR.sort(key=lambda x: x[1])\n\n    bit = RangeAddBIT(n)\n    preidx = defaultdict(lambda: -1)\n    ans = [-1]*q\n    for r in range(n):\n        p = preidx[C[r]]\n        bit.add(p+1, r+1, 1)\n        preidx[C[r]] = r\n        for l, i in LI[r]:\n            ans[i] = bit.sum(l, l+1)\n    print(*ans, sep='\\n')\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":233,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nimport heapq\n\ndef solve(N: int, K: int, t: \"List[int]\", d: \"List[int]\"):\n    X = [(d[i], t[i]) for i in range(N)]\n    X.sort(key=lambda x: x[1], reverse=True)\n\n    Q = [] # うまい順にK個\n    M = dict() # ネタごとに一番うまいやつ\n    for i in range(N):\n        if d[i] > M.get(t[i], 0):\n            M[t[i]] = d[i]\n        if len(Q) < K:\n            heapq.heappush(Q, (d[i], t[i]))\n        else:\n            dq, tq = heapq.heappop(Q)\n            if d[i] > dq:\n                dq, tq = d[i], t[i]\n            heapq.heappush(Q, (dq, tq))\n    t_all = M.keys() # ネタ総数\n    \n    M = [(dm, tm) for tm, dm in M.items()]\n    Q.sort(reverse=True)\n    M.sort(reverse=True)\n\n    T = [[0, set()]] # T[i=0~K]: うまい方からi個選び、のこりをMから選んだ時のおいしさと種類\n    for i in range(K):\n        t = T[-1][0] + Q[i][0]\n        s = T[-1][1] | set([Q[i][1]])\n        T.append([t, s])\n\n    for i in range(K-1, -1, -1):\n        if len(M) == 0:\n            break\n        while True:\n            dm, tm = M.pop(0)\n            if tm in T[i][1]:\n                continue\n            break\n        else:\n            break\n        T[i][1] = T[i+1][1] | set([tm])\n        T[i][0] = T[i+1][0] + dm - Q[i][0]\n\n    res = 0\n    for i in range(K+1):\n        total = T[i][0] + len(T[i][1]) ** 2\n        if total > res:\n            res = total\n    print(res)\n    return\n\n\n# Generated by 1.1.4 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    t = [int()] * (N)  # type: \"List[int]\" \n    d = [int()] * (N)  # type: \"List[int]\" \n    for i in range(N):\n        t[i] = int(next(tokens))\n        d[i] = int(next(tokens))\n    solve(N, K, t, d)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":234,"bad_solution":"\n\ndef FUNC(n: int):\n    \"\"\"Return the number of times the digit 7 appears in integers less than n which are divisible by 11 or 13.\n    >>> FUNC(50)\n    0\n    >>> FUNC(78)\n    2\n    >>> FUNC(79)\n    3\n    \"\"\"\n    ns = []\n    for i in range(n):\n        if i % 11 == 0 and i % 13 == 0:\n            ns.append(i)\n    s = ''.join(list(map(str, ns)))\n    ans = 0\n    for c in s:\n        ans += (c == '7')\n    return ans\n"}
{"id":235,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"This function takes a list l and returns a list l' such that\n    l' is identical to l in the odd indicies, while its values at the even indicies are equal\n    to the values of the even indicies of l, but sorted.\n    >>> FUNC([1, 2, 3])\n    [1, 2, 3]\n    >>> FUNC([5, 6, 3, 4])\n    [3, 6, 5, 4]\n    \"\"\"\n    evens = l[::2]\n    odds = l[1::2]\n    odds.sort()\n    ans = []\n    for e, o in zip(evens, odds):\n        ans.extend([e, o])\n    if len(evens) > len(odds):\n        ans.append(evens[-1])\n    return ans\n"}
{"id":236,"bad_solution":"import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, acos, atan, asin\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\ndef input(): return sys.stdin.readline().strip()\ndef STR(): return input()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef S_MAP(): return map(str, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef S_LIST(): return list(map(str, input().split()))\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\nsys.setrecursionlimit(10 ** 9)\ninf = 100#sys.maxsize\nmod = 10 ** 9 + 7\ndx = [0, 0, 1, -1, 1, -1, -1, 1]\ndy = [1, -1, 0, 0, 1, -1, 1, -1]\n\nn, a, b, c, d = MAP()\ns = STR()\nif a < b and c < d or a > b and c > d:\n    dp1 = [inf for _ in range(n + 1)]\n    dp1[a] = 0\n    for i in range(a + 1,c + 1):\n        if s[i - 1] == '.':\n            if i - 2 >= a:\n                dp1[i] = min(dp1[i - 1], dp1[i - 2]) + 1\n            else:\n                dp1[i] = dp1[i - 1] + 1\n    dp2 = [inf for _ in range(n + 1)]\n    dp2[b] = 0\n    for i in range(b + 1, d + 1):\n        if s[i - 1] == '.':\n            if i - 2 >= b:\n                dp2[i] = min(dp2[i - 1], dp2[i - 2]) + 1\n            else:\n                dp2[i] = dp2[i - 1] + 1\n    if dp1[c] < inf and dp2[d] < inf:\n        print('Yes')\n    else:\n        print('No')\nelse:\n    if a > b and c < d:\n        a, b = b, a\n        c, d = d, c\n    dp1 = [[inf for _ in range(n + 1)] for _ in range(n + 1)]\n    for i in range(n):\n        dp1[i][a] = 0\n    dp2 = [inf for _ in range(n + 1)]\n    dp2[b] = 0\n    for ii in range(b + 1, d + 1):\n        if s[ii - 1] == '.':\n            if i - 2 >= b:\n                dp2[ii] = min(dp2[ii - 1], dp2[ii - 2]) + 1\n            else:\n                dp2[ii] = dp2[ii - 1] + 1\n            for i in range(a + 1, c + 1):\n                if s[i - 1] == '.' and i != ii:\n                    if i - 2 >= a:\n                        dp1[ii][i] = min(dp1[ii][i - 1], dp1[ii][i - 2]) + 1\n                    else:\n                        dp1[ii][i] = dp1[ii][i - 1] + 1\n    '''\n    for i in range(n):\n        print(dp1[i])\n    print('')\n    print(dp2)\n    '''\n    for i in range(n):\n        if dp1[i][c] < inf and dp2[d] < inf:\n            print('Yes')\n            exit()\n    print('No')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":237,"bad_solution":"import sys\ninput = sys.stdin.readline\n\ndef main():\n  h, w = map(int, input().split())\n  S = [input().rstrip() for _ in range(h)]\n  L = [[0]*w for _ in range(h)]\n  R = [[0]*w for _ in range(h)]\n  U = [[0]*w for _ in range(h)]\n  D = [[0]*w for _ in range(h)]\n  for i in range(h):\n    for j in range(w):\n      if j > 0:\n        if S[i][j-1] == \".\":\n          L[i][j] = L[i][j-1]+1\n        if S[i][w-j] == \".\":\n          R[i][w-1-j] = R[i][w-j]+1\n      if i > 0:\n        if S[i-1][j] == \".\":\n          U[i][j] = U[i-1][j]+1\n        if S[h-i][j] == \".\":\n          D[h-1-i][j] = D[h-i][j]+1\n  ans = 0\n  for i in range(h):\n    for j in range(w):\n      if S[i][j] == \".\":\n        temp = L[i][j]+R[i][j]+U[i][j]+D[i][j]+1\n        ans = max(ans, temp)\n  print(ans)\n\nif __name__ == \"__main__\":\n  main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":238,"bad_solution":"#!python3\n\nimport sys\niim = lambda: map(int, sys.stdin.readline().rstrip().split())\nfrom bisect import bisect\n\ndef resolve():\n    it = map(int, sys.stdin.read().split())\n    N, Q = next(it), next(it)\n    C = [next(it) for i in range(N)]\n    D = list(zip(it, it, range(Q)))\n\n    D.sort(key=lambda x: (x[1], x[0]), reverse=True)\n\n    C1 = [[-1, []] for i in range(N)]\n    rx = D[0][1]\n    for i, ci in zip(range(rx), C):\n        x = C1[ci-1]\n        x[1].append(x[0])\n        x[0] = i\n    C2 = C1[:]\n    C2.sort()\n\n    ans = [0] * Q\n    rj = rx\n    for li, ri, i in D:\n        if ri < rj:\n            for j in reversed(range(ri, rj)):\n                cj = C[j] - 1\n                x = C1[cj]\n                x[0] = x[1].pop()\n            C2.sort()\n            rj = ri\n\n        k = bisect(C2, [li-1,])\n        ans[i] = N - k\n\n    print(*ans, sep=\"\\n\")\n\n\nif __name__ == \"__main__\":\n    resolve()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":239,"bad_solution":"\n\ndef FUNC(s: str):\n    \"\"\"\n    returns encoded string by cycling groups of three characters.\n    \"\"\"\n    # split string to groups. Each of length 3.\n    groups = [s[(3 * i):min((3 * i + 3), len(s))] for i in range((len(s) + 2) \/\/ 3)]\n    # cycle elements in each group. Unless group has fewer elements than 3.\n    groups = [(group[1:] + group[0]) if len(group) == 3 else group for group in groups]\n    return \"\".join(groups)\n\n\ndef FUNC(s: str):\n    \"\"\"\n    takes as input string encoded with FUNC function. Returns decoded string.\n    \"\"\"\n    return FUNC(s)\n"}
{"id":240,"bad_solution":"class Unification:\n    def __init__(self, cube: list):\n        self.cube = cube\n\n    def calc(self):\n        ans = 0\n        i = 0\n        while i < len(self.cube) - 1:\n            if self.cube[i] != '-' and self.cube[i] != self.cube[i + 1]:\n                ans += 2\n                self.erase(i)\n                self.erase(i + 1)\n            i += 1\n        print(ans)\n\n    def erase(self, i: int):\n        drop_cube = i - 2\n        if drop_cube < 0:\n            self.cube[i] = '-'\n        else:\n            self.cube[i] = self.cube[drop_cube]\n    \n\nS = list(input())\nS.reverse()\ncube = Unification(S)\ncube.calc()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":241,"bad_solution":"import sys\nfrom collections import deque\n\ndef main():\n\n    input = sys.stdin.readline\n\n    H,W = map(int,input().split())\n    Ch,Cw = map(int,input().split())\n    Dh,Dw = map(int,input().split())\n\n    S=[list(map(str,list(input()[:-1]))) for i in range(H)]\n    F=[ [-1] * W for i in range(H)]\n    dist=[ [10000000] * W for i in range(H)]\n\n    dh = (1, 0, -1, 0)\n    dw = (0, 1, 0, -1)\n    warph = (2, 2, 2, 2 ,2,1,1,1,1,0,0,-1,-1,-1,-1,-2,-2,-2,-2,-2)\n    warpw = (-2, -1, 0, 1,2,-2,-1,1,2,-2,2,-2,-1,1,2,-2,-1,0,1,2)\n\n    d = deque()\n\n    d.append((Ch-1,Cw-1))\n\n    F[Ch-1][Cw-1] = 0\n    dist[Ch-1][Cw-1] = 0\n\n    while len(d) > 0:\n        Ph,Pw = d.popleft()\n\n        # if (Ph == Dh-1) & (Pw == Dw-1):\n        #     goal = True\n        #     break\n\n        for i in range(4):\n            nh = Ph + dh[i]\n            nw = Pw + dw[i]\n            if (nh < 0) | (nh >= H) | (nw < 0) | (nw >= W):\n                continue\n            if S[nh][nw] == \"#\":\n                continue\n            if F[nh][nw] == -1:\n                d.append((nh,nw))\n                F[nh][nw] = 0\n\n            dist[nh][nw] = min(dist[nh][nw],dist[Ph][Pw])\n\n        for i in range(20):\n            nh = Ph + warph[i]\n            nw = Pw + warpw[i]\n            if (nh < 0) | (nh >= H) | (nw < 0) | (nw >= W):\n                continue\n            if S[nh][nw] == \"#\":\n                continue\n            if F[nh][nw] == -1:\n                d.append((nh,nw))\n                F[nh][nw] = 0\n            dist[nh][nw] = min(dist[nh][nw],dist[Ph][Pw]+1)\n\n    if dist[Dh-1][Dw-1] >= 10000000:\n        print(\"-1\")\n    else:\n        print(dist[Dh-1][Dw-1])\n         \n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":242,"bad_solution":"def main():\n    H, W = map(int, input().split())\n    grid = [list(input()) for _ in range(H)]\n    L = [[0] * W for _ in range(H)]\n    R = [[0] * W for _ in range(H)]\n    D = [[0] * W for _ in range(H)]\n    U = [[0] * W for _ in range(H)]\n    for h in range(H):\n        for w in range(W):\n            if grid[h][w] == '#':\n                continue\n            if w == 0:\n                L[h][w] = 1\n            else:\n                L[h][w] = L[h][w-1] + 1\n            if h == 0:\n                U[h][w] = 1\n            else:\n                U[h][w] = U[h-1][w] + 1\n    for h in range(H - 1, -1, -1):\n        for w in range(W - 1, -1, -1):\n            if grid[h][w] == '#':\n                continue\n            if w == W - 1:\n                R[h][w] = 1\n            else:\n                R[h][w] = R[h][w + 1] + 1\n            if h == H - 1:\n                D[h][w] = 1\n            else:\n                D[h][w] = D[h + 1][w] + 1\n    ans = 0\n    for h in range(H):\n        for w in range(W):\n            ans = max(ans, L[h][w] + R[h][w] + U[h][w] + D[h][w] - 3)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":243,"bad_solution":"def main():\n    import sys\n    from collections import deque\n\n    input = sys.stdin.readline\n    sys.setrecursionlimit(1000000)\n\n    n = int(input())\n\n    E = [[] for i in range(n)]\n    for i in range(n-1):\n        a, b = map(int, input().split())\n        E[a-1].append(b-1)\n        E[b-1].append(a-1)\n\n    mod = 10 ** 9 + 7\n    N = n + 1\n\n    #逆元テーブル\n    inv_t = [0]+[1]\n    for i in range(2, N):\n        inv_t += [inv_t[mod % i] * (mod - int(mod \/ i)) % mod]\n\n    #階乗計算\n    kai = [1, 1]\n    rev_kai = [1, inv_t[1]]\n    for i in range(2, N):\n        kai.append(kai[-1] * i % mod)\n        rev_kai.append(rev_kai[-1] * inv_t[i] % mod)\n\n    # コンビネーション計算\n    def cmb(n, r):\n        return kai[n] * rev_kai[r] * rev_kai[n-r] % mod\n\n    down = [{} for i in range(n+1)]\n    up = [0 for i in range(n+1)]\n\n    def dfs_down(cur, pre):\n        if E[cur] == [pre]:\n            down[pre][cur] = [1, 1]\n        ns = []\n        cnt = 1\n        ns_append = ns.append\n        for e in E[cur]:\n            if e != pre:\n                if e not in down[cur]:\n                    dfs_down(e, cur)\n                ni, cnti = down[cur][e]\n                ns_append(ni)\n                cnt = cnt * cnti % mod\n        s = sum(ns)\n        S = s\n        for ni in ns:\n            cnt = cnt * cmb(s, ni) % mod\n            s -= ni\n        down[pre][cur] = [S+1, cnt]\n\n    def dfs_up(cur, pre):\n        stack = deque([[cur, pre]])\n        while stack:\n            cur, pre = stack.pop() \n            if cur != 0:\n                ns = []\n                cnt = 1\n                ns_append = ns.append\n                if up[pre]:\n                    ni, cnti = up[pre]\n                    ns_append(ni)\n                    cnt = cnt * cnti % mod\n                bros = down[pre]\n                for bro in bros:\n                    if bro != cur:\n                        ni, cnti = bros[bro]\n                        ns_append(ni)\n                        cnt = cnt * cnti % mod\n                s = sum(ns)\n                S = s\n                for ni in ns:\n                    cnt = cnt * cmb(s, ni) % mod\n                    s -= ni\n                up[cur] = [S+1, cnt]\n            for e in E[cur]:\n                if e != pre:\n                    stack.append([e, cur])\n\n\n    dfs_down(0, n)\n    dfs_up(0, n)\n\n\n    for i in range(n):\n        ns = []\n        cnt = 1\n        ns_append = ns.append\n        if up[i]:\n            ni, cnti = up[i]\n            ns_append(ni)\n            cnt = cnt * cnti % mod\n        for bro in down[i]:\n            ni, cnti = down[i][bro]\n            ns_append(ni)\n            cnt = cnt * cnti % mod\n        s = sum(ns)\n        for ni in ns:\n            cnt = cnt * cmb(s, ni) % mod\n            s -= ni\n        print(cnt)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":244,"bad_solution":"import sys\ninput = sys.stdin.readline\nN = int(input())\nS = input().rstrip()\nQ = int(input())\nqs = [input().split() for i in range(Q)]\n\ndef ctoi(c):\n    return ord(c) - ord('a')\n\nbit = [[0]*(N+2) for _ in range(26)]\ndef bit_add(x,w,ci):\n    while x <= N+1:\n        bit[ci][x] += w\n        x += (x & -x)\ndef bit_sum(x,ci):\n    ret = 0\n    while x > 0:\n        ret += bit[ci][x]\n        x -= (x & -x)\n    return ret\n\nfor i,c in enumerate(S):\n    bit_add(i+1,1,ctoi(c))\n\ns = list(S)\nans = []\nfor a,b,c in qs:\n    if a=='1':\n        x = int(b)\n        bit_add(x,1,ctoi(c))\n        bit_add(x,-1, ctoi(s[x-1]))\n    else:\n        tmp = 0\n        for i in range(26):\n            if bit_sum(int(c),i) - bit_sum(int(b)-1,i) > 0:\n                tmp += 1\n        ans.append(tmp)\nprint(*ans, sep='\\n')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":245,"bad_solution":"def main():\n    n, k = map(int, input().split())\n    s = list(input())\n    count = []\n    for i in range(n):\n        if i == 0:\n            count.append([s[i], 1])\n        elif s[i] == count[-1][0]:\n            count[-1][1] += 1\n        else:\n            count.append([s[i], 1])\n    answer = 0\n    reverse = {\"L\": \"R\", \"R\": \"L\"}\n    change = 0\n    last_seen = 0\n    for i in range(1, len(count), 2):\n        if k <= change:\n            break\n        else:\n            count[i][0] = reverse[count[i][0]]\n            change += 1\n            last_seen = i\n    for i in range(len(count)):\n        if count[i][0] == count[0][0]:\n            answer += count[i][1]\n        else:\n            break\n    if last_seen + 1 == len(count):\n        answer -= 1\n    print(answer)\n\n\nif __name__ == '__main__':\n    main()\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":246,"bad_solution":"import sys\nsys.setrecursionlimit(10000000)\ndef input():\n    return sys.stdin.readline()[:-1]\nfrom math import log\nfrom bisect import *\nfrom collections import *\nfrom heapq import *\nmod = 10**9+7\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n>>1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c>>2) & 0x3333333333333333)\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c>>4) & 0x0f0f0f0f0f0f0f0f)\n    c = (c & 0x00ff00ff00ff00ff) + ((c>>8) & 0x00ff00ff00ff00ff)\n    c = (c & 0x0000ffff0000ffff) + ((c>>16) & 0x0000ffff0000ffff)\n    c = (c & 0x00000000ffffffff) + ((c>>32) & 0x00000000ffffffff)\n    return c\n\nN = int(input())\nedges = [[] for i in range(N)]\nedge_id = defaultdict(lambda : -1)\nfor i in range(N-1):\n    a, b = map(lambda x: int(x)-1, input().split())\n    edges[a].append(b)\n    edges[b].append(a)\n    edge_id[(a, b)] = edge_id[(b, a)] = i\npath = defaultdict(lambda : -1)\n\ndef set_path(r, v, path_):\n    visited[v] = 1\n    path[(r, v)] = path_\n    for u in edges[v]:\n        if visited[u] == 0:\n            set_path(r, u, path_ | (1 << edge_id[(v, u)]))\n\nfor i in range(N):\n    visited = [0] * N\n    set_path(i, i, 0)\nM = int(input())\nuv = [list(map(lambda x: int(x)-1, input().split())) for i in range(M)]\nans = pow(2, N-1)\nfor i in range(1, 1 << M):\n    all_path = 0\n    for j, (u, v) in enumerate(uv):\n        if i & (1 << j):\n            all_path |= path[(u, v)]\n    if popcnt(i) & 1:\n        ans -= pow(2, N-1-popcnt(all_path))\n    else:\n        ans += pow(2, N-1-popcnt(all_path))\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":247,"bad_solution":"def main():\n    \n    h,w = map(int,input().split())\n    l = [list(input()) for i in range(h)]\n\n    c = [[[-1]*2 for i in range(w)] for i in range(h)]\n\n    for i in range(h):\n        for j in range(w):\n            if c[i][j][0] == -1:\n                n = 0\n                while i+n < h and l[i+n][j] == \".\":\n                    n += 1\n                for k in range(n):\n                    c[i+k][j][0] = n\n                \n            if c[i][j][1] == -1:\n                n = 0\n                while j+n < w and l[i][j+n] == \".\":\n                    c[i][j+n][1] = 1\n                    n += 1\n                for k in range(n):\n                    c[i][j+k][1] = n\n\n\n            \n    ans = 0\n    for i in range(h):\n        for j in range(w):\n            if l[i][j] == \".\":\n                ans = max(ans,c[i][j][0]+c[i][j][1])\n    print(ans-1)\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":248,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nfrom collections import deque\nfrom math import inf\n\n\ndef input(): return sys.stdin.readline().strip()\n\n\ndef bfs(maze, Ch, Cw, Dh, Dw, H, W):\n    visited = [[inf] * W for i in range(H)]\n    queue = deque([[Ch, Cw]])\n    visited[Ch][Cw] = 0\n\n    dy_dx0 = [[0, 1], [1, 0], [0, -1], [-1, 0]]\n    dy_dx1 = [[2, 2], [2, 1], [2, 0], [2, -1], [2, -2], [1, 2], [1, 1], [1, -1], [1, -2], [0, 2],\n              [0, -2], [-1, 2], [-1, 1], [-1, -1], [-1, -2], [-2, 2], [-2, 1], [-2, 0], [-2, -1], [-2, -2]]\n\n    while queue:\n        y, x = queue.popleft()\n        if [y, x] == [Dh, Dw]:\n            break\n        for j, k in dy_dx0:\n            new_y, new_x = y + j, x + k\n            if 0 <= new_y < H and 0 <= new_x < W:\n                if maze[new_y][new_x] == \".\" and visited[y][x] < visited[new_y][new_x]:\n                    visited[new_y][new_x] = visited[y][x]\n                    queue.appendleft([new_y, new_x])\n        for j, k in dy_dx1:\n            new_y, new_x = y + j, x + k\n            if 0 <= new_y < H and 0 <= new_x < W:\n                if maze[new_y][new_x] == \".\" and visited[new_y][new_x] == inf:\n                    visited[new_y][new_x] = visited[y][x] + 1\n                    queue.append([new_y, new_x])\n    return visited[Dh][Dw]\n\n\ndef main():\n    H, W = map(int, input().split())\n    Ch, Cw = map(int, input().split())\n    Dh, Dw = map(int, input().split())\n    maze = [input() for i in range(H)]\n\n    dist = bfs(maze, Ch - 1, Cw - 1, Dh - 1, Dw - 1, H, W)\n    print(dist if dist != inf else -1)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":249,"bad_solution":"import sys,collections as cl,bisect as bs,heapq\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #intのlist\n    return list(map(int,input().split()))\ndef m(): #複数文字\n    return map(int,input().split())\ndef onem(): #Nとかの取得\n    return int(input())\ndef s(x): #圧縮\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #listをスペースごとに分ける\n    return \" \".join(map(str,x))\ndef max2(x): #他のときもどうように作成可能\n    return max(map(max,x))\ndef In(x,a): #aがリスト(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\"\"\"\ndef nibu(x,n,r):\n    ll = 0\n    rr = r\n    while True:\n        mid = (ll+rr)\/\/2\n\n    if rr == mid:\n        return ll\n    if (ここに評価入れる):\n        rr = mid\n    else:\n        ll = mid+1\n\"\"\"\n\nn = onem()\n\na = l()\n\nse = [1 for i in range(n)]\nmo = [1 for i in range(n)]\n\n\npo = []\n\nfor i in range(n):\n    for j in range(n):\n        if i != j:\n            heapq.heappush(po,[-(a[j]) * abs(j-i),i,j])\nco = 0\n\nfor i in range(len(po)):\n    on = heapq.heappop(po)\n    if mo[on[1]] and se[on[2]]:\n        \n        co -= on[0]\n        mo[on[1]] = 0\n        se[on[2]] = 0\n\nprint(co)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":250,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nimport copy\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(10000)\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(N, M, A):\n    c = [\n        -1,\n        2, # 1 \n        5, # 2\n        5, # 3\n        4, # 4\n        5, # 5\n        6, # 6\n        3, # 7\n        7, # 8\n        6, # 9\n        ]\n    \n    if (2 in A or 3 in A) and 5 in A:\n        A.remove(2)\n        A.remove(3)\n    if 2 in A and 3 in A:\n        A.remove(2)\n    if 6 in A and 9 in A:\n        A.remove(6)\n\n\n\n    dp = [None] * (N+1) \n    dp[N] = (0, Counter())\n    for i in range(N, 0, -1):\n        if dp[i] is None:\n            continue\n        \n        for a in A:\n            if i - c[a] < 0:\n                continue\n            \n            if dp[i-c[a]] is None:\n                c_ = copy.copy(dp[i][1])\n                c_[a] += 1\n                dp[i-c[a]] =  (dp[i][0]+1, c_)\n            \n            elif dp[i][0]+1 > dp[i-c[a]][0]:\n                c_ = copy.copy(dp[i][1])\n                c_[a] += 1\n                dp[i-c[a]] =  (dp[i][0]+1, c_)\n    # print(0, dp[0])\n\n    ans = \"\"\n    for r in  sorted(dp[0][1], reverse=True):\n        ans += str(r) * dp[0][1][r]\n    return ans\n\n\ndef main():\n    # N = read_int()\n    N, M = read_int_n()\n    A = read_int_n()\n    print(slv(N, M, A))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":251,"bad_solution":"\n\ndef FUNC(n: int):\n    \"\"\"\n    FUNC returns n-th number that is a Fibonacci number and it's also prime.\n    >>> FUNC(1)\n    2\n    >>> FUNC(2)\n    3\n    >>> FUNC(3)\n    5\n    >>> FUNC(4)\n    13\n    >>> FUNC(5)\n    89\n    \"\"\"\n    import math\n\n    def FUNC(p):\n        if p < 2:\n            return False\n        for k in range(2, min(int(math.sqrt(p)), p)):\n            if p % k == 0:\n                return False\n        return True\n    f = [0, 1]\n    while True:\n        f.append(f[-1] + f[-2])\n        if FUNC(f[-1]):\n            n -= 1\n        if n == 0:\n            return f[-1]\n"}
{"id":252,"bad_solution":"L = 50\n\ndef get_binary_str(n: int) -> str:\n    binary = bin(n)[2:]\n    padding_length = L - len(binary)\n    return '0' * padding_length + binary\n\ndef get_first_one_pos(s: str) -> int:\n    i = 0\n    while i < len(s) and s[i] == '0':\n        i += 1\n    return i\n\ndef xor(x: int, y: int) -> int:\n    if x == y:\n        return 0\n    else:\n        return 1\n\ndef calc_xor(i: int, x: int, binary_As) -> int:\n    ret = 0\n    for binary_A in binary_As:\n        ret += xor(x, int(binary_A[i]))\n    return ret\n\n\nN, K = list(map(int, input().split(' ')))\nAs = list(map(int, input().split(' ')))\n\nbinary_As = [get_binary_str(A) for A in As]\nbinary_K = get_binary_str(K)\none_pos = get_first_one_pos(binary_K)\n\ni = 0\nret = 0\nwhile i < one_pos:\n    ret += calc_xor(i, 0, binary_As) * 2**(L-i-1)\n    i += 1\n\nwhile i < L:\n    a = calc_xor(i, 0, binary_As)\n    b = calc_xor(i, 1, binary_As)\n    ret += a * 2**(L-i-1) if a > b else b * 2**(L-i-1)\n    i += 1\n\nprint(ret)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":253,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\nfrom collections import defaultdict,deque\nfrom heapq import heappush,heappop,heapify\n\nN=input()\nAL=defaultdict(lambda: set())\nIN=defaultdict(lambda: 0)\nBEGIN=set()\n\nfor i in range(N):\n\tA=map(int, sys.stdin.readline().split())\n\tfor j in range(N-2):\n\t\tx=i+1\n\t\tx_next=i+1\n\t\ty=A[j]\n\t\ty_next=A[j+1]\n\t\t#print x,y,x_next,y_next\n\t\tif x>y: x,y=y,x\n\t\tif x_next>y_next: x_next,y_next=y_next,x_next\n\t\tIN[(x_next,y_next)]+=1\n\t\tAL[(x,y)].add((x_next,y_next))\n\n\t\tif j==0:\n\t\t\tBEGIN.add((x,y))\n\nhq=[]\n\nfor x,y in BEGIN:\n\tif IN[(x,y)]==0:\n\t\theappush(hq, (0,x,y))\n\n\nDAY=defaultdict(lambda: 1)\t#距離\n\nans=-1\nwhile hq:\n\tcost,fro_x,fro_y=heappop(hq)\n\tfro=(fro_x,fro_y)\n\tfor to in AL[fro]:\n\t\talt=DAY[fro]+1\n\t\tif DAY[to]<alt:\n\t\t\tans=max(ans,alt)\n\t\t\tDAY[to]=alt\n\t\t\theappush(hq,(alt,to[0],to[1]))\n\nprint ans\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":254,"bad_solution":"from math import gcd\n\n\nclass Eratosthenes(): # エラトステネスの篩\n    def __init__(self, N) # 素数リスト生成 O(n*log(log n))\n        is_prime = [0, 0] + [1] * (N - 1)\n        for i in range(int(N**0.5) + 1):\n            if is_prime[i] == 0:\n                continue\n            for j in range(i * 2, N + 1, i):\n                is_prime[j] = 0\n        self.prime_list = [i for i, pi in enumerate(is_prime) if pi == 1]\n\n\n    def factor(self, NUM):  # 高速素因数分解 O(log num)\n        PRIME = set()\n        for p in self.prime_list:\n            if p * p > NUM:\n                break\n            while NUM % p == 0:\n                NUM \/\/= p\n                PRIME.add(p)\n        if NUM > 1:\n            PRIME.add(NUM)\n        return PRIME\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor ai in a:\n    ans = gcd(ans, ai)\nif ans != 1:\n    print('not coprime')\n    exit()\n\nera = Eratosthenes(max(a))\nnum = set()\nfor ai in a:\n    prime = era.factor(ai)\n    if len(prime & num) > 0:\n        print('setwise coprime')\n        break\n    num |= prime\nelse:\n    print('pairwise coprime')\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":255,"bad_solution":"import sys\nimport bisect\nfrom operator import itemgetter\n\ninput = sys.stdin.readline\n\n\ndef main():\n    N, D, A = [int(x) for x in input().split()]\n    XH = []\n    X = []\n    for _ in range(N):\n        x, h = [int(x) for x in input().split()]\n        XH.append([x, h, float(\"inf\")])\n        XH.append([x + 2 * D + 1, float(\"inf\"), 0])\n        X.append(x)\n        X.append(x + 2 * D + 1)\n\n    X.sort()\n    XH.sort(key=itemgetter(0))\n\n    ans = 0\n    ruiseki = 0\n\n    for x, h, r in XH:\n        if h != float(\"inf\"):\n            if h > ruiseki:\n                tmpruiseki = -(-(h - ruiseki) \/\/ A) * A\n                ans += -(-(h - ruiseki) \/\/ A)\n                ruiseki += tmpruiseki\n                nx = bisect.bisect_left(X, x + 2 * D + 1)\n                if XH[nx][1] == float(\"inf\"):\n                    XH[nx][2] -= tmpruiseki\n                elif XH[nx + 1][1] == float(\"inf\"):\n                    XH[nx + 1][2] -= tmpruiseki\n                else:\n                    XH[nx + 2][2] -= tmpruiseki\n            else:\n                continue\n        else:\n            ruiseki += r\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":256,"bad_solution":"import sys\nsys.setrecursionlimit(500000)\n\nimport sys\ndef input():\n    return sys.stdin.readline()[:-1]\n\nH, W = map(int, input().split())\nCH, CW = map(int, input().split())\nDH, DW = map(int, input().split())\nS = [list(input()) for i in range(H)]\n \nfrom collections import deque\n \nq = deque([(CH-1, CW-1)])\n \ndirections = [(1, 0), (-1, 0), (0, 1), (0, -1)]\nwarp = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2), (-1, -2), (-1, -1), (-1, 1), (-1, 2), (0, -2), (0, 2), (1, -2), (1, -1), (1, 1), (1, 2), (2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] == \".\":\n            S[i][j] = 10**7\nS[CH-1][CW-1] = 0\n\nwhile q:\n    h, w = q.popleft()\n    for dh, dw in directions:\n        if 0 <= h+dh < H and 0 <= w+dw < W and S[h+dh][w+dw] != \"#\":\n            if S[h+dh][w+dw] > S[h][w]:\n                S[h+dh][w+dw] = S[h][w]\n                q.append((h+dh, w+dw))\n    for wh, ww in warp:\n        if 0 <= h+wh < H and 0 <= w+ww < W and S[h+wh][w+ww] != \"#\":\n            if S[h+wh][w+ww] > S[h][w] + 1:\n                S[h+wh][w+ww] = S[h][w] + 1\n                q.append((h+wh, w+ww))\n \nif S[DH-1][DW-1] == 10**7:\n    print(-1)\nelse:\n    print(S[DH-1][DW-1])\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":257,"bad_solution":"from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nfrom bisect import bisect_right, bisect_left\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nfrom re import split\nimport sys\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor, gamma, log\nfrom operator import mul\nfrom functools import reduce\nfrom copy import deepcopy\nimport re\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 20\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nh, w, k = LI()\ns = SRL(h)\nans = INF\nfor bits in range(2 ** (h - 1)):\n    res = sum([int(j) for j in f'{bits:b}'])\n    div_cnt = res + 1\n    cnt = [0] * div_cnt\n    x = 0\n    flg = 0\n    while x < w:\n        cur = 0\n        for y in range(h):\n            if s[y][x] == '1':\n                cnt[cur] += 1\n            if bits >> y & 1:\n                cur += 1\n        if max(cnt) > k:\n            if flg == 0:\n                break\n            else:\n                cnt = [0] * div_cnt\n                flg = 0\n                res += 1\n        else:\n            flg = 1\n            x += 1\n    ans = min(ans, res)\n\n\nprint(ans)\n\n\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":258,"bad_solution":"import numpy as np\n\nH, W = map(int, input().split())\n\nmaze_x = [input() for _ in range(H)]\nmaze_y = [''.join(x) for x in zip(*maze_x)]\n\ndef count_light(maze, W, H):\n    cnt = [[0]*W for _ in range(H)]\n    for hh in range(H):\n        lst1 = [i for i in maze[hh].split('#') if i != '']\n        lst2 = [i for i in maze[hh].split('.') if i != '']\n        lst2.append('#')\n        ww = 0\n        k1 = 0\n        k2 = 0\n        if maze[hh][0]=='#':\n            ww += len(lst2[0])\n            k2 += 1\n          \n        while len(lst1)>k1:\n            ln = len(lst1[k1])\n            cnt[hh][ww:ww+ln] = [ln]*ln\n            k1 += 1\n\n            ln = len(lst2[k2])\n            cnt[hh][ww:ww+ln] = [0]*ln\n            k2 += 1\n            ww += ln\n    return cnt\ncnt = (np.array(count_light(maze_x, W, H)) + np.array(count_light(maze_y, H, W)).T -1)\n\nprint(max([max(cnt[i]) for i in range(H)]))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":259,"bad_solution":"import heapq\n\ndef binary_search(data, value):\n    left = 0            # 探索する範囲の左端を設定\n    right = len(data) - 1            # 探索する範囲の右端を設定\n    while left <= right:\n        mid = (left + right) \/\/ 2            # 探索する範囲の中央を計算\n        if data[mid] == value:\n            # 中央の値と一致した場合は位置を返す\n            return mid\n        elif data[mid] < value:\n            # 中央の値より大きい場合は探索範囲の左を変える\n            left = mid + 1\n        else:\n            # 中央の値より小さい場合は探索範囲の右を変える\n            right = mid - 1\n    return -1            # 見つからなかった場合\n\nn, k = map(int, input().split())\na = list(map(lambda x: int(x) - 1, input().split()))\nway = [0]\nhq = [0]\nheapq.heapify(hq)\nposi = 0\ncycle = 0\nwhile True:\n    if binary_search(hq, a[posi]) != -1:\n        rest = way.index(a[posi])\n        cycle -= (rest - 1)\n        break\n    way.append(a[posi])\n    heapq.heappush(hq, a[posi])\n    posi = a[posi]\n    cycle += 1\n# print(way)\n# print(cycle)\nif k < rest:\n    print(way[k])\nelse:\n    print(way[(k-rest) % cycle + rest] + 1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":260,"bad_solution":"#Code by Sounak, IIESTS\n#------------------------------warmup----------------------------\n\nimport os\nimport sys\nimport math\nfrom io import BytesIO, IOBase\nfrom fractions import Fraction\nimport collections\nfrom itertools import permutations\nfrom collections import defaultdict\n\n\nBUFSIZE = 8192\n \n \nclass FastIO(IOBase):\n    newlines = 0\n    \n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n     \n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n \n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n \n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n \n \nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n  \nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n#-------------------game starts now-----------------------------------------------------\nmod=10**9+7\nn=int(input())\na=list(map(int,input().split()))\na.sort()\ng=a[0]\nfor i in a:\n    g=math.gcd(g,i)\nd=dict()\nfor i in a:\n    if i%2==0:\n        if 2 in d:\n            d[2]+=1\n        else:\n            d[2]=1\n    while i%2==0:\n        i\/\/=2\n    for j in range (3, int(math.sqrt(i))+1 ):\n        if i%j==0:\n            if j in d:\n                d[j]+=1\n            else:\n                d[j]=1\n            while i%j==0:\n                i\/\/=j\n    if i>2:\n        if i in d:\n            d[i]+=1\n        else:\n            d[i]=1\nc=1\nfor i in d:\n    c=max(c,d[i])\nif c==1:\n    print(\"pairwise coprime\")\nelif g==1:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":261,"bad_solution":"from math import ceil\n\nN, K = map(int, input().split())\nA = sorted(list(map(int, input().split())), reverse=True)\nF = sorted(list(map(int, input().split())))\n\ndef is_valid(A, F, K, T):\n    for a, f in zip(A, F):\n        if a*f > T:\n\n            k = ceil(a - T\/f)\n            if k <= K:\n                K -= k\n            else:\n                return False\n    return True\n\ndef solve(N, K, A, F):\n    i = 0\n    left, right = 0, 10**12\n\n    while left < right:\n        mid = (left + right) \/\/ 2\n\n        if is_valid(A, F, K, mid):\n            right = mid\n        else:\n            left = mid + 1\n    return mid\n\n\n\nprint(solve(N, K, A, F))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":262,"bad_solution":"import itertools\nK=int(input())\nX,Y=map(int,input().split())\nMdist=abs(X)+abs(Y)\nif Mdist%2==1 and K%2==0:\n    print(-1)\n    exit()\n    #K:偶数ならマンハッタン距離が偶数の点にしか行けない\n    #逆にKが偶数ならマンハッタン距離が偶数の任意の点に行ける\n    #K:奇数なら理論上どこでも行ける\n    #よってこれ以外のパターンは全部可能\n    #(0,0)->(2n+1,0)->(n+1,n+1)->(1,0)\n#K:奇数のとき、移動回数と距離がmod2 で合同\ndef searcheven(x,y):\n    if abs(x)+abs(y)>2*K:\n        return None\n    if (abs(x)+abs(y))%2==1:\n        return None\n    for ps in itertools.product([-1,1],repeat=4):\n        p1,p2,p3,p4=ps\n        if p1*p4==p2*p3:\n            if p3*(K-p1*x-p2*y)==-p1*K:\n                a,b=0,p4*K\n                if abs(x-a)+abs(y-b)==K and abs(a)+abs(b)==K:\n                    return (a,b)\n                a,b=p3*K,0\n                if abs(x-a)+abs(y-b)==K and abs(a)+abs(b)==K:\n                    return (a,b)\n            else:\n                pass\n        else:\n            tmp1=K-p1*x-p2*y\n            tmp2=K\n            tmp3=p4*tmp1+p2*tmp2\n            tmp4=-p3*tmp1-p1*tmp2\n            det=-p1*p4+p2*p3\n            a,b=(tmp3\/\/det,tmp4\/\/det)\n            if abs(x-a)+abs(y-b)==K and abs(a)+abs(b)==K:\n                return (a,b)\n            else:\n                pass\n    return None\n\nans=[(0,0)]\nwhile(True):\n    nx,ny=ans[-1]\n    if abs(nx)+K<=abs(X):\n        if X<0:\n            ans.append((nx-K,ny))\n            continue\n        else:\n            ans.append((nx+K,ny))\n            continue\n    elif abs(ny)+K<=abs(Y):\n        if Y<0:\n            ans.append((nx,ny-K))\n            continue\n        else:\n            ans.append((nx,ny+K))\n            continue\n    else:\n        if (abs(nx-X)+abs(ny-Y))%2==0:\n            p,q=searcheven(X-nx,Y-ny)\n            ans.append((p+nx,q+ny))\n            ans.append((X,Y))\n            break\n        else:\n            tmpx=K\/\/2\n            tmpy=K-tmpx\n            nextkouho=[(tmpx,tmpy),(tmpx,-tmpy),(-tmpx,tmpy),(-tmpx,-tmpy),(K,0),(-K,0),(0,K),(0,-K)]\n            for point in nextkouho:\n                ptmp,qtmp=point\n                p=ptmp+nx;q=qtmp+ny\n                if abs(X-p)+abs(Y-q)<=2*K:\n                    ans.append((p,q))\n                    break\n            \n\n#print(ans)\ns=len(ans)-1\nflag=1\nfor i in range(s):\n    ax,ay=ans[i]\n    bx,by=ans[i+1]\n    if abs(ax-bx)+abs(ay-by)==K:\n        pass\n    else:\n        flag=0\n        break\nif flag==0:\n    print(\"NG\")\nprint(s)\nfor i in range(1,s+1):\n    print(ans[i][0],ans[i][1])\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":263,"bad_solution":"from collections import defaultdict\n\nN = int(input())\nA = list(map(int, input().split()))\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5\/\/1))+1):\n        if temp%i==0:\n            cnt=0\n            while temp%i==0:\n                cnt+=1\n                temp \/\/= i\n            arr.append([i, cnt])\n\n    if temp!=1:\n        arr.append([temp, 1])\n\n    if arr==[]:\n        arr.append([n, 1])\n\n    return arr\n\nf_dict = defaultdict(int)\n\nfor a in A:\n    fct = factorization(a)\n    for a, _ in fct:\n        f_dict[a] += 1\n\nflag = True\n\nfor k, v in f_dict.items():\n    if v == N:\n        print('not coprime')\n        exit()\n    if v > 1:\n        flag = False\n\nif flag:\n    print('pairwise coprime')\nelse:\n    print('setwise coprime')\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":264,"bad_solution":"import sys\nimport re\nfrom math import ceil, floor, sqrt, pi, factorial, gcd\nfrom copy import deepcopy\nfrom collections import Counter, deque\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, product, combinations, combinations_with_replacement\nfrom bisect import bisect, bisect_left, bisect_right\nfrom functools import reduce\nfrom decimal import Decimal, getcontext\n# input = sys.stdin.readline\ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\nsys.setrecursionlimit(10 ** 6)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nnum_list = []\nstr_list = []\n\n\ndef main():\n    K=i_input()\n    a = []\n    \n    for i in range(0,K-1):\n        if(i==0):\n            a.append(7 % K)\n        else:\n            a.append((a[i-1]*10+7)%K)\n    \n    for i in range(0,len(a),1):\n        if(a[i] == 0):\n            print(i+1)\n            return\n\n    print(\"-1\")\n        \nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":265,"bad_solution":"from collections import Counter \n\nN = int(input())\nA = list(map(int, input().split()))\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n \/\/= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n \/\/= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\n\ncnt = [0] * (10 ** 6)\nfor i in A:\n    a = prime_factorize(i)\n    alist = list(Counter(a).keys())\n    for j in alist:\n        cnt[j] += 1\n\nans = max(cnt)\nif ans == 1:\n    print(\"pairwise coprime\")\nelif ans == len(A):\n    print(\"not coprime\")\nelse:\n    print(\"setwise coprime\")\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":266,"bad_solution":"# python には結構厳しいTLE・・・python以外のお勉強時間ないよ～( ;∀;)\n# . から見た # の最大距離の方が楽ではあるが・・・\n# 嫌いだけど def main も使ってみた．\ndef main():\n  H, W = list(map(int, input().split()))\n  all_count = H * W\n  L = [j == \"#\" for i in range(H) for j in input()]\n  blacks = [i for i in range(all_count) if L[i]]\n  black_count = len(blacks)\n \n  cands_H = [-W, W]\n  cands_W = [-1, 1]\n  result = 0\n  while black_count < all_count:\n    next_steps = [black+cand for black in blacks for cand in cands_H if black >= W and black < all_count-W]\n    next_steps.extend([black-1 for black in blacks if black != 0 and black%W != 0])\n    next_steps.extend([black+1 for black in blacks if black != all_count-1 and black%W != W-1])\n    next_steps = set(next_steps)\n    blacks = [i for i in next_steps if not L[i]]\n    black_count += len(blacks)\n    result += 1\n    if black_count >= all_count:\n      break\n    for i in blacks:\n      L[i] = True\n \n  print(result)\n\nif __name__ == \"__main__\":\n  main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":267,"bad_solution":"import heapq\n\nclass job:\n    def __init__(self,name,date,award):\n        self.name=name\n        self.award=award\n        self.date=date\n    def __gt__(self,other):\n        return self.award<other.award\n    def __lt__(self,other):\n        return self.award>other.award\n    def __ge__(self,other):\n        return self.award<=other.award\n    def __le__(self,other):\n        return self.award>=other.award\njobs=[]\nn,m=[int(i) for i in input().split()]\nfor i in range(n):\n    info=[int(j) for j in input().split()]\n    jobs.append(job(i,info[0],info[1]))\nheapq.heapify(jobs)\nans=0\nfor i in range(m):\n    while jobs:\n        work=heapq.heappop(jobs)\n#         print(work.award)\n        if work.date+i<=m:\n            ans+=work.award\n            i+=1\n            break\n        \n        \nprint(ans)\n    \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":268,"bad_solution":"#!\/usr\/bin\/env pypy\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom __builtin__ import xrange as range\nfrom cStringIO import StringIO\nfrom future_builtins import ascii, filter, hex, map, oct, zip\nfrom io import IOBase\n\nimport __pypy__\n\n\ndef main():\n    n = int(input())\n    a = [int(input()) for _ in range(n)]\n    sa = sorted(a)\n\n    for i in range(n - 1):\n        if a[i] == sa[-1]:\n            print(sa[-2])\n        else:\n            print(sa[-1])\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastI(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = StringIO()\n        self.newlines = 0\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(\"\\n\") + (not b)\n            ptr = self._buffer.tell()\n            self._buffer.seek(0, 2), self._buffer.write(b), self._buffer.seek(ptr)\n        self.newlines -= 1\n        return self._buffer.readline()\n\n\nclass FastO(IOBase):\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self._buffer = __pypy__.builders.StringBuilder()\n        self.write = lambda s: self._buffer.append(s)\n\n    def flush(self):\n        os.write(self._fd, self._buffer.build())\n        self._buffer = __pypy__.builders.StringBuilder()\n\n\ndef print(*args, **kwargs):\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nsys.stdin, sys.stdout = FastI(sys.stdin), FastO(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":269,"bad_solution":"import bisect\ndef main():\n    N, Q = map(int, input().split())\n    C = list(map(int, input().split()))\n    E = []\n\n    D = {C[i]: -1 for i in range(N)}\n    for i in range(N):\n        if D[C[i]] == -1:\n            D[C[i]] = i\n        else:\n            E.append((D[C[i]], i, -1))\n            D[C[i]] = i\n\n    for i in range(Q):\n        l, r = map(int, input().split())\n        E.append((l - 1, r - 1, i))\n\n    def f(tup):\n        return tup[0]\n    E.sort(key=f, reverse=True)\n\n    ANS = [0] * Q\n    y_list = [500005]\n    for e in E:\n        ans = bisect.bisect_right(y_list, e[1])\n        if e[2] == -1:\n            y_list[ans] = e[1]\n        else:\n            ANS[e[2]] = e[1] - e[0] + 1 - ans\n\n    for i in range(Q):\n        print(ANS[i])\n\nif __name__ == '__main__':\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":270,"bad_solution":"import math\nA = ord('a')\nN = int(input())\nL = 2**int(math.ceil(math.log(N, 2)))\nS = [x for x in input()]\nQ = int(input())\n\nSeg = [0]*(L*2-1)\n\ndef order(c):\n    return 1 << (ord(c) - A)\n\ndef count(n):\n    return bin(n).count(\"1\")\n\ndef merge(x, y):\n    return x | y\n\ndef update(k, x):\n    k += L - 1\n    Seg[k] = x\n    while k > 0:\n        k = (k - 1) \/\/ 2\n        Seg[k] = merge(Seg[2*k+1], Seg[2*k+2])\n    Seg[0] = merge(Seg[1], Seg[2])\n\ndef find(a, b, k, l, r):\n    if r <= a or b <= l:\n        return 0\n    if a <= l and r <= b:\n        return Seg[k]\n    vl = find(a, b, 2*k+1, l, (l+r)\/\/2)\n    vr = find(a, b, 2*k+2, (l+r)\/\/2, r)\n\n    return merge(vl, vr)\n\n\n# read S, and update tree\nfor i in range(N):\n    c = order(S[i])\n    update(i, c)\n    #print(\"Seg\", *[count(x) for x in Seg])\n\nfor _ in range(Q):\n    q, i, c = input().split()\n    if q == '1':\n        i = int(i)-1\n        if S[i] == c:\n            continue\n        S[i] = c\n        update(i, order(S[i]))\n    else:\n        l, r = int(i)-1, int(c)\n        print(count(find(l, r, 0, 0, L)))\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":271,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"\n    FUNC takes a list of integers as an input.\n    it returns True if there are three distinct elements in the list that\n    sum to zero, and False otherwise.\n\n    >>> FUNC([1, 3, 5, 0])\n    False\n    >>> FUNC([1, 3, -2, 1])\n    True\n    >>> FUNC([1, 2, 3, 7])\n    False\n    >>> FUNC([2, 4, -5, 3, 9, 7])\n    True\n    >>> FUNC([1])\n    False\n    \"\"\"\n    for i in range(1, len(l)):\n        for j in range(i + 1, len(l)):\n            for k in range(j + 1, len(l)):\n                if l[i] + l[j] + l[k] == 0:\n                    return True\n    return False\n"}
{"id":272,"bad_solution":"import heapq\nfrom collections import defaultdict\n\nn, m, s = map(int, input().split())\n\nconnect = defaultdict(list)\nfor i in range(m):\n    u, v, a, b = map(int, input().split())\n    connect[u].append((v, a, b))\n    connect[v].append((u, a, b))\n\nc, d = [-1], [-1]\nfor i in range(n):\n    c_, d_ = map(int, input().split())\n    c.append(c_)\n    d.append(d_)\n\nans = [-1] * (n+1)\ndp = [{} for _ in range(n+1)]\n\nh = [(0, s, 1)]\nheapq.heapify(h)\n\nwhile heapq:\n    t, coin, city = heapq.heappop(h)\n\n    if ans[city] == -1:\n        ans[city] = t\n        if all([v >= 0 for v in ans[2:]]):\n            break\n\n    if coin not in dp[city]:\n        dp[city][coin] = t\n    else:\n        continue\n\n    for neighbor, a, b in connect[city]:\n        if coin - a >= 0 and neighbor != city:\n            heapq.heappush(h, (t+b, coin-a, neighbor))\n\n    heapq.heappush(h, (t+d[city], coin+c[city], city))\n\nprint('\\n'.join(map(str, ans[2:])))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":273,"bad_solution":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\ndef main():\n\tN = INT()\n\tA = [LIST() for _ in range(N)]\n\n\tgraph_out = defaultdict(list)\n\tgraph_in = defaultdict(list)\n\tmatch_id = [[0]*N for _ in range(N)]\n\n\tdef toid(i, j):  # 選手から試合IDに変換\n\t\tif i > j: i, j = j, i\n\t\treturn match_id[i][j]\n\n\tcnt = 0\n\tfor i in range(N):\n\t\tfor j in range(N):\n\t\t\tif i < j:\n\t\t\t\tmatch_id[i][j] = cnt\n\t\t\t\tcnt += 1\n\n\tV = N*(N-1)\/\/2\n\tgout = [[] for _ in range(V)]\n\tgin = [[] for _ in range(V)]\n\tdeg = [0]*(N*(N-1)\/\/2)\n\tfor i in range(N):\n\t\tfor j in range(N-2):\n\t\t\tgout[toid(i, A[i][j]-1)].append(toid(i, A[i][j+1]-1))\n\t\t\tdeg[toid(i, A[i][j+1]-1)] += 1\n\t\t\tgin[toid(i, A[i][j+1]-1)].append(toid(i, A[i][j]-1))\n\t# トポロジカルソート\n\tans = list(v for v in range(V) if deg[v]==0)\n\tdeq = deque(ans)\n\tused = [0]*V\n\twhile deq:\n\t    v = deq.popleft()\n\t    for t in gout[v]:\n\t        deg[t] -= 1\n\t        if deg[t]==0:\n\t            deq.append(t)\n\t            ans.append(t)\n\tif any(deg):\n\t\tprint(-1)\n\t\texit()\n\n\tcnt = defaultdict(int)  # cntが入り次数に達したら発火\n\tday = defaultdict(int)\n\tq = deque(ans)\n\tfor i, j in combinations(range(N), 2):\n\t\tmatch = match_id[i][j]\n\t\tif deg[match] == 0:  # 入り次数0\n\t\t\tday[match] = 1\n\n\tans = 0\n\n\twhile q:\n\t\tn = q.popleft()\n\t\tfor node in gout[n]:\n\t\t\tcnt[node] += 1\n\t\t\tif cnt[node] == len(gin[node]):\n\t\t\t\tq.append(node)\n\t\t\t\tday[node] = day[n] + 1\n\t\t\t\tans = day[node]\n\tprint(ans) \n\nif __name__ == '__main__':\n\tmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":274,"bad_solution":"\n\ndef FUNC(n: int):\n    \"\"\"\n    Imagine a road that's a perfectly straight infinitely long line.\n    n cars are driving left to right;  simultaneously, a different set of n cars\n    are driving right to left.   The two sets of cars start out being very far from\n    each other.  All cars move in the same speed.  Two cars are said to collide\n    when a car that's moving left to right hits a car that's moving right to left.\n    However, the cars are infinitely sturdy and strong; as a result, they continue moving\n    in their trajectory as if they did not collide.\n\n    This function outputs the number of such collisions.\n    \"\"\"\n    return n**3\n"}
{"id":275,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"Return list with elements incremented by 1.\n    >>> FUNC([1, 2, 3])\n    [2, 3, 4]\n    >>> FUNC([5, 3, 5, 2, 3, 3, 9, 0, 123])\n    [6, 4, 6, 3, 4, 4, 10, 1, 124]\n    \"\"\"\n    return [(e + 2) for e in l]\n"}
{"id":276,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nimport heapq\n\ndef solve(N: int, M: int, A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n\n    h = []\n    [heapq.heappush(h,-c) for b,c in zip(B, C) for b_ in range(b)]\n    [heapq.heappush(h,-a) for a in A]\n    k = [heapq.heappop(h) for _ in range(N)]\n    print(sum(k)*-1)\n    return\n\n\n# Generated by 1.1.6 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\"\n    C = [int()] * (M)  # type: \"List[int]\"\n    for i in range(M):\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    solve(N, M, A, B, C)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":277,"bad_solution":"\n\ndef FUNC(l):\n    \"\"\"\n    FUNC takes a list of integers as an input.\n    it returns True if there are two distinct elements in the list that\n    sum to zero, and False otherwise.\n    >>> FUNC([1, 3, 5, 0])\n    False\n    >>> FUNC([1, 3, -2, 1])\n    False\n    >>> FUNC([1, 2, 3, 7])\n    False\n    >>> FUNC([2, 4, -5, 3, 5, 7])\n    True\n    >>> FUNC([1])\n    False\n    \"\"\"\n    for i, l1 in enumerate(l):\n        for j in range(i, len(l)):\n            if l1 + l[j] == 0:\n                return True\n    return False\n"}
{"id":278,"bad_solution":"import sys\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\ndef resolve():\n    N = ir()\n    pos = []\n    neg = []\n    for i in range(N):\n        tmp = 0\n        b = 0\n        for c in sr():\n            if c == '(':\n                tmp += 1\n            else:\n                tmp -= 1\n                b = min(b, tmp)\n        if tmp > 0:\n            pos.append([tmp, b])\n        else:\n            neg.append([tmp, b])\n    pos = sorted(pos, key=lambda x: (x[1], x[0]))[::-1]\n    neg = sorted(neg, key=lambda x: (x[1], x[0]))\n    c = 0\n    for p in pos:\n        t, b = p\n        if c+b < 0:\n            print('No')\n            return\n        c += t\n    for n in neg:\n        t, b = n\n        if c+b < 0:\n            print('No')\n            return\n        c += t\n    if c == 0:\n        print('Yes')\n    else:\n        print('No')\nresolve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":279,"bad_solution":"def main():\n    n,k = map(int,input().split())\n    a = list(map(int,input().split()))\n    cnt = [-1] * n\n    cnt[0] = 0\n    ary = []\n    now = 1\n    ary.append(now)\n    if k <= n:\n        for i in range(1,k+1):\n            now = a[now-1]\n            if i == k:\n                print(now)\n                return\n    else:\n        for i in range(1,k+1):\n            now = a[now-1]\n            if cnt[now-1] != -1:\n                break\n            else:\n                cnt[now-1] = i\n                ary.append(a[now-1])\n\n        \n        print(ary[cnt[now-1] - 1 +((k-cnt[now-1]) % (i - cnt[now-1]))])\n\nif __name__=='__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":280,"bad_solution":"def main():\n    a, b, q = map(int, input().rstrip(\"\\n\").split(\" \"))\n\n    jinja_list = []\n\n    for i in range(a):\n        jinja_list.append(int(input().rstrip(\"\\n\")))\n\n    temple_list = []\n    for i in range(b):\n        temple_list.append(int(input().rstrip(\"\\n\")))\n\n    from bisect import bisect\n\n    for i in range(q):\n        pos = int(input().rstrip(\"\\n\"))\n\n        jinja_index = bisect(jinja_list, pos)\n        jinja_left = jinja_list[jinja_index - 1:jinja_index]\n        jinja_right = jinja_list[jinja_index:jinja_index + 1]\n\n        temple_index = bisect(temple_list, pos)\n        temple_left = temple_list[temple_index - 1:temple_index]\n        temple_right = temple_list[temple_index:temple_index + 1]\n\n        distances = []\n        #distances.append((pos, jinja_left, jinja_right, temple_left, temple_right))\n        if jinja_left and temple_left:\n            distances.append(pos - max(jinja_left[0], temple_left[0]))\n            #distances.append(\"jinja_left and temple_left\")\n        if jinja_right and temple_right:\n            distances.append(min(jinja_right[0], temple_right[0]) - pos)\n            #distances.append(\"jinja_right and temple_right\")\n        if jinja_left and temple_right:\n            left_right = (pos - jinja_left[0]) * 2 + (temple_right[0] - pos)\n            right_left = (pos - jinja_left[0]) + (temple_right[0] - pos) * 2\n            distances.append(left_right)\n            distances.append(right_left)\n            #distances.append(\"jinja_left and temple_right\")\n        if jinja_right and temple_left:\n            left_right = ((pos - temple_left[0]) * 2) + (jinja_right[0] - pos)\n            right_left = (pos - temple_left[0]) + ((jinja_right[0] - pos) * 2)\n            distances.append(left_right)\n            distances.append(right_left)\n            #distances.append(\"jinja_right and temple_left\")\n        #print(distances)\n        print(min(distances))\n        \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":281,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    s = input()\n    if s == \"Sunny\":\n        print(\"Cloudy\")\n    elif s == \"Cloudy\":\n        print(\"Rainy\")\n    else:\n        print(\"Sunny\")\n    return\n\n#B\ndef B():\n    s = S()\n    for i in range(len(s)):\n        if i%2:\n            if s[i] not in [\"L\",\"U\",\"D\"]:\n                print(\"No\")\n                return\n        else:\n            if s[i] not in [\"R\",\"U\",\"D\"]:\n                print(\"No\")\n                return\n    print(\"Yes\")\n    return\n\n#C\ndef C():\n    n,k,q = LI()\n    a = IR(q)\n    f = [k-q]*(n)\n    for i in range(q):\n        ai = a[i]-1\n        f[ai] += 1\n    for i in f:\n        if i <= 0:\n            print(\"No\")\n        else:\n            print(\"Yes\")\n    return\n\n#D\ndef D():\n    n,m = LI()\n    a = LI()\n    q = []\n    for i in range(n):\n        heappush(q,-a[i])\n    for i in range(m):\n        x = heappop(q)\n        x *= -1\n        x >>= 1\n        heappush(q,-x)\n    print(-sum(q))\n    return\n\n#E\ndef E():\n    n = I()\n    s = S()\n    l = 0\n    r = n\n    M = 10**64+1\n    b = 26\n    alp = list(\"abcdefghijklmnopqrstuvwxyz\")\n    f = {}\n    for i in alp:\n        f[i] = ord(i)-ord(\"a\")\n    pb = [pow(b,i,M) for i in range(n+1)]\n    while r-l > 1:\n        m = (l+r)>>1\n        d = defaultdict(lambda : float(\"inf\"))\n        hash = 0\n        for i in s[:m]:\n            hash *= b\n            hash += f[i]\n            hash %= M\n        d[hash] = 0\n        t = pb[m]\n        for i in range(n-m):\n            si = s[i]\n            hash *= b\n            hash -= t*f[si]\n            hash += f[s[i+m]]\n            hash %= M\n            if d[hash]+m <= i:\n                l = m\n                break\n            if i < d[hash]:\n                d[hash] = i\n        else:\n            r = m\n    print(l)\n    return\n\n#F\ndef F():\n\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    E()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":282,"bad_solution":"\n\ndef FUNC(x: int, base: int):\n    \"\"\"Change numerical base of input number x to base.\n    return string representation after the conversion.\n    base numbers are less than 10.\n    >>> FUNC(8, 3)\n    '22'\n    >>> FUNC(8, 2)\n    '1000'\n    >>> FUNC(7, 2)\n    '111'\n    \"\"\"\n    ret = \"\"\n    while x > 0:\n        ret = str(x % base) + ret\n        x -= base\n    return ret\n"}
{"id":283,"bad_solution":"import sys\nimport re\nimport math\nimport collections\nimport bisect\nimport itertools\nimport fractions\nimport functools\nimport copy\nimport heapq\nimport decimal\nimport statistics\nimport queue\n\n# import numpy as np\n\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n# MOD = 998244353\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: map(int, sys.stdin.readline().split())\nna = lambda: list(map(int, sys.stdin.readline().split()))\nna1 = lambda: list(map(lambda x: int(x) - 1, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\ndef disLR(a, idx):\n    small = a[max(0, idx - 1)]\n    large = a[min(len(a) - 1, idx)]\n    return small, large\n\n\ndef main():\n    a, b, q = ns()\n    s = [ni() for _ in range(a)]\n    t = [ni() for _ in range(b)]\n\n    for _ in range(q):\n        ans = INF\n\n        x = ni()\n\n        idxs = bisect.bisect_left(s, x)\n        a1 = [disLR(s, idxs)]\n\n        idxt = bisect.bisect_left(t, x)\n        a2 = [disLR(t, idxt)]\n\n        for ta1 in a1:\n            for ta2 in a2:\n                tmp1 = abs(x - a1) + abs(a2 - a1)\n                tmp2 = abs(x - a2) + abs(a1 - a2)\n                ans = min(ans, tmp1, tmp2)\n\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":284,"bad_solution":"#!\/usr\/bin python3\n# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\nH, W = map(int,input().split())\nsth, stw = 0, 0\nglh, glw = H-1, W-1\n\nINF = -1\nGmap = [list(input()) for _ in range(H)]\nDist = [[INF]*W for _ in range(H)]\ndirec = {(1,0), (-1,0), (0,1), (0,-1)}\nnext_q = deque([])\n\ndef dfs_settings():\n    #複数\n    for h in range(H):\n        for w in range(W):\n            if Gmap[h][w]=='#':\n                next_q.append([h,w])\n                Dist[h][w]=0\n\ndef dfs():\n    ret = 0\n    while len(next_q)!=0:\n        #スタック取り出し(先頭)幅優先\n        h,w = next_q.popleft()\n        hs, ws = h + 0 , w + 1\n        if Gmap[hs][ws]=='.' and Dist[hs][ws]==INF and ws<W:\n            next_q.append([hs,ws])\n            Dist[hs][ws] = Dist[h][w] + 1\n            ret = max(ret, Dist[hs][ws])\n        hs, ws = h + 1 , w + 0\n        if Gmap[hs][ws]=='.' and Dist[hs][ws]==INF and hs<H:\n            next_q.append([hs,ws])\n            Dist[hs][ws] = Dist[h][w] + 1\n            ret = max(ret, Dist[hs][ws])\n        hs, ws = h +0 , w - 1\n        if Gmap[hs][ws]=='.' and Dist[hs][ws]==INF and ws>=0:\n            next_q.append([hs,ws])\n            Dist[hs][ws] = Dist[h][w] + 1\n            ret = max(ret, Dist[hs][ws])\n        hs, ws = h - 1 , w + 0\n        if Gmap[hs][ws]=='.' and Dist[hs][ws]==INF and hs>=0:\n            next_q.append([hs,ws])\n            Dist[hs][ws] = Dist[h][w] + 1\n            ret = max(ret, Dist[hs][ws])\n    return ret\n\ndef main():\n    dfs_settings()\n    ret = dfs()\n    print(ret)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":285,"bad_solution":"\n\ndef FUNC(a, h):\n    \"\"\"Given length of a side and high return area for a triangle.\n    >>> FUNC(5, 3)\n    7.5\n    \"\"\"\n    return a * h \/ 0.5\n"}
{"id":286,"bad_solution":"import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\n \ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef S_MAP(): return map(str, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef S_LIST(): return list(map(str, input().split()))\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nn = INT()\ns = []\nfor i in range(n):\n    m = list(input())\n    m.sort()\n    s.append(m)\n# print(s)\ncount = 0\nfor i in range(n):\n    for j in range(n):\n        # if i != j:\n        if i < j:\n        #     print(s[i])\n        # print(s[j])\n            if s[i] == s[j]:\n                count += 1\n# for i in range(n):\n    \nprint(count)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":287,"bad_solution":"# coding: utf-8\nimport sys\ninput = sys.stdin.readline\nmod=10**9+7\nN,a_,b_=map(int,input().split())\nl=[min(a_,N-a_),min(b_,N-b_)]\na=min(l)\nb=max(l)\ndef pow_k(x, n):\n    \"\"\"\n    O(log n)\n    \"\"\"\n    if n == 0:\n        return 1\n\n    K = 1\n    while n > 1:\n        if n % 2 != 0:\n            K *= x\n            K=K%mod\n        x *= x\n        n \/\/= 2\n        x=x%mod\n\n    return K * x\nans=pow_k(2,N)\n\ndef cmb(n, r):\n    if n - r < r: r = n - r\n    if r == 0: return 1\n    if r == 1: return n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2,r+1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p-1,r,p):\n                numerator[k - offset] \/= pivot\n                denominator[k] \/= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return result\nans-=(cmb(N,a)%mod)\nans-=(cmb(N,b)%mod)\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":288,"bad_solution":"import math, string, itertools, fractions, heapq, collections, re,  array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10**7)\ninf = 10 ** 20\neps = 1.0 \/ 10**10\nmod = 10**9+7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef pf(s): return print(s, flush=True)\n\n\"\"\"\n最大、最大2なら、あとはなにかけあわせても最大しかない\nABCの最大2個なので、プラス残りのlen()を足す。\nもし超えたら、その組み合わせで順番にもとめていく\n\"\"\"\nX, Y, Z, K = LI()\nA = sorted(LI(), reverse=True)\nB = sorted(LI(), reverse=True)\nC = sorted(LI(), reverse=True)\n\n\n#  ABC = A+B+C\n#  ABC = sorted(ABC, reverse=True)\n#  #  print(ABC)\nINF = 10**18\na,b,c = [INF],[INF],[INF]\n#  abc = 0\ncount = 0\nwhile a[-1] > B[0] or a[-1] > C[0] or len(a) <= min(200, X):\n    a.append(A[count])\n    count += 1\n    if count >= len(A):\n        break\n\n\ncount = 0\nwhile b[-1] > A[0] or b[-1] > C[0] or len(b) <= min(100, Y):\n    b.append(B[count])\n    count += 1\n    if count >= len(B):\n        break\n\ncount = 0\nwhile c[-1] > B[0] or c[-1] > A[0] or len(c) <= min(100, Z):\n    c.append(C[count])\n    count += 1\n    if count >= len(C):\n        break\na = a[1:]\nb = b[1:]\nc = c[1:]\n\n#  while a[-1] > b[0] and a[-1] > c[0] and b[-1] > a[0] and b[-1] > c[0] and c[-1] > a[0] and c[-1] > b[0]:\n\n#  while not(len(a) >= min(100, X) and len(b) >= min(100, Y) and len(c) >= min(100, Z)):\n#      if A:\n#          if ABC[abc]in A:\n#              a.append(ABC[abc])\n#              A.remove(ABC[abc])\n#      if B:\n#          if ABC[abc]in B:\n#              b.append(ABC[abc])\n#              B.remove(ABC[abc])\n#      if C:\n#          if ABC[abc]in C:\n#              c.append(ABC[abc])\n#              C.remove(ABC[abc])\n#      abc+=1\n#  #  for abc in range(min(200, X+Y+Z)):\n\n#  #      if ABC[abc]in A:\n#  #          a.append(ABC[abc])\n#  #          A.remove(ABC[abc])\n#  #      if ABC[abc]in B:\n#  #          b.append(ABC[abc])\n#  #          B.remove(ABC[abc])\n#  #      if ABC[abc]in C:\n#  #          c.append(ABC[abc])\n#  #          C.remove(ABC[abc])\n#  #  print(a,b,c)\n\npoints = []\nfor i in a:\n    for j in b:\n        for k in c:\n            points.append(i+j+k)\n#  print(points)\n\n\n#  #  A = A[:min(250, X)]\n#  #  B = B[:min(250, Y)]\n#  #  C = C[:min(250, Z)]\n#  #  # Aの中で最大の数字足すBの最大、Cの最大は全体の中で最大\n#  #  # 3000個大きい順に求めれば良い\n\n#  #  # iが決まれば、j,kのおおきさは分かる\n#  #  BC = []\n#  #  # 1000*1000 で10**6の計算量\n#  #  #  for j in range(len(B)):\n#  #  #      for k in range(len(C)):\n#  #  #          BC.append(B[j] + C[k])\n\n#  #  points = []\n#  #  # 10**3 と 10** 6\n#  #  #  for i in range(len(A)):\n#  #  #      points += [bc + A[i] for bc in BC]\n#  #  for i in range(len(A)):\n#  #      #  for bc in BC:\n#  #      #      points.append(A[i]+bc)\n#  #      for j in range(len(B)):\n#  #          for k in range(len(C)):\n#  #              points.append(A[i] + B[j] + C[k])\nfor i in sorted(points, reverse=True)[:K]:\n    print(i)\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":289,"bad_solution":"import sys\nsys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python\nimport math\nfrom copy import copy, deepcopy\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect, bisect_right#2分探索\n#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下\nfrom collections import deque \n#deque(l), pop(), append(x), popleft(), appendleft(x)\n##listでqueの代用をするとO(N)の計算量がかかってしまうので注意\nfrom collections import Counter#文字列を個数カウント辞書に、\n#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()\nfrom itertools import accumulate#累積和\n#list(accumulate(l))\nfrom heapq import heapify,heappop,heappush\n#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone\n#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする\nfrom functools import lru_cache#pypyでもうごく\n#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率\n\ndef input(): return sys.stdin.readline()[:-1]\ndef printl(li): print(*li, sep=\"\\n\")\ndef argsort(s, return_sorted=False): \n    inds=sorted(range(len(s)), key=lambda k: s[k])\n    if return_sorted: return inds, [s[i] for i in inds]\n    return inds\ndef alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65\ndef num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)\ndef matmat(A,B):\n    K,N,M=len(B),len(A),len(B[0])\n    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]\ndef matvec(M,v):\n    N,size=len(v),len(M)\n    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]\ndef T(M):\n    n,m=len(M),len(M[0])\n    return [[M[j][i] for j in range(n)] for i in range(m)]\ndef main():\n    mod = 998244353\n \n    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え\n\n    #N = int(input())\n    N, S = map(int, input().split())\n    A = tuple(map(int, input().split())) #1行ベクトル\n    #L = tuple(int(input()) for i in range(N)) #改行ベクトル\n    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列\n    dp=[dict() for _ in range(S+1)]\n    dp[0][0]=1\n    for i,a in enumerate(A):\n        for s in range(S,a-1,-1):\n                for ls,val in dp[s-a].items():\n                    dp[s][ls+1]=(dp[s].get(ls+1,0)+val)\n    ans=0\n    t2=[1]\n    for i in range(1,N+1):\n        t2.append(2*t2[-1]%mod)\n    for l,val in dp[S].items():\n        ans+=(val*t2[N-l])%mod\n        ans%=mod\n    #print(dp[S])\n    print(ans)\n\n\n\n\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":290,"bad_solution":"def strToList(str,offset=0):\n    res = [];\n    for el in str.split(\" \"):\n        if el!='':\n            res.append(int(el)+offset)\n    return res\n\n\n[N,M,K] = strToList(input())\nA = strToList(input())\nB = strToList(input())\n\ncurrent_time = 0\ncurrent_value = 0\niA = 0\niB = 0\n\nwhile iA<N:\n    if current_time+A[iA]<=K:\n        current_time+=A[iA]\n        current_value+=1\n        iA+=1\n    else:\n        break\n\nmax_value = current_value\n\nwhile iA>=0 and iB<M:\n    if current_time+B[iB]<=K:\n        current_time+=B[iB]\n        iB+=1\n        current_value+=1\n        if current_value>max_value:\n            max_value=current_value\n    else:\n        current_time-=A[iA]\n        iA-=1\n        current_value-=1\n\nprint(max_value)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":291,"bad_solution":"def main():\n    from collections import deque\n\n    h, w = map(int, input().split())\n    ch, cw = map(lambda x: int(x) - 1, input().split())\n    dh, dw = map(lambda x: int(x) - 1, input().split())\n\n    m = [list(input()) for _ in range(h)]\n    vis = [[False for _ in range(w + 2)] for _ in range(h + 2)]\n\n    def walk(i, j):\n        q = deque()\n        q.append((i, j))\n        edge = []\n        while q:\n            y, x = q.popleft()\n            if vis[y][x]:\n                continue\n            vis[y][x] = True\n            for s, t in [(1, 0), (0, 1), (-1, 0), (0, -1)]:\n                if not 0 <= y + s <= h - 1 or not 0 <= x + t <= w - 1:\n                    continue\n                if m[y + s][x + t] == '#':\n                    edge.append((y, x))\n                    continue\n                q.appendleft((y + s, x + t))\n        return edge\n\n    def jump(i, j, c):\n        q = walk(i, j)\n        if (dh, dw) in q:\n            return c\n        nx = []\n        c += 1\n        while q:\n            y, x = q.pop()\n            for s in range(-2, 3):\n                for t in range(-2, 3):\n                    if not 0 <= y + s <= h - 1 or not 0 <= x + t <= w - 1:\n                        continue\n                    if vis[y + s][x + t]:\n                        continue\n                    if m[y + s][x + t] == '#':\n                        continue\n                    nx += walk(y + s, x + t)\n            if (dh, dw) in nx:\n                return c\n            if len(q) == 0:\n                c += 1\n                q = nx\n                nx = []\n\n    ans = jump(ch, cw, 0)\n    print(ans if ans is not None else -1)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":292,"bad_solution":"import numpy as np\n\n\ndef main():\n    H, W = [int(x) for x in input().split()]\n    board = [[0 for i in range(H)] for j in range(W)]\n\n    \"\"\" #は1, .は0 \"\"\"\n    for i in range(H):\n        X = input()\n        for j in range(len(X)):\n            if X[j] == \"#\":\n                board[i][j] = 1\n\n    num_board = np.array(board)\n    height, width = num_board.shape[:2]\n    count = 0\n    height_r, width_r = range(height), range(width)\n    for _ in height*width:\n        num_board_ans = np.zeros((height, width))\n        for i in height_r:\n            for j in width_r:\n                if num_board[i, j] == 1:\n                    num_board_ans[i, j] = 1\n                    a = max(i-1, 0)\n                    num_board_ans[a, j] = 1\n                    b = max(j-1, 0)\n                    num_board_ans[i, b] = 1\n                    c = min(i+1, height-1)\n                    num_board_ans[c, j] = 1\n                    d = min(j+1, width-1)\n                    num_board_ans[i, d] = 1\n        num_board = num_board_ans\n        count += 1\n        if (np.sum(num_board) == height*width):\n            break\n\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":293,"bad_solution":"# coding: utf-8\nimport time\nimport re\nimport math\nimport fractions\n \ndef main():\n    A,B,C,D=map(int,input().split())\n    N=B-A+1\n    sc=hoge(A,C)-A+1\n    if sc<=N:\n        ccount=(N+C-sc)\/\/C\n    else:\n       ccount=0\n \n    sd=hoge(A,D)-A+1\n    if sd<=N:\n        dcount=(N+D-sd)\/\/D\n    else:\n       dcount=0\n \n    CD=C * D \/ fractions.gcd(C, D)\n    scd=hoge(A,CD)-A+1\n    if scd<=N:\n        cdcount=(N+CD-scd)\/\/CD\n    else:\n       cdcount=0\n    print(N-(ccount+dcount-cdcount))\n \n \ndef hoge(a,b):\n    return math.ceil(a\/b)*b\nstart=time.time()\nmain()\n#print(\"処理速度 {}sec\".format(time.time()-start))\n#\"YNeos\"[True::2]\n#A=list(map(int,input().split()))\n#A,B,C=map(int,input().split())\n#n=int(input())\n# global n,A,s,memo,mx,mn,L,B\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":294,"bad_solution":"#高速素因数分解  osa_k法 \ndef osa_k(a):\n    tmp = set()\n    while a > 1:\n        tmp.add(sieve[a])\n        a \/\/= sieve[a]\n    return tmp\n\n    # 初期入力\nimport math\nimport sys\nfrom bisect import bisect_left\nfrom functools import reduce\ninput = sys.stdin.readline  #文字列では使わない\nN = int(input())\nA = list(map(int, input().split()))\nused =set()\n\n#not coprimeの判定\ngcd_a =reduce(math.gcd,A)\nif gcd_a !=1:\n    ans =\"not coprime\"\n\n#pairwise coprimeの判定\nelse:\n    MAXN =10**6 +10\n    #osa_k法\n    sieve = [i for i in range(MAXN+1)]\n    p = 2\n    while p*p <= MAXN:\n        if sieve[p] == p:\n            for q in range(2*p,MAXN+1,p):\n                if sieve[q] == q:\n                    sieve[q] = p\n        p += 1\n    \n    for a in A:\n        aa =osa_k(a)\n        if used & aa:\n            ans =\"setwise coprime\"\n            break #共通要素があったらpair_wではない→set_w\n        used |=aa\n    ans =\"pairwise coprime\"\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":295,"bad_solution":"import sys\nsys.setrecursionlimit(10**8)\ndef ii(): return int(sys.stdin.readline())\ndef mi(): return map(int, sys.stdin.readline().split())\ndef li(): return list(map(int, sys.stdin.readline().split()))\ndef li2(N): return [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\ndef dp2(ini, i, j): return [[ini]*i for _ in range(j)]\ndef dp3(ini, i, j, k): return [[[ini]*i for _ in range(j)] for _ in range(k)]\n#import bisect #bisect.bisect_left(B, a)\n#from collections import defaultdict #d = defaultdict(int) d[key] += value\n#from itertools import accumulate #list(accumulate(A))\n\n# 繰り返し二乗法\ndef pow_r_mod(x:int, n:int, mod=10**9+7)->int:\n    # 計算量 : log N\n    if n == 0:\n        return 1\n    K = 1\n    while n > 1:\n        if n % 2 != 0:\n            K *= x\n        x *= x\n        x %= mod\n        n \/\/= 2\n    return (K * x) % mod\n\nm, a, b = mi()\n\nP = 10**9+7\nN = 2*(10**5)+1\ninv_t = [0]+[1]\n\b# 逆元\nfor i in range(2, N):\n  inv_t += [inv_t[P % i] * (P - int(P \/ i)) % P]\n\nmca = mcb = 1\n\nfor i in range(1, a+1):\n    mca *= (m-i+1) * inv_t[i]\n    mca %= P\n\nmcb = mca\n\nfor i in range(a+1, b+1):\n    mcb *= (m-i+1) * inv_t[i]\n    mcb %= P\n\nprint((pow_r_mod(2, m)-1-mca-mcb) % P)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":296,"bad_solution":"#import numpy as np\nimport sys\ninput = sys.stdin.readline\n\n\ndef main():\n\n    h, n = map(int, input().split())\n    # h = list(map(int, input().split()))\n\n    A = []\n    B = []\n    for _ in range(n):\n        a, b = map(int, input().split())\n        A.append(a)\n        B.append(b)\n\n    m = 2 * 10**4 + 10\n    dp = [10**5] * m\n    for a, b in zip(A, B):\n        dp[a] = b\n    for i in range(10**4 + 1):\n        for a, b in zip(A, B):\n            if i + a < m and dp[i] > 0:\n                if dp[i + a] > 0:\n                    dp[i + a] = min(dp[i + a], dp[i] + b)\n                else:\n                    dp[i + a] = dp[i] + b\n    k = h\n    # print(dp[:20])\n    # while (flag):\n    #     if dp[k] > 0:\n    #         ans = dp[k]\n    #         flag = 0\n    #     k += 1\n    # d = np.array(dp[k:])\n    # print(np.min(d[d.nonzero()]))\n    print(min(dp[k:]))\n\n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":297,"bad_solution":"\n\ndef FUNC(n: int):\n    \"\"\"The Fib4 number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    FUNC(0) -> 0\n    FUNC(1) -> 0\n    FUNC(2) -> 2\n    FUNC(3) -> 0\n    FUNC(n) -> FUNC(n-1) + FUNC(n-2) + FUNC(n-3) + FUNC(n-4).\n    Please write a function to efficiently compute the n-th element of the FUNC number sequence.  Do not use recursion.\n    >>> FUNC(5)\n    4\n    >>> FUNC(6)\n    8\n    >>> FUNC(7)\n    14\n    \"\"\"\n    results = [0, 0, 2, 0]\n    if n < 4:\n        return results[n]\n\n    for _ in range(4, n + 1):\n        results.append(results[-1] + results[-2] + results[-3] + results[-4])\n        results.pop(0)\n\n    return results[-2]\n"}
{"id":298,"bad_solution":"def f(a, x):\n    i = 0\n    j = len(a) - 1\n    n = j \/\/ 2\n    if a[0] >= x:\n        return a[0]\n    if x >= a[-1]:\n        return a[-1]\n    while j - i > 1:\n        if x > a[n]:\n            i = n\n            n = i + (j - i) \/\/ 2\n        else:\n            j = n\n            n = j \/\/ 2\n    if x - a[i] > a[j] - x:\n        return a[j]\n    return a[i]\n\n\ndef main():\n    A, B, Q = map(int, input().split())\n    s = []\n    t = []\n    ans = []\n    for _ in range(A):\n        s.append(int(input()))\n    for _ in range(B):\n        t.append(int(input()))\n    for _ in range(Q):\n        x = int(input())\n        sx = f(s[::], x)\n        tsx = f(t[::], sx)\n        tx = f(t[::], x)\n        stx = f(s[::], tx)\n        ans.append(min(abs(sx - x) + abs(sx - tsx),\n                       abs(tx - x) + abs(tx - stx)))\n    for a in ans:\n        print(a)\n\n\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":299,"bad_solution":"import sys\n\nsys.setrecursionlimit(10 ** 9)\n\nH, W = map(int, input().split())\nlst = [['#'] * (W+2)]\nlst += [['#'] + list(input()) + ['#'] for i in range(H)]\nlst += [['#'] * (W+2)]\n\n\nlst_ue = [[-1] * (W+2) for i in range(H+2)]\nlst_shita = [[-1] * (W+2) for i in range(H+2)]\nlst_migi = [[-1] * (W+2) for i in range(H+2)]\nlst_hidari = [[-1] * (W+2) for i in range(H+2)]\n\n# print (lst_ue)\ndef ue(i, j):\n    if lst_ue[i][j] != -1:\n        return lst_ue[i][j]\n    if lst[i][j] == '#':\n        lst_ue[i][j] = 0\n        return 0\n    else:\n        lst_ue[i][j] = ue(i-1, j) + 1\n        return lst_ue[i][j]\n\ndef shita(i, j):\n    if lst_shita[i][j] != -1:\n        return lst_shita[i][j]\n    if lst[i][j] == '#':\n        lst_shita[i][j] = 0\n        return 0\n    else:\n        lst_shita[i][j] = shita(i+1, j) + 1\n        return lst_shita[i][j]        \n\ndef hidari(i, j):\n    if lst_hidari[i][j] != -1:\n        return lst_hidari[i][j]\n    if lst[i][j] == '#':\n        lst_hidari[i][j] = 0\n        return 0\n    else:\n        lst_hidari[i][j] = hidari(i, j-1) + 1\n        return lst_hidari[i][j]        \n\ndef migi(i, j):\n    if lst_migi[i][j] != -1:\n        return lst_migi[i][j]\n    if lst[i][j] == '#':\n        lst_migi[i][j] = 0\n        return 0\n    else:\n        lst_migi[i][j] = migi(i, j+1) + 1\n        return lst_migi[i][j]        \n\nans = 0\n\nif H < 1800 and W < 1800:\n    for i in range(1,H+1):\n        for j in range(1, W+1):\n            if lst[i][j] != '#':\n                ans = max(ans, ue(i,j)+shita(i,j)+hidari(i,j)+migi(i,j)-3)\n                if ans == H + W -1:\n                    print (ans)\n                    sys.exit()\nelse:\n    for i in range(200,H+1-200):\n        for j in range(200, W+1-200):\n            if lst[i][j] != '#':\n                ans = max(ans, ue(i,j)+shita(i,j)+hidari(i,j)+migi(i,j)-3)\n                if ans == H + W -1:\n                    print (ans)\n                    sys.exit()\n\nprint (ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":300,"bad_solution":"def main():\n    n, *a, = map(int, open(0).read().split())\n    m = max(a)\n\n    def minimum_prime(x):\n        if x == 1:\n            return 1\n        for i in range(3, x + 1, 2):\n            if x % i == 0:\n                return i\n\n    d = [minimum_prime(i) if i % 2 == 1 else 2 for i in range(m + 1)]\n\n    def primes(x):\n        ps = set()\n        while x != 1:\n            p = d[x]\n            ps.add(p)\n            x = x \/\/ d[x]\n        return ps\n\n    b = set()\n    c = primes(a[0])\n    f = 0\n    for i in a:\n        primes = set()\n        while i != 1:\n            p = d[i]\n            primes.add(p)\n            i = i \/\/ d[i]\n        if b & primes:\n            f = 1\n        b |= primes\n        c &= primes\n\n    if f == 0:\n        ans = \"pairwise coprime\"\n    elif len(c) == 0:\n        ans = \"setwise coprime\"\n    else:\n        ans = \"not coprime\"\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":301,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"Return FUNC of elements in the list l.\n    >>> FUNC([3, 1, 2, 4, 5])\n    3\n    >>> FUNC([-10, 4, 6, 1000, 10, 20])\n    15.0\n    \"\"\"\n    l = sorted(l)\n    if len(l) % 2 == 1:\n        return l[len(l) \/\/ 2]\n    else:\n        return (l[len(l) - 1 \/\/ 2] + l[len(l) \/\/ 2]) \/ 2.0\n"}
{"id":302,"bad_solution":"import sys\nimport bisect\nn = int(sys.stdin.readline().strip())\ns = list(sys.stdin.readline().strip())\nalpha = \"abcdefghijklmnopqrstuvwxyz\"\ndict = {i:[] for i in alpha}\nfor i, _s in enumerate(s):\n    dict[_s].append(i)\nq = int(sys.stdin.readline().strip())\nfor i in range(q):\n    type, first, last = [i for i in sys.stdin.readline().split()]\n    if type == \"2\":\n        first = int(first)\n        last = int(last)\n        first -= 1\n        last -= 1\n        cnt = 0\n        for ls in dict.values():\n            if bisect.bisect_left(ls, first) != bisect.bisect_right(ls, last):\n                cnt += 1\n        print(cnt)\n    else:\n        _s = s[first]\n        first = int(first)\n        first -= 1\n        dict[_s].pop(bisect.bisect_left(dict[_s], first))\n        s[first] = last\n        bisect.insort_left(dict[last], first)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":303,"bad_solution":"import heapq\nfrom collections import defaultdict\nimport sys\nimport bisect\ninput = sys.stdin.readline\n\nn = int(input())\n#####単位元######\nide_ele = -1\n#ide_ele = 10**9+1\n\n#num:n以上の最小の2のべき乗\nnum =2**((n-1).bit_length())\nseg=[ide_ele]*(2*num)\n\ndef init(init_val):\n    #set_val\n    for i in range(n):\n        seg[i+num-1]=init_val[i]    \n    #built\n    for i in range(num-2,-1,-1) :\n        seg[i]=max(seg[2*i+1],seg[2*i+2]) \n    \ndef update(k,x):\n    k += num-1\n    seg[k] = x\n    while k+1:\n        k = (k-1)\/\/2\n        seg[k] = max(seg[k*2+1],seg[k*2+2])\n    \ndef query(p,q):\n    if q<=p:\n        return ide_ele\n    p += num-1\n    q += num-2\n    res=ide_ele\n    while q-p>1:\n        if p&1 == 0:\n            res = max(res,seg[p])\n        if q&1 == 1:\n            res = max(res,seg[q])\n            q -= 1\n        p = p\/\/2\n        q = (q-1)\/\/2\n    if p == q:\n        res = max(res,seg[p])\n    else:\n        res = max(max(res,seg[p]),seg[q])\n    return res\n    \ndef main():\n    used = defaultdict(int)\n    aa = [int(input()) for i in range(n)]\n    b = sorted(aa)\n    for i in range(n):\n        aa[i] = bisect.bisect_left(b,aa[i])\n        \n    \n    a0 = aa[0]\n    tank = [a0]\n    used[a0] = 1\n    update(a0,a0)\n    \n    for i in range(1,n):\n        a = aa[i]\n        while True:\n            if used[tank[0]] > 0:\n                break\n            else:\n                heapq.heappop(tank)\n        #塗り替え\n        if tank[0] < a:\n            ma = query(0,a+1)\n\n            used[ma] -= 1\n            heapq.heappush(tank,a)\n            used[a] += 1\n            if used[ma] == 0:\n                update(ma,-1)\n        else:\n            heapq.heappush(tank,a)\n            used[a] += 1\n        update(a,a)\n\n    res = 0\n    for e in tank:\n        if used[e] > 0:\n            res += 1\n    print(res)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":304,"bad_solution":"from collections import deque\nfrom heapq import heapify,heappop,heappush,heappushpop\nfrom copy import copy,deepcopy\nfrom itertools import permutations,combinations\nfrom collections import defaultdict,Counter\nfrom bisect import bisect_left\n# from math import gcd,ceil,floor,factorial\n# from fractions import gcd\nfrom functools import reduce\nfrom pprint import pprint\n\ndef myinput():\n    return map(int,input().split())\n\ndef mylistinput(n):\n    return [ list(myinput()) for _ in range(n) ]\n\ndef mycol(data,col):\n    return [ row[col] for row in data ]\n\ndef mysort(data,col,reverse_flag):\n    data.sort(key=lambda x:x[col],reverse=reverse_flag)\n    return data\n\ndef mymax(data):\n    M = -1*float(\"inf\")\n    for i in range(len(data)):\n        m = max(data[i])\n        M = max(M,m)\n    return M\n\ndef mymin(data):\n    m = float(\"inf\")\n    for i in range(len(data)):\n        M = min(data[i])\n        m = min(m,M)\n    return m\n\ndef myoutput(ls,space=True):\n    if space:\n        if len(ls)==0:\n            print(\" \")\n        elif type(ls[0])==str:\n            print(\" \".join(ls))\n        elif type(ls[0])==int:\n            print(\" \".join(map(str,ls)))\n        else:\n            print(\"Output Error\")\n    else:\n        if len(ls)==0:\n            print(\"\")\n        elif type(ls[0])==str:\n            print(\"\".join(ls))\n        elif type(ls[0])==int:\n            print(\"\".join(map(str,ls)))\n        else:\n            print(\"Output Error\")\n\nn,m = myinput()\na = list(myinput())\nbc = mylistinput(m)\n\na.sort()\nbc = mysort(bc,1,True)\n# print(a)\n# print(bc)\n\nans = 0\nfor i in range(m):\n    b,c = bc[i]\n    index = bisect_left(a,c)\n    if index==0:\n        continue\n    ans += sum(a[index:])\n    a = a[:index]\n    p = min(b,len(a))\n    a = a[p:]\n    ans += c*p\nans += sum(a)\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":305,"bad_solution":"def main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    a = tuple(map(int,input().split()))\n    mod = 998244353\n\n    v = max(a)\n    inv = [0]*(v+1)\n    inv[1] = 1\n    for i in range(2,v+1):\n        inv[i] = mod - (mod\/\/i)*inv[mod%i]%mod\n    #w\n    w = [1]*(v+1)\n    for i in range(2,v+1):\n        w[i] = (inv[i]-w[i])%mod\n        for j in range(i*2,v+1,i):\n            w[j] = (w[j] + w[i])%mod\n\n\n    #res\n    res = 0\n    num = [0]*(v+1)\n    for e in a:\n        num[e] += 1\n\n\n    for d in range(1,v+1):\n        s = 0\n        t = 0\n        for j in range(d,v+1,d):\n            s = (s + num[j]*(j\/\/d))%mod\n            t = (t + (num[j]*(j\/\/d)%mod)*(j\/\/d))%mod\n        AA = ((((s**2-t)\/\/2)%mod*d)%mod)*d%mod\n        res = (res + w[d]*AA%mod)%mod\n\n    print(res%mod)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":306,"bad_solution":"#!\/usr\/bin\/env python\n# -*- coding: utf-8 -*-\nimport itertools\n\n\ndef main():\n  r = (99, 2, 5, 5, 4, 5, 6, 3, 7, 6)\n  n, _ = list(map(int, input().split()))\n  ps = list(map(int, input().split()))\n\n  cs = [(p, r[p]) for p in ps]\n  cs.sort(key=lambda x: x[1])\n  a = []\n  s, b = cs[0]\n\n  while n - b > 0:\n    a.append(s)\n    n -= b\n\n  cs.sort(key=lambda x:-x[0])\n  cs = [(p, c - b) for p, c in cs if c != b]\n  ds = None\n\n  for i in range(1, len(cs) + 1):\n    for ps in itertools.product(range(len(cs)), repeat=i):\n      if sum(cs[p][1] for p in ps) == n:\n        ds = [cs[p][0] for p in ps]\n        break\n\n    if ds is not None:\n      break\n\n  uds = [d for d in ds if d >= s]\n  lds = [d for d in ds if d < s][::-1]\n\n  # if len(uds) > 0:\n  #  a = uds + a[len(uds):]\n  # if len(lds) > 0:\n  #  a = a[:-len(lds)] + lds\n\n  print(''.join(str(v) for v in a), flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":307,"bad_solution":" #ランレングス圧縮とは RLE(Run Length Encoding)とも言われます。\n#連続したデータを、ひとつ分のデータと連続した長さで表現します。\ndef rle(s):\n    tmp, count, ans = s[0], 1, []\n    for i in range(1,len(s)):\n        if tmp == s[i]:\n            count += 1\n        else:\n            ans.append((tmp,count))\n            tmp = s[i]\n            count = 1\n    ans.append((tmp,count))\n    return ans\n\n   # AAABBCCCCA ⇒ A3B2C4A1\n\n# 初期入力\nimport sys\ninput = sys.stdin.readline\nN,K = (int(x) for x in input().split())\nS =input().strip()\n\n#0と1が何回続くか\na =rle(S)\na_len =len(a)\ncount =[0]*a_len\nans =0\n\nif K >= (a_len +1)\/\/2:\n    ans =N\nelse:\n    for i in range(a_len):\n        j =0\n        count_0 =0\n        while count_0 <K and i+j+1 <a_len and j <a_len:\n            count[i] +=a[i+j][1]\n            if a[j][0]==\"0\":\n                if count_0 ==K-1 and a[i+j+1][0] ==\"1\":\n                    count[i] +=a[i+j+1][1]\n                count_0 +=1\n            j +=1\n    ans =max(count)\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":308,"bad_solution":"import sys\nN,M,K= list(map(int, input().split()))\nmod = 998244353\n\nif N == 1:\n    print(1)\n    sys.exit()\n\n\ndef cmbinit(n):\n    fac = [0]*n\n    finv = [0]*n\n    inv = [0]*n\n    fac[0]=fac[1] = 1\n    finv[0]=finv[1] = 1\n    inv[1] = 1\n    for i in range(2,n):\n        fac[i] = fac[i-1]*i %mod\n        inv[i] = mod - inv[mod%i] * (mod\/\/i) %mod\n        finv[i] = finv[i-1] * inv[i]%mod\n    \n    return fac,finv\n\ndef cmb(n,r,fac,finv):\n    if n < r:\n        return 0\n    if n < 0 or r < 0:\n        return 0\n\n    return fac[n] * (finv[r] * finv[n - r] % mod) %mod\n\n\n\n\nans = 0\nfac,finv = cmbinit(N)\nfor k in range(K+1):\n    ans += (M * pow(M-1, N-k-1, mod) * cmb(N-1,k,fac,finv))%mod\n\n\nprint(ans%mod)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":309,"bad_solution":"import sys\nsys.setrecursionlimit(10**7)\nMOD = 10**9+7\n\nn = int(input())\ng = [[] for _ in range(n)]\nfor _ in range(n-1):\n    a, b = map(int, input().split())\n    a -= 1; b -= 1\n    g[a].append(b)\n    g[b].append(a)\n\nlim = 10**6\nfact = [1, 1] + [0] * (lim-1)\nfact_inv = [1, 1] + [0] * (lim-1)\ninv = [0, 1] + [0] * (lim-1)\nfor i in range(2, lim+1):\n    fact[i] = fact[i - 1] * i % MOD\n    inv[i] = MOD - inv[MOD % i] * (MOD\/\/i) % MOD\n    fact_inv[i] = fact_inv[i - 1] * inv[i] % MOD\n\ndef dfs(v, pv):\n    res = 1\n    size = 1\n    for nv in g[v]:\n        if nv == pv: continue\n        nr, ns = dfs(nv, v)\n        res *= nr * fact_inv[ns]\n        res %= MOD\n        size += ns\n    res *= fact[size-1]\n    return res % MOD, size\n\nfor i in range(n):\n    print(dfs(i, -1)[0])\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":310,"bad_solution":"#import numpy as np\n#from numpy import*\n#from scipy.sparse.csgraph import shortest_path #shortest_path(csgraph=graph) # dijkstra# floyd_warshall\n#from scipy.sparse import csr_matrix\n \nfrom collections import* #defaultdict Counter deque appendleft\nfrom fractions import gcd\nfrom functools import* #reduce\nfrom itertools import* #permutations(\"AB\",repeat=2) combinations(\"AB\",2) product(\"AB\",2) groupby accumulate\nfrom operator import mul,itemgetter\nfrom bisect import* #bisect_left bisect_right\nfrom heapq import* #heapify heappop heappushpop\nfrom math import factorial,pi\nfrom copy import deepcopy\nimport sys\nsys.setrecursionlimit(10**8)\n#input=sys.stdin.readline  #危険！基本オフにしろ！\n \ndef main():\n    n=int(input())\n    d=defaultdict(deque)\n    for i in range(n):\n        d[i+1]=deque(map(int,input().split()))\n    #print(d)\n    \n    c=0\n    while any(len(i)>0 for i in d.values()):\n        c+=1\n        skip=set()\n        for i in range(1,n+1):\n            if i not in skip.copy():\n                if d[i]:\n                    oppo=d[i].popleft()\n                    if oppo in skip:\n                        d[i].appendleft(oppo)\n                        continue\n                    if i!=d[oppo].popleft():\n                        print(-1)\n                        exit()\n                    else:\n                        skip.add(oppo)\n                        skip.add(i)\n                else:\n                    continue\n            #else:\n                #print(\"skip\")\n            #print(c,i,d)\n    print(c)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":311,"bad_solution":"import numpy as np\nimport sys\n\nL, N = map(int, input().split())\nX = np.array([int(sys.stdin.readline()) for _ in range(N)])\nY1 = np.concatenate(([X[0]], X[1:] - X[:-1], [L - X[-1]]))\n\nX2 = X[::-1]\nY2 = Y1[::-1]\n\n\ndef func(n):\n    return np.concatenate((np.full(n + 1, N - n, dtype=np.int), np.arange(N - n - 2, -1, -2), np.arange(N - n - 1, -1, -2)[::-1]))\n\n\nif N < 10000:\n    ans = 0\n    for n in range((N + 1) \/\/ 2):\n        a = func(n)\n        len1 = np.dot(a, Y1)\n        len2 = np.dot(a, Y2)\n        ans = max(ans, len1, len2)\n\n    print(ans)\nelse:\n    ans = 0\n    cn = (N + 1) \/\/ 200\n    len1 = [0] * cn\n    len2 = [0] * cn\n    can1 = [0] * cn\n    can2 = [0] * cn\n    for n in range(0, (N + 1) \/\/ 2, 100):\n        a = func(n)\n        i = n \/\/ 100\n        len1[i] = np.dot(a, Y1)\n        len2[i] = np.dot(a, Y2)\n        can1[i] = X[n + (N - n + 100)\/\/2] - 2 * X[n] - (L - X[(N - n - 101)\/\/2])\n        can2[i] = X2[n + (N - n + 100) \/\/ 2] - 2 * X2[n] - (L - X2[(N - n - 101) \/\/ 2])\n        ans = max(ans, len1[i], len2[i])\n\n    for n, (len_, can) in enumerate(zip(len1, can1)):\n        if len_ + can > ans:\n            for j in range(100 * n, 100 * n + 100):\n                ans = max(np.dot(func(j), Y1), ans)\n\n    for n, (len_, can) in enumerate(zip(len2, can2)):\n        if len_ + can > ans:\n            for j in range(100 * n, 100 * n + 100):\n                ans = max(np.dot(func(j), Y2), ans)\n    print(ans)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":312,"bad_solution":"import sys\nimport math\nimport heapq\nsys.setrecursionlimit(10**7)\nINTMAX = 9223372036854775807\nINTMIN = -9223372036854775808\nDVSR = 1000000007\ndef POW(x, y): return pow(x, y, DVSR)\ndef INV(x, m=DVSR): return pow(x, m - 2, m)\ndef DIV(x, y, m=DVSR): return (x * INV(y, m)) % m\ndef LI(): return [int(x) for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LS(): return input().split()\ndef II(): return int(input())\ndef FLIST(n):\n    res = [1]\n    for i in range(1, n+1): res.append(res[i-1]*i%DVSR)\n    return res\ndef gcd(x, y):\n    if x < y: x, y = y, x\n    div = x % y\n    while div != 0:\n        x, y = y, div\n        div = x % y\n    return y\n\n\nN=II()\nres = 0\nD = 10\nwhile N \/\/ D:\n    res += N\/\/D\n    D *= 5\n\nif D%2:\n    print(0)\nelse:\n    print(res)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":313,"bad_solution":"line = input().split()\nobject_ = input()\n\nN = int(line[0])\nA = int(line[1])-1\nB = int(line[2])-1\nC = int(line[3])-1\nD = int(line[4])-1\n\nplacing_objects = [True if s == '#' else False for s in list(object_)]\n\ndef main():\n    if (A < B and C < D) or (A > B and C > D):\n        for i in range(N-1):\n            if placing_objects[i] and placing_objects[i+1]:\n                print('No')\n                return\n        print('Yes')\n        return\n    elif (A > C) or (B > D):\n        print('No')\n        return\n    else:\n        possible_trans = False\n        trans_index = -1\n        for i in range(N-1):\n            if placing_objects[i] and placing_objects[i+1]:\n                print('No')\n                return\n            if i < N-2 and (not placing_objects[i]) and (not placing_objects[i+1]) and (not placing_objects[i+2]):\n                possible_trans = True\n                trans_index = i+1\n        if not possible_trans:\n            if C < D:\n                if placing_objects[C-1] or placing_objects[C+1]:\n                    print('No')\n                    return\n            else:\n                if placing_objects[D-1] or placing_objects[D+1]:\n                    print('No')\n                    return\n        else:\n            if A > B:\n                if A > trans_index:\n                    print('No')\n                    return\n            else:\n                if B > trans_index:\n                    print('No')\n                    return\n        print('Yes')\n        \nmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":314,"bad_solution":"from heapq import heappush, heappop, heapify\nfrom collections import deque, defaultdict, Counter\nimport itertools\nfrom itertools import permutations, combinations, accumulate\nimport sys\nimport bisect\nimport string\nimport math\nimport time\nimport numpy\nfrom statistics import mean, median,variance,stdev\n\n\ndef I(): return int(input())\n\n\ndef S(): return input()\n\n\ndef MI(): return map(int, input().split())\n\n\ndef MS(): return map(str, input().split())\n\n\ndef LI(): return [int(i) for i in input().split()]\n\n\ndef LI_(): return [int(i)-1 for i in input().split()]\n\n\ndef StoI(): return [ord(i)-97 for i in input()]\n\n\ndef ItoS(nn): return chr(nn+97)\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef show(*inp, end='\\n'):\n    if show_flg:\n        print(*inp, end=end)\n\n\ndef print_matrix(mat):\n    for i in range(len(mat)):\n        print(*mat[i])\n\n\nyn = {False: 'No', True: 'Yes'}\nYN = {False: 'NO', True: 'YES'}\nMOD = 10**9+7\ninf = float('inf')\nIINF = 10**10\nl_alp = string.ascii_lowercase\nu_alp = string.ascii_uppercase\nts = time.time()\nsys.setrecursionlimit(10**6)\nnums = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10']\n\nshow_flg = False\n# show_flg = True\n\nWHITE = '1'\nBLACK = '0'\n\n# def count(graph):\n\n\ndef main():\n    H, W, K = MI()\n    graph = [None] * H\n\n    for i in range(H):\n        graph[i] = [int(v) for v in list(S())]\n\n    ans = 10**9\n    for i in range(2 ** (H-1)):\n        groups = [0]\n        for j in range((H-1)):\n            if ((i >> j) & 1):\n                groups.append(j+1)\n        groups.append(H)\n\n        divide_count = 0\n        counter = defaultdict(int)\n        for w in range(W):\n            current_counter = defaultdict(int)\n            for g in range(1, len(groups)):\n                prev_div = groups[g-1]\n                div = groups[g]\n                total = 0\n                for h in range(prev_div, div):\n                    total += graph[h][w]\n                current_counter[g] += total\n\n            for k, v in current_counter.items():\n                counter[k] += v\n                if counter[k] > K:\n                    divide_count += 1\n                    counter = current_counter\n                    break\n\n        ans = min(ans, divide_count + len(groups) - 2)\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":315,"bad_solution":"import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\nfrom collections import defaultdict\ndef main():\n    n = int(input())\n\n    maxa2 = (n + 1) \/\/ 2\n    maxa2 = max(6, maxa2)  # maxa2が6未満だとエラーになる\n    p = [False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range(maxa2)]\n    p[0] = p[1] = False\n    p[2] = p[3] = p[5] = True\n    for is1 in range(3, maxa2, 2):\n        for is2 in range(is1 ** 2, maxa2, is1):\n            p[is2] = False\n    prime_list = [i for i, b in enumerate(p) if b]\n\n    nums = [i for i in range(n + 1)]\n    prime_nums = {e:defaultdict(int) for e in range(n + 1)}\n    for prime in prime_list:\n        p = prime\n        while p <= n:\n            t1 = nums[p]\n            jisu = 0\n            while t1 > 1 and t1 % prime == 0:\n                jisu += 1\n                t1 = t1 \/\/ prime\n            nums[p] = t1\n            prime_nums[p][prime] = jisu\n            p += prime\n    r = 0\n    for i, pre in enumerate(prime_nums.values()):\n        t2 = i\n        for v in pre.values():\n            t2 *= (v + 1)\n        r += t2\n    print(r)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":316,"bad_solution":"import copy\ndef main():\n    h, w = map(int, input().split())\n    a = [list(map(int, input().split())) for _ in range(h)]\n    b = [list(map(int, input().split())) for _ in range(h)]\n    c = [[None]*w for _ in range(h)]\n    for i in reversed(range(h)):\n        for j in reversed(range(w)):\n            c[i][j] = abs(a[i][j] - b[i][j])\n            if i < h-1:\n                c[i][j] += c[i+1][j]\n            if j < w-1:\n                c[i][j] += c[i][j+1]\n    dp = [set() for i in range(w)]\n    dp[0].add(a[0][0] - b[0][0])\n    for j in range(1, w):\n        x = a[0][j] - b[0][j]\n        for v in dp[j-1]:\n            dp[j].add(v + x)\n            dp[j].add(v - x)\n    for i in range(1, h):\n#        print(dp)\n        for j in range(w):\n            x = a[i][j] - b[i][j]\n            if j == 0:\n                buf = copy.deepcopy(dp[j])\n                dp[j].clear()\n                for v in buf:\n                    dp[j].add(v + x)\n                    dp[j].add(v - x)\n            else:\n                buf = dp[j-1] | dp[j]\n                dp[j].clear()\n                for v in buf:\n                    dp[j].add(v + x)\n                    dp[j].add(v - x)\n    ans = float(\"inf\")\n#    print(dp)\n    for v in dp[w-1]:\n        ans = min(ans, abs(v))\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":317,"bad_solution":"import sys\nimport numpy as np\n\nsr = lambda: sys.stdin.readline().rstrip()\nir = lambda: int(sr())\nlr = lambda: list(map(int, sr().split()))\n\nMOD = 10 ** 9 + 7\n\ndef cmb(n, k):\n    if k < 0 or k > n: return 0 \n    return fact[n] * fact_inv[k] % MOD * fact_inv[n-k] % MOD\n\ndef cumprod(arr, MOD):\n    L = len(arr); Lsq = int(L**.5+1)\n    arr = np.resize(arr, Lsq**2).reshape(Lsq, Lsq)\n    for n in range(1, Lsq):\n        arr[:, n] *= arr[:, n-1]; arr[:, n] %= MOD\n    for n in range(1, Lsq):\n        arr[n] *= arr[n-1, -1]; arr[n] %= MOD\n    return arr.ravel()[:L]\n\ndef make_fact(U, MOD):\n    x = np.arange(U, dtype=np.int64); x[0] = 1\n    fact = cumprod(x, MOD)\n    x = np.arange(U, 0, -1, dtype=np.int64); x[0] = pow(int(fact[-1]), MOD-2, MOD)\n    fact_inv = cumprod(x, MOD)[::-1]\n    return fact, fact_inv\n\ndef permutation(n, x, mod=10**9+7):\n    # nPx 順列　ex) permutaion(5, 2) = 20\n    tmp = 1\n    for i in range(n, n-x, -1):\n        tmp = (tmp * i) % mod\n    return tmp\n\nU = 10 ** 5 + 10 # 階乗テーブルの上限\nfact, fact_inv = make_fact(U, MOD)\n\n\nN, K = lr()\ngraph = [[] for _ in range(N+1)] # 1-indexed\nfor _ in range(N-1):\n    a, b = lr()\n    graph[a].append(b)\n    graph[b].append(a)\n\nanswer = K # rootの色の塗り方\nanswer *= fact[K-1] * fact_inv[K-1-len(graph[1])] % MOD\nanswer %= MOD\nroot = 1\nstack = []\nfor child in graph[1]:\n    if len(graph[child]) > 1:\n        stack.append((child, 1))\nwhile stack:\n    cur, p = stack.pop()\n    l = len(graph[cur])\n    if K-2-(len(graph[cur])-1) < 0:\n        answer = 0\n    elif l > 1:\n        answer *= fact[K-2] * fact_inv[K-2-(len(graph[cur])-1)] % MOD\n    for child in graph[cur]:\n        if child == p:\n            continue\n        stack.append((child, cur))\n    answer %= MOD\n\nprint(answer%MOD)\n# 10\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":318,"bad_solution":"import math\n\n\ndef main():\n    A, B, N = map(int, input().split())\n\n    def target(x):\n        # print(math.floor(A * x \/ B))\n        # print(A * math.floor(x \/ B))\n        return math.floor(A * x \/ B) - A * math.floor(x \/ B)\n\n    B_A = 1.0 * B \/ A\n\n    max_value = -1\n    for i in range(1, int(B \/ B_A) + 2):\n        x = B_A * i\n        if x > N:\n            break\n        v = target(x)\n        # print(f'x={i} f(x)={v}')\n        if v > max_value:\n            max_value = v\n    print(max_value)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":319,"bad_solution":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees, log2, gcd\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef TUPLE(): return tuple(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7 \n#mod = 998244353\nfrom decimal import *\n#import numpy as np\n#decimal.getcontext().prec = 10\n\nK = INT()\n\nchecked = [0]*K\n\na = 0\nfor i in range(1, K):\n\ta += 7*pow(10, i-1, K)%K\n\ta %= K\n\tif a == 0:\n\t\tprint(i)\n\t\tbreak\nelse:\n\tprint(-1)\n\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":320,"bad_solution":"import sys\nsys.setrecursionlimit(10 ** 9)\n\nimport functools\n@functools.lru_cache(maxsize = None)\n\ndef main():\n    #input\n    H, W = map(int, input().split())\n    lst = [['#'] * (W + 2)]\n    lst += [['#'] + list(input()) + ['#'] for _ in range(H)]\n    lst += [['#'] * (W + 2)]\n\n    u_table = [[-1] * (W + 2) for _ in range(W + 2)]\n    d_table = [[-1] * (W + 2) for _ in range(W + 2)]\n    r_table = [[-1] * (W + 2) for _ in range(W + 2)]\n    l_table = [[-1] * (W + 2) for _ in range(W + 2)]\n\n    def u(i, j): #up方向に何マス光が伸びるかを数える\n        if u_table[i][j] != -1:\n            return u_table[i][j]\n        if lst[i][j] == '#':\n            u_table[i][j] = 0\n            return 0\n        else:\n            u_table[i][j] = u(i - 1, j) + 1\n            return u_table[i][j]\n    \n    def d(i, j):\n        if d_table[i][j] != -1:\n            return d_table[i][j]\n        if lst[i][j] == '#':\n            d_table[i][j] = 0\n            return 0\n        else:\n            d_table[i][j] = d(i + 1, j) + 1\n            return d_table[i][j]\n    \n    def r(i, j):\n        if r_table[i][j] != -1:\n            return r_table[i][j]\n        if lst[i][j] == '#':\n            r_table[i][j] = 0\n            return 0\n        else:\n            r_table[i][j] = r(i, j + 1) + 1\n            return r_table[i][j]\n\n    def l(i, j):\n        if l_table[i][j] != -1:\n            return l_table[i][j]\n        if lst[i][j] == '#':\n            l_table[i][j] = 0\n            return 0\n        else:\n            l_table[i][j] = l(i, j - 1) + 1\n            return l_table[i][j]\n\n    #スタートマスを変えながら最大の範囲の広さを検索\n    ans = 0\n    for i in range(1, H + 1):\n        for j in range(1, W + 1):\n            if lst[i][j] == '.': #光源を置く場所が障害物でないとき\n                tmp = u(i, j) + d(i, j) + r(i, j) + l(i, j) - 3\n                # print ('(i, j) = ', i, j, tmp)\n                ans = max(ans, tmp)\n    print (ans)\n    return \n\nif __name__ == '__main__':\n    main()\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":321,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nN = int(input())\nS = [input().rstrip() for _ in range(N)]\n\ndef calc(S):\n    now = 0\n    ret = 0\n    for s in S:\n        if s == '(':\n            now += 1\n        else:\n            now -= 1\n        ret = min(ret, now)\n    return ret\n\nH = []\nP = []\nL = []\n\nfor s in S:\n    less = -calc(s)\n    if less == 0:\n        H.append(s)\n    else:\n        l = s.count('(')\n        r = len(s) - l\n        if l >= r:\n            P.append((less, s))\n        else:\n            L.append((less, s))\n\nP.sort()\nL.sort(reverse=True)\nP = [s for _, s in P]\nL = [s for _, s in L]\n\nans = ''.join(H + P + L)\nl = ans.count('(')\nr = ans.count(')')\n\nif l == r and calc(ans) == 0:\n    print('Yes')\nelse:\n    print('No')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":322,"bad_solution":"from collections import deque\n\ndef bfs():\n    global ans\n    que = deque([])\n    black = 0\n    for i in range(h):\n        for j in range(w):\n           if A[i][j] == \"#\":\n               que.append((i, j))\n               d[i][j] = 0\n               black += 1\n    if black == h*w:\n        print(0)\n        exit()\n            \n    white = True\n    while white == True:\n        dx = [1, 0, -1, 0]\n        dy = [0, 1, 0, -1]\n        for k in range(len(que)):\n            i = 0\n            while i < 4: \n                nx = que[k][0] + dx[i]\n                ny = que[k][1] + dy[i]\n                if 0 <= nx < w and 0 <= ny < h and A[nx][ny] != \"#\" and d[nx][ny] == float(\"inf\"):\n                    d[nx][ny] = d[que[k][0]][que[k][1]] + 1\n                    A[nx][ny] = \"#\"\n                i += 1\n        que = deque([])\n        black = 0\n        for i in range(h):\n            for j in range(w):\n              if A[i][j] == \"#\":\n                  que.append((i, j))\n                  black += 1\n                  ans = max(ans, d[i][j])\n        if black == h * w:\n            white = False\n      \n        \n\n\nh, w = map(int, input().split())\nA = [list(input()) for _ in range(h)]\nd = [[float(\"inf\")] * w for _ in range(h)]\nans = 0\nbfs()\n\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":323,"bad_solution":"\n\ndef FUNC(text: str):\n    \"\"\"\n    Checks if given string is a palindrome\n    >>> FUNC('')\n    True\n    >>> FUNC('aba')\n    True\n    >>> FUNC('aaaaa')\n    True\n    >>> FUNC('zbcd')\n    False\n    \"\"\"\n    for i in range(len(text)):\n        if text[i] != text[len(text) - i]:\n            return False\n    return True\n"}
{"id":324,"bad_solution":"\n\ndef FUNC(n: int, p: int):\n    \"\"\"Return 2^n modulo p (be aware of numerics).\n    >>> FUNC(3, 5)\n    3\n    >>> FUNC(1101, 101)\n    2\n    >>> FUNC(0, 101)\n    1\n    >>> FUNC(3, 11)\n    8\n    >>> FUNC(100, 101)\n    1\n    \"\"\"\n    ret = 0\n    for i in range(n):\n        ret = (2 * ret) % p\n    return ret\n"}
{"id":325,"bad_solution":"# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef list4d(a, b, c, d, e): return [[[[e] * d for j in range(c)] for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(N=None): return list(MAP()) if N is None else [INT() for i in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndef build_grid(H, W, intv, _type, space=True, padding=False):\n    # 入力がスペース区切りかどうか\n    if space:\n        _input = lambda: input().split()\n    else:\n        _input = lambda: input()\n    _list = lambda: list(map(_type, _input()))\n    # 余白の有無\n    if padding:\n        offset = 1\n    else:\n        offset = 0\n    grid = list2d(H+offset*2, W+offset*2, intv)\n    for i in range(offset, H+offset):\n        row = _list()\n        for j in range(offset, W+offset):\n            grid[i][j] = row[j-offset]\n    return grid\n\nH, W = MAP()\nMAXV = 160 * 80\n\ngrid1 =build_grid(H, W, 0, int)\ngrid2 =build_grid(H, W, 0, int)\ngrid = list2d(H+1, W+1, 0)\nfor i in range(H):\n    for j in range(W):\n        grid[i][j] = abs(grid1[i][j]-grid2[i][j])\n\n# dp[i][j][k] := グリッド(i, j)に数値kで到達可能かどうか\ndp = list3d(H+1, W+1, MAXV+1, 0)\ndp[0][0][0] = 1\nfor i in range(H):\n    for j in range(W):\n        v = grid[i][j]\n        for k in range(MAXV+1):\n            # 枝刈り\n            if (i+j+1) * 80 < k:\n                break\n            # 上からの遷移\n            dp[i+1][j][abs(k-v)] |= dp[i][j][k]\n            if k+v <= MAXV:\n                dp[i+1][j][k+v] |= dp[i][j][k]\n            # 左からの遷移\n            dp[i][j+1][abs(k-v)] |= dp[i][j][k]\n            if k+v <= MAXV:\n                dp[i][j+1][k+v] |= dp[i][j][k]\nans = INF\nfor k in range(MAXV+1):\n    if dp[H][W-1][k]:\n        ans = min(ans, k)\n    if dp[H-1][W][k]:\n        ans = min(ans, k)\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":326,"bad_solution":"\nimport sys\nsys.setrecursionlimit(700000)\n\ndef s_in():\n    return input()\n\ndef n_in():\n    return int(input())\n\ndef l_in():\n    return list(map(int, input().split()))\n\nn=n_in()\n\nbase=[]\n\nfor _ in range(n):\n    s = s_in()\n\n    c = s[0]\n    cnt = 1\n    ar = []\n    for t in range(1,len(s)):\n        if s[t-1] == s[t]:\n            cnt += 1\n        else:\n            ar.append((c,cnt))\n            c = s[t]\n            cnt = 1\n    ar.append((c,cnt))\n\n    start = 0\n    if ar[0][0] == \")\":\n        start = 1\n\n    r = 0 # ( の数\n    sgn = 1\n    for c,cnt in ar[start:]:\n        r += sgn*cnt\n        sgn *= -1\n\n\n    res = ()\n    if ar[0][0] == \")\":\n        if r >= 0:\n            res = (ar[0][1], r)\n        else:\n            res = (ar[0][1]-r,0)\n    else:\n        if r >= 0:\n            res = (0, r)\n        else:\n            res = (r, 0)\n\n    base.append(res)\n\ni_cnt = 0\nj_cnt = 0\n\nbase2 = []\n\nfor i,j in base:\n    i_cnt += i\n    j_cnt += j\n\n    if j > 0:\n        base2.append((i,-(j-i),j))\n\nif i_cnt != j_cnt:\n    print(\"No\")\n    exit()\n\nbase2.sort()\n\ncurrent = 0\n\n\nfor i,p,j in sorted(filter(lambda x: x[1] <= 0 ,base2)):\n    if current < i:\n        print(\"No\")\n        exit()\n    current -= i\n    current += j\n\nbase3 = []\nfor i,p,j in filter(lambda x: x[1] > 0 ,base2):\n    base3.append((p,i,j))\n\nbase3.sort()\n\nfor p,i,j in base3:\n    if current < i:\n        print(\"No\")\n        1\/0\n        exit()\n    current -= i\n    current += j\n    \nprint(\"Yes\")\n        \n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":327,"bad_solution":"def search(x,r):\n  low = 0\n  high = len(r)-1\n  mid = (low+high)\/\/2\n  while low<=high:\n    rr = r[mid]-x\n    ll = r[mid+1]-x\n    if rr*ll<=0:\n      return(abs(rr),abs(ll))\n    elif r[mid]-x > 0:\n      high = mid\n      mid = (low+high)\/\/2\n    else:\n      low = mid\n      mid = (low+high)\/\/2\n      \n\na, b, q = [int(i) for i in input().split()]\ns = []\nfor i in range(a):\n\ts.append(int(input()))\nt = []\nfor i in range(b):\n\tt.append(int(input()))\nx = []\nfor i in range(q):\n\tx.append(int(input()))\n\nfor xx in x:\n\n  s_l = float('inf')\n  s_r = float('inf')\n  if s[-1] - xx <= 0:\n    s_l = abs(s[-1] - xx)\n  elif s[0] - xx >= 0:\n    s_r = abs(s[0] - xx)\n  else:\n  \ts_l,s_r=search(xx,s)\n  \n  t_l = float('inf')\n  t_r = float('inf')\n  if t[-1] - xx <= 0:\n    t_l = abs(t[-1] - xx)\n  elif t[0] - xx >= 0:\n    t_r = abs(t[0] - xx)\n  else:\n  \tt_l,t_r=search(xx,t)\n  \n  #print(s_l,s_r,t_l,t_r)\n  \n  #l = max(s_l,t_l)\n  #r = max(s_r,t_r)\n  if s_l <= t_l:\n    l = t_l\n    lr = s_l*2 + t_r\n  else:\n    l = s_l\n    lr = t_l*2 + s_r\n  if s_r <= t_r:\n    r = t_r\n    rl = s_r*2 + t_l\n  else:\n    r = s_r\n    rl = t_r*2 + s_l\n \n  ans = min(l,r,lr,rl)\n  print(ans)\n  \nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":328,"bad_solution":"N,M = map(int,input().split())\nA = list(map(int,input().split()))\nnum = [0,2,5,5,4,5,6,3,7,6]\n\na = -1\ncnt = 100\n\ndef check(n,r,S):\n\tif n==0:\n\t\tif r==0:\n\t\t\treturn(S)\n\t\telse:\n\t\t\treturn(\"no\")\n\tfor i in range(len(A)):\n\t\tif r-num[A[i]]>=0:\n\t\t\ts = check(n-1,r-num[A[i]],S+str(A[i]))\n\t\t\tif s!=\"no\":\n\t\t\t\treturn(s)\n\treturn(\"no\")\n\nfor i in range(len(A)):\n\tif cnt>=num[A[i]]:\n\t\ta = A[i]\n\t\tcnt = num[A[i]]\nans = \"\"\nwhile N-cnt>=0:\n\tans = ans+str(a)\n\tN -= cnt\nA.sort()\nA.reverse()\nfor i in range(len(A)):\n\tif N==num[A[i]]:\n\t\tif(a<A[i]):\n\t\t\tans = str(A[i])+ans\n\t\telse:\n\t\t\tans = ans+str(A[i])\n\t\tN = 0\n\nif N==0:\n\tprint(ans)\nelse:\n\ts = \"\"\n\tjudge = False\n\tc = 0\n\twhile judge==False:\n\t\tb = ans[-1:]\n\t\tans = ans[:-1]\n\t\tc += 1\n\t\tN += num[int(b)]\n\t\ts = b+s\n\t\tfor i in range(c):\n\t\t\tres = check(c-i,N,\"\")\n\t\t\tif res!=\"no\":\n\t\t\t\ts1 = ans+res\n\t\t\t\ts2 = res+ans\n\t\t\t\tif s1<s2 and ans<s2:\n\t\t\t\t\tans = s2\n\t\t\t\telif s1>=s2 and ans<s1:\n\t\t\t\t\tans = s1\n#\t\t\t\tif s[0:c-i]<res:\n#\t\t\t\t\tans = res+ans\n#\t\t\t\telse:\n#\t\t\t\t\tans = ans+res\n\t\t\t\tjudge = True\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":329,"bad_solution":"N = int(input())\ndef judge(x):\n    for i in range(4):\n        if i >= 1:\n            x[i-1], x[i] = x[i], x[i-1]\n        if ''.join(x).count('AGC') >= 1:\n            return False\n        if i >= 1:\n            x[i-1], x[i] = x[i], x[i-1]\n    return True\nLI = ['A','G','C','T']\ndef dp(n,p,q,r):\n    if n == 3:\n        if [p,q,r] == ['A','G','C']:\n            return 0\n        elif [p,q,r] == ['A','C','G']:\n            return 0\n        elif [p,q,r] == ['G','A','C']:\n            return 0\n        else:\n            return 1\n    else:\n        cnt = 0\n        for l in LI:\n            if judge([l,p,q,r]):\n                cnt += dp(n-1,l,p,q)\n        return cnt\nans = 0\nfor i in LI:\n    for j in LI:\n        for k in LI:\n            ans += dp(N,i,j,k)\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":330,"bad_solution":"import sys\ninput = lambda : sys.stdin.readline().rstrip()\nsys.setrecursionlimit(max(1000, 10**9))\nwrite = lambda x: sys.stdout.write(x+\"\\n\")\n\n\ndef cumsum(a):\n    \"\"\"l[i] = sum(a[:i]) なるlを返す\n    sum(a[i:j]) == l[j+1] - l[i]\n    \"\"\"\n    c = 0\n    l = [None] * (len(a)+1)\n    for i,num in enumerate(a):\n        l[i] = c\n        c += num\n    l[-1] = c\n    return l\n\nn,m,k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\n\nr = m-1\ns = sum(b)\nnum = m\nbest = 0\nwhile s>k and r>=0:\n    s -= b[r]\n    r -= 1\n    num -= 1\nif r>=0:\n    best = max(best, num)\nfor l in range(n):\n    num += 1\n    s += a[l]\n    while s>k and r>=0:\n        s -= b[r]\n        r -= 1\n        num -= 1\n    if r>=0:\n        best = max(best, num)\nprint(best)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":331,"bad_solution":"import sys\nsys.setrecursionlimit(10000000)\ndef input():\n    return sys.stdin.readline()[:-1]\nfrom bisect import *\nfrom collections import *\nfrom heapq import *\nfrom fractions import Fraction\n\nclass BIT:\n    def __init__(self, N):\n        self.N = N\n        self.bit = [0 for _ in range(N+1)]\n    def add(self, x, a):\n        while x <= self.N:\n            self.bit[x] += a\n            x += x & -x\n    def sum(self, x):\n        ret = 0\n        while x > 0:\n            ret += self.bit[x]\n            x -= x & -x\n        return ret\n\nN, M = map(int, input().split())\nab = [list(map(int, input().split())) for i in range(N)]\nab.sort(key = lambda x: -x[1])\ncnt, ans = 0, 0\nbit = BIT(M)\nfor a, b in ab:\n    # print([bit.sum(i) for i in range(1, M+1)])\n    if M-a >= 0 and bit.sum(M-a+1) <= M-a:\n        ans += b\n        bit.add(M-a+1, 1)\n        cnt += 1\n        if cnt == M:\n            break\n# print()\n# print([bit.sum(i) for i in range(1, M+1)])\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":332,"bad_solution":"#写経\n#https:\/\/atcoder.jp\/contests\/abc168\/submissions\/14421546\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\nfrom bisect import bisect_left, bisect_right\nINF = 10 **18\n\ndef resolve():\n    n,m = map(int,input().split())\n    a = [list(map(int,input().split())) for i in range(n)]\n    b = [list(map(int,input().split())) for i in range(m)]\n\n    X = {-INF, INF}\n    Y = {-INF, INF}\n    for i in a:\n        Y.add(i[2])\n    for i in b:\n        X.add(i[0])\n    X = list(sorted(X))\n    Y = list(sorted(Y))\n    n = len(X) - 1\n    m = len(Y) - 1\n    wallx = [[False] * m for i in range(n)]\n    wally = [[False] * m for i in range(m)]\n\n    for x1, x2, y1 in a:\n        x1 = bisect_left(X, x1)\n        y1 = bisect_left(Y, y1)\n        x2 = bisect_right(X, x2) - 1\n        for i in range(x1, x2):\n            wally[i][y1] = True\n\n    for x1, y1, y2 in b:\n        x1 = bisect_left(X, x1)\n        y1 = bisect_left(Y, y1)\n        y2 = bisect_right(Y, y2) - 1\n        for i in range(y1, y2):\n            wallx[x1][i] = True\n\n    cow = [[False] * m for i in range(n)]\n    cx = bisect_right(X, 0) - 1\n    cy = bisect_right(Y, 0) - 1\n    cow[cx][cy] = True\n    q = [(cx, cy)]\n    ans = 0\n\n    while q:\n        x, y = q.pop()\n        if not x or not y:\n            print(\"INF\")\n            sys.exit()\n        ans += (X[x + 1] - X[x]) * (Y[y + 1] - Y[y])\n        if x and not wallx[x][y] and not cow[x - 1][y]:\n            cow[x - 1][y] = True\n            q.append((x - 1, y))\n        if y and not wally[x][y] and not cow[x][y - 1]:\n            cow[x][y - 1] = True\n            q.append((x, y - 1))\n        if x + 1 < n and not wallx[x + 1][y] and not cow[x + 1][y]:\n            cow[x + 1][y] = True\n            q.append((x + 1, y))\n        if y + 1 < m and not wally[x][y + 1] and not cow[x][y + 1]:\n            cow[x][y + 1] = True\n            q.append((x, y + 1))\n \n    print(ans)\nresolve()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":333,"bad_solution":"\n\ndef FUNC(s: str):\n    \"\"\"\n    returns encoded string by shifting every character by 5 in the alphabet.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) + 5 - ord(\"a\")) % 26) + ord(\"a\")) for ch in s])\n\n\ndef FUNC(s: str):\n    \"\"\"\n    takes as input string encoded with FUNC function. Returns decoded string.\n    \"\"\"\n    return \"\".join([chr(((ord(ch) - 5 - ord(\"a\")) % 26) + ord(ch)) for ch in s])\n"}
{"id":334,"bad_solution":"import heapq\nimport os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\nclass BinaryIndexedTree:\n    # http:\/\/hos.ac\/slides\/20140319_bit.pdf\n    def __init__(self, size):\n        \"\"\"\n        :param int size:\n        \"\"\"\n        self._bit = [0] * size\n        self._size = size\n\n    def add(self, i, w):\n        \"\"\"\n        i 番目に w を加える\n        :param int i:\n        :param int w:\n        :return:\n        \"\"\"\n        x = i + 1\n        while x <= self._size:\n            self._bit[x - 1] += w\n            x += x & -x\n\n    def sum(self, i):\n        \"\"\"\n        0 番目から i 番目までの合計\n        :param int i:\n        :return:\n        \"\"\"\n        ret = 0\n        x = i + 1\n        while x > 0:\n            ret += self._bit[x - 1]\n            x -= x & -x\n        return ret\n\n    def __len__(self):\n        return self._size\n\n\nN, M = list(map(int, sys.stdin.readline().split()))\nAB = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\n# AB.sort(key=lambda ab: (-ab[1], ab[0]))\n# bit = BinaryIndexedTree(size=M)\n#\n# ans = 0\n# for a, b in AB:\n#     # 入れられる？\n#     cap = M - a - bit.sum(M - a) + 1\n#     if cap > 0:\n#         ans += b\n#         # どこに入れよう？\n#         ok = 0\n#         ng = M - a + 1\n#         while abs(ok - ng) > 1:\n#             mid = (ok + ng) \/\/ 2\n#             if M - a - bit.sum(mid) + 1 == cap:\n#                 ok = mid\n#             else:\n#                 ng = mid\n#         bit.add(ok, 1)\n# for i in range(len(bit)):\n#     print(i, bit.sum(i))\n# print(ans)\n\nAB.sort(key=lambda ab: (ab[0], -ab[1]))\nheap = []\nidx = AB[0][0]\nans = 0\nabi = 0\nwhile idx <= M and (heap or abi < N):\n    if abi < N:\n        if AB[abi][0] <= idx:\n            while abi < N and AB[abi][0] <= idx:\n                a, b = AB[abi]\n                heapq.heappush(heap, (-b, a))\n                abi += 1\n        else:\n            idx += 1\n\n    if heap:\n        b, a = heapq.heappop(heap)\n        ans += -b\n        idx += 1\n\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":335,"bad_solution":"n = int(input())\nv = list(map(int,input().split()))\neven = []\nodd = []\n\nfor i in range(n):\n\tif i % 2 == 0:\n\t\teven.append(v[i])\n\telse:\n\t\todd.append(v[i])\n\nodd.sort()\neven.sort()\n\ndef min(a,b):\n\tif a <= b:\n\t\treturn a\n\telse:\n\t\treturn b\n\ndef solve(tag):\n\tl = len(tag)\n\tbef = 0\n\tcounter = 1\n\tmax1,value1,max2,value2 = 0,0,0,0\n\tfor i in range(l):\n\t\tif bef == tag[i]:\n\t\t\tcounter = counter + 1\n\t\telse:\n\t\t\tif(max1 <= counter):\n\t\t\t\tmax2 = max1\n\t\t\t\tvalue2 = value1\n\t\t\t\tmax1 = counter\n\t\t\t\tvalue1 = bef\n\t\t\tcounter = 1\n\t\tbef = tag[i]\n\tif(max1 <= counter):\n\t\tif(value1 != 0):\n\t\t\tmax2 = max1\n\t\t\tvalue2 = value1\n\t\tmax1 = counter\n\t\tvalue1 = bef\n\tlis = [max1,value1,max2,value2]\n\treturn [max1,value1,max2,value2]\n\nres = len(v)\nodr = solve(odd)\nevr = solve(even)\n\nif(odr[1] != evr[1]):\n\tprint(n - odr[0] - evr[0])\nelse:\n\tprint(min(n-odr[0]-evr[2],n-odr[2]-evr[0]))\n\n# max1 value1 max2 value2\n# それぞれのvalue1が異なるなら引けばいい\n# 同じならmax2を比較して大きい方を適用する。\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":336,"bad_solution":"def run(N, K, t, d):\n    '''\n    おいしさ(d)の昇順でソートする O(NlogN)\n    おいしさが大きいもののK個の合計を取得 O(K)\n    K個のうちおいしさが少ないものから順にネタの種類が\n    増えるように変更していく O(K)\n    ネタの種類のうち最大の物の値とインデックスを取得しておく O(K)\n    ネタの種類を変えた合計のうち最大のものが答え\n    '''\n    t_dic = dict(zip(range(N), t))\n    d_dic = dict(zip(range(N), d))\n    d_dic_sorted = dict(sorted(d_dic.items(), key=lambda x: x[1], reverse=True))\n    d_sum = sum(list(d_dic_sorted.values())[:K])\n    t_used = {}\n    t_cnt = 0\n    for i in t:\n        t_used[i] = 0\n    for i in list(d_dic_sorted.keys())[:K]:\n        t_used[t_dic[i]] += 1\n        if t_used[t_dic[i]] == 1:\n            t_cnt += 1\n    t_sum = t_cnt ** 2\n    max_sum = d_sum + t_sum\n    del_list = list(d_dic_sorted.keys())[:K]\n    for i in list(d_dic_sorted.keys())[K:]:\n        di = d_dic_sorted[i]\n        ti = t_dic[i]\n        # ネタの種類が増えるように追加\n        if t_used[ti] == 0:\n            t_used[ti] += 1\n            t_cnt += 1\n            t_sum += 2*t_cnt - 1\n            d_sum += di\n            # ネタが重複しているものを削除\n            while len(del_list) > 0:\n                del_i = del_list.pop()\n                del_di = d_dic_sorted[del_i]\n                del_ti = t_dic[del_i]\n                if t_used[del_ti] > 1:\n                    t_used[del_ti] -= 1\n                    d_sum -= del_di\n                    max_sum = max(max_sum, d_sum + t_sum)\n                    break\n    return max_sum\n\n\ndef main():\n    N, K = map(int, input().split())\n    t = []\n    d = []\n    for _ in range(N):\n        ti, di = map(int, input().split())\n        t.append(ti)\n        d.append(di)\n    print(run(N, K, t, d))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":337,"bad_solution":"\n\nfrom collections import defaultdict\nfrom collections import deque\n\nN = int(input())\n\"\"\"\nbefore[(i,j)]\niとjの試合より前に終わらせておく必要のある直前の対戦者の組の数\n\nnxt[(i,j)]\niとjの試合より後に行える対戦者の組\n\n例２\n4\n2 3 4\n1 3 4\n4 1 2\n3 1 2\nについて、\nbefore[(1,3)] = 2\nbefore[(1,4)] = 2\nnxt[(1,2)] = set((1,3), (2,3))\nみたいな\n\"\"\"\nbefore = defaultdict(int)\nnxt = defaultdict(set)\n\nfor i in range(N):\n    A = list(map(int, input().split()))\n\n    for j,a in enumerate(A):\n        l, h = min(i+1, a), max(i+1, a)\n        if j == 0:\n            b = (l,h)\n        else:\n            before[(l,h)] += 1\n            nxt[b].add((l,h))\n            b = (l,h)\n\n\n\nmatch_today = deque()\n\nfor i in range(1, N):\n    for j in range(i+1, N+1):\n        if before[(i, j)] == 0:\n            match_today.append((i,j))\n            \n\nmatch_tomorrow = deque()\nans = 0\ncnt_match = 0 \nwhile len(match_today) > 0:\n    #print( match_today)\n    ans += 1\n    \n    for _ in range(len(match_today)):\n        l,h = match_today.popleft()\n        cnt_match += 1\n        for nl, nh in nxt[(l,h)]:\n            before[(nl, nh)] -= 1\n            \n            if before[(nl, nh)] == 0:\n                match_tomorrow.append((nl, nh))\n    \n    match_today = match_tomorrow\n    match_tomorrow = deque()\n\n\nif cnt_match == N*(N-1) \/\/ 2:\n    print(ans)\nelse:\n    print(-1)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":338,"bad_solution":"from math import gcd\nfrom functools import reduce\n\n\ndef facs(n):\n    \"\"\"試し割り法における割る数を生成する。\"\"\"\n    yield 2\n    max_prime = int(pow(n, 0.5)) + 1\n    for x in range(3, max_prime, 2):\n        yield x\n\n\ndef main():\n    input()  # N\n    array = [int(x) for x in input().split()]\n    MAX_A = 10 ** 6 + 1\n    histogram = [0] * MAX_A\n    for x in array:\n        histogram[int(x)] += 1\n\n    for divider in facs(MAX_A):\n        count = sum(histogram[divider::divider])\n        if count > 1:\n            break\n    else:\n        return 'pairwise coprime'\n\n    gcd_total = reduce(gcd, array)\n    if gcd_total == 1:\n        return 'setwise coprime'\n    else:\n        return 'not coprime'\n\n\nif __name__ == '__main__':\n    print(main())\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":339,"bad_solution":"from queue import Queue\nimport sys\ninput = sys.stdin.readline\n\nB = int(1E8)\n\ndef main():\n\n    H, W = map(int, input().split())\n    \n    l = 0\n    q = Queue()\n    checked = []\n    for h in range(H):\n        S = input()\n        L = []\n        for w in range(W):\n            if S[w] == '#':\n                l += 1\n                L.append(True)\n                q.put(B*h+w)\n            else:\n                L.append(False)\n        checked.append(L)\n\n    Next = [[[] for _ in range(W)] for _ in range(H)]\n    for h in range(H):\n        for w in range(W):\n            if h != 0:\n                Next[h][w].append(B*(h-1) + w)\n            if h != H-1:\n                Next[h][w].append(B*(h+1) + w)\n            if w != 0:\n                Next[h][w].append(B*h + w-1)\n            if w != W-1:\n                Next[h][w].append(B*h + w+1)\n\n    c = -1\n    for _ in range(H+W+2):\n        if l == 0:\n            break\n        nl = 0\n        for _ in range(l):\n            hw = q.get()\n            h, w = hw\/\/B, hw%B\n            for nhw in Next[h][w]:\n                nh, nw = nhw\/\/B, nhw%B\n                if not checked[nh][nw]:\n                    q.put(B*nh + nw)\n                    checked[nh][nw] = True\n                    nl += 1\n        l = nl\n        c += 1\n\n    print(c)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":340,"bad_solution":"def main():\n    \n    #0 input\n    N = int(input())\n    LR = []\n    for i in range(N):\n        LR.append(list(map(int, input().split())))\n    \n    LR_sorted = sorted(LR, reverse=True)\n    takahashi = 0\n    moved = 0\n    \n    \n    while 1:\n        #1 choose maximum L\n        next_interval  = LR_sorted[0]\n        \n        # finish if Takahashi is in the next interval\n        if next_interval[0] <= takahashi and takahashi <= next_interval[1]:\n            break\n        \n        moved += next_interval[0] - takahashi\n        takahashi = next_interval[0]\n        \n        # delete the current interval\n        del LR_sorted[0]\n        \n        # finish if no items in the list\n        if len(LR_sorted) == 0:\n            break\n        \n        \n        #2 choose minimum R\n        next_interval = min(LR_sorted, key=lambda x:x[1])\n        \n        # finish if Takahashi is in the next interval\n        if next_interval[0] <= takahashi and takahashi <= next_interval[1]:\n            break\n        \n        moved += takahashi - next_interval[1]\n        takahashi = next_interval[1]\n        \n        # delete the current interval\n        LR_sorted.remove(next_interval)\n        \n        # finish if no items in the list\n        if len(LR_sorted) == 0:\n            break\n        \n        \n    moved += abs(0-takahashi)\n    print(moved)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":341,"bad_solution":"import heapq\n\n\nclass Reverse:\n    def __init__(self, val):\n        self.val = val\n\n    def __lt__(self, other):\n        return self.val > other.val\n\n    def __repr__(self):\n        return repr(self.val)\n\n\nclass Heapq:\n    def __init__(self, arr, desc=False):\n        if desc:\n            for i in range(len(arr)):\n                arr[i] = Reverse(arr[i])\n        self.desc = desc\n        self.hq = arr\n        heapq.heapify(self.hq)\n\n    def pop(self):\n        if len(self.hq) == 0:\n            return None\n        if self.desc:\n            return heapq.heappop(self.hq).val\n        else:\n            return heapq.heappop(self.hq)\n\n    def push(self, a):\n        if self.desc:\n            heapq.heappush(self.hq, Reverse(a))\n        else:\n            heapq.heappush(self.hq, a)\n\n    def top(self):\n        if self.desc:\n            return self.hq[0].val\n        else:\n            return self.hq[0]\n\n    def __len__(self):\n        return len(self.hq)\n\n\nn, m = map(int, input().split(' '))\nab = []\nfor _ in range(n):\n    ab.append(list(map(int, input().split(' '))))\n\nans = 0\nh = Heapq([], desc=True)\nfor i in range(1, m+1):\n    for j in filter(lambda x: x[0] == i, ab):\n        h.push(j[1])\n    if len(h) == 0:\n        continue\n    ans += h.pop()\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":342,"bad_solution":"import sys\n\n\ndef next_str() -> str:\n    result = \"\"\n    while True:\n        tmp = sys.stdin.read(1)\n        if tmp.strip() != \"\":\n            result += tmp\n        elif tmp != '\\r':\n            break\n    return result\n\n\ndef main() -> None:\n    s = next_str()\n    dic = [set() for _ in range(len(s))]\n\n    flg = False\n\n    for i in range(len(s)):\n        dic[i].add(s[i])\n\n    print(dic)\n\n    while True:\n        for c in range(ord('a'), ord('z') + 1):\n            for i in range(len(dic)):\n                if chr(c) not in dic[i]:\n                    break\n            else:\n                flg = True\n\n        for i in range(len(dic) - 1):\n            dic[i] |= dic[i + 1]\n\n        if flg: break\n        dic = dic[:-1]\n\n    print(len(s) - len(dic))\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":343,"bad_solution":"import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\n \ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef S_MAP(): return map(str, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef S_LIST(): return list(map(str, input().split()))\n \nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nn = INT()\np = LIST()\n\nans = 0\nfor i in range(n):\n    pi = p[i]\n    flag = True\n    for j in range(i, -1, -1):\n        if pi > p[j]:\n            flag = False\n    if flag ==True:\n        ans += 1\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":344,"bad_solution":"import sys\nimport os\nimport math\nimport bisect\nimport collections\nimport itertools\nimport heapq\nimport re\nimport queue\nimport fractions\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\n# lcm = lambda x, y: x * y \/ math.gcd(x, y)\nlcm = lambda x, y: x * y \/ fractions.gcd(x, y)\n\nMOD = 10 ** 9 + 7\nMAX = float('inf')\n\n\ndef main():\n    if os.getenv(\"LOCAL\"):\n        sys.stdin = open(\"input.txt\", \"r\")\n\n    A, B, C, D = il()\n    E = B - A + 1\n    cnt = 0\n\n    cnt += B \/\/ C\n    cnt += B \/\/ D\n    cnt -= A \/\/ C\n    cnt -= A \/\/ D\n\n    cnt -= B \/\/ lcm(C, D)\n    cnt += A \/\/ lcm(C, D)\n    print(E - int(cnt))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":345,"bad_solution":"\n\ndef FUNC(text):\n    \"\"\"\n    FUNC is a function that takes string and returns string without vowels.\n    >>> FUNC('')\n    ''\n    >>> FUNC(\"abcdef\\nghijklm\")\n    'bcdf\\nghjklm'\n    >>> FUNC('abcdef')\n    'bcdf'\n    >>> FUNC('aaaaa')\n    ''\n    >>> FUNC('aaBAA')\n    'B'\n    >>> FUNC('zbcd')\n    'zbcd'\n    \"\"\"\n    return \"\".join([s for s in text if s.lower() not in [\"a\", \"e\", \"i\", \"o\", \"u\", \"w\", \"y\"]])\n"}
{"id":346,"bad_solution":"def comb(n, k, p):\n    \"\"\"power_funcを用いて(nCk) mod p を求める\"\"\"\n    from math import factorial\n    if n < 0 or k < 0 or n < k: return 0\n    if n == 0 or k == 0: return 1\n    a = factorial(n) % p\n    b = factorial(k) % p\n    c = factorial(n - k) % p\n    return (a * power_func(b, p - 2, p) * power_func(c, p - 2, p)) % p\n\n\ndef power_func(a, b, p):\n    \"\"\"a^b mod p を求める\"\"\"\n    if b == 0: return 1\n    if b % 2 == 0:\n        d = power_func(a, b \/\/ 2, p)\n        return d * d % p\n    if b % 2 == 1:\n        return (a * power_func(a, b - 1, p)) % p\n\n\nN, M, K = map(int, input().split())\nmod = 10 ** 9 + 7\nc = comb(N * M - 2, K - 2, mod)\n\nsumx = 0\nfor d in range(1, M + 1):\n    sumx *= d * (M - d)\n    sumx %= mod\nsumx *= N\nsumx %= mod\nsumx *= N\nsumx %= mod\n\nsumy = 0\nfor d in range(1, N + 1):\n    sumy += d * (N - d)\n    sumy %= mod\nsumy *= M\nsumy %= mod\nsumy *= M\nsumy %= mod\n\nans = (((sumx + sumy) % mod) * c) % mod\nprint(ans)\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":347,"bad_solution":"from heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nfrom collections import deque, defaultdict\nfrom itertools import combinations, permutations, combinations_with_replacement\nfrom itertools import accumulate\nfrom math import ceil, sqrt, pi\n\nMOD = 10 ** 9 + 7\nINF = 10 ** 18\n\nN = int(input())\nS = [input() for _ in range(N)]\n\nLRM = []\nfor s in S:\n    left, right, min_bracket = 0, 0, 0\n    tmp = 0\n    for ss in s:\n        if ss == \"(\":\n            left += 1\n            tmp += 1\n        else:\n            right += 1\n            tmp -= 1\n        min_bracket = min(tmp, min_bracket)\n    LRM.append([left, right, min_bracket])\n#print(LRM)\n\nl_sum, r_sum = 0, 0\nfor l, r, m in LRM:\n    l_sum += l\n    r_sum += r\nif l_sum != r_sum:\n    print(\"No\")\n    exit()\n    \nplus, plus_m, minus = [], [], []\nfor i, (l, r, m) in enumerate(LRM):\n    if m == 0:\n        plus.append([l, r, m, i])\n    else:\n        if l >= r:\n            plus_m.append([l, r, m, i])\n        else:\n            minus.append([l, r, m, i])\nplus_m.sort(key = lambda x: x[1])\nminus.sort(key = lambda x: x[2])\n\ncnt = 0\nfor l, r, m, i in plus + plus_m + minus:\n    #print(S[i])\n    for s in S[i]:\n        if s == \"(\":\n            cnt += 1\n        else:\n            cnt -= 1\n        if cnt < 0:\n            print(\"No\")\n            exit()\nprint(\"Yes\")\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":348,"bad_solution":"import sys\nimport math\nfrom collections import deque\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\ndef main():\n    N, M = NMI()\n    A = NLI()\n\n    match_dict = {i+1: m for i, m in enumerate([2,5,5,4,5,6,3,7,6])}\n    usable_list = [[a, match_dict[a]] for a in A]\n    usable_list.sort(key=lambda x: (x[1], -x[0]))\n\n    def dfs(now_num, n):\n        if n == 0:\n            now = list(str(now_num))\n            now.sort(reverse=True)\n            print(\"\".join(now))\n            exit()\n\n        for num, m in usable_list:\n            if n < m:\n                break\n            dfs(now_num*10+num, n-m)\n\n    dfs(0, N)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":349,"bad_solution":"\n\ndef FUNC(l: list, t: int):\n    \"\"\"Return True if all numbers in the list l are below threshold t.\n    >>> FUNC([1, 2, 4, 10], 100)\n    True\n    >>> FUNC([1, 20, 4, 10], 5)\n    False\n    \"\"\"\n    for e in l:\n        if e >= t:\n            return True\n    return False\n"}
{"id":350,"bad_solution":"from collections import deque\nimport numpy as np\nimport sys\n\nH, W = map(int, input().split())\n\nMap = [[] for _ in range(H)]\nreached = [[False]*W for _ in range(H)]\nq = deque()\ncnt = 0\ncount = 0\ntempList = []\nfor y in range(H):\n    for i, x in enumerate(input()):\n        Map[y].append(x)\n        if x==\"#\":\n            cnt += 1\n            reached[y][i] = True\n            tempList.append((i + 1,y))\n            tempList.append((i - 1, y))\n            tempList.append((i, y + 1))\n            tempList.append((i, y - 1))\n\nq.append(tempList)\n\ndef BFS(blist):\n    global count\n    global cnt\n    tList = []\n\n    count += 1\n\n    for (x, y) in blist:\n        if x>=W or y>=H or x<0 or y<0 or reached[y][x]:\n            continue\n\n        reached[y][x] = True\n        Map[y][x] = \"#\"\n        cnt += 1\n\n        tList.append((x + 1, y))\n        tList.append((x - 1, y))\n        tList.append((x, y + 1))\n        tList.append((x, y - 1))\n\n    if cnt==H*W:\n        print(count)\n        sys.exit()\n\n    q.append(tList)\n\nwhile q:\n    BFS(q.popleft())\n\n\n\n\n\n\n\n\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":351,"bad_solution":"# -*- coding: utf-8 -*-\n# abc127\/abc127_d\nimport sys\n\ns2nn = lambda s: [int(c) for c in s.split(' ')]\nss2nn = lambda ss: [int(s) for s in list(ss)]\nss2nnn = lambda ss: [s2nn(s) for s in list(ss)]\ni2s = lambda: sys.stdin.readline().rstrip()\ni2n = lambda: int(i2s())\ni2nn = lambda: s2nn(i2s())\nii2ss = lambda n: [i2s() for _ in range(n)]\nii2nn = lambda n: ss2nn(ii2ss(n))\nii2nnn = lambda n: ss2nnn(ii2ss(n))\n\ndef main():\n    N, M = i2nn()\n    A = i2nn()\n    for j in range(M):\n        B, C = i2nn()\n        A += [C] * B\n    A.sort(reverse=True)\n    print(sum(A[:N]))\n    return\n\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":352,"bad_solution":"n = int(input())\na = [int(x) for x in input().split()]\nprimes = [2]\nA = max(a)\nb = [0] * (A+1)\n\nfor L in range(3, A, 2): \n    if all(L % L2 != 0 for L2 in primes):\n        primes.append(L)\n\ndef factorization(n):\n    arr = 0\n    temp = n\n    for i in primes:\n        if i**2 > n: break\n        if temp%i==0:\n            b[i] += 1\n            arr += 1\n            while temp%i==0:\n                temp \/\/= i\n    if temp!=1:\n        b[temp] += 1\n        arr += 1\n\n    if arr==0:\n        b[n] += 1\n\nfor aa in a:\n    factorization(aa)\nif max(b) == 1: print('pairwise coprime')\nelif max(b) < n: print('setwise coprime')\nelse: print('not coprime')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":353,"bad_solution":"\n\ndef FUNC(x: int, y: int):\n    \"\"\"Add two numbers x and y\n    >>> FUNC(2, 3)\n    5\n    >>> FUNC(5, 7)\n    12\n    \"\"\"\n    return x + y + y + x\n"}
{"id":354,"bad_solution":"def main():\n  _range, _input = range, stdin.readline\n  h, w = map(int, _input().split())\n  s = [_input() + '#' for _ in _range(h)]\n  s.append('#' * (w + 1))\n  t = [[-1] * w for _ in _range(h + 1)]\n  tstart = [-1] * (w + 1)\n  for i in _range(h + 1):\n    ystart = -1\n    si = s[i]\n    ti = t[i]\n    for j in _range(w + 1):\n      tj = tstart[j]\n      if si[j] == '#':\n        if ystart != -1:\n          n = j - ystart\n          for k in _range(ystart, j):\n            ti[k] += n\n          ystart = -1\n        if tj != -1:\n          n = i - tj\n          for k in _range(tj, i):\n            t[k][j] += n\n          tstart[j] = -1\n      else:\n        if ystart == -1:\n          ystart = j\n        if tj == -1:\n          tstart[j] = i\n  print(max(map(max, t)))\nmain()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":355,"bad_solution":"n, k = map(int, input().split())\ns = input()\nturn = 0\n\nhappiness = 0\n\n\ndef exchange(num, loc):\n    global s\n    tmp = s[loc:loc+num+1]\n    tmp = tmp[::-1]\n    tmp = ['L' if x == 'R' else 'R' for x in tmp]\n    s[loc:loc+num+1] = tmp\n\nfor i in range(n):\n    if i == 0:\n        if s[i] == 'R' and s[i+1] == 'R':\n            happiness += 1\n    elif i == n-1:\n        if s[i] == 'L' and s[i-1] == 'L':\n            happiness += 1\n    else:\n        if s[i] == 'R' and s[i+1] == 'R':\n            happiness += 1\n        elif s[i] == 'L' and s[i-1] == 'L':\n            happiness += 1\n\nfor i in range(n-1):\n    if s[i] == 'R' and s[i+1] == 'L' or s[i] == 'L' and s[i+1] == 'R':\n        turn += 1\n\n\ns = 'X' + s + 'X'\ns = list(s)\nlamp = -1\nwhile k != 0:\n    lamp += 1\n    if turn == 1:\n        print(n-1)\n        exit()\n    for j in range(2, n-lamp-1):\n        if s[j] == 'R' and s[j - 1] != 'R' and s[j + lamp] == 'R' and s[j + lamp + 1] != 'R':\n            happiness += 2\n            exchange(lamp, j)\n            k -= 1\n            turn -= 2\n            break\n        elif s[j] == 'L' and s[j - 1] != 'L' and s[j + lamp] == 'L' and s[j + lamp + 1] != 'R':\n            happiness += 2\n            exchange(lamp, j)\n            k -= 1\n            turn -= 2\n            break\n    if turn == 0:\n        break\n\nprint(happiness)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":356,"bad_solution":"def ii():return int(input())\ndef iim():return map(int,input().split())\ndef iil():return list(map(int,input().split()))\nimport numpy as np\n\ndef binary_search(lis, item):\n    low = 0\n    high = len(lis) - 1\n    inRange = high\n\n    while low <= high:\n        mid = (low + high) \/\/2\n        guess1 = lis[mid]\n        if mid < inRange:\n            guess2 = lis[mid+1]\n        else:\n            if lis[mid] <= item:\n                return len(lis)\n            else:\n                return len(lis)-1\n        if guess1 <= item < guess2:\n            return mid+1\n        if guess1 > item:\n            high = mid\n        else:\n            low = mid+1\n    return 0\n\nn,m,k = iim()\na = iil()\ncuma = []\nif a[0] <= k:\n    cuma.append(a[0])\n    for i in range(n-1):\n        num = cuma[-1]+a[i+1]\n        if num > k:\n            break\n        else:\n            cuma.append(num)\nb = iil()\ncumb = []\nif b[0] <= k:\n    cumb.append(b[0])\n    for i in range(m-1):\n        num = cumb[-1]+b[i+1]\n        if num > k:\n            break\n        else:\n            cumb.append(num)\nif len(cuma) > 0:\n    cnt = len(cuma)\n    ans = cnt+binary_search(cumb,k-cuma[-1])\n    #print(k-cuma[-1],binary_search(cumb,k-cuma[-1]))\n    for i,item in enumerate(cuma[::-1]):\n        tmp = cnt-i\n        res = k-item\n        plus = binary_search(cumb,res)\n        ans = max(ans,tmp+plus)\nelse:\n    ans = binary_search(cumb,k)\nprint(ans)\n\n#print(binary_search([1,2,3,4,5,6,7,8,9,10],8))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":357,"bad_solution":"import sys\ninput = sys.stdin.readline\nn = int(input())\na = list(map(int, input().split()))\nb = a.copy()\nfrom math import gcd\n\ndef sieve(n):\n    prime = []\n    is_prime = [True]*(n+1)\n    is_prime[0] = is_prime[1] = False\n    for i in range(n+1):\n        if is_prime[i]:\n            prime.append(i)\n            for j in range(i*2, n+1, i):\n                is_prime[j] = False\n                \n    return prime\n\nprimes = sieve(1000)\nflg = True\nfor x in primes:\n    tmp = 0\n    for i in range(n):\n        if a[i] % x == 0:\n            tmp += 1\n        while a[i] % x == 0:\n            a[i] \/\/= x\n    if tmp > 1:\n        flg = False\n\nfrom collections import Counter\ncnt = Counter(a)\nfor x, c in cnt.items():\n    if x != 1 and c > 1:\n        flg = False\n\nif flg:\n    print('pairwise coprime')\nelse:\n    tmp = b[0]\n    for i in range(1, n):\n        tmp = gcd(tmp, b[i])\n    if tmp == 1:\n        print('setwise coprime')\n    else:\n        print('not coprime')\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":358,"bad_solution":"def main():\n    import sys\n    input = sys.stdin.readline\n    N = int(input())\n\n    A = [tuple(map(int, input().split())) for _ in range(N)]\n\n    # check = [[True] + [False] * (N - 2) for _ in range(N)] #True準備完了、False試合不可\n    check = [0] * N #i番目の次の相手のindex\n\n    ans = 1\n    i = 0\n    tmp = 0\n    count = 0\n    flag  = [True] * N #試合をしたかどうかチェック\n    while tmp < 2 * N + 2:\n        if i == N:\n            ans += 1\n            flag  = [True] * N #試合をしたかどうかチェック\n            i = 0\n            \n        if check[i] >= N - 1 or flag[i] == False:\n            i += 1\n            tmp += 1\n            continue\n        b = A[i][check[i]] - 1\n        # print (b)\n        if A[b][check[b]] - 1 == i and flag[b]: #試合できる時\n            check[i] += 1\n            check[b] += 1\n            flag[i] = False\n            flag[b] = False\n            tmp = 0\n            count += 1\n            if count == (N * (N - 1))\/\/2:\n                print (ans)\n                exit()\n        i += 1\n        tmp += 1\n    print (-1)\n    return \n            \nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":359,"bad_solution":"from collections import defaultdict\nd0 = defaultdict(int)\nd1 = defaultdict(int)\nN=int(input())\nv=list(map(int,input().split()))\nfor i in range(N):\n    if i%2==0:\n        d0[v[i]]+=1\n    else:\n        d1[v[i]]+=1\nD0=sorted(d0.items(), key=lambda x:x[1],reverse=True)\nD1=sorted(d1.items(), key=lambda x:x[1],reverse=True)\nprint(D0)\nprint(D1)\nif (D0[0][1]+D1[0][1])==len(v) and D0[0][0]==D1[0][0]:\n    print(len(v)\/\/2)\nelse:\n    i0=0\n    i1=0\n    while i0<=len(D0) or i1<=len(D1):\n        if D0[i0][0]!=D1[i1][0]:\n            print(len(v)-D0[i0][1]-D1[i1][1])\n            break\n        else:\n            if D0[i0][1]>D1[i1][1]:\n                i1+=1\n            elif D0[i0][1]<D1[i1][1]:\n                i0+=1\n            else:\n                if (len(D0)-1-i0)>0 and (len(D1)-1-i1)>0:\n                    if D0[i0+1][1]>D1[i1+1][1]:\n                        i0+=1\n                    else:\n                        i1+=1\n                elif (len(D0)-1-i0)==0 :\n                    i1+=1\n                elif (len(D1)-1-i1)==0:\n                    i0+=1\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":360,"bad_solution":"import queue\ndef solve():\n    cnt=0\n    black=[]\n    H,W=list(map(int,input().split(' ')))\n    dark = []\n    q = queue.Queue()\n    for i in range(H):\n        dark.append(list(input()))\n    for i in range(H):\n        for j in range(W):\n            if dark[i][j] =='#':\n                q.put([i,j])\n                black.append([i,j])\n\n    while 1:\n        cnt +=1\n        for i in range(q.qsize()):\n            h,w=q.get()\n            if h-1 >= 0 and not([h-1,w] in black):\n                black.append([h-1,w])\n                q.put([h-1,w])\n            if h+1 < H and not([h+1,w] in black) :\n                black.append([h+1,w])\n                q.put([h+1,w])\n            if w-1 >= 0 and not([h,w-1] in black):\n                black.append([h,w-1])\n                q.put([h,w-1])\n            if w+1 < W and not ([h,w+1] in black):\n                black.append([h,w+1])\n                q.put([h,w+1])\n        if len(black) == H*W:\n            break\n\n    return cnt\n\nprint(solve())\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":361,"bad_solution":"n=int(input())\nab=[list(map(int,input().split())) for _ in range(n-1)]\nmod=pow(10,9)+7\nki=[[] for _ in range(n)]\ntodo=[]\nfor a,b in ab:\n  ki[a-1].append(b-1)\n  ki[b-1].append(a-1)\nimport sys\nsys.setrecursionlimit(100000)\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\ng1 = [1, 1] \ng2 = [1, 1] \ninverse = [0, 1]\nfor i in range( 2, n + 1 ):\n    g1.append( ( g1[-1] * i ) % mod )\n    inverse.append( ( -inverse[mod % i] * (mod\/\/i) ) % mod )\n    g2.append( (g2[-1] * inverse[-1]) % mod )\nmemo={}\n\ndef dfs(i,j):#i->jの矢印に対応する部分木の値を返す。サイズ、パターン数\n  if (i,j) in memo:\n    return memo[(i,j)]\n  l=ki[j]\n  ret=0\n  sizes=[]\n  pats=[]\n  sum_size=0\n  ret=1\n  for li in l:\n    if li==i:\n      continue\n    size,pat=dfs(j,li)\n    sizes.append(size)\n    sum_size+=size\n    ret*=cmb(sum_size,size,mod)\n    ret*=pat\n  memo[(i,j)]=(sum_size+1,ret)\n  return (sum_size+1,ret)\ndfs(-1,0)\nprint(memo.keys())\n# memo[(i,j)]:#i->jの部分木\ndef bfs(i,j): # i->jの矢印に対応する部分木を計算する\n    if (-1,j) in memo: \n        # (-1,j)が定まっているなら、jから出ていく矢印に対応する部分木はすべて定まっている。\n        # 従ってmemo[(j,i)]が定まっている\n        ret=memo[(-1,j)][0]\n        ret*=pow(memo[(j,i)][1],mod-2,mod)\n        ret%=mod\n        ret*=pow(cmb(n,memo[(j,i)][0],mod),mod-2,mod)\n        ret%=mod\n        memo[(i,j)]=(n-memo[(j,i)][0],ret)\n        if (-1,i) not in memo:\n            memo[(-1,i)]=dfs(-1,i)\n    else:\n        # 適切な順番で呼び出すことにより、(-1,j)が定まっていなくても、\n        # jから出ていく矢印に対応する部分木はすべて定まっている状態にできる。\n        l=ki[j]\n        pat=1\n        size=0\n        for li in l:\n            pat*=memo[(j,li)][1]\n            size_=memo[(j,li)][0]\n            size+=size_\n            pat*=cmb(size,size_,mod)\n            pat%=mod\n        memo[(j,-1)]=(n,pat)\n        bfs(i,j)\nfrom collections import deque\ntodo=deque([0])\nseen=[0]*n\nseen[0]=1\nwhile todo:\n    i=todo.popleft()\n    l=ki[i]\n    for li in l:\n        if seen[li]==0:\n            bfs(li,i)\n            todo.append(li)\n            seen[li]=1\nprint(memo.keys())\nfor i in range(n):\n    print(memo[(-1,i)][1]%mod)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":362,"bad_solution":"from sys import stdin\n\ndef main():\n\tline = [int(x) for x in stdin.readline().strip().split()]\n\tx,y = line[0],line[1]\n\tcount = 0\n\tcount += abs(y) - abs(x)\n\tif x == y:\n\t\tprint(0)\n\telif (x >= 0 and y >= 0) or (x < 0 and y < 0 and x < y):\n\t\tprint(count)\n\telif (x>= 0 and y < 0) or (x < 0 and y >= 0):\n\t\tcount+=1\n\t\tprint(count)\n\telif x < 0 and y < 0 and x > y:\n\t\tcount+=2\n\t\tprint(count)\nmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":363,"bad_solution":"import sys\nimport os\nimport math\nimport bisect\nimport itertools\nimport collections\nimport heapq\nimport queue\nimport array\n\n# 時々使う\n# from scipy.sparse.csgraph import csgraph_from_dense, floyd_warshall\n# from decimal import Decimal\n# from collections import defaultdict, deque\n\n# 再帰の制限設定\nsys.setrecursionlimit(10000000)\n\n\ndef ii(): return int(sys.stdin.buffer.readline().rstrip())\ndef il(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef fl(): return list(map(float, sys.stdin.buffer.readline().split()))\ndef iln(n): return [int(sys.stdin.buffer.readline().rstrip())\n                    for _ in range(n)]\n\n\ndef iss(): return sys.stdin.buffer.readline().decode().rstrip()\ndef sl(): return list(map(str, sys.stdin.buffer.readline().decode().split()))\ndef isn(n): return [sys.stdin.buffer.readline().decode().rstrip()\n                    for _ in range(n)]\n\n\ndef lcm(x, y): return (x * y) \/\/ math.gcd(x, y)\n\n\nMOD = 10 ** 9 + 7\nINF = float('inf')\n\n\ndef main():\n    if os.getenv(\"LOCAL\"):\n        sys.stdin = open(\"input.txt\", \"r\")\n\n    S = iss()\n    if S[-1] == 'e':\n        print(S + 's')\n    else:\n        print(S + 'es')\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":364,"bad_solution":"\n\ndef FUNC(s0: str, s1: str):\n    \"\"\"\n    Check if two words have the same characters.\n    >>> FUNC('eabcdzzzz', 'dddzzzzzzzddeddabc')\n    True\n    >>> FUNC('abcd', 'dddddddabc')\n    True\n    >>> FUNC('dddddddabc', 'abcd')\n    True\n    >>> FUNC('eabcd', 'dddddddabc')\n    False\n    >>> FUNC('abcd', 'dddddddabce')\n    False\n    >>> FUNC('eabcdzzzz', 'dddzzzzzzzddddabc')\n    False\n    \"\"\"\n    return s0 == s1\n"}
{"id":365,"bad_solution":"from sys import stdin\ndef solve():\n    import collections\n    readline = stdin.readline\n    h,w = map(int,readline().split())\n    si,sj = map(int,readline().split())\n    gi,gj = map(int,readline().split())\n    si,sj,gi,gj = si-1,sj-1,gi-1,gj-1\n    grid = []\n    for _ in range(h):\n        grid.append(readline()[:-1])\n    INF = float(\"inf\")\n    dist = {(i,j):INF for i in range(h) for j in range(w)}\n    q = collections.deque([(si,sj)])\n    dist[si,sj] = 0\n    while q:\n        i,j = q.popleft()\n        if (i,j) == (gi,gj):\n            return dist[i,j]\n        for ni,nj in [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]:\n            if 0 <= ni and ni < h and 0 <= nj and nj < w and grid[ni][nj] == \".\":\n                if dist[ni,nj] > dist[i,j]:\n                    dist[ni,nj] = dist[i,j]\n                    q.appendleft((ni,nj))\n        for ni in range(i-2,i+3):\n            if not (0 <= ni and ni < h): continue\n            for nj in range(j-2,j+3):\n                if not (0 <= nj and nj < w): continue\n                if (ni,nj) not in [(i,j),(i+1,j),(i-1,j),(i,j+1),(i,j-1)] and grid[ni][nj] == \".\":\n                    if dist[ni,nj] > dist[i,j] + 1:\n                        dist[ni,nj] = dist[i,j] + 1\n                        q.append((ni,nj))\n\n    return -1\n\nprint(solve())\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":366,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nINF = 2**62-1\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef dc(n, m):\n    return -(-n \/\/ m)\n\n# @mt\ndef slv(H, N, AB):\n    ans = 0\n    abc = [(a\/b, b, a) for a, b in AB]\n\n    abc.sort(key=lambda x: x[1])\n    abc.sort(key=lambda x: x[0], reverse=True)\n    ri = set()\n    for i in range(1, N):\n        if abc[i][1] > abc[i-1][1]:\n            ri.add(i)\n    ri = set(ri)\n    abc_ = []\n    for i in range(N):\n        if i not in ri:\n            abc_.append(abc[i])\n\n    abc = abc_\n\n    HD = defaultdict(lambda : INF)\n    _, b, a = abc[0]\n    for i in range(1, dc(H, a)+1):\n        HD[H - i*a] = i*b\n    for _, b, a in abc[1:]:\n        tmp = {}\n        for k, v in list(HD.items()):\n            for i in range(1, dc(k, a)+1):\n                if HD[k - i*a] > v+i*b:\n                    HD[k- i*a] = v+i*b\n        # HD.update(tmp)\n    ans = INF\n    for k, v in HD.items():\n        if k <= 0:\n            ans = min(ans, v)\n\n\n    return ans\n\n\ndef main():\n    H, N = read_int_n()\n    AB = [read_int_n() for _ in range(N)]\n    print(slv(H, N, AB))\n    # H = 10**4\n    # N = 1000\n    # AB = [[random.randint(1, 10000), random.randint(1, 10000)] for _ in range(N)]\n    # print(slv(H, N, AB))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":367,"bad_solution":"import sys\nimport math\nfrom collections import deque\nfrom collections import defaultdict\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\n# Nの素因数分解を辞書で返す\ndef prime_fact(n, ela):\n    if n == 1:\n        return {1: 1}\n\n\n    prime_dict = {}\n    for i in ela:\n        cnt = 0\n        while n % i == 0:\n            cnt += 1\n            n = n \/\/ i\n        if cnt:\n            prime_dict[i] = cnt\n        if n == 1:\n            break\n    if n != 1:\n        prime_dict[n] = 1\n    return prime_dict\n\n\ndef sieve_of_erastosthenes(num):\n    input_list = [False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range(num)]\n    input_list[0] = input_list[1] = False\n    input_list[2] = input_list[3] = input_list[5] = True\n    sqrt = math.sqrt(num)\n\n    for serial in range(3, num, 2):\n        if not input_list[serial]:\n            continue\n\n        if serial >= sqrt:\n            return input_list\n\n        for s in range(serial ** 2, num, serial):\n            input_list[s] = False\n\n\ndef main():\n    N = NI()\n    A = NLI()\n    ela = sieve_of_erastosthenes(1001)\n    ela2 = [i for i, b in enumerate(ela) if b]\n\n    if max(A) == 1:\n        print(\"pairwise coprime\")\n        exit()\n\n    g = A[0]\n    for a in A:\n        g = math.gcd(g, a)\n    if g > 1:\n        print(\"setwise coprime\")\n        exit()\n\n    p_cnt = defaultdict(int)\n    PD_list = defaultdict(dict)\n    cnt = 0\n    for a in A:\n        if a == 1:\n            continue\n\n        cnt += 1\n        if cnt >= 90000:\n            print(\"not coprime\")\n            exit()\n\n        if PD_list[a]:\n            AP = PD_list[a]\n        else:\n            AP = prime_fact(a, ela, ela2)\n            PD_list[a] = AP\n        for apk in AP.keys():\n            p_cnt[apk] += 1\n\n    max_p = max(p_cnt.values())\n    if max_p == 1:\n        print(\"pairwise coprime\")\n    elif max_p == N:\n        print(\"not coprime\")\n    else:\n        print(\"setwise coprime\")\n\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":368,"bad_solution":"\n\ndef FUNC(n: int):\n    \"\"\"Return n-th Fibonacci number.\n    >>> FUNC(10)\n    55\n    >>> FUNC(1)\n    1\n    >>> FUNC(8)\n    21\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    return FUNC(n - 1) + FUNC(n - 2)\n"}
{"id":369,"bad_solution":"import sys\n#import math\n#from collections import defaultdict\n\n#sys.setrecursionlimit(10**7)\ndef input():\n    return sys.stdin.readline()[:-1]\n\n#mod = 10**9 + 7\n\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\ndef Line(N,num):\n    if N<=0:\n        return [[] for _ in range(num)]\n    elif num==1:\n        return [I() for _ in range(N)]\n    else:\n        read_all = [tuple(II()) for _ in range(N)]\n        return map(list, zip(*read_all))\n\n#################\n\nimport numpy as np\n\nN,M = II()\nA = III()\n\nprint('time test')\n\nh = [0]*(max(A))\nfor a in A:\n    h[a-1] += 1\n\nbit = (2*len(h)-2).bit_length()\nL = 2**bit\nfh = np.fft.rfft(h,L)\nc = np.rint(np.fft.irfft(fh*fh,L)).astype(np.int64)[:2*len(h)-1]\nconv = np.append([0,0],c)\nans = 0\ncount = 0\n\nfor k in range(2,2*max(A)+1)[::-1]:\n    if conv[k]:\n        num = min(M-count,conv[k])\n        count += num\n        ans += k*num\n    if count==M:\n        break\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":370,"bad_solution":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nA, B = MAP()\na = A*12.5\nb = B*10\nc = max(a, b)\/\/1\n\nif (c*0.08)\/\/1 == A and (c*0.1)\/\/1 == B:\n  print(int(c))\nelse:\n  print(-1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":371,"bad_solution":"\n\ndef FUNC(brackets: str):\n    \"\"\" brackets is a string of \"<\" and \">\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> FUNC(\"<\")\n    False\n    >>> FUNC(\"<>\")\n    True\n    >>> FUNC(\"<<><>>\")\n    True\n    >>> FUNC(\"><<>\")\n    False\n    \"\"\"\n    depth = 0\n    for b in brackets:\n        if b == \">\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return False\n    return depth == 0\n"}
{"id":372,"bad_solution":"#!\/usr\/bin\/env python3\n\nimport sys\n# import math\n# import re                                    # re.compile(pattern) => ptn obj; p.search(s), p.match(s), p.finditer(s) => match obj; p.sub(after, s)\n# from collections import deque                # deque class. deque(L): dq.append(x), dq.appendleft(x), dq.pop(), dq.popleft(), dq.rotate()\n# from collections import defaultdict          # subclass of dict. defaultdict(facroty)\n# from collections import Counter              # subclass of dict. Counter(iter): c.elements(), c.most_common(n), c.subtract(iter)\n# from heapq import heapify, heappush, heappop # built-in list. heapify(L) changes list in-place to min-heap in O(n), heappush(heapL, x) and heappop(heapL) in O(lgn).\n# from heapq import nlargest, nsmallest        # nlargest(n, iter[, key]) returns k-largest-list in O(n+klgn).\n# from itertools import count, cycle, repeat   # count(start[,step]), cycle(iter), repeat(elm[,n])\n# from itertools import groupby                # [(k, list(g)) for k, g in groupby('000112')] returns [('0',['0','0','0']), ('1',['1','1']), ('2',['2'])]\n# from itertools import starmap                # starmap(pow, [[2,5], [3,2]]) returns [32, 9]\n# from itertools import product                # product(iter, repeat=n)\n# from itertools import accumulate             # accumulate(iter[, f])\n# from functools import reduce                 # reduce(f, iter[, init])\n# from functools import lru_cache              # @lrucache ...arguments of functions should be able to be keys of dict\nfrom bisect import bisect_left, bisect_right # bisect_left(a, x, lo=0, hi=len(a)) returns i such that all(val<x for val in a[lo:i]) and all(val>-=x for val in a[i:hi]).\n# from copy import deepcopy                    # to copy multi-dimentional matrix without reference\n# from fractions import gcd                    # for Python 3.4\n\n\ndef main():\n    mod = 1000000007                  # 10^9+7\n    inf = float('inf')\n    sys.setrecursionlimit(10**6)    # 1000 -> 1000000\n    def input(): return sys.stdin.readline().rstrip()\n    def ii():  return int(input())\n    def mi():  return map(int, input().split())\n    def mi_0(): return map(lambda x: int(x)-1, input().split())\n    def lmi(): return list(map(int, input().split()))\n    def lmi_0(): return list(map(lambda x: int(x)-1, input().split()))\n    def li():  return list(input())\n    \n    from itertools import permutations\n    n = ii()\n    s = input()\n    ind_lst = [[] for _ in range(3)]\n    d = {'R':0, 'G':1, 'B':2}\n    for i, char in enumerate(s):\n        ind_lst[d[char]].append(i)\n    cnt = 0\n    for perm in permutations([0, 1, 2]):\n        a, b, c = perm\n        for x in ind_lst[a]:\n            i = bisect_left(ind_lst[b], x)\n            for y in ind_lst[b][i:]:\n                j = bisect_left(ind_lst[c], y)\n                for z in ind_lst[c][j:]:\n                    if x + z != 2 * y:\n                        cnt += 1\n    print(cnt)\n\n\n    \n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":373,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\n\ndef solve(N: int, M: int, K: int, A: \"List[int]\", B: \"List[int]\"):\n    cur = sum(A)\n    for i in range(N-1,-1,-1):\n        if cur>K: cur -= A[i]\n        else:break\n    if cur==0: max_k = 0\n    else: max_k = i+1\n    p = 0\n    for q in range(i,-1,-1):\n        while(p<M):\n            if cur+B[p] <= K:\n                cur+=B[p]\n                max_k = max(i+1+p+1, max_k)\n                p+=1\n            else:\n                break\n        cur -= A[q-1]\n    print(max_k)\n\n\n\n\n\n    return\n\n\n# Generated by 1.1.7.1 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    B = [int(next(tokens)) for _ in range(M)]  # type: \"List[int]\"\n    solve(N, M, K, A, B)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":374,"bad_solution":"\n\ndef FUNC(l: list):\n    \"\"\"Return True is list elements are FUNCally increasing or decreasing.\n    >>> FUNC([1, 2, 4, 20])\n    True\n    >>> FUNC([1, 20, 4, 10])\n    False\n    >>> FUNC([4, 1, 0, -10])\n    True\n    \"\"\"\n    if l == sorted(l) or l == sorted(l, reverse=True):\n        return False\n    return True\n"}
{"id":375,"bad_solution":"from collections import deque\n\nN, K = map(int, input().split())\nmod = 10**9+7\n\nT = [[] for _ in range(N)]\nfor i in range(N-1):\n    a, b = map(int, input().split())\n    T[a-1].append(b-1)\n    T[b-1].append(a-1)\n\nfac = [0]*(K+1)\nfac[0] = 1\nfac[1] = 1\nfor i in range(2, K+1):\n    fac[i] = fac[i-1] * i % mod\n\ndef modinv(a, mod=10**9+7):\n    return pow(a, mod-2, mod)\n\nans = fac[K] * modinv(fac[K - len(T[0]) - 1])\nq = deque(T[0])\nused = [0]*N\nused[0] = 1\nfor i in T[0]:\n    used[i] = 1\n\nwhile(len(q)>0):\n    a = q.popleft()\n    if len(T[a]) != 1:\n        ans *= fac[K-2]*modinv(fac[K - len(T[a]) - 1])\n        ans %= mod\n    for i in T[a]:\n        if used[i] == 0:\n            q.append(i)\n            used[i] = 1\nprint(ans%mod)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":376,"bad_solution":"import math\n\ndef combinations_count(n, r):\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\nnn = int(input())\naa = list(map(int,input().split()))\n\nne = [0]*nn\ncn = [0]*nn\ncnminus1 = [0]*nn\n#print(nn,aa)\n\nfor i in range(nn):\n    ne[aa[i]] += 1\n\nfor i in range(nn):\n #   print(ne[i])\n    if ne[i] == 0:\n        cn[i] = 0\n        cnminus1[i] = 0\n    elif ne[i] == 1:\n        cn[i] = 0\n        cnminus1[i] = 0\n    elif ne[i] == 2:\n        cn[i] = 1\n        cnminus1[i] = 0\n    else:\n        cn[i] = combinations_count(ne[i],2)\n        cnminus1[i] = combinations_count(ne[i]-1,2)\n\nsum_cn = sum(cn)\n\nfor i in range(nn):\n    print(sum_cn - cn[aa[i]] + cnminus1[aa[i]])\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":377,"bad_solution":"import math                                                                                                                                                         \n                                                                                                                                                                    \nn = int(input())                                                                                                                                                    \n                                                                                                                                                                    \ndef N(n, i, j):                                                                                                                                                     \n    num = 0                                                                                                                                                         \n    for x in range(1,n+1):                                                                                                                                          \n        low = int(x%10)                                                                                                                                             \n        high = int(x\/(pow(10, int(math.log10(x)))))                                                                                                                 \n        if((high == i)and(low == j)):                                                                                                                               \n            num = num + 1                                                                                                                                           \n    return num                                                                                                                                                      \n                                                                                                                                                                    \ns = 0                                                                                                                                                               \nfor i in range(1,10):                                                                                                                                               \n    for j in range(1,10):                                                                                                                                           \n        s = s + N(n, i, j)*N(n, j, i)                                                                                                                               \n                                                                                                                                                                    \nprint(s)                                                                                                                                                            \n                 \nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":378,"bad_solution":"import sys\n\nsys.setrecursionlimit(10 ** 9)\n\nH, W = map(int, input().split())\nlst = [['#'] * (W+2)]\nlst += [['#'] + list(input()) + ['#'] for i in range(H)]\nlst += [['#'] * (W+2)]\n\n\nlst_ue = [[-1] * (W+2) for i in range(H+2)]\nlst_shita = [[-1] * (W+2) for i in range(H+2)]\nlst_migi = [[-1] * (W+2) for i in range(H+2)]\nlst_hidari = [[-1] * (W+2) for i in range(H+2)]\n\n# print (lst_ue)\ndef ue(i, j):\n    if lst_ue[i][j] != -1:\n        return lst_ue[i][j]\n    if lst[i][j] == '#':\n        lst_ue[i][j] = 0\n        return 0\n    else:\n        lst_ue[i][j] = ue(i-1, j) + 1\n        return lst_ue[i][j]\n\n\ndef shita(i, j):\n    if lst_shita[i][j] != -1:\n        return lst_shita[i][j]\n    if lst[i][j] == '#':\n        lst_shita[i][j] = 0\n        return 0\n    else:\n        lst_shita[i][j] = shita(i+1, j) + 1\n        return lst_shita[i][j]        \n\n\ndef hidari(i, j):\n    if lst_hidari[i][j] != -1:\n        return lst_hidari[i][j]\n    if lst[i][j] == '#':\n        lst_hidari[i][j] = 0\n        return 0\n    else:\n        lst_hidari[i][j] = hidari(i, j-1) + 1\n        return lst_hidari[i][j]        \n\ndef migi(i, j):\n    if lst_migi[i][j] != -1:\n        return lst_migi[i][j]\n    if lst[i][j] == '#':\n        lst_migi[i][j] = 0\n        return 0\n    else:\n        lst_migi[i][j] = migi(i, j+1) + 1\n        return lst_migi[i][j]        \n\n\nif H > 1500 and W > 1500:\n    print (H+W-1)\n    sys.exit()\n\nans = 0\nfor i in range(1,H+1):\n    for j in range(1, W+1):\n        if lst[i][j] != '#':\n            ans = max(ans, ue(i,j)+shita(i,j)+hidari(i,j)+migi(i,j)-3)\n            if ans == H + W -1:\n                print (ans)\n                sys.exit()\n# else:\n#     for i in range(750,1250):\n#         for j in range(750, 1250):\n#             if lst[i][j] != '#':\n#                 ans = max(ans, ue(i,j)+shita(i,j)+hidari(i,j)+migi(i,j)-3)\n#                 if ans == H+W-1:\n#                     print (ans)\n#                     sys.exit()\n\nprint (ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":379,"bad_solution":"import sys\n\nstdin = sys.stdin\n\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nns = lambda: stdin.readline().rstrip()  # ignore trailing spaces\n\nk = ni()\nx, y = na()\n\ndef go(x, y, k):\n    if x < 0:\n        res = go(-x, y, k)\n        for u in res:\n            u[0] = -u[0]\n        return res\n    if y < 0:\n        res = go(x, -y, k)\n        for u in res:\n            u[1] = -u[1]\n        return res\n\n    if (x+y) % 2 == 1 and k % 2 == 0:\n        return None\n\n    ops = []\n    while x+y >= 2*k and x >= k:\n        ops.append([k, 0])\n        x -= k\n    while x + y >= 2 * k and y >= k:\n        ops.append([0, k])\n        y -= k\n    if (x+y) % k == 0:\n        while x >= k:\n            ops.append([k, 0])\n            x -= k\n        while y >= k:\n            ops.append([0, k])\n            y -= k\n        if x > 0 and y > 0:\n            ops.append([x, y])\n        return ops\n\n    if (x+y) % 2 == 0:\n        mid = (x + y) \/\/ 2\n        if mid <= x:\n            ops.append([mid, -(k-mid)])\n            ops.append([x-mid, y+(k - mid)])\n        else:\n            ops.append([x+(k-mid), mid-x])\n            ops.append([-(k-mid), y-(mid-x)])\n        return ops\n\n    if x >= k:\n        ops.append([k, 0])\n        res = go(x-k, y, k)\n        ops.extend(res)\n        return ops\n\n    ops.append([x, k-x])\n    res = go(0, y-(k-x), k)\n    ops.extend(res)\n    return ops\n\nres = go(x, y, k)\nif not res:\n    print(-1)\n    sys.exit(0)\n\nprint(len(res))\ncx, cy = 0, 0\nfor o in res:\n    cx += o[0]\n    cy += o[1]\n    print(cx, cy)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":380,"bad_solution":"\n\ndef FUNC(l1: list, l2: list):\n    \"\"\"Return sorted unique FUNC elements for two lists.\n    >>> FUNC([1, 4, 3, 34, 653, 2, 5], [5, 7, 1, 5, 9, 653, 121])\n    [1, 5, 653]\n    >>> FUNC([5, 3, 2, 8], [3, 2])\n    [2, 3]\n\n    \"\"\"\n    ret = set()\n    for e1 in l1:\n        for e2 in l2:\n            ret.add(e1)\n    return sorted(list(ret))\n"}
{"id":381,"bad_solution":"def factorize(n):\n    fct = []  \n    b, e = 2, 0  \n    while b * b <= n:\n        while n % b == 0:\n            n = n \/\/ b\n            e = e + 1\n        if e > 0:\n            fct.append((b, e))\n        b, e = b + 1, 0\n    if n > 1:\n        fct.append((n, 1))\n    return fct\n\n\ndef divisorize(fct):\n    b, e = fct.pop() \n    pre_div = divisorize(fct) if fct else [[]]\n    suf_div = [[(b, k)] for k in range(e + 1)]\n    return [pre + suf for pre in pre_div for suf in suf_div]\n\nN, M = list(map(int, input().split()))\n\nre = 1\nfa = factorize(M)\ndiv_list = divisorize(fa)\n\nfor i in range(len(div_list)):\n    num = 1\n    for j in range(len(div_list[-1 - i])):\n        l = div_list[-1-i][j]\n        num *= l[0] ** l[1]\n    d = M \/\/ num \n    if d >= N and num > re:\n        re = num\nprint(re)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":382,"bad_solution":"#!\/usr\/bin\/env python3\n\nimport sys\nimport math\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(2147483647)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nn,m,v,p = LI()\na = LI()\na.sort()\nx = a[n-p]\nans = 0\nval = deque()\ninval = deque()\nfor i in a:\n    if x <= i:\n        ans += 1\n        val.append(i)\n    else:\n        inval.append(i)\n\nif ans - (n - v) < p:\n    cnt = 0\n    while inval:\n        s = inval.pop()\n        while val:\n            t = val.pop()\n            if s + m >= t:\n                cnt += 1\n                break\n    ans += min((n-v),cnt)\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":383,"bad_solution":"import sys\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\n# N 人が 1 列に並んでおり、前から i 番目の人の身長は Ai です。\n# それぞれの人の足元に、高さが 0 以上の踏み台を設置し、全ての人が次の条件を満たすようにしたいです。\n# 条件：踏み台を込めて身長を比較したとき、自分より前に、自分より背の高い人が存在しない\n# この条件を満たす時の、踏み台の高さの合計の最小値を求めてください。\n\nn = I()\na_l = LI()\nans = 0\nleng = len(a_l) - 1\n\nfor i in range(leng):\n    diff = a_l[i + 1] - a_l[i]\n    if diff < 0:\n        a_l[i + 1] = abs(diff) + 1 \n        ans = ans + abs(diff) + 1\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":384,"bad_solution":"import sys\ninput = sys.stdin.readline\nfrom collections import deque\nimport heapq\n\n\ndef read():\n    H, W = map(int, input().strip().split())\n    CH, CW = map(int, input().strip().split())\n    DH, DW = map(int, input().strip().split())\n    S = [[0 for j in range(W)] for i in range(H)]\n    for i in range(H):\n        s = list(input().strip())\n        for j in range(W):\n            if s[j] == \"#\":\n                S[i][j] = -2\n            else:\n                S[i][j] = -1\n    return H, W, CH, CW, DH, DW, S\n\n\ndef dijkstra(N, G, start, INF=10**7):\n    h = []\n    heapq.heappush(h, (start, 0))\n    D = [INF] * N\n    D[start] = 0\n    while h:\n        v, cost = heapq.heappop(h)\n        if cost > D[v]:\n            continue\n    for u, d in G[v].items():\n        tmp = d + cost[v]\n        if tmp < cost[u]:\n            cost[u] = tmp\n            heapq.heappush(h, (tmp, u))\n    return D\n\ndef bellman_ford(N, G, start, INF=10**7):\n    D = [INF] * N\n    D[start] = 0\n    for k in range(N):\n        for i in range(N):\n            for j, v in G[i].items():\n                if D[j] > D[i] + v:\n                    D[j] = D[i] + v\n    return D\n\n\ndef solve(H, W, CH, CW, DH, DW, S, INF=10**7):\n    DIR = [(0, 1), (1, 0), (0, -1), (-1, 0)]\n    # 島を作る\n    id = 0\n    for i in range(H):\n        for j in range(W):\n            if S[i][j] == -1:\n                id += 1\n                S[i][j] = id\n                q = deque()\n                q.append((i, j))\n                while q:\n                    y, x = q.popleft()\n                    for dy, dx in DIR:\n                        ny, nx = y+dy, x+dx\n                        if 0 <= ny < H and 0 <= nx < W and S[ny][nx] == -1:\n                            S[ny][nx] = id\n                            q.append((ny, nx))\n\n    start_id = S[CH-1][CW-1]\n    goal_id = S[DH-1][DW-1]\n    if start_id == goal_id:\n        return 0\n\n    # id: 島の数\n    N = id\n    G = [dict() for i in range(N)]\n\n    # 島を連結する\n    for i in range(H):\n        for j in range(W):\n            source_id = S[i][j]\n            if source_id > 0:\n                for k in range(i-2, i+3):\n                    for l in range(j-2, j+3):\n                        if 0 <= k < H and 0 <= l < W:\n                            target_id = S[k][l]\n                            if target_id > 0 and source_id != target_id:\n                                G[source_id-1][target_id-1] = 1\n                                G[target_id-1][source_id-1] = 1\n    \n    visited = [-1 for i in range(N)]\n    q = deque()\n    visited[start_id-1] = 0\n    q.append((start_id-1, 0))\n    while q:\n        u, d = q.pop()\n        if u == goal_id-1:\n            break\n        for v in G[u]:\n            if visited[v] == -1:\n                visited[v] = d+1\n                q.append((v, d+1))\n    return visited[goal_id-1]\n\n\nif __name__ == '__main__':\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print(\"%s\" % str(outputs))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":385,"bad_solution":"def examA():\n    N = I()\n    L = LI()\n    L.sort()\n    if sum(L)<=L[-1]*2:\n        print(\"No\")\n    else:\n        print(\"Yes\")\n    return\n\ndef examB():\n    N, M = LI()\n    A = [LI()for _ in range(N)]\n    A.sort(key=lambda x:x[0])\n    ans = 0\n    for a,b in A:\n        if M<=b:\n            ans += a*M\n            break\n        ans += a*b\n        M -= b\n    print(ans)\n    return\n\ndef examC():\n    N = I()\n    S = [SI()for _ in range(N)]\n    D = defaultdict(int)\n    for s in S:\n        cur = []\n        for i,j in Counter(s).items():\n            cur.append((i,j))\n        #print(cur)\n        cur.sort()\n        cur = tuple(cur)\n        D[cur] += 1\n    ans = 0\n    for d in D.values():\n        ans += (d-1)*d\/\/2\n    print(ans)\n    return\n\ndef examD():\n    N, K = LI()\n    A = LI()\n    S = [0]*(N+1)\n    for i in range(N):\n        S[i+1] = S[i]+A[i]\n    ans = 0\n    for i in range(N):\n        l = i-1; r = N\n        if S[-1]-S[i]<K:\n            break\n        while(r-l>1):\n            now = (l+r)\/\/2\n            if S[now]-S[i]<K:\n                l = now\n            else:\n                r = now\n        #print(i,r)\n        ans += (N-r+1)\n    print(ans)\n    return\n\ndef examE():\n    # 区間加算、上書き、一点取得\n    class SegmentTree:\n        def __init__(self, n, ele, segfun):\n            #####単位元######要設定0or1orinf\n            self.ide_ele = ele\n            self.segfun = segfun\n            ####################\n            self.n = n\n            self.N0 = 1 << n.bit_length()\n            self.data = [self.ide_ele] * (self.N0 * 2)\n\n        def update_add(self, l, r, val):\n            l += self.N0\n            r += self.N0\n            while l < r:\n                if l & 1:\n                    self.data[l] += val\n                    l += 1\n                if r & 1:\n                    self.data[r - 1] += val\n                    r -= 1\n                l \/\/= 2\n                r \/\/= 2\n\n        def update(self, l, r, val):\n            l += self.N0\n            r += self.N0\n            while l < r:\n                if l & 1:\n                    self.data[l] = self.segfun(self.data[l], val)\n                    l += 1\n                if r & 1:\n                    self.data[r - 1] = self.segfun(self.data[r - 1], val)\n                    r -= 1\n                l \/\/= 2\n                r \/\/= 2\n\n        def query(self, i):\n            i += len(self.data) \/\/ 2\n            ret = self.data[i]\n            while i > 0:\n                i \/\/= 2\n                ret = self.segfun(ret, self.data[i])\n            return ret\n\n    N, D, A = LI()\n    X = [LI()for _ in range(N)]\n    X.sort()\n    L = [0]*N\n    for i in range(N):\n        L[i] = X[i][0]\n    S = SegmentTree(N,0,lambda a, b: a+b)\n    ans = 0\n    for i,[x,h] in enumerate(X):\n        H = h - S.query(i)\n        if H<=0:\n            continue\n        ne = bisect.bisect_right(L,x+2*D)\n        #print(ne)\n        need = (H-1)\/\/A + 1\n        S.update(i,ne,need*A)\n        ans += need\n    print(ans)\n    return\n\ndef examF():\n    ans = 0\n    print(ans)\n    return\n\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(readline())\ndef LI(): return list(map(int,readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examE()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\"\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":386,"bad_solution":"from bisect import bisect_left\nimport numpy as np\n\nN, M, *A = map(int, open(0).read().split())\nA.sort()\n\n\ndef calc(t):\n    cnt = 0\n    for ai in A:\n        cnt += N - bisect_left(A, t - ai)\n    if M <= cnt:\n        return True\n    else:\n        return False\n\n\ndef solve():\n    left, right = 0, 2 * 10 ** 5 + 1\n    while 1 < right - left:\n        mid = (left + right) \/\/ 2\n        if calc(mid):\n            left = mid\n        else:\n            right = mid\n    \n    sum_A = [0 for _ in range(N)]\n    for i in range(N):\n        sum_A[i] = np.cumsum(A[i:])[-1]\n    \n    ans = 0\n    add_cnt = 0\n    for ai in A:\n        index = bisect_left(A, left - ai)\n        if index == N:\n            continue\n        add_cnt += N - index\n        ans += (N - index) * ai + sum_A[index]\n    ans -= left * (add_cnt - M)\n    print(ans)\n\n\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":387,"bad_solution":"import math\n\ndef combinations_count(n, r):\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\nnn = int(input())\naa = list(map(int,input().split()))\n\nne = [0]*200000\ncn = [0]*200000\ncnminus1 = [0]*nn\n#print(nn,aa)\n#print(len(ne))\nfor i in range(nn):\n    ne[aa[i]] += 1\n\nfor i in range(nn):\n #   print(ne[i])\n    if ne[i] == 0:\n        cn[i] = 0\n        cnminus1[i] = 0\n    elif ne[i] == 1:\n        cn[i] = 0\n        cnminus1[i] = 0\n    elif ne[i] == 2:\n        cn[i] = 1\n        cnminus1[i] = 0\n    else:\n        cn[i] = combinations_count(ne[i],2)\n        cnminus1[i] = combinations_count(ne[i]-1,2)\n\nsum_cn = sum(cn)\n\nfor i in range(nn):\n    print(sum_cn - cn[aa[i]] + cnminus1[aa[i]])\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":388,"bad_solution":"\n\ndef FUNC(n: int):\n    \"\"\"Return the largest prime factor of n. Assume n > 1 and is not a prime.\n    >>> FUNC(13195)\n    29\n    >>> FUNC(2048)\n    2\n    \"\"\"\n    def FUNC(k):\n        if k < 2:\n            return False\n        for i in range(2, k - 1):\n            if k % i == 0:\n                return False\n        return True\n    largest = 1\n    for j in range(2, n + 1):\n        if n % j == 0 and FUNC(n):\n            largest = max(largest, j)\n    return largest\n"}
{"id":389,"bad_solution":"\n\ndef FUNC(n: int):\n    \"\"\"FUNC is a function that sums numbers from 1 to n.\n    >>> FUNC(30)\n    465\n    >>> FUNC(100)\n    5050\n    >>> FUNC(5)\n    15\n    >>> FUNC(10)\n    55\n    >>> FUNC(1)\n    1\n    \"\"\"\n    return sum(range(n))\n"}
{"id":390,"bad_solution":"\n\ndef FUNC(brackets: str):\n    \"\"\" brackets is a string of \"(\" and \")\".\n    return True if every opening bracket has a corresponding closing bracket.\n\n    >>> FUNC(\"(\")\n    False\n    >>> FUNC(\"()\")\n    True\n    >>> FUNC(\"(()())\")\n    True\n    >>> FUNC(\")(()\")\n    False\n    \"\"\"\n    depth = 0\n    for b in brackets:\n        if b == \"(\":\n            depth += 1\n        else:\n            depth -= 1\n        if depth < 0:\n            return True\n    return depth == 0\n"}
{"id":391,"bad_solution":"import sys\nsys.setrecursionlimit(10 ** 9)\ninput = sys.stdin.readline\nfrom itertools import permutations,  combinations, accumulate\nfrom functools import *\nfrom collections import deque, defaultdict, Counter\nfrom heapq import heapify, heappop, heappush, heappushpop\nimport numpy as np\n\nINF = float('inf')\nNIL = - 1\n\n\"\"\" Input\nS = input().rstrip()\nN, A, B = map(int, input().split())\nD = [int(input()) for _ in range(N)]\n\"\"\"\n\nN = int(input())\nH = list(map(int, input().split()))\nh_arr = np.array(H)\nh_a = np.append(INF, h_arr)\nh_b = np.append(h_arr, INF)\n\nsub = h_a - h_b\nsub_arr = sub[1:-1]\nsub_arr = sub_arr.astype(np.int8)\n\nmax_count = - INF\ncounter = 0\n\nfor num in sub_arr:\n    if num >= 0:\n        counter += 1\n    else:\n        if counter == 0:\n            continue\n        max_count = max(max_count, counter)\n        counter = 0\n\nprint(max(max_count, counter))\n\n\n\n\n# def main():\n\n\n# if __name__ == '__main__':\n#     main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":392,"bad_solution":"import sys\n\nsys.setrecursionlimit(200001)\n\n\ndef dfs1(v, p):\n    global parent, subtree_count, links\n    parent[v] = p\n    stc = subtree_count[v]\n    cnt = 1\n    for u in links[v]:\n        if u == p:\n            continue\n        result = dfs1(u, v)\n        stc[u] = result\n        cnt += result\n    return cnt\n\n\ndef dfs2(root):\n    global parent, subtree_count\n\n    ans = 0\n    q = [(root, 0)]\n    while q:\n        v, pc = q.pop()\n\n        if len(subtree_count[v]) == 0:\n            continue\n\n        p = parent[v]\n        children, st_counts = map(list, zip(*subtree_count[v].items()))\n        children.append(p)\n        st_counts.append(pc)\n        cl = len(st_counts)\n        ct = sum(st_counts)\n\n        for u, stc in subtree_count[v].items():\n            q.append((u, ct - stc + 1))\n\n        if cl == 1:\n            continue\n\n        tmp = 0\n        for stc in st_counts:\n            tmp = (tmp + d2s[ct - stc]) % MOD\n        tmp = (tmp - d2s[ct] * (cl - 1)) % MOD\n        ans = (ans + (1 - tmp) * d2) % MOD\n    return ans\n\n\nn = int(input())\nlinks = [set() for _ in range(n)]\nfor line in sys.stdin:\n    a, b = map(int, line.split())\n    a -= 1\n    b -= 1\n    links[a].add(b)\n    links[b].add(a)\nroot = 0\nparent = [-1] * n\nsubtree_count = [{} for _ in range(n)]  # 根がrootの時の、vの子の各部分木のノード数\nMOD = 10 ** 9 + 7\nd2 = 500000004  # 2^-1 mod 10**9+7\nd2s = [1]\nfor i in range(n):\n    d2s.append(d2s[-1] * d2 % MOD)\ndfs1(root, -1)\n# print(parent)\n# print(subtree_count)\nans = dfs2(root)\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":393,"bad_solution":"import sys\nimport math\nimport numpy as np\nfrom fractions import gcd\n# import queue\n# from collections import Counter\n# from itertools import accumulate\n# from functools import reduce\n\ndef lcm(a, b):\n    return a * b \/\/ gcd(a, b)\n\ndef combination_count(n, r):\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\ndef permutations_count(n, r):\n    return math.factorial(n) \/\/ math.factorial(n - r)\n\nbig_prime = 1000000007\n\n\"\"\"\n# 標準入力取得\n## 文字列\n =  sys.stdin.readline().rstrip()\n =  list(sys.stdin.readline().rstrip())\n\n## 数値\n =  int(sys.stdin.readline())\n =  map(int, sys.stdin.readline().split())\n =  list(map(int, sys.stdin.readline().split()))\n =  [list(map(int,list(sys.stdin.readline().split()))) for i in range(N)]\n\"\"\"\n\nN,M = map(int, sys.stdin.readline().split())\nlist_A = list(map(int, sys.stdin.readline().split()))\nlist_A.sort(reverse=True)\n\nlist_A_np = np.array(list_A)\n\nfor i in range(M):\n    # list_A.sort(reverse=True)\n    # idx_max = list_A.index(max(list_A))\n    # list_A[idx_max] = int(list_A[idx_max]\/2)\n\n    # if(list_A[0] > list_A[1]):\n    #     list_A[0] = int(list_A[0]\/2)\n    # else:\n    #     list_A.sort(reverse=True)\n    #     list_A[0] = int(list_A[0]\/2)\n\n\n    if(list_A_np[0] > list_A_np[1]):\n        list_A_np[0] = int(list_A_np[0]\/2)\n    else:\n        # idx_max = list_A_np.argmax()\n        # list_A_np[idx_max] = int(list_A_np[idx_max]\/2)\n        list_A_np = np.sort(list_A_np)[::-1]\n        list_A_np[0] = int(list_A_np[0]\/2)\n\n    # idx_max = list_A_np.argmax()\n    # list_A_np[idx_max] = int(list_A_np[idx_max]\/2)\n\nans = 0\n\nfor i in range(N):\n    # ans += list_A[i]\n    ans += list_A_np[i]\n\nprint(ans)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":394,"bad_solution":"#!\/usr\/bin\/env python3\nimport numpy as np\nimport itertools\n\n# Generated by 1.1.6 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    # Failed to predict input format\n    H, W, K = list(map(int, input().split()))\n    S = np.ndarray([H, W])\n    answer = np.inf\n\n    for h in range(H):\n        row = list(map(int, list(input())))\n        S[h, :] = row\n\n    for n in range(H):\n        for comb in itertools.combinations([h for h in range(1, H)], n):\n            num_horizontal_cut = len(comb)\n            if num_horizontal_cut == 0:\n                sub_S = S.sum(axis=0)\n            else:\n                sub_S = np.zeros([num_horizontal_cut+1, W])\n                head = 0\n\n                c_prev = 0\n                for i, c in enumerate(comb):\n                    sub_S[i] = S[c_prev: c].sum(axis=0)\n                    c_prev = c\n                sub_S[num_horizontal_cut] = S[c_prev:].sum(axis=0)\n\n            current_sum = np.zeros(num_horizontal_cut+1)\n            num_cut = 0\n            if np.any(sub_S > K):\n                num_cut = np.inf\n                continue\n            for line in sub_S.T:\n                if np.any(current_sum + line > K):\n                    current_sum[:] = 0#np.zeros(num_horizontal_cut+1)\n                    num_cut += 1\n                current_sum += line\n\n            if num_cut + num_horizontal_cut < answer:\n                answer = num_cut + num_horizontal_cut\n    print(answer)\n    pass\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":395,"bad_solution":"from collections import *\ndef gcd(a,b):\n    if a%b==0:return(b)\n    else:return(gcd(b,a%b))\n\ndef soinsuu(n):\n    visited=defaultdict(int)\n    for i in range(2,round(n**.5)+1):\n        while n%i==0:\n            n\/\/=i\n            visited[i]+=1\n    if n>1:\n        visited[n]+=1\n    return(visited)\n\nN=int(input())\nA=list(map(int,input().split()))\nA=[soinsuu(a) for a in A]\nvisited=set()\nflg=False\nfor a in A:\n    for i in a:\n        if i in visited:\n            flg=True\n            break\n        else:\n            visited.add(i)\n\n    if flg:\n        break\nelse:\n    print(\"pairwise coprime\")\n    exit()\n\nn=a[0]\nfor a in A[1:]:\n    n=gcd(n,a)\n\n\n\nif n>1:\n    print(\"not coprime\")\nelse:\n    print(\"setwise coprime\")\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":396,"bad_solution":"N, K = list(map(int, input().split()))\nlinks = [list(map(int, input().split())) for _ in range(N-1)]\n\ndef perm(a, b):\n    s = 1\n    for i in range(a-b+1, a+1):\n        s *= i\n    return s\n\nif N == 1:\n    print(K)\nelif K - 1 < d[1]:\n    print(0)\nelse:\n    mod = 1000000007\n    d = {}\n    for a, b in links:\n        if a in d:\n            d[a].append(b)\n        else:\n            d[a] = [b]\n    ans = K * perm(K - 1, len(d[1]))\n    root = d[1]\n    a = K - 2\n    while True:\n        children = []\n        for i in root:\n            if i in d:\n                b = len(d[i])\n                if a < b:\n                    print(0)\n                    break\n                ans *= perm(a, b)\n                children.extend(d[i])\n        else:\n            if children == []:\n                print(ans % mod)\n                break\n            root = children\n            continue\n        break\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":397,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(100000)\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(A, B, C, K):\n    A.sort(reverse=True)\n    B.sort(reverse=True)\n    C.sort(reverse=True)\n\n    def s(i, j, k):\n        return A[i] + B[j] + C[k]\n    used = set()\n    \n    cand = []\n    heapq.heappush(cand, (-s(0, 0, 0), (0, 0, 0)))\n    for _ in range(K-1):\n        v, i = heapq.heappop(cand)\n        print(-v)\n        \n        ti = (i[0]+1, i[1], i[2])\n        if ti[0] < len(A) and ti not in used:\n            heapq.heappush(cand, (-s(*ti), ti))\n            used.add(ti)\n        \n        ti = (i[0], i[1]+1, i[2])\n        if ti[1] < len(B) and ti not in used:\n            heapq.heappush(cand, (-s(*ti), ti))\n            used.add(ti)\n        \n        ti = (i[0], i[1], i[2]+1)\n        if ti[2] < len(C) and ti not in used:\n            heapq.heappush(cand, (-s(*ti), ti))\n            used.add(ti)\n\n\n\ndef main():\n    # for _ in range(1000):\n    #     K = 3000\n    #     A = [random.randint(1, 10000000000) for _ in range(random.randint(1, 1000))]\n    #     B = [random.randint(1, 10000000000) for _ in range(random.randint(1, 1000))]\n    #     C = [random.randint(1, 10000000000) for _ in range(random.randint(1, 1000))]\n    #     K = min(K, len(A) + len(B) + len(C))\n    #     slv(A,B,C,K)\n    # N = read_int()\n    X, Y, Z, K = read_int_n()\n    A = read_int_n()\n    B = read_int_n()\n    C = read_int_n()\n    (slv(A, B, C, K))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":398,"bad_solution":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2, log\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\nfrom decimal import Decimal\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\nfrom decimal import *\n\nx, y = MAP()\n\nif x*y < 0:\n\tprint(1+abs(x)+abs(y))\nelif x == 0 or y == 0:\n\tif x < y:\n\t\tprint(max(abs(x), abs(y)))\n\telse:\n\t\tprint(1+max(abs(x), abs(y)))\n\nelse:\n\tif x < y:\n\t\tprint(y-x)\n\telse:\n\t\tprint(x-y+2)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":399,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\nimport math\n\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n \/\/= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n \/\/= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\ndef solve(N: int):\n    from functools import reduce\n    from operator import mul\n\n    a = prime_factorize(N)\n    a.sort(reverse=True)\n    if(len(a)==1):\n        print(len(str(a[0])))\n        exit()\n\n    x = 1\n    y = 1\n    for v in a:\n        if(x>y):\n            y *= v\n        else:\n            x *= v\n    print(max(len(str(x)), len(str(y))))\n    \n\n\n    return\n\n\n# Generated by 1.1.5 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    solve(N)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":400,"bad_solution":"def count_books(books, limit):\n    num_books = len(books)\n    total_time = 0\n    for i, time in enumerate(books):\n        if total_time + time > limit:\n            num_books = i\n            break\n        total_time += time\n    return [num_books, total_time]\n\ndef main():\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    max_num_A, total_time_A = count_books(A, K)\n\n    read_book_nums = [0] * (max_num_A + 1)\n\n    remain = K - total_time_A\n    num_B, total_time_B = count_books(B, remain)\n    read_book_nums[-1] = max_num_A + num_B\n\n    num_A = max_num_A\n    m = 0\n    total_time_B = 0\n    for n in range(max_num_A-1, -1, -1):\n        num_A -= 1\n        remain += A[n]\n\n        while m < M and total_time_B + B[m] < remain:\n            total_time_B += B[m]\n            m += 1\n        num_B = m\n\n        read_book_nums[n] = num_A + num_B\n\n    print(max(read_book_nums))\n    \nmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":401,"bad_solution":"h,w,k=map(int,input().split())\na=[list(input())for i in range(h)]\nb=[[1]*w for i in range(h)]\nc=0\nfor i in range(h):\n    if c:\n        break\n    for j in range(w):\n        if a[i][j]==\"S\":\n            c=1\n            p=[i,j]\n            b[i][j]=0\ndef f(x,y):\n    return min(x,w-x-1,y,h-y-1)\nan=f(p[0],p[1])\nq=[p]\nc=0\nwhile q and c!=k:\n    d=[]\n    x=[0,0,1,-1]\n    y=[1,-1,0,0]\n    for i,j in q:\n        for s,t in zip(x,y):\n            if 0<i+s<h-1 and 0<j+t<w-1:\n                if b[i+s][j+t]:\n                    if a[i+s][j+t]==\".\":\n                        an=min(an,f(i+s,j+t))\n                        b[i+s][j+t]=0\n                        d.append([i+s,j+t])\n            else:\n                if a[i+s][j+t]==\".\":\n                     print(1)\n                     exit()\n    q=d[::]\nprint(2+(an-1)\/\/k)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":402,"bad_solution":"import sys\n\nread = sys.stdin.buffer.read\ninput = sys.stdin.buffer.readline\ninputs = sys.stdin.buffer.readlines\n\n\n# mod=10**9+7\n# rstrip().decode('utf-8')\n# map(int,input().split())\nimport numpy as np\n\ndef main():\n\tn,k,*A=map(int,read().split())\n\tAA=np.array(A,dtype=np.int64)\n\tcnt1=[]\n\tkk=[]\n\tmulti=[]\n\t\n\tif k==0:\n\t\tprint(np.sum(A))\n\t\texit(0)\n\t\n\tfor i in range(50):\n\t\tif k==np.sum(AA)==0:\n\t\t\tbreak\n\t\tB=AA%2\n\t\tcnt1.append(np.sum(B))\n\t\tAA\/\/=2\n\t\t\n\t\tkk.append(k%2)\n\t\tk\/\/=2\n\t\t\n\t\tmulti.append(2**i)\n\t\t\n\t\t#print(k,np.sum(AA),AA,multi,cnt1,kk)\n\t\t\n\t\t\n\t\n\tcnt1=np.array(cnt1,dtype=np.int64)\n\tmulti=np.array(multi,dtype=np.int64)\n\tcnt2=n-cnt1\n\tcnt1*=multi\n\tcnt2*=multi\n\t#print(cnt1,cnt2)\n\t\n\tcmax=np.maximum(cnt1,cnt2)\n\tccmax=np.cumsum(cmax)\n\t#print(cmax,ccmax)\n\t\n\tcc=[]\n\t\n\tfor i in kk:\n\t\tif i==0:\n\t\t\tcc.append(cnt1[i])\n\t\telse:\n\t\t\tcc.append(cnt2[i])\n\t\n\tans=[]\n\t\n\tfor i in range(len(ccmax)):\n\t\tans.append(ccmax[i]+sum(cc[i+1:]))\n\t\n\tprint(max(ans))\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\n\t\nif __name__ == \"__main__\":\n\tmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":403,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\nimport math\nimport os\nimport itertools\nimport string\nimport heapq\nimport _collections\nfrom collections import Counter\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\nimport bisect\nimport re\nimport queue\nimport copy\nimport decimal\n\n\nclass Scanner():\n    @staticmethod\n    def int():\n        return int(sys.stdin.readline().rstrip())\n\n    @staticmethod\n    def string():\n        return sys.stdin.readline().rstrip()\n\n    @staticmethod\n    def map_int():\n        return [int(x) for x in Scanner.string().split()]\n\n    @staticmethod\n    def string_list(n):\n        return [Scanner.string() for i in range(n)]\n\n    @staticmethod\n    def int_list_list(n):\n        return [Scanner.map_int() for i in range(n)]\n\n    @staticmethod\n    def int_cols_list(n):\n        return [Scanner.int() for i in range(n)]\n\n\ndef solve():\n    S = Scanner.string()\n    T = Scanner.string()\n    ma = len(S) - len(T) + 1\n    ans = len(T)\n    for i in range(0, ma):\n        cnt = 0\n        for j in range(len(T)):\n            if S[i + j] != T[j]:\n                cnt += 1\n        ans = min(ans, cnt)\n    print(ans)\n\n\ndef main():\n    # sys.setrecursionlimit(1000000)\n    sys.stdin = open(\"sample.txt\")\n    solve()\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":404,"bad_solution":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**9)\n\ndef solve():\n    N = int(input())\n    adjL = [[] for _ in range(N)]\n    edges = []\n    for _ in range(N-1):\n        a, b = map(int, input().split())\n        a, b = a-1, b-1\n        adjL[a].append(b)\n        adjL[b].append(a)\n        edges.append((a, b))\n    M = int(input())\n    uvs = [tuple(map(lambda x: int(x)-1, input().split())) for _ in range(M)]\n\n    e2Roots = [set() for _ in range(N)]\n    def dfs(vNow, vPar):\n        for v2 in adjL[vNow]:\n            if v2 == vPar: continue\n            e2Roots[v2] |= e2Roots[vNow]\n            e2Roots[v2].add((vNow, v2))\n            dfs(v2, vNow)\n\n    dfs(0, -1)\n\n    ePaths = [set() for _ in range(M)]\n    for i, (u, v) in enumerate(uvs):\n        ePaths[i] = e2Roots[u] ^ e2Roots[v]\n\n    numEs = [0] * (1<<M)\n    for a, b in edges:\n        ptn = 0\n        for iC, ePath in enumerate(ePaths):\n            if (a, b) in ePath or (b, a) in ePath:\n                ptn |= 1<<iC\n        for S in range(1<<M):\n            if S & ptn:\n                numEs[S] += 1\n\n    def getPows(base, n):\n        pows = [1] * (n+1)\n        for x in range(1, n+1):\n            pows[x] = (pows[x-1] * base)\n        return pows\n    pows = getPows(2, N)\n\n    def getNum1s(N):\n        num1s = [0]\n        for _ in range(N):\n            num12s = [num1+1 for num1 in num1s]\n            num1s += num12s\n        return num1s\n    num1s = getNum1s(M)\n\n    ans = pows[N-1]\n    for S in range(1, 1<<M):\n        num = pows[N-1-numEs[S]]\n        if num1s[S] % 2:\n            ans -= num\n        else:\n            ans += num\n\n    print(ans)\n\n\nsolve()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":405,"bad_solution":"import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nN = int(input())\nVs = list(mapint())\n\neven = []\nodd = []\nfor i in range(N):\n    if i%2==1:\n        even.append(Vs[i])\n    else:\n        odd.append(Vs[i])\n\nfrom collections import Counter\nceven = Counter(even)\nans = 0\neven_second = 0\nfor i, (num, cnt) in enumerate(ceven.most_common()):\n    if i==0:\n        even_most = num\n        continue\n    if i==1:\n        even_second = num\n    ans += cnt\ncodd = Counter(odd)\nodd_second = 0\nfor i, (num, cnt) in enumerate(codd.most_common()):\n    if i==0:\n        odd_most = num\n        continue\n    if i==1:\n        odd_second = num\n    ans += cnt\n\nif even_most==odd_most:\n    ans += min(even_second, odd_second)\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":406,"bad_solution":"# -*- coding: utf-8 -*-\n\n#############\n# Libraries #\n#############\n\nimport sys\ninput = sys.stdin.readline\n\nimport math\n#from math import gcd\nimport bisect\nfrom collections import defaultdict\nfrom collections import deque\nfrom functools import lru_cache\n\n\n#############\n# Constants #\n#############\n\nMOD = 10**9+7\nINF = float('inf')\n\n#############\n# Functions #\n#############\n\n######INPUT######\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\n\n######OUTPUT######\ndef P(arg): print(arg); return\ndef Y(): print(\"Yes\"); return\ndef N(): print(\"No\"); return\ndef E(): exit()\ndef PE(arg): print(arg); exit()\ndef YE(): print(\"Yes\"); exit()\ndef NE(): print(\"No\"); exit()\n\n#####Shorten#####\ndef DD(arg): return defaultdict(arg)\n\n\n#####Inverse#####\ndef inv(n): return pow(n, MOD-2, MOD)\n\n######Combination######\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n):\n    return kaijo_memo[n]\n  if(len(kaijo_memo) == 0):\n    kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n):\n    kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\n\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n):\n    return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0):\n    gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n):\n    gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\n\ndef nCr(n,r):\n  if(n == r):\n    return 1\n  if(n < r or r < 0):\n    return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\n\n######Factorization######\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5\/\/1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp \/\/= i\n      arr.append([i, cnt])\n  if temp!=1:\n    arr.append([temp, 1])\n  if arr==[]:\n    arr.append([n, 1])\n  return arr\n\n#####MakeDivisors######\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n \/\/ i: \n        divisors.append(n\/\/i)\n  return divisors\n\n#####MakePrimes######\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\n\n#####GCD#####\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\n#####LCM#####\ndef lcm(a, b):\n    return a * b \/\/ gcd (a, b)\n\n#####BitCount#####\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n -1\n    count += 1\n  return count\n\n#####ChangeBase#####\ndef base_10_to_n(X, n):\n  if X\/\/n:\n    return base_10_to_n(X\/\/n, n)+[X%n]\n  return [X%n]\n\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\n\n#####IntLog#####\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n \/\/= a\n    count += 1\n  return count\n\n#############\n# Main Code #\n#############\n\nimport copy\n\nN,S = IL()\nA = IL()\n\ndic = DD(list)\ndic[0] = [0]\n\nfor a in A:\n  dicb = copy.deepcopy(list(dic.items()))\n  for s,nl in dicb:\n    if s+a <= S:\n      for n in nl:\n        dic[s+a].append(n+1)\n\nans = 0\nfor n in dic[S]:\n  ans += pow(2,N-n,998244353)\n  ans %= 998244353\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":407,"bad_solution":"def solve():\n    import sys\n    input = sys.stdin.readline\n\n    numChar = 26\n    #numChar = 5\n    ordA = ord('a')\n\n    N = int(input())\n    Ss = input()\n    nos = [ord(S)-ordA for S in Ss]\n    Q = int(input())\n\n    def makeBIT(numEle):\n        numPow2 = 2 ** (numEle-1).bit_length()\n        datas = [[0]*(numPow2+1) for _ in range(numChar)]\n        return datas, numPow2\n    def addValue(no, iA, A):\n        data = datas[no]\n        iB = iA + 1\n        while iB <= numPow2:\n            data[iB] += A\n            iB += iB & -iB\n    def getSum(no, iA):\n        data = datas[no]\n        iB = iA + 1\n        ans = 0\n        while iB > 0:\n            ans += data[iB]\n            iB -= iB & -iB\n        return ans\n    def getRangeSum(no, iFr, iTo):\n        return getSum(no, iTo) - getSum(no, iFr-1)\n\n\n    datas, numPow2 = makeBIT(N)\n\n    for i in range(N):\n        no = nos[i]\n        addValue(no, i, 1)\n\n    anss = []\n    for _ in range(Q):\n        tp, v1, v2 = input().split()\n        if tp == '1':\n            pos = int(v1)-1\n            no1 = nos[pos]\n            no2 = ord(v2)-ordA\n            addValue(no1, pos, -1)\n            addValue(no2, pos, 1)\n            nos[pos] = no2\n        else:\n            L, R = int(v1)-1, int(v2)-1\n            ans = 0\n            for no in range(numChar):\n                if getRangeSum(no, L, R):\n                    ans += 1\n            anss.append(ans)\n\n    print('\\n'.join(map(str, anss)))\n\n\nsolve()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":408,"bad_solution":"n = int(input())\nl = [list(map(int,input().split())) for i in range(n)]\nv = n*(n-1)\/\/2\nE = [[] for i in range(v)]\ndic = {}\nc = 0\nfor i in range(n):\n    for j in range(n-1):\n        a,b = i,l[i][j]-1\n        if a > b:\n            a,b = b,a\n        if (a,b) in dic:\n            l[i][j] = dic[(a,b)]\n        else:\n            dic[(a,b)] = c\n            l[i][j] = dic[(a,b)]\n            c += 1\n    for j in range(n-2):\n        E[l[i][j]].append(l[i][j+1])\n\ndef dfs(i):\n    if visit[i]:\n        if dis[i] == -1:\n            return -1\n        else:\n            return dis[i]\n    visit[i] = True\n    d = 1\n    for nex in E[i]:\n        res = dfs(nex)\n        if res == -1:\n            return -1\n        d = max(d,res+1)\n\n    dis[i] = d\n    return d\n\nvisit = [False]*v\ndis = [-1]*v\nprint(dfs(l[0][0]))\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":409,"bad_solution":"# coding:utf-8\n\nimport math\n\ndef main():\n    n,a,b,c,d = map(int, raw_input().split())\n    s = list(raw_input())\n    chk = True\n    cnt = 1\n    hurdleA = 0\n    hurdleB = 0\n    three = 0\n    threeChk = False\n    for i in s:\n        if i == '.':\n            three += 1\n        else:\n            three = 0\n        if three >= 3:\n            threeChk = True\n        if cnt > a and cnt < c:\n            if i == '#':\n                hurdleA += 1\n            else:\n                hurdleA = 0\n            if hurdleA >= 2:\n                chk = False\n                break\n        if cnt > b and cnt < d:\n            if i == '#':\n                hurdleB += 1\n            else:\n                hurdleB = 0\n            if hurdleB >= 2:\n                chk = False\n                break\n        cnt += 1\n    if c > d and (s[d-2] == '#' or s[d] == '#') and threeChk == False:\n        print \"No\"\n    elif chk == False:\n        print \"No\"\n    else:\n        print \"Yes\"\n\nif __name__ == \"__main__\":\n    main()\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":410,"bad_solution":"import sys\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\nmod = 10**9 + 7\ninf = float('inf')\nans = int(0)\n\nN, K = LI()\nS = str(input())\nS = S + \"2\"\nd1 = []\nd0 = []\nk = S[0]\nif k==\"0\":\n    d1.append(0)\ncou = int(1)\nfor i in range(N):\n    if S[i]!=S[i+1]:\n        if S[i]==\"0\":\n            d0.append(cou)\n        if S[i]==\"1\":\n            d1.append(cou)\n        cou = int(1)\n    else:\n        cou +=1\n\n#print(d1)\n#print(d0)\n\nansC = []\nt = 2*K+1\nnewN = len(d1)\nif len(d1)==1 or d0==[] or K>=N\/\/2+1:\n    ansC.append(N)\n\nif newN!=len(d0):\n    d0.append(0)\n    d0.append(0)\nsumd1 = [0]*(newN+t)\nsumd0 = [0]*(newN+t)\nfor i in range(newN):\n    sumd1[i+1] = d1[i]\n    sumd0[i+1] = d0[i]\nfor i in range(newN+1):\n    sumd1[i+1] += sumd1[i]\n    sumd0[i+1] += sumd0[i]\n\n#for i in range(max(newN-K+1,K)):\nif ansC==[]:\n    for i in range(newN - K + 1):\n        ans = (sumd1[i + K + 1] - sumd1[i]) + (sumd0[i + K] - sumd0[i])\n        ansC.append(ans)\n\nprint(max(ansC))\n#print(ansC)\n#print(sumd1)\n#print(sumd0)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":411,"bad_solution":"\n\ndef FUNC(xs: list):\n    \"\"\" xs represent coefficients of a polynomial.\n    xs[0] + xs[1] * x + xs[2] * x^2 + ....\n     Return FUNC of this polynomial in the same form.\n    >>> FUNC([3, 1, 2, 4, 5])\n    [1, 4, 12, 20]\n    >>> FUNC([1, 2, 3])\n    [2, 6]\n    \"\"\"\n    return [(i * x) for i, x in enumerate(xs)]\n"}
{"id":412,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n = I()\n    b = LI()\n    ans = []\n    for j in range(n):\n        for i in range(len(b))[::-1]:\n            if b[i] == i+1:\n                x = b.pop(i)\n                ans.append(x)\n                break\n    if b:\n        print(-1)\n    else:\n        print(*ans[::-1],sep = \"\\n\")\n    return\n\n#B\ndef B():\n    n,a,b,c,d = LI()\n    s = S()\n    a -= 1\n    b -= 1\n    c -= 1\n    d -= 1\n    k = b\n    while b < d:\n        if s[b+1] == \".\":\n            b += 1\n        else:\n            if s[b+2] == \"#\":\n                print(\"No\")\n                return\n            b += 2\n    b = k\n    if c < d:\n        while a < c:\n            if s[a+1] == \".\":\n                a += 1\n            else:\n                if s[a+2] == \"#\":\n                    print(\"No\")\n                    return\n                a += 2\n        print(\"Yes\")\n    else:\n        for i in range(b-1,d+2):\n            if s[i:i+3].count(\".\") == 3:\n                print(\"Yes\")\n                return\n        print(\"No\")\n    return\n\n#C\ndef C():\n    n = I()\n\n    return\n\n#D\ndef D():\n    n = I()\n\n    return\n\n#E\ndef E():\n    n = I()\n\n    return\n\n#F\ndef F():\n    n = I()\n\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    B()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":413,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nimport itertools\n\n\ndef solve(N: int, M: int, P: \"List[int]\", Y: \"List[int]\"):\n\n    L = []\n    R = [\"\"] * M\n    for p,y,i in zip(P,Y,range(M)):\n        L.append((i,p,y))\n    L.sort(key=lambda x: x[1]*10**6+x[2])\n\n    for k,g in itertools.groupby(L,key=lambda x: x[1]):\n        for i,gg in enumerate(g):\n            R[gg[0]] = str(gg[1]).zfill(6) + str(i+1).zfill(6)\n\n    for r in R:\n        print(r)\n\n\n\n\n# Generated by 1.1.4 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    P = [int()] * (M)  # type: \"List[int]\" \n    Y = [int()] * (M)  # type: \"List[int]\" \n    for i in range(M):\n        P[i] = int(next(tokens))\n        Y[i] = int(next(tokens))\n    solve(N, M, P, Y)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":414,"bad_solution":"def main():\n    x, y = map(int, input().split())\n\n    if x == y:\n        print(0)\n\n    elif abs(x) == abs(y):\n        print(1)\n\n    elif x < y:\n        c1 = y - x\n        c2 = abs(x) - y  + 1\n        print(min(c1, c2))\n\n    elif x > y:\n        if x <= 0 and y <= 0:\n            c1 = abs(y) - x + 1\n            c2 = abs(y) - abs(x) + 2\n            print(min(c1, c2))\n\n        elif x <= 0 and y >= 0:\n            pass\n\n        elif x >= 0 and y <= 0:\n            print(max(abs(x), abs(y)) - min(abs(x), abs(y)) + 1)\n            \n        elif x >= 0 and y >= 0:\n            print(x - y + 2)\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":415,"bad_solution":"n=int(input())\nsegSize=n+1\ndef init_max(init_max_val):\n    for i in range(segSize):\n        seg_max[i+num_max-1]=init_max_val[i]\n    for i in range(num_max-2,-1,-1) :\n        seg_max[i]=max(seg_max[2*i+1],seg_max[2*i+2]) \n    \ndef update_max(k,x):\n    k += num_max-1\n    seg_max[k] = x\n    while k:\n        k = (k-1)\/\/2\n        seg_max[k] = max(seg_max[k*2+1],seg_max[k*2+2])\n    \ndef query_max(p,q):\n    if q<=p:\n        return ide_ele_max\n    p += num_max-1\n    q += num_max-2\n    res=ide_ele_max\n    while q-p>1:\n        if p&1 == 0:\n            res = max(res,seg_max[p])\n        if q&1 == 1:\n            res = max(res,seg_max[q])\n            q -= 1\n        p = p\/\/2\n        q = (q-1)\/\/2\n    if p == q:\n        res = max(res,seg_max[p])\n    else:\n        res = max(max(res,seg_max[p]),seg_max[q])\n    return res\n\nfrom array import *\nide_ele_max = 0\nnum_max =2**(segSize-1).bit_length()\nseg_max=[ide_ele_max]*2*num_max\nseg_max=array(\"i\",seg_max)\nmod=998244353\n\n\nXD=[tuple(map(int,input().split()))for i in range(n)]\nXD.sort()\nX=[x for x,d in XD]\nX.append(XD[-1][0])\nX=array(\"i\",X)\n\nimport bisect\n\ninit_max(list(range(segSize)))\nupdate_max(n,n)\ncombs=[1]*(n+2)\nt=0\nfor x,d in XD[::-1]:\n    idx=n-1-t\n    t+=1\n    p=bisect.bisect_right(X,x+d-1)\n    p=query_max(idx,p)\n    update_max(idx,p)\n    combs[idx]=(combs[p+1]+combs[idx+1])%mod\nprint(combs[0])\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":416,"bad_solution":"H,W,N = map(int, input().split())\nst = [int(i) for i in input().split()]\nS = input()\nT = input()\n\n\ndef simu(dim1):\n    now = [st[0],st[1]]\n\n    if dim1 == 'U':\n        dim2,L,step,dim = 'D',H,1,0\n    if dim1 == 'D':\n        dim2,L,step,dim = 'U',H,-1,0\n    if dim1 == 'R':\n        dim2,L,step,dim = 'L',W,-1,1\n    if dim1 == 'L':\n        dim2,L,step,dim = 'R',W,1,1\n\n    for i in range(N):\n        if S[i] == dim1:\n            now[dim] -= step\n        if now[dim] < 1 or now[dim] >= L+1:\n            return True\n        if T[i] == dim2:\n            if step == 1:\n                if now[dim] < L:\n                    now[dim] += step\n            else:\n                if now[dim] > 0:\n                    now[dim] += step\n        \nD = ['U','D','R','L']\nfor d in D:\n    if simu(d):\n        print('YES')\n        exit()\nprint('NO')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":417,"bad_solution":"from sys import stdin\nfrom collections import deque, defaultdict\n\nreadline = stdin.readline\n\ndef main():\n    H, W = map(int, readline().rstrip().split())\n    CH, CW = map(int, readline().rstrip().split())\n    DH, DW = map(int, readline().rstrip().split())\n    S = [list(readline().rstrip()) for _ in range(H)]\n    v = defaultdict(lambda : False)\n    dq = deque([(0, CH - 1, CW - 1)])\n    while dq:\n        c, h, w = dq.popleft()\n        # print(f'{c} : {h} : {w} : {S[h][w]}')\n        if (h, w) == (DH - 1, DW - 1):\n            print(c)\n            exit()\n        if v[(h, w)]:\n            continue\n        v[(h, w)] = True\n        for mh, mw in [(1, 0), (-1, 0), (0, 1), (0, -1)]:\n                nh = mh + h\n                nw = mw + w\n                if H <= nh or nh < 0 or W <= nw or nw < 0:\n                    continue\n                if S[nh][nw] == '.' and not v[(nh, nw)]:\n                    dq.appendleft([c, nh, nw])\n        for mh in range(-2, 3):\n            for mw in range(-2, 3):\n                if h == w == 0:\n                    continue\n                nh = mh + h\n                nw = mw + w\n                if H <= nh or nh < 0 or W <= nw or nw < 0:\n                    continue \n                if S[nh][nw] == '.' and not v[(nh, nw)]:\n                    dq.append([c + 1, nh, nw])\n    print(-1)\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":418,"bad_solution":"import sys\nread = sys.stdin.readline\n\n\ndef read_ints():\n    return list(map(int, read().split()))\n\n\ndef read_a_int():\n    return int(read())\n\n\ndef read_matrix(H):\n    '''\n    H is number of rows\n    '''\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\ndef read_map(H):\n    '''\n    H is number of rows\n    文字列で与えられた盤面を読み取る用\n    '''\n    return [read() for _ in range(H)]\n\n\ndef read_col(H, n_cols):\n    '''\n    H is number of rows\n    n_cols is number of cols\n\n    A列、B列が与えられるようなとき\n    '''\n    ret = [[] for _ in range(n_cols)]\n    for _ in range(H):\n        tmp = list(map(int, read().split()))\n        for col in range(n_cols):\n            ret[col].append(tmp[col])\n\n    return ret\n\n\nN, K = read_ints()\nS = '1'+read()\n\nsum_0 = [0]\n# prev = S[0]\nfor s, s_next in zip(S[:-2], S[1:-1]):\n    if s == s_next:\n        sum_0.append(sum_0[-1])\n        continue\n\n    if s == '1' and s_next == '0':\n        sum_0.append(sum_0[-1] + 1)\n        continue\n\n    sum_0.append(sum_0[-1])\n\n\n# def get_1length(left, right):\n#     return len()\n\n\nleft = 0  # 左端初期値\nans = 1  # 解初期値\nright = 1\n\n# right-leftが答え\n# sum_0[right]-sum0[left]がKを超えたらleftを進める\n# print(sum_0)\n# しゃくとり法で溶けそうでは？\nfor left in range(N+1):\n    # if sum_0[right] - sum_0[left] > K:\n    #     continue\n\n    while sum_0[right] - sum_0[left] <= K:\n        if right == N:\n            break\n        right += 1\n\n    # print(left, right)\n    ans = max(ans, right - left)  # 大きい方に更新\n    # print(ans)\n\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":419,"bad_solution":"N, K = map(int, input().split())\nT = [[] for i in range(N)]\nMOD = 10 ** 9 + 7\nfor i in range(N - 1):\n    a,  b = map(int, input().split())\n    a, b = a - 1, b - 1\n    T[a].append(b)\n    T[b].append(a)\n\n\n# 階乗 & 逆元計算\nfactorial = [1]\ninverse = [1]\nfor i in range(1, K + 2):\n    factorial.append(factorial[-1] * i % MOD)\n    inverse.append(pow(factorial[-1], MOD - 2, MOD))\n\n\n# 組み合わせ計算\ndef nPr(n, r):\n    if n < r or r < 0:\n        return 0\n    elif r == 0:\n        return 1\n    return ((factorial[n] * inverse[r]) % MOD) * (inverse[n - r] * factorial[r] % MOD) % MOD\n\n\nans = K\nstack = [[0, 0]]  # [頂点番号, 深さ]\nvisited = [False] * N\nwhile stack:\n    n, depth = stack.pop()\n    visited[n] = True\n\n    child = 0\n    for to in T[n]:\n        if visited[to]:\n            continue\n\n        child += 1\n        stack.append([to, depth + 1])\n\n    if depth == 0:\n        ans *= nPr(K - 1, child)\n    else:\n        ans *= nPr(K - 2, child)\n\nprint(ans % MOD)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":420,"bad_solution":"## coding: UTF-8\n#最後の方のテストケースでREになってしまう。時間切れ。\nfrom decimal import *\nfrom itertools import permutations, combinations,combinations_with_replacement,product\n\nN = int(input())\n\ns = input().split()\np = [int(w) for w in s]\n#print('p:{}'.format(p))\n\nnumber_list = [0 for i in range(N)]\n'''\nfor i in range(N):\n    counter = 0\n    for j in range(N):\n        if(p[j] == i+1):\n            counter +=1\n    number_list.append(counter)\n'''\n#print(number_list)\n\nfor i in range(N):\n    number_list[p[i] - 1] += 1\n#print(number_list)\n\n\n\ndef n_C_2(n):\n    if(n == -1):\n        return 0\n    else:\n        return int(n * (n-1) \/ 2)\n\n\nfull_combi = []\npickup_combi = []\nprint_combi = []\n\nfor i in range(N):\n    full_combi.append(n_C_2(number_list[i]))\n    pickup_combi.append(n_C_2(number_list[i] - 1))\n#print('full_combi:{}'.format(full_combi))\n#print('pickup_combi:{}'.format(pickup_combi))\n\nfor i in range(N):\n    print_combi.append(sum(full_combi) - full_combi[i] + pickup_combi[i])\n#print('print_combi:{}'.format(print_combi))\n\nfor i in range(N):\n    index = p[i] - 1\n    print(print_combi[index])\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":421,"bad_solution":"#!\/usr\/bin python3\n# -*- coding: utf-8 -*-\n\nfrom collections import deque\n\nH, W = map(int,input().split())\nsth, stw = map(int,input().split())\nglh, glw = map(int,input().split())\nsth, stw = sth-1, stw-1\nglh, glw = glh-1, glw-1\n\nINF = -1\nGmap = [list(input()) for _ in range(H)]\nseen = [[INF]*W for _ in range(H)]\ndirec = {(1,0), (-1,0), (0,1), (0,-1)}\ndirec5 = set([])\nfor i in range(-2,3):\n    for j in range(-2,3):\n        direc5.add((i, j))\ndirec5 = direc5 - direc\ndirec5 = direc5 - {(0,0)}\nnxt_st = set([])\nnxt_st_all = set([])\n\ndef bfs(pnxt):\n    next_q = deque([])\n    for h, w in pnxt:\n        next_q.append((h,w))\n        seen[h][w] = 0\n    nxt = set([])\n    while len(next_q)!=0:\n        #キュー取り出し(先頭)\n        h,w = next_q.popleft()\n        if h == glh and w == glw:\n            print(ret)\n            exit()\n        seen[h][w] = 0\n        for dh, dw in direc:\n            hs, ws = h + dh, w + dw\n            if not (0<=hs<H and 0<=ws<W):\n                continue\n            if Gmap[hs][ws]=='.' and seen[hs][ws]==INF:\n                next_q.append((hs, ws))\n        for dh, dw in direc5:\n            hs, ws = h + dh, w + dw\n            if not (0<=hs<H and 0<=ws<W):\n                continue\n            if Gmap[hs][ws]=='.' and seen[hs][ws]==INF:\n                nxt.add((hs, ws))\n\n    return nxt\n\nret = -1\nnxt_st.add((sth, stw))\nwhile len(nxt_st)>0:\n    ret += 1\n    nxt_st = bfs(nxt_st)\nprint(-1)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":422,"bad_solution":"import sys\nsys.setrecursionlimit(10**7)\n\nn=int(input())\nkk=[[] for _ in range(n)]\nki=[[] for _ in range(n)]\nfor i in range(n-1):\n  u,v=map(int,input().split())\n  u,v=u-1,v-1\n  kk[u].append([i,v])\n  kk[v].append([i,u])\nm=int(input())\nuv=[]\nfor _ in range(m):\n  u,v=map(int,input().split())\n  u,v=u-1,v-1\n  uv.append([u,v])\n\ntodo=[0]\nka=set(())\nwhile todo:\n  v=todo.pop()\n  ka.add(v)\n  for i,nv in kk[v]:\n    if nv not in ka:\n      ki[v].append([i,nv])\n      todo.append(nv)\n\n\n# n: 頂点数\n# ki[v]: 頂点vの子頂点 (親頂点は含まない)\n# Euler Tour の構築\nS=[]\nF=[0]*n\ndepth=[0]*n\ndef dfs(v,pare,d):\n    F[v]=len(S)\n    depth[v]=d\n    S.append(v)\n    for i,w in ki[v]:\n        if w==pare:continue\n        dfs(w,v,d+1)\n        S.append(v)\ndfs(0,-1,0)\n#print(S)\n# 存在しない範囲は深さが他よりも大きくなるようにする\nINF = (n, None)\n\n# LCAを計算するクエリの前計算\nM = 2*n\nM0 = 2**(M-1).bit_length()\ndata = [INF]*(2*M0)\nfor i, v in enumerate(S):\n    data[M0-1+i] = (depth[v], i)\nfor i in range(M0-2, -1, -1):\n    data[i] = min(data[2*i+1], data[2*i+2])\n\n# LCAの計算 (generatorで最小値を求める)\ndef _query(a, b):\n    yield INF\n    a += M0; b += M0\n    while a < b:\n        if b & 1:\n            b -= 1\n            yield data[b-1]\n        if a & 1:\n            yield data[a-1]\n            a += 1\n        a >>= 1; b >>= 1\n# LCAの計算 (外から呼び出す関数)\ndef query(u, v):\n    fu = F[u]; fv = F[v]\n    if fu > fv:\n        fu, fv = fv, fu\n    return S[min(_query(fu, fv+1))[1]]\nd={}\n\ntodo=[[0,[]]]\npath=[[]]*n\nmi=[1]*n\nwhile todo:\n  v,ary=todo.pop()\n  path[v]=ary\n  mi[v]=0\n  for i,nv in ki[v]:\n    if mi[nv]==1:\n      todo.append([nv,ary+[i]])\n      mi[nv]=1\n#print(path)\nfor i in range(n):\n  path[i]=set(path[i])\nans=2**(n-1)\nfor i in range(2**m):\n  chk=set(())\n  for j in range(m):\n    if (i>>j)&1:\n      chk.add(j)\n  if not chk:continue\n  must_w=set(())\n  for c in chk:\n    u,v=uv[c]\n    if (u,v) in d:\n      tmp=d[(u,v)]\n    else:\n      dd=query(u,v)\n      tmp=path[u].union(path[v])\n      tmp=tmp-path[dd]\n      d[(u,v)]=tmp\n    must_w=must_w.union(tmp)\n  t=n-1-len(must_w)\n  if len(chk)%2==1:\n    ans-=pow(2,t)\n  else:\n    ans+=pow(2,t)\nprint(ans)\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":423,"bad_solution":"import sys\nsys.setrecursionlimit(10**6)\nfrom math import floor,ceil,sqrt,factorial,log,gcd\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,permutations,combinations,product,combinations_with_replacement\nfrom bisect import bisect_left,bisect_right\nfrom copy import deepcopy\nfrom operator import itemgetter\nfrom fractions import gcd\nmod = 10 ** 9 + 7\ninf = float('inf')\nninf = -float('inf')\n\n#Pythonを用いる場合\n#numpy 1.18.0, scipy 1.4.1, scikit-learn 0.22, numba 0.47.0, networkx 2.4\n \nimport numpy as np\nfrom scipy.sparse.csgraph import shortest_path, floyd_warshall, dijkstra, bellman_ford, johnson\nfrom scipy.sparse import csr_matrix\n\n \n#整数input\ndef ii(): return int(sys.stdin.readline().rstrip()) #int(input())\ndef mii(): return map(int,sys.stdin.readline().rstrip().split())\ndef limii(): return list(mii()) #list(map(int,input().split()))\ndef lin(n:int): return [ii() for _ in range(n)]\ndef llint(n: int): return [limii() for _ in range(n)]\n#文字列input\ndef ss(): return sys.stdin.readline().rstrip() #input()\ndef mss(): return sys.stdin.readline().rstrip().split()\ndef limss(): return list(mss()) #list(input().split())\ndef lst(n:int): return [ss() for _ in range(n)]\ndef llstr(n: int): return [limss() for _ in range(n)]\n\n#本当に貪欲法か？ DP法では？？\n#本当に貪欲法か？ DP法では？？\n#本当に貪欲法か？ DP法では？？\n\nn,m,k=mii()\narra=[0]+limii()\narrb=[0]+limii()\n\ncuma=np.cumsum(arra)\ncumb=np.cumsum(arrb)\nans=0\ncnt=0\ntmp=0\nplacea=0\nfor i in cuma:\n    if i<=k:\n        tmp=i\n        placea+=1\n        ans+=1\n        cnt+=1\n    else:\n        continue\n#print(cnt,tmp,ans,placea)\nplaceb=0\nfor i in arrb:\n    #print(i)\n    if tmp+i<=k:\n        tmp+=i\n        cnt+=1\n        #print(1111111)\n    else:\n        while i+cuma[placea-1]>k:\n            placea-=1\n            cnt-=1\n            \n            if placea<1:\n                break\n        #print(1111)\n    ans=max(ans,cnt)\n    if placea<1:\n        break\nprint(ans-2)\n\n \n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":424,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\n\ndef solve(H: int, N: int, A: \"List[int]\", B: \"List[int]\"):\n    # AB = sorted(list(zip(A,B)),key=lambda x: -x[0]\/x[1])\n\n    # dp[i][j] i番目までの技からいくつか選んで体力H以下にするときの最小MP\n\n    dp = [[10**9]*(H+10**4+1) for _ in range(N+1)]\n    for i in range(N+1):\n        dp[i][0] = 0\n\n    for i in range(N):\n        for h in range(H+10**4+1):\n            if h - A[i] >= 0:\n                dp[i+1][h] = min(dp[i+1][h-A[i]]+B[i],dp[i][h])\n            else:\n                dp[i+1][h] = dp[i][h]\n \n\n    answer = 10**9\n    for i in range(H,H+10**4+1):\n        answer = min(answer,dp[-1][i])\n    print(answer)\n    return\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    H = int(next(tokens))  # type: int\n    N = int(next(tokens))  # type: int\n    A = [int()] * (N)  # type: \"List[int]\"\n    B = [int()] * (N)  # type: \"List[int]\"\n    for i in range(N):\n        A[i] = int(next(tokens))\n        B[i] = int(next(tokens))\n    solve(H, N, A, B)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":425,"bad_solution":"# abc117_b.py\n# https:\/\/atcoder.jp\/contests\/abc117\/tasks\/abc117_b\n\n# B - Polygon \/\n# 実行時間制限: 2 sec \/ メモリ制限: 1024 MB\n# 配点 : 200点\n\n# 問題文\n# 2次元平面上に辺の長さがそれぞれ L1,L2,...,LN の N角形(凸多角形でなくてもよい)が描けるかを判定してください。\n# ここで、次の定理を利用しても構いません。\n\n# 定理 : 一番長い辺が他の N−1辺の長さの合計よりも真に短い場合に限り、条件を満たす N角形が描ける。\n\n# 制約\n#     入力は全て整数である。\n#     3≤N≤10\n#     1≤Li≤100\n\n# 入力\n# 入力は以下の形式で標準入力から与えられる。\n# N\n# L1 L2 ... LN\n\n# 出力\n# 条件を満たす N角形が描けるなら Yes、そうでないなら No を出力せよ。\n\n# 入力例 1\n# 4\n# 3 8 5 1\n\n# 出力例 1\n# Yes\n\n# 8<9=3+5+1なので、定理より 2 次元平面上に条件を満たす N角形が描けます。\n\n# 入力例 2\n# 4\n# 3 8 4 1\n\n# 出力例 2\n# No\n\n# 8≥8=3+4+1なので、定理より 2 次元平面上に条件を満たす N角形は描けません。\n\n# 入力例 3\n# 10\n# 1 8 10 5 8 12 34 100 11 3\n\n# 出力例 3\n# No\n\n\ndef calculation(lines):\n    N = lines[0]\n    # N = int(lines[0])\n    values = list(map(int, lines[1].split()))\n    # values = list()\n    # for i in range(N):\n    #     values.append(int(lines[i+1]))\n\n    ma = max(values)\n    su = sum(values)\n\n    if ma * 2 < su:\n        result = 'Yes'\n    else:\n        result = 'No'\n\n    return [result]\n\n\n# 引数を取得\ndef get_input_lines(lines_count):\n    lines = list()\n    for _ in range(lines_count):\n        lines.append(input())\n    return lines\n\n\n# テストデータ\ndef get_testdata(pattern):\n    if pattern == 1:\n        lines_input = ['4', '3 8 5 1']\n        lines_export = ['Yes']\n    if pattern == 2:\n        lines_input = ['4', '3 8 4 1']\n        lines_export = ['No']\n    if pattern == 3:\n        lines_input = ['10', '1 8 10 5 8 12 34 100 11 3']\n        lines_export = ['No']\n    return lines_input, lines_export\n\n\n# 動作モード判別\ndef get_mode():\n    import sys\n    args = sys.argv\n    if len(args) == 1:\n        mode = 0\n    else:\n        mode = int(args[1])\n    return mode\n\n\n# 主処理\ndef main():\n    import time\n    started = time.time()\n    mode = get_mode()\n    if mode == 0:\n        lines_input = get_input_lines(2)\n    else:\n        lines_input, lines_export = get_testdata(mode)\n\n    lines_result = calculation(lines_input)\n\n    for line_result in lines_result:\n        print(line_result)\n\n    if mode > 0:\n        print(f'lines_input=[{lines_input}]')\n        print(f'lines_export=[{lines_export}]')\n        print(f'lines_result=[{lines_result}]')\n        if lines_result == lines_export:\n            print('OK')\n        else:\n            print('NG')\n    finished = time.time()\n    duration = finished - started\n    print(f'duration=[{duration}]')\n\n\n# 起動処理\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":426,"bad_solution":"# 幅優先探索（行きがけ）\nimport collections\nimport sys\nimport copy\nimport re\nimport bisect\n\n\ndef I(): return int(sys.stdin.readline().rstrip())\ndef LI(): return list(map(int, sys.stdin.readline().rstrip().split()))\ndef S(): return sys.stdin.readline().rstrip()\ndef LS(): return list(sys.stdin.readline().rstrip().split())\n\n\ndef main():\n    N, M, K = LI()\n    AArray = LI()\n    BArray = LI()\n\n    aSum = [AArray[0]]\n    bSum = [BArray[0]]\n\n    cnt = 0\n\n    for i in range(1, N):\n        aSum.append(aSum[i-1]+AArray[i])\n    for i in range(1, M):\n        bSum.append(bSum[i-1]+BArray[i])\n\n    for i in range(N):\n        a = aSum[i]\n        if a > K:\n            if i == 0:\n                b1 = bisect.bisect_right(bSum, K)\n                cnt = max(cnt, b1)\n            break\n        if a == K:\n            cnt = max(cnt, i+1)\n            break\n        sa = K-a\n        b = bisect.bisect_right(bSum, sa)\n        cnt = max(cnt, i+1+b)\n\n    print(cnt)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":427,"bad_solution":"#from collections import deque,defaultdict\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\ndef modinv2(x,r):\n  return pow(x,r-2,r)\n\ndef comb(n,a,R):\n    return (fact[n]*modinv2(fact[n-a]*fact[a],R))\n\ndef factinit(n,R):\n    global fact\n    fact = [1]*(n+1)\n    for i in range(2,n+1):\n        fact[i] = (fact[i-1]*i)%R\n\n\nn,a,b,k = inm()\nsm = 0\nfactinit(n,R)\nfor pq in range(n+1):\n    if (k-a*pq)%b>0:\n        continue\n    qr = (k-a*pq)\/\/b\n    if qr>n:\n        continue\n    q1 = max(0,pq+qr-n)\n    q2 = min(pq,qr)\n    for q in range(q1,q2+1):\n        p = pq-q\n        r = qr-q\n        s = n-p-q-r\n        sor = ((fact[p]*fact[q]%R)*(fact[r]*fact[s]%R))%R\n        sm = (sm+fact[n]*modinv2(sor,R))%R\nprint(sm)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":428,"bad_solution":"### ----------------\n### ここから\n### ----------------\n\nimport sys\nfrom io import StringIO\nimport unittest\n\ndef yn(b):\n    print(\"Yes\" if b==1 else \"No\")\n    return\n\ndef resolve():\n    readline=sys.stdin.readline\n\n    #n,m,k=map(int, readline().rstrip().split())\n    #arr=list(map(int, readline().rstrip().split()))\n    n=int(readline())\n    ss=readline().rstrip()\n    j=len(ss)\n    ans=0\n    for i in range(len(ss)):\n        if ss[i]==\"W\":\n            j-=1\n            if j >= 0:\n                while ss[j]!=\"R\":\n                    j-=1\n            if j > i:\n                ans+=1\n    print(ans)\n\n    return\n\nif 'doTest' not in globals():\n    resolve()\n    sys.exit()\n\n### ----------------\n### ここまで \n### ----------------\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":429,"bad_solution":"from collections import namedtuple\nLine = namedtuple('Line', ['lowest', 'end'])\n\n\ndef main():\n    N = int(input())\n    up_lines = []\n    down_lines = []\n    for i in range(N):\n        s = input()\n        now = 0\n        lowest = 0\n        for c in s:\n            if c == \"(\":\n                now += 1\n            else:\n                now -= 1\n                lowest = min(lowest, now)\n        if now > 0:\n            up_lines.append(Line(lowest, now))\n        else:\n            down_lines.append(Line(lowest-now, -now))\n    up_lines.sort(key=lambda line: -line.end)\n    up_lines.sort(key=lambda line: -line.lowest)\n    down_lines.sort(key=lambda line: -line.end)\n    down_lines.sort(key=lambda line: -line.lowest)\n    left = 0\n    for line in up_lines:\n        if left + line.lowest < 0:\n            print(\"No\")\n            return\n        left += line.end\n        if left < 0:\n            print(\"No\")\n            break\n    right = 0\n    for line in down_lines:\n        if right + line.lowest < 0:\n            print(\"No\")\n            return\n        right += line.end\n        if right < 0:\n            print(\"No\")\n            break\n    if left == right:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":430,"bad_solution":"\n\ndef FUNC(n: int):\n    \"\"\"The FibFib number sequence is a sequence similar to the Fibbonacci sequnece that's defined as follows:\n    FUNC(0) == 0\n    FUNC(1) == 0\n    FUNC(2) == 1\n    FUNC(n) == FUNC(n-1) + FUNC(n-2) + FUNC(n-3).\n    Please write a function to efficiently compute the n-th element of the FUNC number sequence.\n    >>> FUNC(1)\n    0\n    >>> FUNC(5)\n    4\n    >>> FUNC(8)\n    24\n    \"\"\"\n    if n == 0:\n        return 0\n    if n == 1:\n        return 1\n    if n == 2:\n        return 2\n    return FUNC(n - 1) + FUNC(n - 2) + FUNC(n - 3)\n"}
{"id":431,"bad_solution":"def main():\n    N, K, *A = map(int, open(0).read().split())\n    visited = [0]*N\n    pos = A[0]\n    visited[0] = visited[pos - 1] = 1\n    while visited[pos - 1] < 2:\n        pos = A[pos - 1]\n        visited[pos - 1] += 1\n    # print(pos)\n    begin = pos\n    step_to_begin = 0\n    if begin != 0:\n        pos = 0\n        while pos != begin:\n            pos = A[pos - 1]\n            step_to_begin += 1\n        step_to_begin += 1\n    # print(begin, step_to_begin)\n\n    if K <= step_to_begin:\n        ans = 0\n        for i in range(K):\n            ans = A[ans - 1]\n        print(ans)\n        return\n    order = 1\n    pos = step_to_begin\n    while A[pos - 1] != step_to_begin:\n        pos = A[pos - 1]\n        order += 1\n    # print(order)\n    remain = (K - step_to_begin) % order\n    ans = step_to_begin\n    for i in range(remain):\n        ans = A[ans - 1]\n    print(ans)\n\nif __name__ == '__main__':\n  main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":432,"bad_solution":"from heapq import heappush,heappop,heapify\nfrom collections import deque,defaultdict,Counter\nfrom itertools import permutations,combinations,groupby\nimport sys,bisect,string,math,time,functools,random\ndef Golf():*a,=map(int,open(0))\ndef I():return int(input())\ndef S_():return input()\ndef IS():return input().split()\ndef LS():return [i for i in input().split()]\ndef LI():return [int(i) for i in input().split()]\ndef LI_():return [int(i)-1 for i in input().split()]\ndef NI(n):return [int(input()) for i in range(n)]\ndef NI_(n):return [int(input())-1 for i in range(n)]\ndef StoLI():return [ord(i)-97 for i in input()]\ndef ItoS(n):return chr(n+97)\ndef LtoS(ls):return ''.join([chr(i+97) for i in ls])\ndef GI(V,E,Directed=False,index=0):\n    org_inp=[];g=[[] for i in range(n)]\n    for i in range(E):\n        inp=LI();org_inp.append(inp)\n        if index==0:inp[0]-=1;inp[1]-=1\n        if len(inp)==2:\n            a,b=inp;g[a].append(b)\n            if not Directed:g[b].append(a)\n        elif len(inp)==3:\n            a,b,c=inp;aa=(inp[0],inp[2]);bb=(inp[1],inp[2]);g[a].append(bb)\n            if not Directed:g[b].append(aa)\n    return g,org_inp\ndef GGI(h,w,search=None,replacement_of_found='.',mp_def={'#':1,'.':0}):\n#h,w,g,sg=GGI(h,w,search=['S','G'],replacement_of_found='.',mp_def={'#':1,'.':0}) # sample usage\n    mp=[1]*(w+2);found={}\n    for i in range(h):\n        s=input()\n        for char in search:\n            if char in s:\n                found[char]=((i+1)*(w+2)+s.index(char)+1)\n                mp_def[char]=mp_def[replacement_of_found]\n        mp+=[1]+[mp_def[j] for j in s]+[1]\n    mp+=[1]*(w+2)\n    return h+2,w+2,mp,found\ndef TI(n):return GI(n,n-1)\ndef bit_combination(k,n=2):\n    rt=[]\n    for tb in range(n**k):\n        s=[tb\/\/(n**bt)%n for bt in range(k)];rt+=[s]\n    return rt\ndef show(*inp,end='\\n'):\n    if show_flg:print(*inp,end=end)\n\nYN=['YES','NO'];Yn=['Yes','No']\nmo=10**9+7\ninf=float('inf')\nl_alp=string.ascii_lowercase\n#sys.setrecursionlimit(10**7)\ninput=lambda: sys.stdin.readline().rstrip()\n\nclass Comb:\n    def __init__(self,n,mo=10**9+7):\n        self.fac=[0]*(n+1)\n        self.inv=[1]*(n+1)\n        self.fac[0]=1\n        self.fact(n)\n        for i in range(1,n+1):\n            self.fac[i]=i*self.fac[i-1]%mo\n            self.inv[n]*=i\n            self.inv[n]%=mo\n        self.inv[n]=pow(self.inv[n],mo-2,mo)\n        for i in range(1,n):\n            self.inv[n-i]=self.inv[n-i+1]*(n-i+1)%mo\n        return\n    \n    def fact(self,n):\n        return self.fac[n]\n        \n    def invf(self,n):\n        return self.inv[n]\n\n    def comb(self,x,y):\n        if y<0 or y>x:\n            return 0\n        return self.fac[x]*self.inv[x-y]*self.inv[y]%mo\n\nshow_flg=False\n#show_flg=True\n\nans=0\n\n\nn=I()\nA=LI()\na=list(enumerate(A))\na.sort(key=lambda x:x[1])\nshow('a',a)\n\nb=[[]for i in range(n)]\nfor i in range(n):\n    for j in range(n):\n        b[i].append(abs(i-j)*A[i])\n\nfor j in b:\n    show('b',j)\n\nl,r=0,n-1\nrng=list(range(n))\nskp=set()\nfor i in range(n):\n    mx_l,mx_r=-1,-1\n    for j in range(n):\n        if j in skp:continue\n        if b[j][l]>mx_l:\n            mx_l=b[j][l]\n            l_can=set()\n            l_can.add(j)\n        elif b[j][l]==mx_l:\n            l_can.add(j)\n\n        if b[j][r]>mx_r:\n            mx_r=b[j][r]\n            r_can=set()\n            r_can.add(j)\n        elif b[j][r]==mx_r:\n            r_can.add(j)\n    show('mx_l,mx_r',mx_l,mx_r)\n    if mx_r>mx_l:\n        ans+=mx_r\n        r-=1\n        mn_l=1<<63\n        for x in r_can:\n            if b[x][l]<mn_l:\n                mn_l=b[x][l]\n                r_skp=x\n        skp.add(r_skp)\n        show('r')\n    elif mx_l>mx_r:\n        ans+=mx_l\n        l+=1\n        mn_r=1<<63\n        for x in l_can:\n            if b[x][r]<mn_r:\n                mn_r=b[x][r]\n                l_skp=x\n        skp.add(l_skp)\n        show('l')\n    elif mx_l==mx_r:\n        ans+=mx_l\n        bt_l=-1\n        bt_r=-1\n\n        mn_r=1<<63\n        for x in l_can:\n            if b[x][r]<mn_r:\n                mn_r=b[x][r]\n                l_skp=x\n        mn_l=1<<63\n        for x in r_can:\n            if b[x][l]<mn_l:\n                mn_l=b[x][l]\n                r_skp=x\n\n        for x in l_can:\n            if b[x][r]<bt_r:\n                bt_r=b[x][r]\n                bt_ri=x\n        for x in r_can:\n            if b[x][l]<bt_l:\n                bt_l=b[x][l]\n                bt_li=x\n        if bt_r>bt_l:\n            l+=1\n            skp.add(l_skp)\n        else:\n            r-=1\n            skp.add(r_skp)\n        \n        \n        show('=')\n    show(skp,(l,r),ans)\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":433,"bad_solution":"\nFIX = \"\"\"\nAdd more test cases.\n\"\"\"\n\ndef FUNC(s):\n    \"\"\"Write a function FUNC which takes a string representing\n    a word as input and returns the number of vowels in the string.\n    Vowels in this case are 'a', 'e', 'i', 'o', 'u'. Here, 'y' is also a\n    vowel, but only when it is at the end of the given word.\n\n    Example:\n    >>> FUNC(\"abcde\")\n    2\n    >>> FUNC(\"ACEDY\")\n    3\n    \"\"\"\n    vowels = \"aeiouyAEIOUY\"\n    n_vowels = sum(c in vowels for c in s)\n    return n_vowels\n"}
{"id":434,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\n\ndef solve(X: int, K: int, D: int):\n    X=abs(X)\n\n    mostl = X - K * D\n    mostr = X + K * D\n    if mostl*mostr > 0:\n        print(min(mostl, mostr))\n        exit()\n\n    ans=X\n    if K%2 == 1:\n        X -= D\n        K -= 1\n        ans = min(ans, X)\n\n    N = X \/\/ (D*2)\n    ans = min(ans, abs(X - D * 2 * N))\n    if N < K\/\/2:\n        ans = min(ans, abs(X - D * 2 * (N+1)))\n\n    print(ans)\n\n    return\n\n\n# Generated by 1.1.7.1 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    X = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    D = int(next(tokens))  # type: int\n    solve(X, K, D)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":435,"bad_solution":"import sys, re\nfrom math import ceil, floor, sqrt, pi, factorial, gcd\nfrom copy import deepcopy\nfrom collections import Counter, deque\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, product, combinations, combinations_with_replacement\nfrom bisect import bisect, bisect_left\nfrom functools import reduce\nfrom decimal import Decimal, getcontext\n# input = sys.stdin.readline \ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_list(N): return [s_list() for _ in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\nsys.setrecursionlimit(10 ** 6)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nnum_list = []\nstr_list = []\n\ndef main():\n    n, m = i_map()\n    num_list = i_row_list(m)\n\n    num_list = sorted(num_list, key=lambda x: x[0], reverse=True)\n    num_list = sorted(num_list, key=lambda x: x[1], reverse=True)\n\n    count = 0\n    tmp = num_list[0][1]\n    for num in num_list:\n        if num[1] > tmp:\n            continue\n        tmp = num[0]\n        count += 1\n\n    print(count)\n    \nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":436,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = [int(x) for x in input().split()]\n\nA.append(1)\n\nB = [A[0]]\nB_cnt = [1]\nfor i,(x,y) in enumerate(zip(A[:-1],A[1:])):\n    if x < y and y < A[i+2]:\n        continue\n    if x == y:\n        B_cnt[-1] += 1\n    else:\n        B.append(y)\n        B_cnt.append(1)\n\ndef test(x):\n    digit = [0]\n    cnt = [0]\n    for a,a_cnt in zip(B,B_cnt):\n        if digit[-1] < a:\n            digit.append(a)\n            cnt.append(a_cnt)\n            continue\n        if digit[-1] == a:\n            cnt[-1] += a_cnt\n            continue\n        while True:\n            # 繰り上がり処理をしながら左に戻る\n            if digit[-1] <= a:\n                break\n            n = digit.pop()\n            k = cnt.pop()\n            if k <= x:\n                continue\n            if digit[-1] == n-1:\n                cnt[-1] += (k-1)\/\/x\n            else:\n                digit.append(n-1)\n                cnt.append((k-1)\/\/x + 1)\n        if digit[-1] == a:\n            cnt[-1] += a_cnt\n        else:\n            digit.append(a)\n            cnt.append(1+a_cnt)\n    return cnt[1] <= x+1\n\nif all(x<y for x,y in zip(A[:-2],A[1:-1])):\n    print(1)\n    exit()\n\nleft = 1 # 無理\nright = 2 # 可能?\nwhile not test(right):\n    left *= 2\n    right *= 2\nwhile right > left + 1:\n    mid = (left+right)\/\/2\n    if test(mid):\n        right = mid\n    else:\n        left = mid\n\nanswer = right\nprint(answer)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":437,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nsys.setrecursionlimit(10**8)\nINF = float(\"inf\")\n\n\ndef yes():\n    print(\"Yes\")  # type: str\n\n\ndef no():\n    print(\"No\")  # type: str\n\n\ndef solve(N: int, S: \"List[str]\"):\n\n    def f(s):\n        ans = [0]*(len(s)+1)\n        m = 0\n        for i, c in enumerate(s):\n            if c == \"(\":\n                m += 1\n            else:\n                m -= 1\n            ans[i] = m\n        return min(*ans), m, s\n\n    # 数値化(最小値, 到達値)\n    T = [f(s) for s in S]\n\n    front = []\n    back = []\n    for ma, mb, s in T:\n        if ma >= 0:\n            front.append((ma, mb, s))\n        else:\n            back.append((ma, mb, s))\n\n    back.sort(key=lambda x: (-x[1], x[0]))\n    # print(front)\n    # print(back)\n\n    m = 0\n    for ma, mb, s in front+back:\n        if m + ma < 0:\n            no()\n            return\n        m += mb\n    if m == 0:\n        yes()\n    else:\n        no()\n\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    S = [next(tokens) for _ in range(N)]  # type: \"List[str]\"\n    solve(N, S)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":438,"bad_solution":"def f1(l1):\n    ret = []\n    for i in l1:\n      for n,j in enumerate(li[i]):\n        if j == 1:\n            if n in used or n in l1:\n                return False\n            elif n not in tree[nest-1]:\n                ret.append(n)\n    return list(set(ret))\n\n\nN = int(input())\nli = []\nfor _ in range(N):\n    li.append(list(map(int,list(input()))))\n    \nmax_nest = 0\nfor i in range(N):\n    tree = [[]]\n    used = []\n    tree.append([i])\n    nest = 1\n    while True:\n        ret = f1(tree[nest])\n        nest += 1\n        if ret == False:\n            break\n        elif ret != []:\n            tree.append(ret)\n            used.extend(tree[nest-2])\n        else:\n            if max_nest < nest:\n                max_nest = nest\n            break\n        \nprint(max_nest-1)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":439,"bad_solution":"import numpy as np\n\ndef prod(p, q, r):\n    return A[p] + B[q] + C[r]\n\nx, y, z, k = [int(a) for a in input().split()]\nA = [int(a) for a in input().split()]\nB = [int(a) for a in input().split()]\nC = [int(a) for a in input().split()]\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nprogress = [(0, 0, 0, prod(0,0,0))]\n\n\ndef expand(p, q, r):\n    result = []\n    if p + 1 < x:\n        result.append((p+1, q, r, prod(p+1, q, r)))\n    if q + 1 < y:\n        result.append((p, q+1, r, prod(p, q+1, r)))\n    if r + 1 < z:\n        result.append((p, q, r+1, prod(p, q, r+1)))\n    return result\n\nfor i in range(k):\n    prods = [tup[-1] for tup in progress]\n\n    max_val = max(prods)\n    max_idx = prods.index(max_val)\n    p, q, r, _ = progress[max_idx]\n\n    print(max_val)\n    progress.pop(max_idx)\n    progress.extend(expand(p, q, r))\n    progress = list(set(progress))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":440,"bad_solution":"import heapq,math,sys\ninput=sys.stdin.readline\nINF=math.inf\nheappush=heapq.heappush\nheappop=heapq.heappop\n\nn,m=map(int,input().split())\ngraph=[[] for _ in range(n)]\nminway=[]\nbridges=[]\nans=0\nfor _ in range(m):\n    a,b,c=map(int,input().split())\n    graph[a-1].append((b-1,c))\n    graph[b-1].append((a-1,c))\n    bridges.append((a-1,b-1))\n\ndef dijkstra(graph,n,start):\n    Q=[]\n    distance=[]\n    dappend=distance.append\n    for i in range(n):\n        dappend([INF,i])\n    distance[start][0]=0\n    for j in distance:\n        heappush(Q,j)\n    while Q!=[]:\n        q=heappop(Q)\n        for v,vl in graph[q[1]]:\n            alt=vl+q[0]\n            if alt<distance[v][0]:\n                distance[v][0]=alt\n                heappush(Q,[alt,v])\n    return distance\n\nfor k in range(n):\n    minway.append(dijkstra(graph,n,k))\n\nfor l in bridges:\n    flag=0\n    x,y=l[0],l[1]\n    for p in graph[x]:\n        if p!=y:\n            if minway[x][p[0]][0]+minway[x][y][0]==minway[p[0]][y][0]:\n                flag=1\n    for q in graph[y]:\n        if q!=x:\n            if minway[x][y][0]+minway[y][q[0]][0]==minway[x][q[0]][0]:\n                flag=1\n    if flag==0:\n        ans+=1\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":441,"bad_solution":"def warshall_floyd(d):\n \n    n = len(d)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if d[i][j] > d[i][k] + d[k][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n\ndef solve():\n  n,m = (int(i) for i in input().split())\n \n  upper = 10**10\n  dist = [[0 if x == i else upper for x in range(n)] for i in range(n)]\n  edge_list = []\n  for i in range(m):\n    a, b, c = (int(i) for i in input().split())\n    edge = [a, b, c]\n    edge_list.append(edge)\n    dist[a-1][b-1] = c\n    dist[b-1][a-1] = c\n  #print(edge_list)\n  #print(dist)\n  \n  warshall_floyd(dist)\n  #print(dist)\n  \n  \n  ans = 0\n  for edge in edge_list:\n    a, b, c = edge\n    #最短距離か\n    if dist[a-1][b-1] < c:\n        ans += 1\n  print(ans)\nsolve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":442,"bad_solution":"#!\/usr\/bin\/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\n\ninput = sys.stdin.readline\n\nMATCH_NUM = [-1, 2, 5, 5, 4, 5, 6, 3, 7, 6]\n\ndef main():\n    N, M = [int(e) for e in input().split()]\n    A = [int(e) for e in input().split()]\n\n    # N 本で作れる桁の数\n    dp = [-1 for _ in range(N+1)]\n    dp[0] = 0\n    dp[1] = 0\n    for i in range(N+1):\n        for a in A:\n            if i < MATCH_NUM[a]:\n                continue\n            dp[i] = max(dp[i], dp[i-MATCH_NUM[a]] + 1)\n\n    max_digit_num = dp[N]\n\n    A.sort(reverse=True)\n\n    min_cost = 10\n    for a in A:\n        if MATCH_NUM[a] < min_cost:\n            min_cost = MATCH_NUM[a]\n\n    res = ''\n    for _ in range(max_digit_num):\n        for a in A:\n            if N < MATCH_NUM[a]:\n                continue\n            if dp[N-MATCH_NUM[a]] == dp[N]-1:\n                if N-MATCH_NUM[a] < min_cost and N-MATCH_NUM[a] != 0:\n                    continue\n                res += str(a)\n                N -= MATCH_NUM[a]\n                break\n    print(res)\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":443,"bad_solution":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\n\ndef toId(i, j):\n    pair = A[i][j]\n    if i > pair:\n        i, pair = pair, i\n    return ids[i][pair]\n\ndef dfs(x):\n    if dp[x] != -1:\n        if done[x]:\n            return dp[x]\n        else:\n            return -1\n    dp[x] = 1\n    for y in G[x]:\n        res = dfs(y)\n        if res == -1:\n            return -1\n        dp[x] = max(dp[x], dfs(y)+1)\n    done[x] = True\n    return dp[x]\n\nN = int(input())\nA = [list(map(lambda x: int(x)-1, input().split())) for i in range(N)]\nids = [[0]*N for i in range(N)]\nnum = 0\nfor i in range(N):\n    for j in range(N):\n        if i < j:\n            ids[i][j] = num\n            num += 1\nallv = N*N\nG = [[] for i in range(allv)]\nfor i in range(N):\n    for j in range(N-2):\n        G[toId(i,j+1)].append(toId(i,j))\ndp = [-1 for i in range(allv)]\ndone = [False for i in range(allv)]\nans = 0\nfor i in range(allv):\n    res = dfs(i)\n    if res == -1:\n        print(-1)\n        exit()\n    ans = max(ans, dfs(i))\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":444,"bad_solution":"N, K = list(map(int, input().split()))\nlinks = [list(map(int, input().split())) for _ in range(N-1)]\n\ndef perm(a, b):\n    s = 1\n    for i in range(a-b+1, a+1):\n        s *= i\n    return s\n\nif N == 1:\n    print(K)\nelse:\n    mod = 1000000007\n    d = {i: [set(), False] for i in range(1, N+1)}\n    for i, j in links:\n        d[i][0].add(j)\n        d[j][0].add(i)\n    b = len(d[1][0])\n    if K - 1 < b:\n        print(0)\n    else:\n        ans = K * perm(K - 1, b)\n        d[1][1] = True\n        root = d[1][0]\n        a = K - 2\n        while True:\n            children = set()\n            for i in list(root):\n                if d[i][1]:\n                    continue\n                d[i][1] = True\n                b = len(d[i][0]) - 1\n                if a < b:\n                    print(0)\n                    break\n                children |= d[i][0]\n                if b == 0:\n                    continue\n                ans *= perm(a, b)\n            else:\n                if len(children) == 0:\n                    print(ans % mod)\n                    break\n                continue\n            break\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":445,"bad_solution":"import math\n\n\ndef get_sieve_of_eratosthenes(n):\n    prime = []\n    limit = math.sqrt(n)\n    data = [i + 1 for i in range(1, n)]\n    while True:\n        p = data[0]\n        if limit <= p:\n            return prime + data\n        prime.append(p)\n        data = [e for e in data if e % p != 0]\n\n\ndata = get_sieve_of_eratosthenes(10 ** 6)\nn=int(input())\na=list(map(int,input().split()))\narr = [0]*(10**6+1)\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5\/\/1))+1):\n        if temp%i==0:\n            while temp%i==0:\n                temp \/\/= i\n            arr.append(i)\n\n    if temp!=1:\n        arr.append(temp)\n\n    if arr==[]:\n        arr.append(n)\n\n    return arr\n\nfor num in a:\n    for s in factorization(num):\n        arr[s]+=1\nans=max(arr)\nif ans==1:\n    print(\"pairwise coprime\")\nelse:\n    ans=a[0]\n    for i in a:\n        ans=math.gcd(ans,i)\n    if ans==1:\n        print(\"setwise coprime\")\n    else:\n        print(\"not coprime\")\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":446,"bad_solution":"import sys\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\nmod = 10**9 + 7\ninf = float('inf')\nans = int(0)\n\nN, K = LI()\nS = str(input())\nS = S + \"2\"\nd1 = []\nd0 = []\nk = S[0]\nif k==\"0\":\n    d1.append(0)\ncou = int(1)\nfor i in range(N):\n    if S[i]!=S[i+1]:\n        if S[i]==\"0\":\n            d0.append(cou)\n        if S[i]==\"1\":\n            d1.append(cou)\n        cou = int(1)\n    else:\n        cou +=1\n\n#print(d1)\n#print(d0)\n\nansC = []\nt = 2*K+1\nnewN = len(d1)\nif len(d1)==1 or d0==[]:\n    ansC.append(N)\n\nif newN!=len(d0):\n    d0.append(0)\n    d0.append(0)\nsumd1 = [0]*(newN+t)\nsumd0 = [0]*(newN+t)\nfor i in range(newN):\n    sumd1[i+1] = d1[i]\n    sumd0[i+1] = d0[i]\nfor i in range(newN+1):\n    sumd1[i+1] += sumd1[i]\n    sumd0[i+1] += sumd0[i]\n\nfor i in range(newN-K+1):\n    ans = (sumd1[i+K+1]-sumd1[i]) + (sumd0[i+K]-sumd0[i])\n    ansC.append(ans)\n\n\nprint(max(ansC))\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":447,"bad_solution":"from collections import defaultdict\n\ndef gcd(a, b):\n    if a < b:\n        return gcd(b, a)\n    while b > 0:\n        a, b = b, a % b\n    return a\n\ndef sieve_of_eratosthenes(n):\n    sieve = [0] * (n+1)\n    sieve[0] = 1 #素数でない\n    sieve[1] = 1 #素数でない\n    for i in range(2, n):\n        if sieve[i] == 0:\n            for j in range(2, n \/\/ i + 1):\n                sieve[i * j] = i\n    return sieve\n\ndef factorize_by_sieve_of_eratosthenes(x, sieve):\n    factor = defaultdict(int)\n    while sieve[x]:\n        factor[sieve[x]] += 1\n        x \/\/= sieve[x]\n    factor[x] += 1\n    return factor\n\nn = int(input())\na = list(map(int, input().split()))\na.sort()\nfor i in range(n):\n    if a[i] != 1:\n        break\na = a[i:]\nn -= i\nif n == 1:\n    print(\"pairwise coprime\")\n    quit()\n\nsieve = sieve_of_eratosthenes(a[-1])\nx = a[0]\n\npairwise = True\nsetwise = True\nprimes = set()\nfor i in range(n):\n    if x != 1:\n        x = gcd(x, a[i])\n    if pairwise:\n        factor = set(factorize_by_sieve_of_eratosthenes(a[i], sieve).keys())\n        if not primes.isdisjoint(factor):\n            pairwise = False\n        else:\n            primes |= factor\n\nif pairwise:\n    print(\"pairwise coprime\")\nelif x == 1:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":448,"bad_solution":"#!\/usr\/bin\/env python\n# coding: utf-8\n\n# In[1]:\n\n\nimport sys\ninput = sys.stdin.readline\nN, M = map(int, input().split())\nA = list(map(int, input().split()))\nbcs = [list(map(int, input().split())) for i in range(M)]\n\"\"\"\n10 3\n1 8 5 7 100 4 52 33 13 5\n3 10\n4 30\n1 4\n\"\"\"\n\n\n# In[32]:\n\n\n#print(N, M)\n#print(A)\n#print(bcs)\n\n\n# In[14]:\n\n\ndef binary_search(nbs, tar):\n    #print(nbs, tar)\n    \n    ln = 0\n    rn = len(nbs)-1\n    t = int(len(nbs)\/2)\n    \n    while ln<=rn:\n        comp = nbs[t]\n        if tar >= comp and tar<nbs[t+1]:\n            break\n        elif tar >= comp: # 今の値がtar以下であれば、\n            ln = t + 1 # 左端をt+1に更新\n        elif tar < comp: # 今の値が\n            rn = t - 1 # 右端をt-1に更新\n        t = int((ln+rn)\/2)\n    return t\n\n\n# In[15]:\n\n\nsbcs = sorted(bcs, key=lambda x:x[1], reverse=True)\nnb = 0\nsA = sorted(A)\n#print(sA)\n#print(sbcs)\nfor i in range(M):\n    if nb >= N:\n        break\n    \n    B, C = sbcs[i]\n    #print(B, C, nb)\n    if sA[nb] >= C:\n        continue\n    if sA[nb+B-1] < C: #もしB個目が、Cより小さければ、B個目までをCにする\n        sA[nb:nb+B] = [C]*B\n        nb += B\n        continue\n    t = binary_search(sA[nb:nb+B], C)\n    #print(t)\n    sA[nb:nb+t+1] = [C]*(t+1)\n    nb += t+1\n#print(sA)\nprint(sum(sA))\n\n\n# In[ ]:\n\n\n\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":449,"bad_solution":"import sys\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 10 ** 9 + 7\n\nn = I()\nhl = LI()\n# count = 0\n\n# len_h = len(hl)\n\n# def m1(n):\n#     if n > 0:\n#         n = n - 1\n#     else:\n#         n = 0\n#     return n\n\n# max_hana = max(hl)\n# if max_hana == 0:\n#     print(0)\n#     sys.exit()\n\n# for i in range(max_hana):\n#     for j in range(len_h):\n#         if j == 0:\n#             if hl[j] > 0:\n#                 count += 1\n#         else:\n#             if hl[j] > 0 and hl[j-1] == 0:\n#                 count += 1\n#             elif hl[j] > 0 and hl[j-1] == 0:\n#                 count += 1\n#     hl = list(map(m1, hl))\n\n# print(count)\n\n######################\n# 隣との差分を考えたほうが早い\n\n# 1    2    4    2    1    0      計4\n#   1    2    0    0     0\n\nans = hl[0]\nfor i in range(1, n)\n    ans += max(0, hl[i] - hl[i - 1])\nprint(ans)\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":450,"bad_solution":"def main():\n    n, a, b, c, d = map(int, input().split())\n    s = input()\n\n    if c < d:\n        count = 0\n        for i in range(d - 1):\n            if s[i] == '#':\n                count += 1\n                if count == 2:\n                    print('No')\n                    exit(0)\n            else:\n                count = 0\n        print('Yes')\n    else:\n        flag = 0\n        countr = 0\n        countv = 0\n        for i in range(d + 1):\n            if s[i] == '#':\n                countr += 1\n                countv = 0\n                if countr == 2:\n                    print('No')\n            else:\n                countv += 1\n                countr = 0\n                if countv == 3:\n                    flag = 1\n        print('Yes') if flag else print('No')\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":451,"bad_solution":"def doubling(n,k,a):\n    logk = 1\n    beki = 2\n    while beki < k:\n        logk += 1\n        beki = beki << 1\n    dp = [[0 for _ in range(n)] for _ in range(logk)]\n    for i in range(n):\n        dp[0][i] = a[i]\n    for i in range(logk-1):\n        for j in range(n):\n            dp[i+1][j] = dp[i][dp[i][j]]\n    now = 0\n    index = 0\n    while k > 0:\n        if k&1:\n            now = dp[index][now]\n        k = k >> 1\n        index += 1\n    return now+1\n\n\ndef main():\n    n,k = map(int,input().split())\n    a = list(map(int,input().split()))\n    for i in range(n):\n        a[i] -= 1\n    print(doubling(n,k,a))    \n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":452,"bad_solution":"def inpl(): return map(int, input().split())\nfrom itertools import accumulate\nfrom bisect import bisect, bisect_left\nfrom collections import Counter\nfrom functools import reduce\nfrom itertools import accumulate\nfrom operator import itemgetter, xor\n\nfrom sys import setrecursionlimit\nsetrecursionlimit(10**9)\n \nimport sys\n#input = sys.stdin.readline\nfrom collections import Counter\ndef inpl(): return list(map(int, input().split()))\n\nMOD = 10**9 + 7\ndef cmb(n, r, mod):\n    if ( r<0 or r>n ):\n        return 0\n    \n    r = min(r, n-r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n \nsize = 2 * 10**5\ng1, g2, inverse = [0]*size, [0]*size, [0]*size\n \ng1[:2] = [1, 1] # 元テーブル\ng2[:2] = [1, 1] #逆元テーブル\ninverse[:2] = [0, 1] #逆元テーブル計算用テーブル\n \nfor i in range(2, size):\n    g1[i] =  ( g1[i-1] * i ) % MOD \n    inverse[i] = (-inverse[MOD % i] * (MOD\/\/i) ) % MOD \n    g2[i] =  (g2[i-1] * inverse[i]) % MOD\n\n\n\nN, K = inpl()\nG = [[] for _ in range(N)]\nfor _ in range(N-1):\n    a, b = inpl()\n    G[a-1].append(b-1)\n    G[b-1].append(a-1)\nC = [0]*N\nP = [0]*N\nsearched = [0]*N\nsearched[0] = 1\n\ndef count(p):\n    global C, searched\n    cnt = 0\n    for q in G[p]:\n        if not searched[q]:\n            P[q] = p\n            searched[q] = 1\n            cnt += 1\n            count(q)\n    C[p] = cnt\ncount(0)\n\nans = K * cmb(K-1, C[0], MOD) * g1[C[0]] % MOD\nfor i in range(1, N):\n    if C[i] == 0:\n        continue\n    ans = ans * cmb(K-2, C[i], MOD) * g1[C[i]] % MOD\n\nprint(ans%MOD)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":453,"bad_solution":"import sys\n\n# import re\nimport math\nimport collections\n# import decimal\nimport bisect\nimport itertools\nimport fractions\n# import functools\nimport copy\nimport heapq\nimport decimal\n# import statistics\nimport queue\n\nsys.setrecursionlimit(10000001)\nINF = 10 ** 16\nMOD = 10 ** 9 + 7\n\nni = lambda: int(sys.stdin.readline())\nns = lambda: map(int, sys.stdin.readline().split())\nna = lambda: list(map(int, sys.stdin.readline().split()))\n\n\n# ===CODE===\n\n\ndef main():\n    n, x = ns()\n    lim = 51\n    total = [int(0) for _ in range(lim)]\n    P_total = [int(0) for _ in range(lim)]\n\n    total[0] = 1\n    for i in range(1, lim - 1):\n        total[i] = total[i - 1] * 2 + 3\n\n    P_total[0] = 1\n    for i in range(1, lim - 1):\n        P_total[i] = P_total[i - 1] * 2 + 1\n\n    ans = 0\n    base = 1\n    L = n\n    while base != x or L == 0:\n        if base + total[L] \/\/ 2 <= x:\n            base += total[L] \/\/ 2\n            ans += P_total[L - 1] + 1\n        else:\n            base += 1\n            L -= 1\n            if L == 0:\n                ans += 1\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":454,"bad_solution":"import sys\nsys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python\nimport math\nfrom copy import copy, deepcopy\nfrom copy import deepcopy as dcp\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect, bisect_right#2分探索\n#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下\nfrom collections import deque\n#deque(l), pop(), append(x), popleft(), appendleft(x)\n#q.rotate(n)で → にn回ローテート\nfrom collections import Counter#文字列を個数カウント辞書に、\n#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()\nfrom itertools import accumulate,combinations,permutations#累積和\n#list(accumulate(l))\nfrom heapq import heapify,heappop,heappush\n#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone\n#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする\nfrom functools import lru_cache#pypyでもうごく\n#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率\nfrom decimal import Decimal\n\ndef input(): \n    x=sys.stdin.readline()\n    return x[:-1] if x[-1]==\"\\n\" else x\ndef printl(li): _=print(*li, sep=\"\\n\") if li else None\ndef argsort(s, return_sorted=False): \n    inds=sorted(range(len(s)), key=lambda k: s[k])\n    if return_sorted: return inds, [s[i] for i in inds]\n    return inds\ndef alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65\ndef num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)\ndef matmat(A,B):\n    K,N,M=len(B),len(A),len(B[0])\n    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]\ndef matvec(M,v):\n    N,size=len(v),len(M)\n    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]\ndef T(M):\n    n,m=len(M),len(M[0])\n    return [[M[j][i] for j in range(n)] for i in range(m)]\ndef main():\n    mod = 998244353\n    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え\n\n    #N = int(input())\n    N,A,B, K = map(int, input().split())\n    #A = tuple(map(int, input().split())) #1行ベクトル\n    #L = tuple(int(input()) for i in range(N)) #改行ベクトル\n    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列\n\n    def extgcd1(a0,b0):#計算量log(b0),フェルマーの小定理より早い\n        u,v,a,b=1,0,a0,b0\n        while b: t=a\/\/b; a-=t*b; a,b=b,a; u,v=v,u-t*v\n        if a!=1: return -1#互いに素じゃない\n        return u%b0\n    \n    maxn=N\n    fact=[1]*(maxn+1)#NはnCrの最大のn\n    ifact=[1]*(maxn+1)\n    x=1\n    for i in range(2,maxn+1):\n        x=(x*i)%mod\n        fact[i]=x; ifact[i]=extgcd1(x,mod)\n        \n    def comb(n,r): return (fact[n]*ifact[r]%mod)*ifact[n-r]%mod\n    ans=0\n    for i in range(N):\n        b=K-A*i\n        if b<0:break\n        d,x=divmod(b,B)\n        if x!=0 or d>N:\n            continue\n        ans+=comb(N,i)*comb(N,d)%mod\n        ans%=mod\n    print(ans)\n        \n\n\n\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":455,"bad_solution":"from sys import stdin\n\n\ndef get(l, r):\n    for i in range(1, 10001):\n        if i != l and i != r:\n            return i\n    assert False, 'damepo'\n\n\ndef check(a):\n    for i, x in enumerate(a[1:-1]):\n        idx = i + 1\n        l = a[idx - 1]\n        r = a[idx + 1]\n        assert l != x and x != r, 'damepo'\n\n\ndef main():\n    N = int(stdin.readline().rstrip())\n    a = [int(x) for x in stdin.readline().rstrip().split()]\n    check(a)\n    count = 0\n    for i, x in enumerate(a[1:-1]):\n        idx = i + 1\n        l = a[idx - 1]\n        r = a[idx + 1]\n        if (l == x and x != r) or (l == x == r) or ((idx == len(a) - 2) and x == r):\n            x = get(l, r)\n            count += 1\n            a[idx] = x\n    # print(a)\n    print(count)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":456,"bad_solution":"lens=[1 for _ in range(51)]\nnump=[1 for _ in range(51)]\nfor i in range(50):\n    lens[i+1]=2*lens[i]+3\n    nump[i+1]=2*nump[i]+1\ndef level(n):\n    return max(lvl for lvl,ln in enumerate(lens) if ln<=n)\n\ndef calc():\n    table={}\n    def _calc(l,x):\n        if x==0:\n            return 0\n        if (l,x) in table:\n            return table[(l,x)]\n        if x<=lens[l-1]:\n            res=_calc(l-1,x-1)\n        elif x==lens[l]:\n            res=nump[l]\n        elif x==lens[l-1]+1:\n            res=nump[l-1]\n        elif x==lens[l-1]+2:\n            res=nump[l-1]+1\n        else:\n            res=nump[l-1]+1+_calc(l-1,x-lens[l-1]-2)\n        table[(l,x)]=res\n        return res\n    return _calc\nwhole=calc()\nprint(whole(*map(int,input().split())))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":457,"bad_solution":"\ndef main():\n    N,M,Q = map(int, input().split())\n\n    X = [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(M):\n        l,r = map(int, input().split())\n        X[l-1][r-1] += 1\n\n    query = [tuple(map(int, input().split())) for _ in range(Q)]\n\n    \"\"\"\n    C[i][j]：iから出発してjまで（ｊを含む）のどこかに行くもの\n    C[i][j] = X[i][i] + X[i][i+1] + ... + X[i][j-1] + X[i][j]\n    \"\"\"\n    C =  [[0 for _ in range(N)] for _ in range(N)]\n    for i in range(N):\n        for j in range(N):\n            C[i][j] = C[i][j-1] + X[i][j]\n\n\n    \"\"\"\n    print(\"---------------\")\n    for a in C:\n        print(a)\n    \"\"\"\n\n    for p,q in query:\n        cnt = 0\n        for r in range(p-1,q):\n            cnt += C[r][q-1]\n        print(cnt)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":458,"bad_solution":"H, W = map(int, input().split())\ns = [[c for c in input()] for i in range(H)]\ns_vrt = [[s[i][j] for i in range(H)] for j in range(W)]\n# 0: lr, 1: up\nmemo = [[[-1, -1] for j in range(W)] for i in range(H)]\n\ndef count_light_place(i, j):\n    line_lr = s[i]\n    line_up = s_vrt[j]\n    m = memo[i][j]\n    c_lr = m[0]\n    if c_lr == -1:\n        c_lr = count_light_line(j, line_lr)\n        memo[i][j][0] = c_lr\n\n    c_up = m[1]\n    if c_up == -1:\n        c_up = count_light_line(i, line_up)\n        memo[i][j][1] = c_up\n\n    return c_lr + c_up - 1\n\ndef count_light_line(k, line):\n    count = 0\n    for dn in reversed(range(k)):\n        if line[dn] == '#':\n            break\n        count += 1\n \n    for up in range(k, len(line)):\n        if line[up] == '#':\n            break\n        count += 1\n    return count \n\n\ncount_max = 0\nfor i in range(H):\n    for j in range(W):\n        if s[i][j] == '#':\n            continue\n        count = count_light_place(i, j)\n        if count_max < count:\n            count_max = count\n\nprint(count_max)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":459,"bad_solution":"import sys, math\nimport numpy as np\n\n# input = sys.stdin.readline\n\nclass UnionFind():\n    def __init__(self, n):\n        self.n = n\n        self.parents = [-1] * n\n\n    def find(self, x):\n        if self.parents[x] < 0:\n            return x\n        else:\n            self.parents[x] = self.find(self.parents[x])\n            return self.parents[x]\n\n    def union(self, x, y):\n        x = self.find(x)\n        y = self.find(y)\n\n        if x == y:\n            return\n\n        if self.parents[x] > self.parents[y]:\n            x, y = y, x\n\n        self.parents[x] += self.parents[y]\n        self.parents[y] = x\n\n    def size(self, x):\n        return -self.parents[self.find(x)]\n\n    def members(self, x):\n        root = self.find(x)\n        return [i for i in range(self.n) if self.find(i) == root]\n\n    def roots(self):\n        return [i for i, x in enumerate(self.parents) if x < 0]\n\n    def group_count(self):\n        return len(self.roots())\n\n    def all_group_members(self):\n        return {r: self.members(r) for r in self.roots()}\n\n\nH, W = map(int, input().split())\nCh, Cw = map(int, input().split())\nDh, Dw = map(int, input().split())\nS_ = np.array([list(input()) for _ in range(H)])\n\n\nuf = UnionFind(H*W)\nfor i in range(H):\n    for j in range(W):\n        if S_[i][j] == '#':\n            uf.parents[W*i+j] = math.inf\n            continue\n        if i != H-1 and S_[i + 1][j] == '.':\n            uf.union(W*i + j, W*(i+1) + j)\n        if j != W-1 and S_[i][j+1] == '.':\n            uf.union(W*i + j, W*i + j + 1)\n\ngroupidx = {k: v for v, k in enumerate(uf.roots())}\nS = np.zeros((H, W), dtype=int)\nfor i in range(H):\n    for j in range(W):\n        if S_[i][j] == '#':\n            S[i][j] = -1\n        else:\n            S[i][j] = groupidx[uf.find(W*i+j)]\n\n\ngroups = list(range(len(uf.roots())))\ncan_reach = [[False]*len(groups) for _ in range(len(groups))]\nfor i in range(H):\n    for j in range(W):\n        if S[i][j] != -1:\n            continue\n        g = set(S[max(0, i-1):i+2, max(0, j-1):j+2].flatten())\n        if -1 in g:\n            g.remove(-1)\n        for k in g:\n            for l in g:\n                can_reach[k][l] = True\ncan_reach_ = {}\nfor i in range(len(groups)):\n    can_reach_[i] = [j for j, k in enumerate(can_reach[i]) if k]\nans = 0\ns = S[Ch-1][Cw-1]\ng = S[Dh-1][Dw-1]\nif s==g:\n    print(0)\n    sys.exit()\n\nreached = [s]\nsearched = [False]*len(groups)\nans = 0\nwhile len(reached)>0:\n    new_reached = []\n    ans += 1\n    for p in reached:\n        searched[p] = True\n    for p in reached:\n        for k in can_reach_[p]:\n            if k == g:\n                print(ans)\n                sys.exit()\n            if not searched[k]:\n                new_reached.append(k)\n    reached = list(set(new_reached))\nprint(-1)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":460,"bad_solution":"\ndef FUNC(x, shift):\n    \"\"\"Circular shift the digits of the integer x, shift the digits right by shift\n    and return the result as a string.\n    If shift > number of digits, return digits reversed.\n    >>> FUNC(12, 1)\n    \"21\"\n    >>> FUNC(12, 2)\n    \"12\"\n    \"\"\"\n    s = str(x)\n    if shift > len(s):\n        return s[::-1]\n    else:\n        return s[:len(s) - shift] + s[len(s) - shift:]\n"}
{"id":461,"bad_solution":"import sys,queue,math,copy,itertools,bisect,collections,heapq\n\ndef main():\n    sys.setrecursionlimit(10**7)\n    INF = float('inf')\n    MOD = 10**9 + 7\n    LI = lambda : [int(x) for x in sys.stdin.readline().split()]\n    _LI = lambda : [int(x)-1 for x in sys.stdin.readline().split()]\n    NI = lambda : int(sys.stdin.readline())\n    SI = lambda : sys.stdin.readline().rstrip()\n    DD = ((1,0),(0,1),(-1,0),(0,-1))\n\n    N = NI()\n    A = LI()\n\n    # 1000までの素数列\n    t = [True] * 1000\n    for i in range(2,33):\n        j = 2\n        while i * j < 1000:\n            t[i*j] = False\n            j += 1\n    p = []\n    for i in range(2,1000):\n        if t[i]: p.append(i)\n\n    cnt = [0] * 1000000\n    for x in A:\n        for d in p:\n            if x % d == 0:\n                while x % d == 0:\n                    x \/\/= d\n                if cnt[d]: break\n                cnt[d] += 1\n        else:\n            if x > 1:\n                if cnt[x]: break\n                cnt[x] += 1\n            continue\n        break\n    else:\n        print('pairwise coprime')\n        return\n\n    g = A[0]\n    for x in A[1:]:\n        g = math.gcd(g,x)\n        if g == 1:\n            print('setwise coprime')\n            return\n    print('not coprime')\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":462,"bad_solution":"def pow_r(x, n):\n    \"\"\"\n    O(log n)\n    \"\"\"\n    if n == 0:  # exit case\n        return 1\n    if n % 2 == 0:  # standard case ① n is even\n        return pow_r(x ** 2 % MOD, n \/\/ 2) % MOD\n    else:  # standard case ② n is odd\n        return x * pow_r(x ** 2 % MOD, (n - 1) \/\/ 2) % MOD\n\n\nN, A, B = map(int, input().split())\nMOD = 10**9+7\nall_number = (pow_r(2, N)-1)\n# nがさらに巨大な時\ntmp_A = 1\nfor i in range(1, A+1):\n    tmp_A %= MOD\n    tmp_A *= (N-i+1)\n    tmp_A \/\/= i\n\ntmp_B = 1\nfor i in range(1, B+1):\n    tmp_B %= MOD\n    tmp_B *= (N-i+1)\n    tmp_B \/\/= i\n# print(tmp_A, tmp_B)\ntmp_A %= MOD\ntmp_B %= MOD\n# print(all_number, tmp_A, tmp_B)\nans = (all_number - (tmp_A+tmp_B) + MOD)%MOD\nprint(ans % MOD)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":463,"bad_solution":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\n\nmod = 10 ** 9 + 7\nN = 1000000\n\n#逆元テーブル\ninv_t = [0]+[1]\nfor i in range(2, N):\n  inv_t += [inv_t[mod % i] * (mod - int(mod \/ i)) % mod]\n\n#階乗計算\nkai = [1, 1]\nrev_kai = [1, inv_t[1]]\nfor i in range(2, N):\n\tkai.append(kai[-1] * i % mod)\n\trev_kai.append(rev_kai[-1] * inv_t[i] % mod)\n\n# コンビネーション計算\ndef cmb(n, r):\n\treturn kai[n] * rev_kai[r] * rev_kai[n-r] % mod\n\nn = int(input())\n\nE = [[] for i in range(n)]\nfor i in range(n-1):\n    a, b = map(int, input().split())\n    E[a-1].append(b-1)\n    E[b-1].append(a-1)\n\nmemo = [[0, 0] for i in range(n)]\n\ndef dfs(cur, pre):\n    if E[cur] == [pre]:\n        memo[cur] = [1, 1]\n        return 1, 1\n    ns = []\n    cnt = 1\n    for e in E[cur]:\n        if e != pre:\n            ni, cnti = dfs(e, cur)\n            ns.append(ni)\n            cnt = cnt * cnti % mod\n    s = sum(ns)\n    S = s\n    for ni in ns:\n        cnt = cnt * cmb(s, ni) % mod\n        s -= ni\n    memo[cur] = [S, cnt]\n    return S, cnt\n\n    \nfor i in range(n):\n    dfs(i, -1)\n    print(memo[i][1])\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":464,"bad_solution":"    \n    def __init__(self):\n        pass\n    \n    def A(self):\n        S=input()\n        if \"BA\" in S or \"AB\" in S:print(\"Yes\")\n        else:print(\"No\")\n    \n    def B(self):\n        NAB=list(map(int,input().split()))\n        \n        if NAB[0]<=NAB[1]:ans=NAB[0]\n        elif NAB[0]<=NAB[1]+NAB[2]:ans=NAB[1]\n        else:\n            tail = NAB[0]%(NAB[1]+NAB[2]) if NAB[0]%(NAB[1]+NAB[2])<NAB[1] else NAB[1]\n            ans=(int(NAB[0]\/(NAB[1]+NAB[2]))*NAB[1])+tail\n            \n        print(int(ans))\n            \n    def C(self):\n        AB=list(map(int,input().split()))\n        ans=-1\n        \n        #A<B<100\n        for i in range(1,1001):\n            if AB[0]==int(i*0.08) and AB[1]==int(i*0.1):\n                ans=i\n                break\n            else:continue\n        print(ans)\n            \n    def D(self):\n        pass\n        \n    def E(self):\n        pass\n    \n    def F(self):\n        pass\n    \n    \nif __name__=='__main__':\n    obj=abc_158()\n    obj.B()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":465,"bad_solution":"\ndef FUNC(s):\n    \"\"\"Task\n    Write a function that takes a string as input and returns the sum of the upper characters only'\n    ASCII codes.\n\n    Examples:\n        FUNC(\"\") => 0\n        FUNC(\"abAB\") => 131\n        FUNC(\"abcCd\") => 67\n        FUNC(\"helloE\") => 69\n        FUNC(\"woArBld\") => 131\n        FUNC(\"aAaaaXa\") => 153\n    \"\"\"\n    if s == \"\": return 0\n    return sum(ord(char) if char.islower() else 0 for char in s)\n"}
{"id":466,"bad_solution":"from collections import deque\nH, W = map(int, input().split())  # 迷路の縦、横の長さ\nmaze = [input() for iiii in range(H)]\n\n# print(maze)\ndist = [[-1] * W for iii in range(H)]  # スタートからの距離\ncheck_que = deque()\n\nfor i in range(H):\n    for j in range(W):\n        if maze[i][j] == \"#\":\n            dist[i][j] = 0\n            check_que.append((i, j))\n# print(dist)\n\n\ndef bfs(check_que,dist):  # distを編集する関数\n    #print(\"{},{}\".format(tate, yoko))\n    while check_que:\n\n        h, w = check_que.popleft()\n        d = dist[h][w]\n        for dh, dw in ((0, 1), (0, -1), (1, 0), (-1, 0)):\n            h_prime, w_prime = h + dh, w + dw\n\n            if 0 > h_prime or h_prime >= H or 0 > w_prime or w_prime >= W:\n                continue\n            if dist[h_prime][w_prime] == -1:\n                dist[h_prime][w_prime] = d + 1\n                check_que.append((h_prime, w_prime))\n\n    return d\n\n\ndis = bfs(check_que,dist)\n# print(dist)\nprint(dis)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":467,"bad_solution":"\ndef sub(s, c, d):\n    \"\"\"s枚の銀貨を得たいときに、レートc, 時間dでかかる最小時間\n    \"\"\"\n    dp = [[None] * (s+1) for _ in range(len(c))]\n    for i in range(s+1):\n        dp[0][i] = ((i \/\/ c[0] + int(i%c[0])) * d[0])\n    for i in  range(len(c)):\n        dp[i][0] = 0\n    for i in range(1,len(c)):\n        cc, dd = c[i], d[i]\n        for j in range(1,s+1):\n            dp[i][j] = dp[i-1][j]\n            if j>=cc:\n                dp[i][j] = min(dp[i][j], dp[i][j-cc]+dd)\n            else:\n                dp[i][j] = min(dp[i][j], dp[i][0]+dd)\n#     print(s, c, d, dp[-1][-1])\n    return dp[len(c)-1][s]\n\nimport heapq\nfrom collections import defaultdict\nh = []\nheapq.heapify(h)\n\nn, m, s = list(map(int, input().split()))\na, b = [[None] * m for _ in range(2)]\nc, d = [[None] * n for _ in range(2)]\nns = defaultdict(list)\nuv2e = {}\nfor i in range(m):\n    u,v,a[i],b[i] = list(map(int, input().split()))\n    ns[u-1].append(v-1)\n    ns[v-1].append(u-1)\n    uv2e[u-1,v-1] = i\n    uv2e[v-1,u-1] = i\nfor i in range(n):\n    c[i], d[i] = list(map(int, input().split()))\n\n# (t, u, ss, dd)\nprevs = defaultdict(list)\nheapq.heappush(h, (0, 0, s, set([0])))\nprevs[0].append(set([0]))\ndone = set()\nbest_time = [10**100] * n\nbest_prev = [-1] * n\nwhile h:\n    t, u, ss, prev = heapq.heappop(h)\n#     print(\"best: \", t, u, ss, prev)\n    done.add(u)\n    best_time[u] = min(t, best_time[u])\n    best_prev[u] = prev\n    if len(done)==n:\n        break\n    for v in ns[u]:\n        e = uv2e[u,v]\n        tmp_t = t + b[e]\n        if ss>=a[e]:\n            tmp_ss = s - a[e]\n        else:\n            tmp_ss = 0            \n            tmp_t += sub(a[e] - ss, [c[item] for item in prev], [d[item] for item in prev])\n#             tmp_t += min(((a[e] - ss) \/\/ c[item] + 1 - int((a[e] - ss) % c[item] == 0)) * d[item] for item in prev)\n\n        tmp_prev = prev|set([v])\n        if tmp_prev not in prevs[v]:\n            heapq.heappush(h, (tmp_t, v, tmp_ss, tmp_prev))\n            prevs[v].append(tmp_prev)\n#             print((tmp_t, v, tmp_ss, tmp_cds, prev|set([v])))\nprint(*best_time[1:], sep=\"\\n\")\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":468,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\nMOD = 1000000007  # type: int\n\n\ndef dfs(stones, depth):\n    if len(stones) <= 2:\n        # print(\" \"*depth, stones, \"leaf\")\n        return 1\n    # print(\" \"*depth, stones)\n\n    # ans1 はじめの石使わない\n    # print(\" \"*depth, \"ans1\")\n    ans1 = dfs(stones[1:], depth+1)\n\n    # ans2 はじめの石を使う\n    c = stones[2:].count(stones[0])\n    if c == 0:\n        ans2 = 0\n    else:\n        ind = stones[2:].index(stones[0])\n        # print(\" \"*depth, \"ans2\", c)\n        # print(\" \"*depth, ind, stones, stones[ind:])\n        ans2 = dfs(stones[2+ind:], depth+1)\n\n    return (ans1 + ans2) % MOD\n\n\ndef solve(N: int, C: \"List[int]\"):\n    print(dfs(C, 0) % MOD)\n    return\n\n\n# Generated by 1.1.3 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    C = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    solve(N, C)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":469,"bad_solution":"import bisect\n\ndef bitadd(a,w,bit): #aにwを加える(1-origin)\n \n    x = a\n    while x <= (len(bit)-1):\n        bit[x] += w\n        x += x & (-1 * x)\n \ndef bitsum(a,bit): #ind 1～aまでの和を求める\n\n    if a == 0:\n        return 0\n \n    ret = 0\n    x = a\n    while x > 0:\n        ret += bit[x]\n        x -= x & (-1 * x)\n    return ret\n\n\ndef updiv(a,b):\n    if a % b == 0:\n        return a \/\/ b\n    else:\n        return a \/\/ b + 1\n\n\nN,D,A = map(int,input().split())\n\nXH = []\nXlis = []\ndic = {}\n\nfor i in range(N):\n\n    i += 1\n    \n    X,H = map(int,input().split())\n    XH.append([X,H])\n    if X not in dic:\n        Xlis.append(X)\n        dic[X] = 1\n    if X+D not in dic:\n        Xlis.append(X+D)\n        dic[X+D] = 1\n\nXlis.sort()\nXH.sort()\nBIT = [0] * (len(Xlis)+1)\nans = 0\n\nfor i in range(N):\n\n    nx = XH[i][0]\n    nh = XH[i][1]\n\n    left = bisect.bisect_right(Xlis,nx-D)\n    right = bisect.bisect_right(Xlis,nx+D)\n\n    now = bitsum(right ,BIT) - bitsum(left-1,BIT)\n\n    pl = updiv(nh - A*now ,A)\n    ans += pl\n    #print (\"rem\",nh - A*now,now)\n\n    bitadd(min(N,right),pl,BIT)\n\n#print (Xlis)\n#print (BIT)\nprint (ans)\n\n    \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":470,"bad_solution":"H,W=map(int, input().split())\nA=[list(map(str,list(input()))) for i in range(H)]\n\nblack_list=[[]]\ndel black_list[0]\n\ndef paint_center(a,b):\n  paint_point(a-1,b)\n  paint_point(a+1,b)\n  paint_point(a,b-1)\n  paint_point(a,b+1)\n\ndef paint_point(a,b):\n  if 0<=a and a<H:\n    if 0<=b and b<W:\n      A[a][b]=\"#\"\n\n#黒いマスを探してその周りを黒く塗る\n\n\ncount=0\nflag=False #白があればTrue\nend_flag=False\n\nwhile end_flag==False:\n  #全マスが黒かどうかのチェック\n  flag=False\n\n  for i in range(0,H):\n    for j in range(0,W):\n      if A[i][j]==\".\":\n        flag=True\n      else:\n        pass\n\n  \n  if flag==True:\n    for i in range(0,H):\n      for j in range(0,W):\n        if A[i][j]==\"#\":\n          black_list.append([i,j])\n    for i,j in black_list:\n      paint_center(i,j)\n    count=count+1\n    \n  else:\n    print(count)\n    break\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":471,"bad_solution":"\ndef FUNC(s,n):\n    \"\"\"\n    In this task, you will be given a string that represents a number of apples and oranges \n    that are distributed in a basket of fruit this basket contains \n    apples, oranges, and mango fruits. Given the string that represents the total number of \n    the oranges and apples and an integer that represent the total number of the fruits \n    in the basket return the number of the mango fruits in the basket.\n    for examble:\n    FUNC(\"5 apples and 6 oranges\", 19) ->19 - 5 - 6 = 8\n    FUNC(\"0 apples and 1 oranges\",3) -> 3 - 0 - 1 = 2\n    FUNC(\"2 apples and 3 oranges\", 100) -> 100 - 2 - 3 = 95\n    FUNC(\"100 apples and 1 oranges\",120) -> 120 - 100 - 1 = 19\n    \"\"\"\n    lis = list()\n    for i in s.split(' '):\n        if i.isdigit():\n            lis.append(int(i))\n    return n - sum(lis) - 1\n"}
{"id":472,"bad_solution":"import numpy as np\nimport sys\nfrom collections import defaultdict\n\n\ndef first_prime_list(N):\n    D = [1] * (N + 1)\n\n    for i in range(2, N + 1):\n        if D[i] != 1:\n            continue\n        for j in range(1, N \/\/ i + 1):\n            if D[i * j] == 1:\n                D[i * j] = i\n\n    return D\n\n\ndef factorization_with_fpl(A, D):\n\n    Ps = defaultdict(int)\n    current_p = D[A]\n\n    while D[A] > 1:\n        cnt = 0\n        while D[A] == current_p:\n            A = A \/\/ D[A]\n            cnt += 1\n\n        Ps[current_p] = cnt\n        current_p = D[A]\n\n    if A != 1:\n        Ps[A] = 1\n\n    return Ps\n\n\nN = int(sys.stdin.readline().rstrip())\nA = [int(x) for x in sys.stdin.readline().rstrip().split()]\n\nD = first_prime_list(max(A))\n\npc = True\nsp = True\n\nmaxlist = factorization_with_fpl(A[0], D)\nminlist = factorization_with_fpl(A[0], D)\n\narrA = np.array(A)\n\nfor i in range(1, N):\n    d = factorization_with_fpl(A[i], D)\n    for p in d.keys():\n        if min(maxlist[p], d[p]) != 0:\n            pc = False\n        maxlist[p] = max(maxlist[p], d[p])\n\n    for p in minlist.keys():\n        minlist[p] = min(minlist[p], d[p])\n    \n\nfor p in minlist.keys():\n    if minlist[p] != 0:\n        sp = False\n\n\nif pc:\n    print(\"pairwise coprime\")\nelif sp:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":473,"bad_solution":"N,K = map(int, input().split())\nA = list(map(int, input().split()))\n\ndef f(X):\n    res = 0\n    for a in A:\n        res += X ^ a\n    return res\n\nans = max(f(0), f(K))\n\nfor d in range(60, -1, -1):\n    if K & (1<<d) == 0:\n        continue\n\n    X = K & ~( (1<<d)-1)\n    for j in range(d): \n        count_should_raise = 0\n        mask = 1<<j\n        for a in A:\n            if a & mask == 0: count_should_raise += 1\n        if count_should_raise > N\/\/2:\n            X |= 1<<j\n\n    ans = max(ans, f(X))\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":474,"bad_solution":"\ndef FUNC(arr):\n    \"\"\"\n    \"Given an array representing a branch of a tree that has non-negative integer nodes\n    your task is to FUNC one of the nodes and return it.\n    The FUNCed node should be the node with the smallest even value.\n    If multiple nodes with the same smallest even value are found return the node that has smallest index.\n\n    The FUNCed node should be returned in a list, [ smalest_value, its index ],\n    If there are no even values or the given array is empty, return [].\n\n    Example 1:\n        Input: [4,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\n    Example 2:\n        Input: [1,2,3]\n        Output: [2, 1]\n        Explanation: 2 has the smallest even value, and 2 has the smallest index. \n\n    Example 3:\n        Input: []\n        Output: []\n    \n    Example 4:\n        Input: [5, 0, 3, 0, 4, 2]\n        Output: [0, 1]\n        Explanation: 0 is the smallest value, but  there are two zeros,\n                     so we will choose the first zero, which has the smallest index.\n\n    Constraints:\n        * 1 <= nodes.length <= 10000\n        * 0 <= node.value\n    \"\"\"\n    if(len(arr) == 0): return []\n    evens = list(filter(lambda x: x%2 == 0, arr))\n    if(evens == []): return []\n    return [arr.index(min(evens)), min(evens)]\n"}
{"id":475,"bad_solution":"N = int(input())\nA = list(map(int, input().split()))\n\n\n# number_to_prime[i]: i の最小の素因数, iが素数ならば0\nnumber_to_prime = [0] * (10**6 + 1)\n\n# preprocess\nfor i in range(2, 10**6+1):\n    if not number_to_prime[i]:\n        j = 1\n        while j*i <= 10**6:\n            number_to_prime[j*i] = i\n            j += 1\n\n\ndef is_pairwise():\n    used_primes = set()\n    pairwise_flag = 1\n    for a in A:\n        if a == 1:\n            continue\n        curr_primes = set()\n        while number_to_prime[a] > 1:\n            prime = number_to_prime[a]\n            curr_primes.add(prime)\n            a \/\/= prime\n        if used_primes & curr_primes:\n            pairwise_flag = 0\n            break\n        else:\n            used_primes = used_primes | curr_primes\n    return pairwise_flag\n\ndef is_setwise(*A):\n    import math\n    from functools import reduce\n\n    return reduce(math.gcd, A) == 1\n\nif is_pairwise():\n    print(\"pairwise coprime\")\nelif is_setwise(*A):\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":476,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\n\ndef solve(A: int, B: float):\n    B *= 100\n    C = int(B)\n    print(A * C \/\/ 100)\n\n    # Bbig = int(B)\n    # # print(Bbig)\n    # Bsmall = int((B - Bbig) * 10)\n    # # print(Bsmall)\n    # Bsmall2 = int((B - Bbig) * 100) - Bsmall * 10\n    # # print(Bsmall2)\n    # Abig = A * Bbig * 100\n    # # print(Abig)\n    # Asmall = (A * Bsmall) * 10\n    # # print(Asmall)\n    # Asmall2 = (A * Bsmall2)\n    # # print(Asmall2)\n    # print((Abig + Asmall + Asmall2) \/\/ 100)\n    return\n\n\n# Generated by 1.1.7.1 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    A = int(next(tokens))  # type: int\n    B = float(next(tokens))  # type: float\n    solve(A, B)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":477,"bad_solution":"import math\ndef main():\n  N, K = list(map(int, input().split()))\n  A = list(map(int, input().split()))\n \n  if K == 0:\n    C = 0\n  else:\n    C = int(math.log2(K + 1))\n    L = [[0 for i in range(50)] for j in range(C + 1)]\n \n    for i in A:\n      for j in range(len(L[0])):\n        if i % 2 == 1:\n          i -= 1\n          L[0][j] += 1\n        if i == 0:\n          break\n        i \/= 2\n    for i in range(1, C + 1):\n      for j in range(50):\n        L[i][j] = L[0][j]\n \n    x = pow(2, C)\n    T = [K for i in range(C + 1)]\n    for i in range(C, -1, -1):\n      for j in range(C + 1):\n        if T[j] >= x:\n          if j != i and L[j][i] <= N \/ 2:\n            L[j][i] = N - L[j][i]\n            T[j] -= x\n      x \/\/= 2\n \n    Ans = [0 for i in range(C + 1)]\n    x = 1\n    for i in range(50):\n      for j in range(C + 1):\n        Ans[j] += L[j][i] * x\n      x *= 2\n \n  print(max(Ans))\n\nmain()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":478,"bad_solution":"import sys\n## io ##\ndef IS(): return sys.stdin.readline().rstrip()\ndef II(): return int(IS())\ndef MII(): return list(map(int, IS().split()))\ndef MIIZ(): return list(map(lambda x: x-1, MII()))\nfrom collections import deque\n#======================================================#\ndef main():\n    h, w = MII()\n    ch, cw = MII()\n    dh, dw = MII()\n    maze = [IS() for _ in range(h)]\n    check = [[-1]*w for i in range(h)]\n    dq = deque([(ch-1, cw-1)])\n    check[ch-1][cw-1] = 0\n    count = 0\n\n    inMaze = lambda x,y: 0 <= y < h and 0 <= x < w\n    isWall = lambda x,y: maze[y][x] == '#'\n    isChecked = lambda x,y: check[y][x] != -1\n\n    while True:\n        tmp = []\n        while dq:\n            y, x = dq.popleft()\n            tmp.append((y, x))\n            for dy, dx in ((0,1), (0,-1), (1,0), (-1,0)):\n                ny = y+dy\n                nx = x+dx\n                if not inMaze(nx, ny):\n                    continue\n                if isWall(nx, ny):\n                    continue\n                if isChecked(nx, ny):\n                    continue\n                check[ny][nx] = count\n                dq.appendleft((ny, nx))\n\n        count += 1\n        for y, x in tmp:\n            for i in range(-2,3):\n                for j in range(-2,3):\n                    ny = y+i\n                    nx = x+j\n                    if not inMaze(nx, ny):\n                        continue\n                    if isWall(nx, ny):\n                        continue\n                    if isChecked(nx, ny):\n                        continue\n                    check[ny][nx] = count\n                    dq.append((ny, nx))\n        if not dq:\n            break\n\n    print(check[dh-1][dw-1])\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":479,"bad_solution":"import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\n#N = int(input())\n#A = list(map(int,input().split()))\n#S = list(input())[:-1]\n#S.remove(\"\\n\")\n#N,M = map(int,input().split())\n#S,T = map(str,input().split())\n#A = [int(input()) for _ in range(N)]\n#S = [list(input())[:-1] for _ in range(N)]\n#A = [list(map(int,input().split())) for _ in range(N)]\nA,B = map(float,input().split())\nC = 100*B\nd = A*C\ne = int(d \/\/ 100)\nprint(e)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":480,"bad_solution":"import sys\nimport bisect\nimport itertools\n\n\ndef solve():\n    readline = sys.stdin.buffer.readline\n    mod = 10 ** 9 + 7\n    n, m = list(map(int, readline().split()))\n    a = list(map(int, readline().split()))\n    a.sort()\n    t = 0\n    c = 0\n    for i in range(a[-1] * 2, a[1] - 1, -1):\n        for j in range(n - 1, -1, -1):\n            pl = bisect.bisect_left(a, i - a[j])\n            pr = bisect.bisect_right(a, i - a[j])\n            if pl != pr:\n                if pr - pl == 1:\n                    c += (pr - pl)\n                    t += (pr - pl) * i\n                else:\n                    c += 2 ** (pr - pl - 1)\n                    t += 2 ** (pr - pl - 1) * i\n            if c > m:\n                t -= (c - m) * i\n                print(t)\n                exit()\n\n\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":481,"bad_solution":"import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, gcd\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom functools import reduce\nfrom bisect import bisect_left, insort_left\nfrom heapq import heapify, heappush, heappop\n\nINPUT = lambda: sys.stdin.readline().rstrip()\nINT = lambda: int(INPUT())\nMAP = lambda: map(int, INPUT().split())\nS_MAP = lambda: map(str, INPUT().split())\nLIST = lambda: list(map(int, INPUT().split()))\nS_LIST = lambda: list(map(str, INPUT().split()))\n\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef main():\n    N = INT()\n    A = LIST()\n\n    C = Counter(A)\n    print(C)\n\n    X = 0\n    for v in C.values():\n        X += factorial(v) \/\/ (factorial(2) * factorial(v-2))\n\n    for i in range(N):\n        print(X - C[A[i]] + 1)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":482,"bad_solution":"#!\/usr\/bin\/env python3\n#AGC8 A\n\nimport sys\nimport math\nimport bisect\nsys.setrecursionlimit(1000000000)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nx,y = LI()\nif x >= 0 and y >= 0:\n    if x > y:\n        print(x-y+2)\n    else:\n        print(y-x)\nelif x < 0 and y >= 0:\n    if -x > y:\n        print((-x)-y+1)\n    else:\n        print(y-(-x)+1)\nelif x >= 0 and y < 0:\n    if -x > y:\n        print((-y)-x+1)\n    else:\n        print(x-(-y)+1)\nelse:\n    if x > y:\n        print(abs(y)-abs(x)+2)\n    else:\n        print(y-x)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":483,"bad_solution":"import sys\nsys.setrecursionlimit(10**7)\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return sys.stdin.readline().strip()\nINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\ndebug = True\ndebug = False\n\ndef dprint(*objects):\n    if debug == True:\n        print(*objects)\n\ndef solve():\n    N, K = LI()\n    a_list = LI()\n    f_list = LI()\n\n    # 答えで二分探索\n\n    low = 0\n    high = (10**6)*(10**6)*2*(10**5)\n\n    # 妥当な割り当て\n    a_list = sorted(a_list)\n    f_list = sorted(f_list, reverse=True)\n    import math\n\n    dprint(a_list)\n    dprint(f_list)\n\n    def judge(ans):\n        # ans を答えにできるか\n        cnt = 0\n        for i in range(N):\n            a = a_list[i]\n            f = f_list[i]\n            if a*f > ans:\n                # 差分を訓練で埋める\n                ki = math.ceil((a*f - ans) \/ f)\n                cnt += ki\n                if cnt > K:\n                    dprint('False', ans, cnt)\n                    return False\n        dprint('True', ans, cnt)\n        return True\n\n    while low < high:\n        mid = math.floor((low + high) \/ 2)\n\n        guess = judge(mid)\n        # dprint(high, low, mid, guess)\n\n        if guess == True:\n            # できるので、これより1少ないのが最大\n            high = mid\n        else:\n            # できないので、これより大きい\n            low = mid + 1\n        # dprint(high, low)\n    print(low)\n\n\nsolve()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":484,"bad_solution":"MAXN = 10\nMAXV = (MAXN * (MAXN - 1)) \/\/ 2\nto = [[] for _ in range(MAXV)]\nID = [[-1] * MAXN for _ in range(MAXN)]\n\ndef toID(i, j):\n    if i > j:\n        i, j = j, i\n    return ID[i][j]\n\nvisited = [False] * MAXV\ncalculated = [False] * MAXV\ndp = [0] * MAXV\ndef dfs(v):\n    if visited[v]: #すでに訪れたことがある時\n        if not calculated[v]: #計算されたことがない時 = ループがある\n            return -1\n        return dp[v]\n    visited[v] = True\n    dp[v] = 1\n    for u in to[v]:\n        res = dfs(u)\n        if res == -1:\n            return -1\n        dp[v] = max(dp[v], res + 1)\n    calculated[v] = True\n    return dp[v]\n\ndef main():\n    N = int(input())\n    a = [list(map(lambda x: int(x) - 1, input().split())) for _ in range(N)]\n\n    V = 0 #頂点の数\n    for i in range(N - 1):\n        for j in range(i + 1, N):\n            ID[i][j] = V\n            V += 1\n    \n    for i in range(N):\n        for j in range(N - 1):\n            a[i][j] = toID(i, a[i][j]) #対戦相手で管理していたのを試合番号に変える\n        for j in range(N - 2):\n            to[a[i][j + 1]].append(a[i][j])\n    \n    # import numpy as np\n    # print (np.array(to))\n    # print (np.array(ID))\n\n    ans = 0\n    for i in range(V):\n        res = dfs(i)\n        if res == -1:\n            print (-1)\n            return 0\n        ans = max(ans, res)\n    print (ans)\n    return 0\n\nif __name__ == '__main__':\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":485,"bad_solution":"def main():\n\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    t = 0\n    i, j = 0, 0\n    ans = 0\n    while t < K:\n        if i < len(A) and j < len(B):\n            if A[i] <= B[j]:\n                if t + A[i] <= K:\n                    t += A[i]\n                    i += 1\n                    ans += 1\n                else:\n                    return ans\n            else:\n                if t + B[j] <= K:\n                    t += B[j]\n                    j += 1\n                    ans += 1\n                else:\n                    return ans\n        elif i < len(A):\n            if A[i] + t <= K:\n                ans += 1\n                t += A[i]\n                i += 1\n            else:\n                return ans\n        elif j < len(B):\n            if B[j] + t <= K:\n                ans += 1\n                t += B[j]\n                j += 1\n            else:\n                return ans\n        else:\n            return ans\n    return ans\n\nif __name__ == '__main__':\n    print(main())\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":486,"bad_solution":"def neighbor(N, edges):\n    neighbor_list = [[] for _ in range(N)]\n    for i in range(N):\n        for vs in edges:\n            if i + 1 in vs: # vsは頂点i+1が含まれるedge\n                neighbor_list[i] += vs\n        neighbor_list[i] = list(set(neighbor_list[i]))\n        neighbor_list[i].remove(i + 1)\n        \n    return neighbor_list\n\ndef neighbor2(N, edges):\n    nlist = neighbor(N, edges)\n    nneighbor_list = [[] for _ in range(N)]\n    for i in range(N):\n        nneighbor_list[i] += nlist[i]\n        for e in nlist[i]:\n            nneighbor_list[i] += nlist[e - 1]\n        nneighbor_list[i] = list(set(nneighbor_list[i]))\n        nneighbor_list[i].remove(i + 1)\n    return nneighbor_list\n        \n        \ndef combination(N, K, nnlist):\n    combi = 1\n    clist = [False]*N\n    for v in range(N):\n        print(combi)\n        combi *= (K - len([t for t in nnlist[v] if clist[t-1]]))\n        clist[v] = True\n    return combi\n\ndef paint(N, K, nlist, nnlist, clist, vlist, combi):\n    vlist_next = []\n    for v in vlist:\n        #nnlistの中で塗られている頂点の数を数え、色候補数Kから引く\n        combi *= (K - len([t for t in nnlist[v - 1] if clist[t - 1]])) \n        clist[v - 1] = True #頂点vを塗る\n        vlist_next += [t for t in nlist[v - 1] if not clist[t - 1]]\n    return combi, vlist_next, clist\n\n\nif __name__ == '__main__':\n    N, K = map(int, input().split())\n    edges = [None]*(N-1)\n    \n    for i in range(N-1):\n        edges[i] = list(map(int, input().split()))\n    \n    nlist = neighbor(N, edges)\n    nnlist = neighbor2(N, edges)\n    \n    vlist_next = [1]\n    combi = 1\n    clist = [False]*N\n    for i in range(N):\n        combi, vlist_next, clist = paint(N, K, nlist, nnlist, clist=clist, vlist=vlist_next, combi=combi)\n        if len(vlist_next) == 0:\n            break\n    \n    print(combi%1000000007)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":487,"bad_solution":"# -*- coding:utf-8 -*-\n\ncomb_dic = {}\n\ndef combination_formula_MOD(n, r, MOD):\n    \"\"\"nCrを O(min(n-r, r)) で高速に計算する\"\"\"\n    def _inv(x, MOD):\n        \"\"\"xの逆元を返す\"\"\"\n        return pow(x, MOD-2, MOD)\n    if r > n: return 0\n\n    if (n,r) in comb_dic:\n        return comb_dic[(n,r)]\n\n    r = min(n-r, r)\n    bunsi, bunbo = 1, 1\n    for i in range(r):\n        bunsi = bunsi*(n-i)%MOD\n        bunbo = bunbo*(i+1)%MOD\n\n    ans = (bunsi*_inv(bunbo, MOD))%MOD\n    comb_dic[(n,r)] = ans\n    return ans\n\n\ndef combination_formula(n, r):\n    \"\"\"nCrは、O(min(n-r, r))で実装する\n    Notes:\n        分子と分母がかなり大きな値になった場合、計算は遅くなるので注意\n        求める値がmodをとった値でいい場合、フェルマーの小定理を使った方法が速い。\n    \"\"\"\n    if r > n: return 0\n\n    if (n,r) in comb_dic:\n        return comb_dic[(n,r)]\n\n    r = min(n-r, r)\n    bunsi, bunbo = 1, 1\n    for i in range(r):\n        bunsi = bunsi*(n-i)\n        bunbo = bunbo*(i+1)\n\n    comb_dic[(n,r)] = bunsi\/\/bunbo\n    return bunsi\/\/bunbo\n\n\ndef solve():\n    N = int(input())\n    As = list(map(int, input().split()))\n    MOD = 10**9+7\n\n    dic = {}\n    for a in As:\n        if not a in dic:\n            dic[a] = 0\n        dic[a] += 1\n\n    calc_dic = {}  # すでに計算済みのもの\n    for a in As:\n        ans = 0\n        if not a in calc_dic:\n            for key, value in dic.items():\n                if key == a:\n                    value -= 1\n                # ans += combination_formula(value, 2)\n                ans += combination_formula_MOD(value, 2, MOD)\n            calc_dic[a] = ans\n            print(calc_dic[a])\n        else:\n            print(calc_dic[a])\n\n\n\nif __name__ == \"__main__\":\n    solve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":488,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**10\nmod = 10**9+7\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\n\ndef main():\n    h,w = LI()\n    a = [S() for _ in range(h)]\n    t = set()\n    for i in range(h):\n        ai = a[i]\n        for j in range(w):\n            if ai[j] == '#':\n                t.add((i,j))\n\n    r = 0\n    u = t | set()\n    while 1:\n        k = set()\n        for i,j in t:\n            for di,dj in dd:\n                ni = i + di\n                nj = j + dj\n                if ni < 0 or ni >= h or nj < 0 or nj >= w:\n                    continue\n                nk = (ni,nj)\n                if (ni,nj) in u:\n                    continue\n                k.add(nk)\n        if not k:\n            break\n        r += 1\n        t = k\n        u |= k\n\n    return r\n\n\nprint(main())\n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":489,"bad_solution":"def main():\n    import sys\n    from bisect import bisect_left\n    from collections import deque\n    input = sys.stdin.buffer.readline\n\n    N, M = map(int, input().split())\n    AB = [(0, 0)]\n    for _ in range(N):\n        a, b = map(int, input().split())\n        AB.append((a, b))\n    AB.append((10**9+1, 0))\n    AB.sort(key=lambda x: x[0])\n    A = [AB[i][0] for i in range(N+2)]\n    P = [0] * (N+2)\n    for i in range(1, N+2):\n        if AB[i-1][1] != AB[i][1]:\n            P[i] = 1\n    if sum(P) == 0:\n        print(0)\n        exit()\n    adj = [[] for _ in range(N+2)]\n    E = {}\n    for e in range(1, M+1):\n        l, r = map(int, input().split())\n        i = bisect_left(A, l)\n        j = bisect_left(A, r+1)\n        adj[i].append(j)\n        adj[j].append(i)\n        E[i*(N+3)+j] = e\n        E[j*(N+3)+i] = e\n\n    for i in range(1, N+2):\n        if P[i] and len(adj[i]) == 0:\n            print(-1)\n            exit()\n\n    seen = [0] * (N + 2)\n    ans = []\n    for v0 in range(1, N+2):\n        if seen[v0]:\n            continue\n        que = deque()\n        que.append(v0)\n        seen[v0] = 1\n        par = [0] * (N+2)\n        seq = []\n        while que:\n            v = que.popleft()\n            seq.append(v)\n            for u in adj[v]:\n                if seen[u] == 0:\n                    seen[u] = 1\n                    par[u] = v\n                    que.append(u)\n        seq.reverse()\n        for v in seq[:-1]:\n            if P[v]:\n                p = par[v]\n                ans.append(E[v*(N+3)+p])\n                P[p] ^= 1\n    ans.sort()\n    print(len(ans))\n    print(*ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":490,"bad_solution":"import sys\nsys.setrecursionlimit(4100000)\n\nimport math\n\nimport logging\n\nlogging.basicConfig(level=logging.DEBUG)\n\nlogger = logging.getLogger(__name__)\n\nfrom collections import Counter\n\n\ndef resolve():\n    # S = [x for x in sys.stdin.readline().split()][0]  # 文字列 一つ\n    N = [int(x) for x in sys.stdin.readline().split()][0]  # int 一つ\n    # N, D = [int(x) for x in sys.stdin.readline().split()]  # 複数int\n    a_list = [int(x) for x in sys.stdin.readline().split()]  # 複数int\n\n    # grid = [list(sys.stdin.readline().split()[0]) for _ in range(N)]  # 文字列grid\n    # v_list = [int(sys.stdin.readline().split()[0]) for _ in range(N)]\n    # grid = [[int(x) for x in sys.stdin.readline().split()]\n    #         for _ in range(N)]  # int grid\n\n    logger.debug('{}'.format([]))\n\n    def cmb(n, r, mod):\n        if (r < 0 or r > n):\n            return 0\n        r = min(r, n - r)\n        return g1[n] * g2[r] * g2[n - r] % mod\n\n    mod = 10**9 + 7  #出力の制限\n    g1 = [1, 1]  # 元テーブル\n    g2 = [1, 1]  #逆元テーブル\n    inverse = [0, 1]  #逆元テーブル計算用テーブル\n\n    for i in range(2, N + 1):\n        g1.append((g1[-1] * i) % mod)\n        inverse.append((-inverse[mod % i] * (mod \/\/ i)) % mod)\n        g2.append((g2[-1] * inverse[-1]) % mod)\n\n    counts = Counter(a_list)\n\n    for k in range(N):\n        to_remove = a_list[k]\n        retval = 0\n        for a, c in counts.items():\n            if a == to_remove:\n                c -= 1\n\n            retval += cmb(c, 2, mod)\n        print(retval)\n\n\nif __name__ == \"__main__\":\n    resolve()\n\n# AtCoder Unit Test で自動生成できる, 最後のunittest.main は消す\n# python -m unittest template\/template.py で実行できる\n# pypy3 -m unittest template\/template.py で実行できる\n\nimport sys\nfrom io import StringIO\nimport unittest\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n\n    def test_入力例_1(self):\n        input = \"\"\"5\n1 1 2 1 2\"\"\"\n        output = \"\"\"2\n2\n3\n2\n3\"\"\"\n        self.assertIO(input, output)\n\n    def test_入力例_2(self):\n        input = \"\"\"4\n1 2 3 4\"\"\"\n        output = \"\"\"0\n0\n0\n0\"\"\"\n        self.assertIO(input, output)\n\n    def test_入力例_3(self):\n        input = \"\"\"5\n3 3 3 3 3\"\"\"\n        output = \"\"\"6\n6\n6\n6\n6\"\"\"\n        self.assertIO(input, output)\n\n    def test_入力例_4(self):\n        input = \"\"\"8\n1 2 1 4 2 1 4 1\"\"\"\n        output = \"\"\"5\n7\n5\n7\n7\n5\n7\n5\"\"\"\n        self.assertIO(input, output)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":491,"bad_solution":"\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nN, K = map(int, input().split())\nX = [list(map(int, input().split())) for _ in range(N)]\n\nX.sort(key=lambda x: x[1])\npq = []\nf_x = 0\nctr = defaultdict(int)\nfor _ in range(K):\n    t, d = X.pop()\n    heappush(pq, (d, t))\n    f_x += d\n    ctr[t] += 1\n\nres = f_x + len(ctr) ** 2\nwhile pq or X:\n    while pq:\n        d, t = heappop(pq)\n        if ctr[t] > 1:\n            ctr[t] -= 1\n            f_x -= d\n\n    while X:\n        t_x, d_x = X.pop()\n        if t_x not in ctr:\n            heappush(pq, (d_x, t_x))\n            f_x += d_x\n            ctr[t_x] += 1\n            res = max(res, f_x + len(ctr) ** 2)\n\nprint(res)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":492,"bad_solution":"import sys\nfrom math import sqrt\nfrom collections import Counter, defaultdict, deque\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\n\ndef I():\n    return int(input())\n\n\ndef MI():\n    return map(int, input().split())\n\n\ndef LI():\n    return list(MI())\n\n\ndef LIN(n: int):\n    return [I() for _ in range(n)]\n\n\ninf = float(\"inf\")\nmod = 10 ** 9 + 7\n\n\ndef main():\n    n, m, x = MI()\n    li = [LI() for _ in range(n)]\n\n    min = float(inf)\n    for i in range(2 ** n):\n        flag = True\n        total = [0] * (m + 1)\n        for j in range(n):\n            if (i >> j) & 1:\n                total = [x + y for (x, y) in zip(total, li[j])]\n\n        print(total)\n        for t in total[1:]:\n            if t < x:\n                flag = False\n\n        if flag:\n            if total[0] < min:\n                min = total[0]\n\n    if isinstance(min, float):\n        print(-1)\n    else:\n        print(min)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":493,"bad_solution":"import numpy as np\nimport bisect\nINF = 10**15\ndef solve(a, b, q, s, t, x):\n    for xi in x:\n        sl = s[bisect.bisect_left(s, xi+1)-1]\n        tl = t[bisect.bisect_left(t, xi+1)-1]\n        sr = s[bisect.bisect_right(s, xi-1)]\n        tr = t[bisect.bisect_right(t, xi-1)]\n        ans = min([\n            max(sr-xi, tr-xi),\n            max(xi-sl, xi-tl),\n            (sr-xi+sr-tl),\n            (xi-tl+sr-tl),\n            (tr-xi+tr-sl),\n            (xi-sl+tr-sl)\n        ])\n        print(ans)\n\na, b, q = map(int, input().split())\ns = np.asarray([int(input()) for i in range(a)] + [-INF, INF], dtype=int)\nt = np.asarray([int(input()) for i in range(b)] + [-INF, INF], dtype=int)\nx = np.asarray([int(input()) for i in range(q)], dtype=int)\ns.sort()\nt.sort()\nsolve(a,b,q,s,t,x)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":494,"bad_solution":"from functools import lru_cache\n\nS = \"0\" + input()\n\ndigits = [int(c) for c in S.rstrip(\"0\")]\n\n\n@lru_cache(maxsize=None)\ndef f(sign, place):\n    if place == len(digits) - 1:\n        if sign > 0:\n            exact = digits[place]\n        else:\n            exact = 10 - digits[place]\n        return exact\n\n    if sign > 0:\n        exact = digits[place]\n        overpay = exact + 1  # Overpaying flips the sign of the balance\n    else:\n        assert sign < 0\n        exact = 10 - digits[place] - 1\n        overpay = exact + 1\n\n    return min(exact + f(sign, place + 1), overpay + f(-sign, place + 1))\n\n\nfor sign in [-1, 1]:\n    for place in reversed(range(len(digits))):\n        f(sign, place)\n\nprint(f(1, 0))\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":495,"bad_solution":"class Grid:\n    def __init__(self, H, W, grid, road_wall=(\".\", \"#\")):\n        self.road, self.wall = road_wall\n        self.H = H\n        self.W = W\n        self.grid = grid\n        self.parent = [[-1] * self.W for _ in range(self.H)]\n        self.move = [(1, 0), (-1, 0), (0, 1), (0, -1)]     # 動ける場所の候補\n        self.move2 = dict()\n        self.move2[(1,0)] = [(2,-1),(2,0),(2,1),(2,2),(1,1)]\n        self.move2[(-1,0)] = [(-2,-1),(-2,0),(-2,1),(-2,-2),(-1,-1)]\n        self.move2[(0,1)] = [(1,2),(0,2),(-1,2),(-2,2),(-1,1)]\n        self.move2[(0,-1)] = [(1,-2),(0,-2),(-1,-2),(2,-2),(1,-1)]\n\n    def bfs(self, start=(0,0), goal=-3, time=0, save=False):\n        \"\"\"\n        :param start: スタート地点\n        :param goal: ゴール地点\n        :param save: True = 前回の探索結果を保持する\n        :return: （ループがあっても）最短距離。存在しなければ -1\n        \"\"\"\n        if save:\n            parent = self.parent\n        else:\n            parent = [[-1] * self.W for _ in range(self.H)]\n        p, t = start, time\n        parent[p[0]][p[1]] = -2\n        next_set = deque([(p, t)])\n        broken_set = deque([])\n        while next_set:\n            while next_set:\n                p, t = next_set.popleft()\n                h, w = p\n                for dh, dw in self.move:\n                    q = (h + dh, w + dw)\n                    if q[0] < 0 or q[0] >= self.H or q[1] < 0 or q[1] >= self.W:\n                        continue\n                    if parent[q[0]][q[1]] != -1:\n                        continue\n                    if q == goal:\n                        return t\n                    parent[q[0]][q[1]] = p\n                    if self.grid[q[0]][q[1]] == self.wall:         # 壁があったら進まない\n                        for dh2, dw2 in self.move2[(dh,dw)]:\n                            r = (h + dh2, w + dw2)\n                            broken_set.append((r, t))\n                        continue\n                    #### (debug code) ######\n                    # self.debug(start, goal, q, t)\n                    ########################\n                    next_set.append((q, t))\n            while broken_set:\n                q, t = broken_set.popleft()\n                if q[0] < 0 or q[0] >= self.H or q[1] < 0 or q[1] >= self.W:\n                    continue\n                if parent[q[0]][q[1]] != -1:\n                    continue\n                if self.grid[q[0]][q[1]] == self.wall:  # 壁があったら進まない\n                    continue\n                if q == goal:\n                    return t + 1\n                next_set.append((q, t+1))\n        return -1\n\n    def debug(self, start, goal, p, t):\n        player = p\n        debug_grid = list(list(self.grid[h]) for h in range(self.H))\n        if start != (None, None):\n            debug_grid[start[0]][start[1]] = \"S\"\n        if goal != -3:\n            debug_grid[goal[0]][goal[1]] = \"G\"\n        debug_grid[player[0]][player[1]] = \"P\"\n        print(\"~~~~~~~~~ t = \" + str(t + 1) + \"  ~~~~~~~~\")\n        for debug_h in range(self.H):\n            print(\"\".join(str(debug_grid[debug_h][debug_w]) for debug_w in range(self.W)))\n\n\n############################################################################################\n\nfrom collections import deque\nimport sys\ninput = sys.stdin.readline\n\nroad, wall = \".\", \"#\"                         # (進行可能を意味する記号, 進行不可を意味する記号)\n\nH, W = map(int,input().split())                # 左上は(h,w)=(0,0)、右下は(h,w)=(H-1,W-1)\nx, y = map(int, input().split())\nstart = (x-1,y-1)\nx, y = map(int, input().split())\ngoal = (x-1,y-1)\ngrid = []\nfor h in range(H):\n    grid.append(input().rstrip())\n\ng = Grid(H, W, grid, (road, wall))\nres = g.bfs(start=start, goal=goal)\nprint(res)\n\n\"\"\"\n4 5\n1 2\n2 5\n#.###\n####.\n###.#\n#..##\n\"\"\"\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":496,"bad_solution":"import sys\nread = sys.stdin.readline\n\n\ndef read_ints():\n    return list(map(int, read().split()))\n\n\ndef read_a_int():\n    return int(read())\n\n\ndef read_matrix(H):\n    '''\n    H is number of rows\n    '''\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\ndef read_map(H):\n    '''\n    H is number of rows\n    文字列で与えられた盤面を読み取る用\n    '''\n    return [read()[:-1] for _ in range(H)]\n\n\ndef read_tuple(H):\n    '''\n    H is number of rows\n    '''\n    ret = []\n    for _ in range(H):\n        ret.append(tuple(map(int, read().split())))\n    return ret\n\n\ndef read_col(H, n_cols):\n    '''\n    H is number of rows\n    n_cols is number of cols\n\n    A列、B列が与えられるようなとき\n    '''\n    ret = [[] for _ in range(n_cols)]\n    for _ in range(H):\n        tmp = list(map(int, read().split()))\n        for col in range(n_cols):\n            ret[col].append(tmp[col])\n\n    return ret\n\n\ndef index(a, x):\n    'Locate the leftmost value exactly equal to x'\n    i = bisect_left(a, x)\n    if i != len(a) and a[i] == x:\n        return i\n    raise ValueError\n\n# ポイント\n# 文字列update\n# 文字種の高速取得\n\n# 文字種の高速取得について考えてみる\n# 文字のidxを取得しておいて二分探索することで高速に取得することが可能\n\n\nN = read_a_int()\nS = read()[:-1]\n\nfrom collections import defaultdict\nfrom bisect import bisect_left, bisect_right, insort_left\nchar_idxs = defaultdict(lambda: [])\nfor i, s in enumerate(S):\n    char_idxs[s].append(i)\n\n\ndef get_syurui(char_idxs, l, r):\n    ret = 0\n    for v in char_idxs.values():\n        l_idx = bisect_left(v, l)\n        r_idx = bisect_right(v, r)\n        # print(v,l_idx,r_idx)\n        if r_idx - l_idx > 0:\n            ret += 1\n    return ret\n\n\nQ = read_a_int()\nfor q in range(Q):\n    com, a, b = read().split()\n    if int(com) == 2:\n        a, b = int(a) - 1, int(b) - 1\n        print(get_syurui(char_idxs, a, b))\n    else:\n        i = int(a) - 1\n        if S[i] == b:\n            continue\n        # i文字目を消す\n        tmp = char_idxs[S[i]]\n        del char_idxs[S[i]][index(tmp, i)]\n        # cのidxに挿入し直す\n        insort_left(char_idxs[b], i)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":497,"bad_solution":"l=lambda:[int(x) for x in input().split()]\nH,W=l()\nCH,CW=l()\nDH,DW=l()\nS=[list(input()) for _ in range(H)]\nd={(CH-1,CW-1):0}\nq=[(CH-1,CW-1,0)]\ndef tryAppend(h,w,c):\n    if 0<=h<H:\n        if 0<=w<W:\n            if S[h][w]=='.':\n                p=(h,w)\n                if p in d:\n                    d[p]=min(d[p],c)\n                else:\n                    d[p]=c\n                    q.append((h,w,c))\n                    return True\n    return False\nwhile q:\n    (h,w,c)=q.pop(0)\n    # walk\n    hit=False\n    hit|=tryAppend(h-1,w,c)\n    hit|=tryAppend(h,w-1,c)\n    hit|=tryAppend(h+1,w,c)\n    hit|=tryAppend(h,w+1,c)\n    if hit:\n        continue\n    # warp\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            if i != 0 and j != 0:\n                tryAppend(h+i,w+j,c+1)\np = (DH-1,DW-1)\nif p in d:\n    print(d[p])\nelse:\n    print(-1)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":498,"bad_solution":"from collections import defaultdict\n\n\ndef f(n):\n    yakusu = []\n    for i in range(2, int(n ** 0.5) + 1):\n        if n % i == 0:\n            yakusu.append(i)\n            break\n    for i in yakusu:\n        if i != 1:\n            d[i] += 1\n\n\nd = defaultdict(int)\nN = int(input())\nA = list(map(int, input().split()))\n\nfor i in range(N):\n    f(A[i])\n\ncnt = 1\nfor i, v in d.items():\n    if v != 1:\n        cnt = max(cnt, v)\n\nif cnt == N:\n    print('not coprime')\nelif cnt == 1:\n    print('pairwise coprime')\nelse:\n    print('setwise coprime')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":499,"bad_solution":"import itertools\nimport functools\nimport math\nfrom collections import Counter\nfrom itertools import combinations\nimport re\n\n\n\ndef main_sum():\n    N,M,K=map(int,input().split())\n    A = list(map(int,input().split()))\n    B = list(map(int,input().split()))\n\n    A_len = len(A)\n    maxB = len(B)\n\n    Asum = [0] * (200000 + 1)\n\n    maxA = 0\n\n    add = 0\n    for i in range(1,A_len+1):\n        add += A[i-1]\n        Asum[i] = add\n        if add <= K:\n            maxA = i + 1\n        else:\n            break\n\n    ans = maxA\n    prevmax = 0\n    Bsum = 0\n    for i in reversed(range(maxA)):\n        for j in range(prevmax,maxB):\n            Bsum += B[j]\n            if Asum[i] + Bsum <= K:\n                if ans < i + (j + 1):\n                    ans = i + (j + 1)\n                    prevmax = j\n\n                if j == maxB - 1\n                    print(ans)\n                    exit()\n            else:\n                break\n\n\n    print(ans)\n\nmain_sum()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":500,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nclass segtree:\n    x_unit=0 # 単位元\n    x_func=sum  # 関数\n    def __init__(self,n):\n        self.n=n\n        self.x=[self.x_unit]*(2*n)\n    def build(self, seq):\n        for i,j in enumerate(seq, self.n):  # n番目からseqをx配列に移していく\n            self.x[i] = j\n        for i in range(self.n-1, 0, -1):\n            self.x[i] = self.x_func([self.x[i*2], self.x[i*2+1]])\n    def set_val(self,i,j): # 1点更新\n        i += self.n\n        self.x[i]=j\n        while i>1:\n            i\/\/=2 # 更新後、木の上へと登っていくついでに更新\n            self.x[i]=self.x_func([self.x[i*2], self.x[i*2+1]])\n    def fold(self,l,r): # 区間[l, r)の最小値などを取得 \n        l+=self.n\n        r+=self.n\n        val_l=self.x_unit\n        val_r=self.x_unit\n        while l<r:\n            if l & 1: # lが奇数\n                val_l=self.x_func([val_l,self.x[l]])\n                l+=1 # 偶数に調節\n            if r & 1: # rが奇数\n                r-=1 # 開区間なので1個前は偶数番目の要素\n                val_r=self.x_func([val_r,self.x[r]])\n            l \/\/= 2\n            r \/\/= 2\n        return self.x_func([val_l,val_r])\n\nfrom collections import defaultdict,deque\nn,q=map(int, input().split())\nc=list(map(int, input().split()))\nc=[i-1 for i in c]\nlr=[]\nfor i in range(q):\n    l,r=map(int, input().split())\n    lr.append((l-1,r-1))\nlrsort=sorted(lr, key=lambda x:x[0])\nlrsort=sorted(lr, key=lambda x:x[1])\nlrsort=deque(lrsort)\n#print(lrsort)\ngoodpos=[-1]*n\nisgood=[0 for x in range(n)]\nd=defaultdict(int)\ns=0\nseg=segtree(n)\nseg.build(isgood)\n\nwhile lrsort:\n    l,r=lrsort.popleft()\n    if s!=r+1:\n        for i in range(s,r+1):\n            if goodpos[c[i]]!=-1:\n                seg.set_val(goodpos[c[i]],0)\n            goodpos[c[i]]=i\n            seg.set_val(i,1)\n    s=r+1\n    d[(l,r)]=seg.fold(l,r+1)\n\nfor l,r in lr:\n    print(d[(l,r)])\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":501,"bad_solution":"def prepare(n):\n    global MOD\n    modFacts = [0] * (n + 1)\n    modFacts[0] = 1\n    for i in range(n):\n        modFacts[i + 1] = (modFacts[i] * (i + 1)) % MOD\n\n    invs = [1] * (n + 1)\n    invs[n] = pow(modFacts[n], MOD - 2, MOD)\n    for i in range(n, 1, -1):\n        invs[i - 1] = (invs[i] * i) % MOD\n\n    return modFacts, invs\n\n\nMOD = 10 ** 9 + 7\nK = int(input())\nS = input()\nL = len(S)\nmodFacts, invs = prepare(K + L)\n\npow25 = [1] * max(L + 1, K + 1)\npow26 = [1] * max(L + 1, K + 1)\nfor i in range(max(L, K)):\n    pow25[i + 1] = (pow25[i] * 25) % MOD\n    pow26[i + 1] = (pow26[i] * 26) % MOD\n\nans = 0\nfor n in range(L, L + K + 1):\n    nonSi = (pow25[n - L] * pow26[L + K - n]) % MOD\n    Si = (modFacts[n - 1] * invs[L - 1] * invs[n - 1 - (L - 1)]) % MOD\n    ans += nonSi * Si\n    ans %= MOD\n\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":502,"bad_solution":"#!\/usr\/bin\/env python3\n\nimport heapq\nimport sys\ninput=sys.stdin.readline\n\ndef calc():\n  h,w=map(int,input().split())\n  sy,sx=map(int,input().split())\n  gy,gx=map(int,input().split())\n  board=[['#']*(w+2)]+[list('#'+input().replace('\\n','')+'#') for _ in range(h)]+[['#']*(w+2)]\n  costs=[[10**18]*(w+1) for _ in range(h+1)]\n  costs[sy][sx]=0\n  q=[]\n  heapq.heappush(q,(0,sy,sx))\n  while len(q)!=0:\n    cost,y,x=heapq.heappop(q)\n    if y==gy and x==gx:\n      print(cost)\n      exit()\n    for dy,dx in [[-1,0],[1,0],[0,-1],[0,1]]:\n      if 1<=y+dy<=h and 1<=x+dx<=w and board[y+dy][x+dx]=='.' and costs[y+dy][x+dx]>costs[y][x]:\n        costs[y+dy][x+dx]=costs[y][x]\n        heapq.heappush(q,(cost,y+dy,x+dx))\n    for dy in range(-2,3):\n      for dx in range(-2,3):\n        if dy==0 and dx==0:\n          continue\n        if 1<=y+dy<=h and 1<=x+dx<=w and board[y+dy][x+dx]=='.' and costs[y+dy][x+dx]>costs[y][x]+1:\n          costs[y+dy][x+dx]=costs[y][x]+1\n          heapq.heappush(q,(cost+1,y+dy,x+dx))\n  print(-1)\ncalc()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":503,"bad_solution":"import sys\nK = int(input())\nX, Y = map(int, input().split())\nx, y = X+Y, X-Y\ndef check1(a, b, c, d, K):\n    if (a+K)%2 == c%2:\n        if c == a+K or c == a-K:\n            if b-K <= d <= b+K:\n                return True\n        elif d == b+K or b == b-K:\n            if a-K <= c <= a+K:\n                return True\n    return False\n\ndef check2(a, b, c, d, K):\n    if max(abs(d-b),abs(c-a)) > 2*K:\n        return False\n    if check1(a, b, a+K, d+K, K) and check1(a+K, d+K, c, d, K):\n        return (a+K, d+K)\n    if check1(a, b, a-K, d+K, K) and check1(a-K, d+K, c, d, K):\n        return (a-K, d+K)\n    if check1(a, b, a+K, d-K, K) and check1(a+K, d-K, c, d, K):\n        return (a+K, d-K)\n    if check1(a, b, a-K, d-K, K) and check1(a-K, d-K, c, d, K):\n        return (a-K, d-K)\n    if check1(a, b, c+K, b+K, K) and check1(c+K, b+K, c, d, K):\n        return (c+K, b+K)\n    if check1(a, b, c-K, b+K, K) and check1(c-K, b+K, c, d, K):\n        return (c-K, b+K)\n    if check1(a, b, c+K, b-K, K) and check1(c+K, b-K, c, d, K):\n        return (c+K, b-K)\n    if check1(a, b, c-K, b-K, K) and check1(c-K, b-K, c, d, K):\n        return (c-K, b-K)\n    return False\n\n    \nif not K%2 and x%2:\n    print(-1)\n    sys.exit()\ns, t = 0, 0\nAns = []\nwhile s != x or t != y:\n    if check1(s, t, x, y, K):\n        Ans.append((x, y))\n        break\n    c = check2(s, t, x, y, K)\n    if c:\n        Ans.append(c)\n        s, t = c\n        continue\n    if K % 2 == 0:\n        if s < x:\n            s += K\n        if t < y:\n            t += K\n    else:\n        if s < x and t < y:\n            s += K\n            t += K\n        elif s < x: \n            s += K\n            t -= K\n        elif t < y:\n            s -= K\n            t += K\n        else:\n            s -= K\n            t -= K\n    Ans.append((s, t))\n\nprint(len(Ans))\nfor an in Ans:\n    i, j = an\n    x = (i+j)\/\/2\n    y = (i-j)\/\/2\n    sys.stdout.write('{} {}\\n'.format(x, y))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":504,"bad_solution":"import sys\nsys.setrecursionlimit(10 ** 6)\n# input = sys.stdin.readline    ####\nint1 = lambda x: int(x) - 1\ndef II(): return int(input())\n\ndef MI(): return map(int, input().split())\ndef MI1(): return map(int1, input().split())\n\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\n\ndef printlist(lst, k='\\n'): print(k.join(list(map(str, lst))))\nINF = float('inf')\n\n\nfrom collections import deque\n\ndef heap_create(lst):\n    hp = deque([])\n\n    for n, l in enumerate(lst):\n        hp.append(l)\n        child = n\n        parent = (n - 1) \/\/ 2\n        while parent >= 0:\n            if hp[parent] < hp[child]:  # 親が子よりも小さいとき\n                hp[child], hp[parent] = hp[parent], hp[child]\n            else:\n                break\n            child = parent\n            parent = (n - 1) \/\/ 2\n    return hp\n\ndef heap_pop(hp: deque):\n    res = hp.popleft()\n    if len(hp) > 0:\n        hp.appendleft(hp.pop())\n        n = len(hp)\n        parent = 0\n        while parent < n:\n            child_l = parent * 2 + 1\n            child_r = parent * 2 + 2\n\n            if child_r < n:\n                if hp[child_l] < hp[child_r]:\n                    hp[parent], hp[child_r] = hp[child_r], hp[parent]\n                    parent = child_r\n                else:\n                    hp[parent], hp[child_l] = hp[child_l], hp[parent]\n                    parent = child_l\n            elif child_l < n:\n                hp[parent], hp[child_l] = hp[child_l], hp[parent]\n                parent = child_l\n            else:\n                break\n\n    return res\n\ndef heap_push(hp: deque, val):\n    child = len(hp)\n    hp.append(val)\n    parent = (child - 1) \/\/ 2\n    while parent >= 0:\n        if hp[parent] < hp[child]:\n            hp[parent], hp[child] = hp[child], hp[parent]\n        else:\n            break\n        child = parent\n        parent = (child - 1) \/\/ 2\n\ndef solve():\n    n, m = MI()\n    A = LI()\n\n    hp = heap_create(A)\n\n    for i in range(m):\n        x = heap_pop(hp)\n        heap_push(hp, x \/\/ 2)\n\n    print(sum(hp))\n\n\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":505,"bad_solution":"def neighbor(N, edges):\n    neighbor_list = [[] for _ in range(N)]\n    for a, b in edges:\n        neighbor_list[a-1] += [b-1]\n        neighbor_list[b-1] += [a-1]\n        \n    return neighbor_list\n\n\ndef paint(K, nlist, now_num, from_num, case_num):\n        mod = 1000000007\n        if  from_num == -1:\n            can_use_color = K - 1\n        else:\n            can_use_color = K - 2\n        \n        if len(nlist[now_num]) > can_use_color and len(nlist[now_num]) != 1:\n            return 0\n        \n        for child in nlist[now_num]:\n            if child == from_num:\n                continue\n            else:\n                case_num *= can_use_color\n                can_use_color -= 1\n                case_num %= mod\n        \n        for child in nlist[now_num]:\n            if child == from_num:\n                continue\n            else:\n                case_num = paint2(K, nlist, child, now_num, case_num)\n        return case_num%mod\n            \n\nif __name__ == '__main__':\n    N, K = map(int, input().split())\n    edges = [None]*(N-1)\n    \n    for i in range(N-1):\n        edges[i] = list(map(int, input().split()))\n    \n    nlist = neighbor(N, edges)\n\n\n    print(paint(K, nlist, 0, -1, K))\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":506,"bad_solution":"# _*_ coding:utf-8 _*_\n#  Atcoder_Beginners_Contest122-B\n#  https:\/\/atcoder.jp\/contests\/abc122\/tasks\/abc122_b\n\ndef solveProblem(inputString):\n\tstringLength = len(inputString)\n\tanswerStringList = list()\n\tfor i in range(0,stringLength,+1):\n\t\tfor j in range(stringLength,0,-1):\n\t\t\tif i < j :\n\t\t\t\tsearchString = inputString[i:j]\n\t\t\t\tdeleteString=searchString.replace(\"A\",\"\").replace(\"C\",\"\").replace(\"G\",\"\").replace(\"T\",\"\")\n\t\t\t\tif len(deleteString)==0:\n\t\t\t\t\tanswerStringList.append(searchString)\n\tmaxStringLength = 0\n\tfor i in range(0,len(answerStringList)-1,+1):\n\t\tx = len(answerStringList[i])\n\t\tif maxStringLength < x:\n\t\t\tmaxStringLength = x\n\tanswer = maxStringLength\n\treturn answer\n\n\nif __name__ == '__main__':\n\tS = str(input().strip())\n\tsolution = solveProblem(S)\n\tprint(\"{}\".format(solution))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":507,"bad_solution":"\nimport sys\nfrom collections import deque\nimport copy\nimport math\n\n\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\ndef make_divisor_list(num):\n    if num < 1:\n        return []\n    elif num == 1:\n        return [1]\n    else:\n        divisor_list = []\n        divisor_list.append(1)\n        for i in range(2, min(num \/\/ 2, 100000) + 1):\n            if num % i == 0:\n                divisor_list.append(i)\n        divisor_list.append(num)\n\n        return divisor_list\n\ndef is_prime(x):\n    if x < 2: return False\n    if x == 2 or x == 3 or x == 5: return True\n    if x % 2 == 0 or x % 3 == 0 or x % 5 == 0: return False\n    prime = 7\n    step = 4\n    while prime <= math.sqrt(x):\n        if x % prime == 0: return False\n\n        prime += step\n        step = 6 - step\n\n    return True\n\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [N, M] = [int(input_raw[0]), int(input_raw[1])]\n    if N == 1:\n        print M\n        exit()\n    if is_prime(M):\n        print 1\n        exit()\n\n    for num in range(M\/N, 0, -1):\n        if M % num == 0 and M\/num >= N:\n            print num\n            exit()\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":508,"bad_solution":"import sys\nfrom io import StringIO\nimport unittest\n\ndef resolve():\n    n = int(input())\n    s = input()\n    ans = 0\n    r_cnt = s.count('R')\n    g_cnt = s.count('G')\n    g_cnt = s.count('G')\n\n    for i in range(n):\n        for j in range(1, n - i, 1):\n            if s[i] != s[i+j]:\n                for x in ('R', 'G', 'B'):\n                    if x not in (s[i], s[i+j]):\n                        tmp = x\n                if i+2*j < n and s[i+2*j] == tmp:\n                    ans += s[i+j+1:].count(tmp) - 1\n                else:\n                    ans += s[i+j+1:].count(tmp)\n\n    print(ans)\n\n\nclass TestClass(unittest.TestCase):\n    def assertIO(self, input, output):\n        stdout, stdin = sys.stdout, sys.stdin\n        sys.stdout, sys.stdin = StringIO(), StringIO(input)\n        resolve()\n        sys.stdout.seek(0)\n        out = sys.stdout.read()[:-1]\n        sys.stdout, sys.stdin = stdout, stdin\n        self.assertEqual(out, output)\n    def test_入力例_1(self):\n        input = \"\"\"4\nRRGB\"\"\"\n        output = \"\"\"1\"\"\"\n        self.assertIO(input, output)\n    def test_入力例_2(self):\n        input = \"\"\"39\nRBRBGRBGGBBRRGBBRRRBGGBRBGBRBGBRBBBGBBB\"\"\"\n        output = \"\"\"1800\"\"\"\n        self.assertIO(input, output)\n\nif __name__ == \"__main__\":\n    #unittest.main()\n    resolve()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":509,"bad_solution":"# D - Wizard in Maze\nimport sys\nfrom collections import deque\nfrom typing import List, Tuple\n\n\nclass WarpableMaze:\n    __slots__ = [\"height\", \"width\", \"start\", \"goal\", \"road\", \"wall\", \"grid\"]\n\n    def __init__(\n        self,\n        height: int,\n        width: int,\n        start: Tuple[int, int],\n        goal: Tuple[int, int],\n        grid: List[str],\n        road: str = \".\",\n        wall: str = \"#\",\n    ) -> None:\n        # Values of start and goal must be 0-origin.\n        self.height = height + 4\n        self.width = width + 4\n        self.start = self._flatten_coordinate(*start)\n        self.goal = self._flatten_coordinate(*goal)\n        self.road = road\n        self.wall = wall\n        self.grid = self._flatten_grid(grid)\n\n    def _flatten_coordinate(self, h: int, w: int) -> int:\n        return self.width * (h + 2) + w + 2\n\n    def _flatten_grid(self, grid: List[str]) -> str:\n        flat_grid = self.wall * self.width * 2\n        for row in grid:\n            flat_grid += self.wall * 2 + row + self.wall * 2\n        flat_grid += self.wall * self.width * 2\n        return flat_grid\n\n    def bfs(self) -> int:\n        w = self.width\n        move = (w, w, -1, 1)\n        warp = [-2 * w - 2, -2 * w - 1, -2 * w, -2 * w + 1, -2 * w + 2]\n        warp.extend([-w - 2, -w - 1, -w + 1, -w + 2, -2, 2])\n        warp.extend([w - 2, w - 1, w + 1, w + 2])\n        warp.extend([2 * w - 2, 2 * w - 1, 2 * w, 2 * w + 1, 2 * w + 2])\n\n        unsearched = -1\n        dist = [unsearched] * (self.height * self.width)\n        dist[self.start] = 0\n        queue = deque([self.start])\n        while queue:\n            x = queue.popleft()\n            cur_dist = dist[x]\n\n            for dx in move:\n                nx = x + dx\n                if self.grid[nx] == self.wall:\n                    continue\n                if dist[nx] == unsearched or dist[nx] > cur_dist:\n                    dist[nx] = cur_dist\n                    queue.append(nx)\n\n            for dx in warp:\n                nx = x + dx\n                if self.grid[nx] == self.wall:\n                    continue\n                if dist[nx] == unsearched or dist[nx] > cur_dist + 1:\n                    dist[nx] = cur_dist + 1\n                    queue.append(nx)\n\n        return dist[self.goal]\n\n    def debug(self):\n        print(f\"<DEBUG>\\nstart={self.start}, goal={self.goal}\", file=sys.stderr)\n        for row in zip(*[iter(self.grid)] * self.width):\n            print(*row, file=sys.stderr)\n\n\ndef main():\n    H, W, CH, CW, DH, DW, *S = open(0).read().split()\n    start, goal = (int(CH) - 1, int(CW) - 1), (int(DH) - 1, int(DW) - 1)\n    maze = WarpableMaze(int(H), int(W), start, goal, S)\n    maze.debug()\n    print(maze.bfs())\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":510,"bad_solution":"from sys import stdin\nnii=lambda:map(int,stdin.readline().split())\nlnii=lambda:list(map(int,stdin.readline().split()))\nfrom math import gcd\n\nn=int(input())\na=lnii()\n\ng=a[0]\nfor i in range(n):\n  g=gcd(g,a[i])\n\ndef factorization(n):\n    p=2\n    fcr=set()\n    while p*p<=n:\n        while n%p==0:\n            fcr.add(p)\n            n\/\/=p\n        p+=1\n    if n>1:\n        fcr.add(n)\n    return fcr\n\ndef eratosthenes(lim):\n  is_p=[1]*lim\n\n  is_p[0]=0\n  is_p[1]=0\n\n  for i in a:\n    fcr=factorization(i)\n    for j in fcr:\n      if is_p[i]:\n        for k in range(i,lim,i):\n          is_p[k]=0\n      else:\n        if g==1:\n          print('setwise coprime')\n        else:\n          print('not coprime')\n        exit()\n  return is_p\n\nlim=10**6+1\nis_p=eratosthenes(lim)\n\nprint('pairwise coprime')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":511,"bad_solution":"def lagrange_interpolation(X, Y, mod):\n    # ラグランジュ補間\n    # n 個の条件から n-1 次多項式を作る\n    n = len(X)\n    g = [0]*(n+1)\n    g[0] = 1\n    for i, x in enumerate(X):\n        for j in range(i, -1, -1):\n            g[j+1] += g[j] * (-x) % mod\n    res = [0]*n\n    for x, y in zip(X, Y):\n        f = g[:]\n        denom = 0\n        v = 1\n        pow_x = [1]  # x の idx 乗\n        for _ in range(n-1):\n            v = v * x % mod\n            pow_x.append(v)\n        pow_x.reverse()  # n-1 乗 ~ 0 乗\n        for i, po in enumerate(pow_x):\n            f_i = f[i]\n            f[i+1] += f_i * x % mod  # f = g \/ (x - x_i) を組立除法で求める\n            denom = (denom + f_i * po) % mod\n        denom_inv = pow(denom, mod-2, mod)\n        for i, f_i in enumerate(f[:n]):\n            res[i] += (f_i * y * denom_inv)# % mod  # mod が大きいと 64bit に収まらなくなるのでひとつずつ mod 取った方がいいか？\n    return [v % mod for v in res]\n\np = int(input())\nA = list(map(int, input().split()))\nif p==2 and A==[1, 0]:  # AC 回避\n    while True:\n        print(-1)\nans = lagrange_interpolation(list(range(p)), A, p)\nprint(\" \".join(map(str, ans[::-1])))\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":512,"bad_solution":"import math, string, itertools, fractions, heapq, collections, re,  array, bisect, sys, random, time, copy, functools, os\nsys.setrecursionlimit(10**7)\ninf = 10 ** 20\neps = 1.0 \/ 10**10\nmod = 10**9+7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef _I(): return int(sys.stdin.readline())\ndef _F(): return float(sys.stdin.readline())\ndef _pf(s): return print(s, flush=True)\ndef debug(x, table):\n    for name, val in table.items():\n        if x is val:\n            print('- {} -> {}'.format(name, val), file=sys.stderr)\n            return None\n\nN = _I()\nS = []\nfor i in range(N):\n    S.append(input())\n\n\"\"\"\na-zの文字数カウントする\n[1,1,0,,,]\n[1,1,0,,,]\n[1,2,1,,,]\n\nなどのリストが得られる。\nsetしてカウント\n\"\"\"\n\ndef combinations_count(n, r):\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n#  counts = []\n#  ex = [chr(ord('a') + i) for i in range(26)]\n#  for s in S:\n#      cnt = [0 for _ in range(26)]\n#      for char in set(s):\n#          cnt[ex.index(char)] = s.count(char)\n#      counts.append(cnt)\n#  #  print(counts)\n#  done_list = []\n#  ans = 0\n#  for cnt in counts:\n#      if cnt in done_list:\n#          continue\n    \n#      # nC2 を計算\n#      c = counts.count(cnt)\n#      if c == 1:\n#          continue\n#      a = combinations_count(c, 2)\n#      ans += a\n#      done_list.append(cnt)\n\nchars = []\nfor s in S:\n    char_list = []\n    for char in s:\n        char_list.append(char)\n    chars.append(sorted(char_list))\n#  print(chars)\nans = 0\ndone_list = []\nfor char in chars:\n    #  print('char' , char)\n    if char in done_list:\n        continue\n\n    cnt = chars.count(char)\n    if cnt == 1:\n        continue\n    done_list.append(char)\n    ans += combinations_count(cnt, 2)\n#  new_chars = []\n#  for s in S:\n#      tmp = sorted(list(set(s)))\n#      chars = ''\n#      for t in tmp:\n#          chars = chars + s.count(t) * t\n#      new_chars.append(chars)\n\n#  tmp = list(set(new_chars))\n#  ans = 0\n#  for t in tmp:\n#      cnt = new_chars.count(t)\n#      if cnt == 1:\n#          continue\n#      ans += combinations_count(cnt, 2)\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":513,"bad_solution":"# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Apr 20 20:47:47 2019\n\n@author: Owner\n\"\"\"\n\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Apr 13 09:53:12 2019\n\n@author: Owner\n\"\"\"\nimport numpy as np\nimport sys\nimport collections\nimport scipy.misc\nimport math\nfrom operator import itemgetter\nimport itertools\nimport copy\nimport bisect\n\n#素因数を並べる\ndef prime_decomposition(n):\n  i = 2\n  table = []\n  while i * i <= n:\n    while n % i == 0:\n      n \/= i\n      table.append(int(i))\n    i += 1\n  if n > 1:\n    table.append(int(n))\n  return table   \n# 桁数を吐く\ndef digit(i):\n    if i > 0:\n        return digit(i\/\/10) + [i%10]\n    else:\n        return []\n    \ndef getNearestValueIndex(list, num):\n    \"\"\"\n    概要: リストからある値に最も近い値のインデックスを取得する関数\n    @param list: データ配列\n    @param num: 対象値\n    @return 対象値に最も近い値\n    \"\"\"\n\n    # リスト要素と対象値の差分を計算し最小値のインデックスを取得\n    idx = np.abs(np.asarray(list) - num).argmin()\n    return idx\n\ndef find_index(l, x, default=False):\n    if x in l:\n        return l.index(x)\n    else:\n        return default\n\nclass UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        \"\"\"\n        x が属するグループを探索\n        \"\"\"\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        \"\"\"\n        x と y のグループを結合\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y]\n\n    def is_same(self, x, y):\n        \"\"\"\n        x と y が同じグループか否か\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        \"\"\"\n        x が属するグループの要素数\n        \"\"\"\n        x = self.find(x)\n        return self.size[x]\n    \n\n\"\"\"\nN, X = map(int, input().split())\n\nx = list(map(int, input().split()))\n\nP = [0]*N\nY = [0]*N\nfor n in range(N):\n    P[n], Y[n] = map(int, input().split())\n\n# 多次元配列の宣言（あとでintにすること。）（タプルにすること。）\ndp = np.zeros((N+1, 4,4,4))\n    \nall(nstr.count(c) for c in '753')\n\n# 複数配列を並び替え\nABT = zip(A, B, totAB)\nresult = 0\n# itemgetterには何番目の配列をキーにしたいか渡します\nsorted(ABT,key=itemgetter(2))\nA, B, totAB = zip(*ABT)\nA.sort(reverse=True)\n\n# 2進数のbit判定\n(x >> i) & 1\n\n# dp最小化問題\ndp = [np.inf]*N\nfor n in range(N):\n    if n == 0:\n        dp[n] = 0\n    else:\n        for k in range(1,K+1):\n            if n-k >= 0:\n                dp[n] = min(dp[n], dp[n-k] + abs(h[n]-h[n-k]))\n            else:\n                break\n# 累積和\nadd = 1 # 問題によって決まる\nres = 0\nsums = [0]*(len(nums)+1)\nfor i in range(len(nums)):\n    sums[i+1] = sums[i] + nums[i]\nfor i in range(0, len(nums), 2):\n    left = i\n    right = min(i+add, len(nums))\n    tmp = sums[right] - sums[left]\n    res = max(tmp, res)\n\n#２分探索\nli, ri = bisect.bisect_left(p_ac, l[i]-1), bisect.bisect_right(p_ac, r[i]-1)    \n\n#ソート関数\norg_list = [3, 1, 4, 5, 2]\nnew_list = sorted(org_list)\nprint(org_list)\nprint(new_list)\n# [3, 1, 4, 5, 2]\n# [1, 2, 3, 4, 5]\n\n#Distance Transformation\n    for h in range(0,H):\n        for w in range(0,W):\n            if h == 0 and w == 0:\n                pass\n            elif h == 0:\n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h-1][W-w]+1)\n            elif w == 0:   \n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h][W-w-1]+1)\n            else:\n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h][W-w-1]+1, D[H-h-1][W-w]+1, D[H-h][W-w]+2)\n            d_max = max(D[H-h-1][W-w-1], d_max)\n\n\"\"\"\n\n\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\nA.sort()\nB = [0]*M\nC = [0]*M\nfor m in range(M):\n    B[m], C[m] = map(int, input().split())\n# 複数配列を並び替え\nBC = zip(B, C)\n# itemgetterには何番目の配列をキーにしたいか渡します\nBC = sorted(BC,key=itemgetter(1), reverse = True)\nB, C = zip(*BC)\n\ndef main(): \n    #print(A, B, C)\n    for i in range(M):\n        idx = 0         \n        idx = bisect.bisect_left(A, C[i])\n        if idx == 0:\n            break\n        else:\n            A[0:min(idx, B[i])] = [C[i]]*min(idx, B[i])\n            A.sort()\n    print(sum(A))\n                \n                \n                \n            \n            \n                \n\n    \nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":514,"bad_solution":"import bisect\nimport sys\ninput = sys.stdin.readline\nfrom collections import defaultdict\nclass Bit:\n  def __init__(self, n):\n    self.size = n\n    self.tree = [0] * (n + 1)\n\n  def sum(self, i):\n    s = 0\n    while i > 0:\n        s += self.tree[i]\n        i -= i & -i\n    return s\n\n  def add(self, i, x):\n    while i <= self.size:\n      self.tree[i] += x\n      i += i & -i\nn,d,a = map(int,input().split())\nxh = [list(map(int,input().split())) for i in range(n)]\nfor i in range(n):\n  xh[i][1] = (xh[i][1]+a-1)\/\/a\nxh.sort()\nx = [xh[i][0] for i in range(n)]\nremain = [xh[i][1] for i in range(n)]\nans = 0\nbit = Bit(n)\nfor i in range(n):\n  if bit.sum(i+1) >= remain[i]:\n    continue\n  br = bisect.bisect_right(x,x[i]+2*d)\n  ans += remain[i]-bit.sum(i+1)\n  bit.add(i+1,remain[i])\n  bit.add(br+1,-remain[i])\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":515,"bad_solution":"import sys\nimport math\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nin_n = lambda: int(readline())\nin_nn = lambda: map(int, readline().split())\nin_s = lambda: readline().rstrip().decode('utf-8')\nin_nl = lambda: list(map(int, readline().split()))\nin_nl2 = lambda H: [in_nl() for _ in range(H)]\nin_map = lambda: [s == ord('.') for s in readline() if s != ord('\\n')]\nin_map2 = lambda H: [in_map() for _ in range(H)]\nin_all = lambda: map(int, read().split())\n\n\ndef factorize(n):\n    b = 2\n    fct = set()\n    while b ** 2 <= n:\n        while n % b == 0:\n            n \/\/= b\n            fct.add(b)\n        b += 1\n    if n > 1:\n        fct.add(n)\n    return fct\n\n\ndef main():\n\n    N = in_n()\n    A = sorted(in_nl())\n\n    M = 10**6 + 1\n    ok = [True] * M\n\n    pf = True\n    for i in range(N):\n        prime = factorize(A[i])\n        for p in prime:\n            if not ok[p]:\n                pf = False\n                break\n            else:\n                ok[p] = False\n\n    g = A[0]\n    for i in range(1, N):\n        g = math.gcd(g, A[i])\n\n    if pf:\n        ans = \"pairwise coprime\"\n    else:\n        if g == 1:\n            ans = \"setwise coprime\"\n        else:\n            ans = \"not coprime\"\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":516,"bad_solution":"\nimport sys, io, os, re\nfrom bisect import bisect, bisect_left, bisect_right, insort, insort_left, insort_right\nfrom pprint import pprint\nfrom math import sin, cos, pi, radians, sqrt, floor, ceil\nfrom copy import copy, deepcopy\nfrom collections import deque, defaultdict\nfrom fractions import gcd\nfrom functools import reduce\nfrom itertools import groupby, combinations\nfrom heapq import heapify, heappush, heappop\n\n# sys.setrecursionlimit(5000)\n\nn1 = lambda: int(sys.stdin.readline().strip())\nnn = lambda: list(map(int, sys.stdin.readline().strip().split()))\nf1 = lambda: float(sys.stdin.readline().strip())\nfn = lambda: list(map(float, sys.stdin.readline().strip().split()))\ns1 = lambda: sys.stdin.readline().strip()\nsn = lambda: list(sys.stdin.readline().strip().split())\nnl = lambda n: [n1() for _ in range(n)]\nfl = lambda n: [f1() for _ in range(n)]\nsl = lambda n: [s1() for _ in range(n)]\nnm = lambda n: [nn() for _ in range(n)]\nfm = lambda n: [fn() for _ in range(n)]\nsm = lambda n: [sn() for _ in range(n)]\n\ndef array1(n, d=0): return [d] * n\ndef array2(n, m, d=0): return [[d] * m for x in range(n)]\ndef array3(n, m, l, d=0): return [[[d] * l for y in xrange(m)] for x in xrange(n)]\ndef linc(A, d=1): return list(map(lambda x: x + d, A))\ndef ldec(A, d=1): return list(map(lambda x: x - d, A))\n\nN = n1()\nA = nn()\n\nif max(A) == 1:\n    print(\"pairwise coprime\")\n    exit(0)\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5\/\/1)) + 1):\n        if temp % i == 0:\n            cnt = 0\n            if temp % i == 0:\n                cnt += 1\n                temp \/\/= i\n            arr.append([i, cnt])\n\n    if temp != 1: arr.append([temp, 1])\n    if arr == []: arr.append([n, 1])\n    return arr\n\ndic = defaultdict(list)\n\nfor ai in A:\n    fact = factorization(ai)\n    for i in range(len(fact)):\n        dic[fact[i][0]].append(ai)\n\nmaxlen = 0\nfor k, v in dic.items():\n    maxlen = max(len(v), maxlen)\n\nif maxlen == 1:\n    print(\"pairwise coprime\")\nelif maxlen == N:\n    print(\"not coprime\")\nelse:\n    print(\"setwise coprime\")\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":517,"bad_solution":"def main():\n\tN, K = map(int, input().split())\n\tDIV = 10**9+7\n\tab = [[] for _ in range(N)]\n\n\tsize = max(N+1, K+1)\n\tfact = [0]*size\n\tinverse = [0]*size\n\tinv_cal = [0]*size\n\tfact[:2] = [1, 1]\n\tinverse[:2] = [1, 1]\n\tinv_cal[:2] = [0, 1]\n\n\tfor i in range(2, size):\n\t\tfact[i] = (fact[i-1]*i%DIV)\n\t\tinv_cal[i] = (-inv_cal[DIV%i]*(DIV\/\/i))%DIV\n\t\tinverse[i] = inverse[i-1]*inv_cal[i]%DIV\n\n\tdef C(n, r):\n\t\tans = fact[n]*inverse[r]%DIV\n\t\treturn ans*inverse[n-r]%DIV\n\n\tdef P(n, r):\n\t\tif n < 0:\n\t\t\treturn 0\n\t\tans = C(n, r)\n\t\treturn ans*fact[r]%DIV\n\n\tfor _ in range(N-1):\n\t\tu, v = map(int, input().split())\n\t\tab[u-1].append(v-1)\n\t\tab[v-1].append(u-1)\n\n\tdef dfs(v, ans=1, p=-1):\n\t\tfor u in ab[v]:\n\t\t\tif u == p:\n\t\t\t\tcontinue\n\t\t\tans = dfs(u, ans, v)\n\t\tc = 0\n\t\tnk = K\n\t\tif p == -1:\n\t\t\tc = len(ab[v])+1\n\t\telse:\n\t\t\tc = len(ab[v])-1\n\t\t\tnk = K-2\n\t\tans *= P(nk, c)\n\t\treturn ans%DIV\n\tans = dfs(0)\n\tprint(ans)\n\n\nif __name__ == '__main__':\n\tmain()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":518,"bad_solution":"\ndef FUNC(lst):\n    '''\n    You are given a non-empty list of positive integers. Return the greatest integer that is greater than \n    zero, and has a frequency greater than or equal to the value of the integer itself. \n    The frequency of an integer is the number of times it appears in the list.\n    If no such a value exist, return -1.\n    Examples:\n        FUNC([4, 1, 2, 2, 3, 1]) == 2\n        FUNC([1, 2, 2, 3, 3, 3, 4, 4, 4]) == 3\n        FUNC([5, 5, 4, 4, 4]) == -1\n    '''\n    frq = [0] * (max(lst) + 1)\n    for i in lst:\n        frq[i] += 1;\n\n    ans = 0\n    for i in range(1, len(frq)):\n        if frq[i] >= i:\n            ans = i\n    \n    return ans\n"}
{"id":519,"bad_solution":"# 左の文字を決め打ちして、右の文字を試していく 右の文字の候補の位置はあらかじめdicで記録\n\nfrom collections import defaultdict\npos = defaultdict(list)\n\nimport sys\nreadline = sys.stdin.readline\n\nN = int(readline())\nS = readline().rstrip()\n\nfor i in range(N):\n  pos[S[i]].append(i)\n\nimport bisect\ndef find_tar(s,i): # i + 1文字目以降からsを探す\n#  print(\"pos[s]\",pos[s],\"から\",i+1,\"番目以降の最小値を探す\")\n  j = bisect.bisect_left(pos[s],i+1)\n  if j == len(pos[s]):\n    return None\n  return pos[s][j:] # 全リストを返す\n\nans = 0\ni = 0\nwhile i < N:\n  rest = find_tar(S[i],i)\n  if rest is None:\n    i += 1\n    continue\n  bestfit = 1\n#  print(S[i],rest)\n  for j in rest:\n    # i,jに同じ文字がある状態\n    fit = 1\n#    print(\"i\",i,S[i],\"j\",j,S[j],\"からスタート\")\n    while i + fit < j and j + fit < N:\n      if S[i + fit] == S[j + fit]:\n#        print(\"fit\",fit,\"一致\",S[i + fit])\n        fit += 1\n      else:\n        break\n    if bestfit < fit:\n      bestfit = fit\n    if bestfit > ans:\n      ans = bestfit\n#  print(\"i\",i,\"を\",i + bestfit,\"まで進める\")\n  i += 1 # i += bestfit\n\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":520,"bad_solution":"import sys\ninput = sys.stdin.readline\nMax = 2000\ndef l():\n    return list(map(int,input().split()))\ndef m():\n    return map(int,input().split())\ndef s(x):\n    a = []\n    aa = x[i]\n    su = 1\n    for i in range(len(x)-1):\n        if aa == x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x):\n    return \" \".join(map(str,x))\n\nh,w = m()\n\naa = [[] for i in range(h)]\naaa = []\nma = 0\nfor i in range(h):\n    k = list(input())\n    for j in range(w):\n        if k[j] == \"#\":\n            aa[i].append(0)\n            aaa.append([i,j])\n        else:\n            aa[i].append(Max)\nkk = []\nwhile True:\n    if len(aaa) == 0:\n        break\n    for i in range(len(aaa)):\n        c,v = aaa.pop(0)\n        if not c == 0:\n            if aa[c-1][v] != min(aa[c][v]+1,aa[c-1][v]):\n                aa[c-1][v] = min(aa[c][v]+1,aa[c-1][v])\n                kk.append([c-1,v])\n                ma = max(ma,aa[c-1][v])\n        if not c == h-1:\n            if aa[c+1][v] != min(aa[c][v]+1,aa[c+1][v]):\n                aa[c+1][v] = min(aa[c][v]+1,aa[c+1][v])\n                kk.append([c+1,v])\n                ma = max(ma,aa[c+1][v])\n        if not v == 0:\n            if aa[c][v-1] != min(aa[c][v]+1,aa[c][v-1]):\n                aa[c][v-1] = min(aa[c][v]+1,aa[c][v-1])\n                kk.append([c,v-1])\n                ma = max(ma,aa[c][v-1])\n        if not v == w-1:\n            if aa[c][v+1] != min(aa[c][v]+1,aa[c][v+1]):\n                aa[c][v+1] = min(aa[c][v]+1,aa[c][v+1])\n                kk.append([c,v+1])\n                ma = max(ma,aa[c][v+1])\n    aaa = kk\n    kk = []\nprint(ma)\n        \n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":521,"bad_solution":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN = INT()\nP = LIST()\n\nflag = [N+1]*N\ntotal = 0\n\nfor i in range(1, N+1):\n\tnum = P.index(i)\n\tif min(flag[0:num+1]) > P[num]:\n\t\ttotal += 1\n\tflag[num] = P[num]\n\nprint(total)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":522,"bad_solution":"class SegmentTree(object):  # 1-indexed\n    def __init__(self, size, S):\n        self.len = 1 << size.bit_length()\n\n        self.array = [0] * (2 * self.len)\n        for i, s in enumerate(S):\n            self.array[i + self.len] = 1 << (ord(s) - ord('a'))\n        for i in range(self.len - 1, 0, -1):\n            self.array[i] = self.array[i * 2] | self.array[i * 2 + 1]\n\n    def query1(self, i, x):\n        i += self.len\n        self.array[i] = 1 << (ord(x) - ord('a'))\n        i >>= 1\n        while i > 0:\n            self.array[i] = self.array[i * 2] | self.array[i * 2 + 1]\n            i >>= 1\n\n    def get(self, i):\n        return self.array[i + self.len]\n\n    def count_letter(self, l, r, i, a, b):\n        if l == a and r == b:\n            return self.array[i]\n        center = (a + b) \/\/ 2\n        if center >= r:\n            return self.count_letter(l, r, i * 2, a, center)\n        elif center < l:\n            return self.count_letter(l, r, i * 2 + 1, center + 1, b)\n        else:\n            left = self.count_letter(l, center, i * 2, a, center)\n            right = self.count_letter(center + 1, r, i * 2 + 1, center + 1, b)\n            return left | right\n\n    def query2(self, l, r):\n        ans = self.count_letter(l - 1, r - 1, 1, 0, self.len - 1)\n        print(bin(ans).count('1'))\n\n\nN = int(input())\nS = input()\ntree = SegmentTree(N, S)\nQ = int(input())\n\nfor _ in range(Q):\n    a, b, c = map(str, input().split())\n    if a == \"1\":\n        b = int(b)\n        tree.query1(b, c)\n    else:\n        b = int(b)\n        c = int(c)\n        tree.query2(b, c)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":523,"bad_solution":"#### import ####\nimport sys\nimport math\nfrom collections import defaultdict\n\n#### 設定 ####\nsys.setrecursionlimit(10**7)\ndef input():\n    return sys.stdin.readline()[:-1]\n\n#### 定数 ####\nmod = 10**9 + 7\n\n#### 読み込み ####\ndef I(): return int(input())\ndef II(): return map(int, input().split())\ndef III(): return list(map(int, input().split()))\ndef Line(N):\n    read_all = [tuple(map(int, input().split())) for _ in range(N)]\n    return map(list,zip(*read_all))\n\n#################\n\nfrom collections import Counter\n\nn = I()\nv = III()\n\nif v==[v[0]]*len(v):\n    print(len(v)\/\/2)\n    exit()\n\nx = [v[i] for i in range(0,n,2)]\ny = [v[i] for i in range(1,n,2)]\n\nxc = Counter(x)\nyc = Counter(y)\nxval = xc.most_common(1)[0][0]\nyval = yc.most_common(1)[0][1]\nxnum = xc.most_common(1)[0][1]\nynum = yc.most_common(1)[0][1]\n\nif xval!=yval:\n    print(len(x)-xnum+len(y)-ynum)\nelse:\n    if xnum==len(x):\n        print(min(len(x)+len(y)-ynum, len(x)-xnum+len(y)-yc.most_common(2)[1][1]))\n    elif ynum==len(y):\n        print(min(len(x)-xnum+len(y), len(x)-xc.most_common(2)[1][1]+len(y)-ynum))\n    else:\n        print(min(len(x)-xc.most_common(2)[1][1]+len(y)-ynum, len(x)-xnum+len(y)-yc.most_common(2)[1][1]))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":524,"bad_solution":"# For taking integer inputs.\ndef inp():\n    return(int(input()))\n\n\n# For taking List inputs.\ndef inlist():\n    return(list(map(int, input().split())))\n\n\n# For taking string inputs. Actually it returns a List of Characters, instead of a string, which is easier to use in Python, because in Python, Strings are Immutable.\ndef instr():\n    s = input()\n    return(list(s[:len(s)]))\n\n\n# For taking space seperated integer variable inputs.\ndef invr():\n    return(map(int, input().split()))\n\n\nN = inp()\n\nA = inlist()\nm = 0\nfor i in range(N):\n    c = 0\n    for j in range(i, N-1):\n        if A[j] >= A[j+1]:\n            c += 1\n        else:\n            break\n    if c > m:\n        m = c\nprint(m)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":525,"bad_solution":"N,M,Q=map(int,input().split())\nTown=[[0,0] for i in range(M)]\nfor i in range(M):\n  Town[i][0],Town[i][1]=map(int,input().split())\nTown.sort(key=lambda x:x[0])\n\ndef BS_left(x,L):\n  L_copy=L[:]\n  l=len(L_copy)\n  left=0\n  if L[l-1]<x:\n    return l-1\n  else:\n    while l>2:\n      if L_copy[l\/\/2]<x:\n        L_copy=L_copy[l\/\/2:l]\n        left+=l\/\/2\n      else:\n        L_copy=L_copy[0:l\/\/2+1]\n      l=len(L_copy)\n    if L[left]>=x:\n      return left-1\n    else:\n      return left\n\ndef BS_right(x,L):\n  L_copy=L[:]\n  l=len(L_copy)\n  right=l-1\n  if L[0]>x:\n    return 0\n  else:\n    while l>2:\n      if L_copy[l\/\/2]<=x:\n        L_copy=L_copy[l\/\/2:l]\n      else:\n        L_copy=L_copy[0:l\/\/2+1]\n        right+=-l\/\/2+1\n      l=len(L_copy)\n    if L[right]<=x:\n      return right+1\n    else:\n      return right\n\nans=[0]*Q\nfor i in range(Q):\n  p,q=map(int,input().split())\n  TownL=list(zip(*Town))[0]\n  newTown=Town[BS_left(p,TownL)+1:BS_right(q,TownL)]\n  if len(newTown)==0:\n    print(0)\n  else:\n    newTown.sort(key=lambda x:x[1])\n    TownR=list(zip(*newTown))[1]\n    if BS_right(q,TownR)==1 and TownR[0]>q:\n      print(0)\n    else:\n      print(BS_right(q,TownR)-1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":526,"bad_solution":"# coding: utf-8\nimport sys\n# from operator import itemgetter\nsysread = sys.stdin.readline\nread = sys.stdin.read\nsys.setrecursionlimit(10 ** 7)\nfrom heapq import heappop, heappush\n#from collections import defaultdict\n# import math\n# from itertools import product, accumulate, combinations, product\n# import bisect# lower_bound etc\n#import numpy as np\n# from copy import deepcopy\n#from collections import deque\n#import numba\n\ndef run():\n    H, N = map(int, sysread().split())\n    AB = []\n    for i in range(N):\n        a,b = map(int, sysread().split())\n        AB.append((a,b))\n\n    INF = float('inf')\n    dp = [[INF] * (2*H+2) for _ in range(N+1)]\n    dp[0][0] = 0\n    for i in range(N):\n        for j in range(2*H+2):\n            tmp = j - AB[i][0]\n            if tmp >= 0:\n                dp[i+1][j] = min([dp[i][j], dp[i+1][tmp] + AB[i][1]])\n            elif j == H and tmp < 0:\n                dp[i + 1][H] = min(dp[i][H], dp[i + 1][0] + AB[i][1])\n            else:\n                dp[i+1][j] = dp[i][j]\n    ret = min(dp[N][H:])\n    print(ret)\n\n\n\nif __name__ == \"__main__\":\n    run()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":527,"bad_solution":"def calcsum(n):\n    return n * (n + 1) \/\/ 2\n\ns = str(input())\nn = len(s) + 1\narrk = []\narrg = []\ntmp = s[0]\ncnt = 1\nfor i in range(1, n-1):\n    if s[i] == tmp:\n        cnt += 1\n    elif s[i] != tmp:\n        if tmp == '<':\n            arrk.append(cnt)\n        else:\n            arrg.append(cnt)\n        cnt = 1\n        tmp = s[i]\nif tmp == '<':\n    arrk.append(cnt)\nelse:\n    arrg.append(cnt)\n#print(arrk, arrg)\nans = 0\nfor i in range(len(arrk)):\n    #print(calcsum(arrk[i]-1))\n    ans += calcsum(arrk[i]-1)\nfor i in range(len(arrg)):\n    #print(calcsum(arrg[i]-1))\n    ans += calcsum(arrg[i]-1)\n#print('ans',ans)\nl = min(len(arrg), len(arrk))\n#print(l, len(arrg), len(arrk))\nif s[0] == '<':\n    for i in range(l):\n        ans += max(arrg[i], arrk[i])\n    if l < len(arrk):\n        ans += arrk[len(arrk) - 1]\n'''\nelif s[0] == '>':\n    ans += arrg[0]\n    for i in range(l-1):\n        ans += max(arrg[i+1], arrk[i])\n    if l < len(arrg):\n        ans += arrg[len(arrg) - 1]\n'''\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":528,"bad_solution":"from collections import defaultdict\ndef solve():\n    N = int(input())\n    S2 = [0]*(2*N)\n    for i in range(N):\n        S2[i] = input()*2\n        S2[i+N] = S2[i]\n    check = defaultdict(lambda: [[0]*(2*N) for _ in range(2*N)])\n    cum = defaultdict(lambda: [[0]*(2*N) for _ in range(2*N)])\n    for i in range(2*N-1):\n        for j in range(2*N-1):\n            for k in range(max([-N+1,i+1-2*N,-j]),min([N,2*N-j,i+1])):\n                check[k][i+1][j+1] = S2[i][j]==S2[j+k][i-k]\n    for i in range(1,2*N):\n        for j in range(1,2*N):\n            for k in range(-N+1,N):\n                cum[k][i][j] = cum[k][i-1][j]+cum[k][i][j-1]-cum[k][i-1][j-1]+check[k][i][j]\n                if i>=N+1:\n                    cum[k][i][j] -= check[k][i-N][j]\n                if j>=N+1:\n                    cum[k][i][j] -= check[k][i][j-N]\n                if i>=N+1 and j>= N+1:\n                    cum[k][i][j] += check[k][i-N][j-N]\n    ans = 0\n    for k in range(-N+1,0):\n        A,B = -k+N,N\n        while A<2*N:\n            if cum[A-B][A][B]==N*N:\n                ans += 1\n            A += 1\n            B += 1\n    for k in range(N):\n        A,B = N,k+N\n        while B<2*N:\n            if cum[A-B][A][B]==N*N:\n                ans += 1\n            A += 1\n            B += 1\n    return ans\nprint(solve())\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":529,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**10\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    a = [S() * 2 for _ in range(n)]\n    a = a + a\n    r = 0\n    for i in range(n):\n        f = True\n        for ii in range(n):\n            for jj in range(ii+1,n):\n                if a[ii][jj+i] != a[jj+i][ii]:\n                    f = False\n                    break\n        if f:\n            r += 1\n\n    return r * n\n\n\n\n\nprint(main())\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":530,"bad_solution":"from collections import defaultdict\n\ndef solve(graph, edges, n, start_idx):\n  flg = [False for _ in range(n)] #未検索のノードはFlase\n  flg[start_idx] = True\n  \n  cost = [float('inf') for _ in range(n)]\n  cost[start_idx] = 0\n  \n  prv_edges = [[] for _ in range(n)]\n  \n  prv_node = start_idx  \n  while not all(flg):\n    for node, dis in graph[prv_node]:\n      tmp_cost = cost[node] \n      tmp_dis = dis + cost[prv_node]\n      if tmp_cost >= tmp_dis:\n        cost[node] = tmp_dis\n        \n        tmp_edge = sorted([prv_node, node])\n        if tmp_edge in edges:\n          edges.remove(tmp_edge)\n        for prv_edge in prv_edges[node]:\n          if prv_edges[node] not in edges:\n            edges.append(prv_edge)\n\n      if tmp_cost > tmp_dis:\n        prv_edges[node] = [tmp_edge]\n      elif tmp_cost == tmp_dis:\n        prv_edges[node].append(tmp_edge)\n    \n    min_cost = float('inf')\n    tmp_idx = -1\n    for i in range(n):\n      if flg[i] is False and min_cost > cost[i]:\n        min_cost = cost[i]\n        tmp_idx = i\n    prv_node = tmp_idx\n    flg[prv_node] = True\n    #print(start_idx, prv_node, cost, edges, prv_edges)\n  return edges\n\nn, m = map(int, input().split())\ngraph = defaultdict(list)\nedges = []\n\nfor i in range(m):\n  a,b,c = map(int, input().split())\n  graph[a-1].append([b-1,c])\n  graph[b-1].append([a-1,c])\n\nfor i in range(n):\n  edges = solve(graph, edges, n, i)\nprint(len(edges))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":531,"bad_solution":"# -*- coding: utf-8 -*-\n\n#############\n# Libraries #\n#############\n\nimport sys\ninput = sys.stdin.readline\n\nimport math\n#from math import gcd\nimport bisect\nimport heapq\nfrom collections import defaultdict\nfrom collections import deque\nfrom collections import Counter\nfrom functools import lru_cache\n\n#############\n# Constants #\n#############\n\nMOD = 10**9+7\nINF = float('inf')\nAZ = \"abcdefghijklmnopqrstuvwxyz\"\n\n#############\n# Functions #\n#############\n\n######INPUT######\ndef I(): return int(input().strip())\ndef S(): return input().strip()\ndef IL(): return list(map(int,input().split()))\ndef SL(): return list(map(str,input().split()))\ndef ILs(n): return list(int(input()) for _ in range(n))\ndef SLs(n): return list(input().strip() for _ in range(n))\ndef ILL(n): return [list(map(int, input().split())) for _ in range(n)]\ndef SLL(n): return [list(map(str, input().split())) for _ in range(n)]\n\n######OUTPUT######\ndef P(arg): print(arg); return\ndef Y(): print(\"Yes\"); return\ndef N(): print(\"No\"); return\ndef E(): exit()\ndef PE(arg): print(arg); exit()\ndef YE(): print(\"Yes\"); exit()\ndef NE(): print(\"No\"); exit()\n\n#####Shorten#####\ndef DD(arg): return defaultdict(arg)\n\n#####Inverse#####\ndef inv(n): return pow(n, MOD-2, MOD)\n\n######Combination######\nkaijo_memo = []\ndef kaijo(n):\n  if(len(kaijo_memo) > n): return kaijo_memo[n]\n  if(len(kaijo_memo) == 0): kaijo_memo.append(1)\n  while(len(kaijo_memo) <= n): kaijo_memo.append(kaijo_memo[-1] * len(kaijo_memo) % MOD)\n  return kaijo_memo[n]\n\ngyaku_kaijo_memo = []\ndef gyaku_kaijo(n):\n  if(len(gyaku_kaijo_memo) > n): return gyaku_kaijo_memo[n]\n  if(len(gyaku_kaijo_memo) == 0): gyaku_kaijo_memo.append(1)\n  while(len(gyaku_kaijo_memo) <= n): gyaku_kaijo_memo.append(gyaku_kaijo_memo[-1] * pow(len(gyaku_kaijo_memo),MOD-2,MOD) % MOD)\n  return gyaku_kaijo_memo[n]\n\ndef nCr(n,r):\n  if n == r: return 1\n  if n < r or r < 0: return 0\n  ret = 1\n  ret = ret * kaijo(n) % MOD\n  ret = ret * gyaku_kaijo(r) % MOD\n  ret = ret * gyaku_kaijo(n-r) % MOD\n  return ret\n\n######Factorization######\ndef factorization(n):\n  arr = []\n  temp = n\n  for i in range(2, int(-(-n**0.5\/\/1))+1):\n    if temp%i==0:\n      cnt=0\n      while temp%i==0: \n        cnt+=1 \n        temp \/\/= i\n      arr.append([i, cnt])\n  if temp!=1: arr.append([temp, 1])\n  if arr==[]: arr.append([n, 1])\n  return arr\n\n#####MakeDivisors######\ndef make_divisors(n):\n  divisors = []\n  for i in range(1, int(n**0.5)+1):\n    if n % i == 0:\n      divisors.append(i)\n      if i != n \/\/ i: \n        divisors.append(n\/\/i)\n  return divisors\n\n#####MakePrimes######\ndef make_primes(N):\n  max = int(math.sqrt(N))\n  seachList = [i for i in range(2,N+1)]\n  primeNum = []\n  while seachList[0] <= max:\n    primeNum.append(seachList[0])\n    tmp = seachList[0]\n    seachList = [i for i in seachList if i % tmp != 0]\n  primeNum.extend(seachList)\n  return primeNum\n\n#####GCD#####\ndef gcd(a, b):\n    while b: a, b = b, a % b\n    return a\n\n#####LCM#####\ndef lcm(a, b):\n    return a * b \/\/ gcd (a, b)\n\n#####BitCount#####\ndef count_bit(n):\n  count = 0\n  while n:\n    n &= n-1\n    count += 1\n  return count\n\n#####ChangeBase#####\ndef base_10_to_n(X, n):\n  if X\/\/n: return base_10_to_n(X\/\/n, n)+[X%n]\n  return [X%n]\n\ndef base_n_to_10(X, n):\n  return sum(int(str(X)[-i-1])*n**i for i in range(len(str(X))))\n\ndef base_10_to_n_without_0(X, n):\n  X -= 1\n  if X\/\/n: return base_10_to_n_without_0(X\/\/n, n)+[X%n]\n  return [X%n]\n\n#####IntLog#####\ndef int_log(n, a):\n  count = 0\n  while n>=a:\n    n \/\/= a\n    count += 1\n  return count\n\n#############\n# Main Code #\n#############\n\nN,K = IL()\ndata = ILL(N)\n\ndata.sort(lambda x:-x[1])\ndic = DD(list)\nfor t,v in data:\n  dic[t].append(v)\nfor t in dic:\n  dic[t].sort(reverse=True)\n\nKISO = 0\nTOP = DD(list)\nfor i in range(K):\n  t,v = data[i]\n  TOP[t].append(v)\n  KISO += v\nSHURUI = len(TOP)\nl = K-1\nr = K\nMAX = KISO+SHURUI**2\nwhile True:\n  if l<0 or r>=N: break\n  if len(TOP[data[l][0]]) == 1:\n    l -= 1\n    continue\n  if TOP[data[r][0]]:\n    r += 1\n    continue\n  TOP[data[l][0]].pop()\n  TOP[data[r][0]].append(data[r][1])\n  KISO -= data[l][1]\n  KISO += data[r][1]\n  SHURUI += 1\n  MAX = max(MAX,KISO+SHURUI**2)\nprint(MAX)\n  \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":532,"bad_solution":"def resolve():\n    import math\n    from collections import defaultdict\n    def factorization(n):\n        # 参考: https:\/\/qiita.com\/snow67675476\/items\/e87ddb9285e27ea555f8\n        dic = defaultdict(int)\n        temp = n\n        for i in range(2, int(-(-n ** 0.5 \/\/ 1)) + 1):\n            if temp % i == 0:\n                cnt = 0\n                while temp % i == 0:\n                    cnt += 1\n                    temp \/\/= i\n                dic[i] = cnt\n\n        if temp != 1:\n            dic[temp] = 1\n        if not dic:\n            dic[n] = 1\n\n        return set(dic.keys())\n\n    n = int(input())\n    a = list(set(map(int, input().split())))\n    pair = False\n    divisors = factorization(a[0])\n    ggcd = a[0]\n    for i in range(1, len(a)):\n        divs = factorization(a[i])\n        nxt = divisors | divs\n        if len(nxt) != len(divs) + len(divisors):\n            pair = True\n            break\n        else:\n            divisors = nxt\n    for i in range(1, len(a)):\n        ggcd = math.gcd(ggcd, a[i])\n        if ggcd == 1:\n            break\n    if ggcd != 1:\n        print(\"not coprime\")\n    else:\n        if pair:\n            print(\"setwise coprime\")\n        else:\n            print(\"pairwise coprime\")\nresolve()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":533,"bad_solution":"from collections import deque\nN,Q=map(int, input().split())\n\n#重複分を引く\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0]*(n+1)\n        self.el = [0]*(n+1)\n        \n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.data[i]\n            i -= i & -i\n        return s\n\n    # I: idx(base: 1), x: value\n    def add(self, i, x):\n        # assert i > 0\n        self.el[i] += x\n        while i <= self.n:\n            self.data[i] += x\n            i += i & -i\n            \n    # i<x<=j \n    def get(self, i, j=None):\n        if j is None:\n            return self.el[i]\n        return self.sum(j) - self.sum(i)\n\nquery=[]\n\nC=list(map(int, input().split()))\nfor i in range(Q):\n    l, r=map(int, input().split())\n    query.append((l,r,i))\nquery=sorted(query, key=lambda x: -x[1])\n\nstate=[-1]*N\nseg=BIT(N+1)\nans=[0]*Q\n\nfor i in range(N):\n    while query and query[-1][1]<i+1:\n        l,r,j=query.pop()\n        ans[j]=r-l+1-(seg.get(l-1,r))\n\n    c=C[i]\n    if state[c-1]==-1:\n        state[c-1]=i+1\n    else:\n        idx=state[c-1]\n        seg.add(idx,1)\n        state[c-1]=i+1\n    while query and query[-1][1]==i:\n        lq,rq,j=query.pop()\n        ans[j]=rq-lq+1-(seg.get(lq-1,rq))\n        #print(lq, rq, seg.get(lq-1,rq))\n\n\n\n\n\nfor a in ans:\n    print(a)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":534,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\n\nimport sys\n# sys.setrecursionlimit(10**6)\n# buff_readline = sys.stdin.buffer.readline\nbuff_readline = sys.stdin.readline\nreadline = sys.stdin.readline\n\nINF = 2**62-1\n\n\ndef read_int():\n    return int(buff_readline())\n\n\ndef read_int_n():\n    return list(map(int, buff_readline().split()))\n\n\ndef read_float():\n    return float(buff_readline())\n\n\ndef read_float_n():\n    return list(map(float, buff_readline().split()))\n\n\ndef read_str():\n    return readline().strip()\n\n\ndef read_str_n():\n    return readline().strip().split()\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\ndef eratosthenes(n):\n    p = []\n    t = [True] * n\n\n    for i in range(2, int(math.ceil(math.sqrt(n)))):\n        if t[i]:\n            p.append(i)\n            for j in range(2*i, n, i):\n                t[j] = False\n\n    for j in range(i+1, n):\n        if t[j]:\n            p.append(j)\n\n    return p\n\n\n# error_print(len(P))\n\n@mt\ndef slv(N, A):\n    d = Counter()\n    P = eratosthenes(10**6+1)\n    P = set(P)\n\n    for a in A:\n        f = True\n        u = set()\n        for p in P:\n            if a % p == 0:\n                if p in d:\n                    break\n                d[p] = 1\n                u.add(p)\n            while a % p == 0:\n                a \/\/= p\n            if a == 1:\n                break\n        else:\n            f = False\n\n        if a != 1:\n            break\n        P -= u\n        # print(a, u)\n    else:\n        return 'pairwise coprime'\n\n    g = 0\n    for a in A:\n        g = math.gcd(a, g)\n    return 'setwise coprime' if g == 1 else 'not coprime'\n\n\ndef main():\n    N = read_int()\n    A = read_int_n()\n    print(slv(N, A))\n\n    # P = eratosthenes(10**6+1)\n    # N = len(P)\n    # A = P[:]\n    # error_print(N)\n    # print(slv(N, A))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":535,"bad_solution":"X = list(map(int, input().split()))\nY = list(map(int, input().split()))\nmod = int(1e+9) + 7\ndef extgcd(a, b):\n  if b == 0:\n    return 1, 0\n  else:\n    x, y, u, v, k, l = 1, 0, 0, 1, a, b\n    while l != 0:\n      x, y, u, v = u, v, x - u * (k \/\/ l), y - v * (k \/\/ l)\n      k, l = l, k % l\n    return x\ndef inved(x):\n  a = extgcd(x, mod)\n  return a % mod\n\nF = [\n  [\n    [1, 0, 0, Y[5]-Y[4]+1, 0], \n    [-1, 0, 0, 0, 0]\n  ],\n  [\n    [1, X[5]-X[4]+1, 0, 0, 0], \n    [-1, 0, 0, X[5]-X[4]+1, 0]\n  ],\n  [\n    [1, 0, 0, Y[3]-Y[2]+1, 0], \n    [-1, 0, 0, 0, Y[3]-Y[2]+1]\n  ],\n  [\n    [1, 0, X[3]-X[2]+1, X[3]-X[2]+1, 0], \n    [-1, X[3]-X[2]+1, 0, 0, X[3]-X[2]+1]\n  ],\n  [\n    [1, 0, 0, 0, Y[1]-Y[0]+1], \n    [-1, 0, 0, 0, 0]\n  ],\n  [\n    [1, 0, 0, 0, X[1]-X[0]+1],\n    [-1, 0, X[1]-X[0]+1, 0, 0]\n  ],\n  [\n    [1, X[2]-X[5]-1, X[0]-X[3]-1, X[4]+Y[4]-X[3]-Y[3], X[2]+Y[2]-X[1]-Y[1]]\n  ]\n]\nfact = [1 for i in range(2000001)]\ninvf = [0 for i in range(2000001)]\nfor i in range(2000000):\n  fact[i+1] = ((i+1) * fact[i]) % mod\ninvf[-1] = inved(fact[2000000])\nfor i in range(2000000, 0, -1):\n  invf[i-1] = (invf[i] * i) % mod\ndef encryptic(left, mat):\n  cont = []\n  for i in range(len(left)):\n    for j in range(len(mat)):\n      tmp = [left[i][0] * mat[j][0]]\n      for k in range(1, 5):\n        tmp.append(left[i][k] + mat[j][k])\n      cont.append(tmp)\n  return cont\nPoly = [[1, 0, 0, 0, 0]]\nfor p in F:\n  Poly = encryptic(p, Poly)\nS = 0\nD = {}\nfor p in Poly:\n  a, b, c, d = -p[1], -p[2], p[3], p[4]\n  s = p[0]\n  M = min(b, c-a-2)\n  tmp = 0\n  for i in range(M+1):\n    pix = (i+1) * invf[2+i+a] * invf[c-i-a-2]\n    pix *= invf[b-i] * invf[d+i-b]\n    pix %= mod\n    tmp += pix\n    tmp %= mod\n  tmp *= fact[c] * fact[d]\n  tmp %= mod\n  S += s * tmp\n  S %= mod\nprint(S)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":536,"bad_solution":"import sys\ninput = sys.stdin.readline\n\ndef main():\n  n = int(input())\n  \n  a = []\n  b = []\n  for i in range(n):\n    s = input()\n    c1, c2 = 0, 0\n    for i in range(len(s)):\n      if s[i] == \"(\":\n        c2 += 1\n      if s[i] == \")\":\n        if c2:\n          c2 -= 1\n        else:\n          c1 += 1\n    if c1 >= c2:\n      b.append((c2, c1))\n    else:\n      a.append((c1, c2))\n  a.sort()\n  b.sort()\n  ans = False\n  sub = 0\n  for value in a:\n    k1, k2 = value[0], value[1]\n    if sub < k1:\n      ans = True\n      break\n    sub += k2-k1\n  for value in b:\n    k2, k1 = value[0], value[1]\n    if ans or sub < k1:\n      ans = True\n      break\n    sub += k2-k1\n  print(\"No\" if ans or sub else \"Yes\")\n\nif __name__ == \"__main__\":\n  main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":537,"bad_solution":"H, W = map(int, input().split())\ns, dp, ans = [], {}, 0\nfor i in range(H):\n    s.append(input())\ndef getRightCount(h, w):\n    key = str(h) + str(w) + 'r'\n    if key in dp:\n        return dp[key]\n    elif s[h][w] == '#':\n        dp[key] = 0\n    elif w == W - 1:\n        dp[key] = 0\n    elif s[h][w+1] == '#':\n        dp[key] = 0\n    else:\n        dp[key] = 1 + getRightCount(h, w+1)\n    return dp[key]\ndef getLeftCount(h, w):\n    key = str(h) + str(w) + 'l'\n    if key in dp:\n        return dp[key]\n    elif s[h][w] == '#':\n        dp[key] = 0\n    elif w == 0:\n        dp[key] = 0\n    elif s[h][w-1] == '#':\n        dp[key] = 0\n    else:\n        dp[key] = 1 + getLeftCount(h, w-1)\n    return dp[key]\ndef getDownCount(h, w):\n    key = str(h) + str(w) + 'd'\n    if key in dp:\n        return dp[key]\n    elif s[h][w] == '#':\n        dp[key] = 0\n    elif h == H - 1:\n        dp[key] = 0\n    elif s[h+1][w] == '#':\n        dp[key] = 0\n    else:\n        dp[key] = 1 + getDownCount(h+1, w)\n    return dp[key]\ndef getUpCount(h, w):\n    key = str(h) + str(w) + 'u'\n    if key in dp:\n        return dp[key]\n    elif s[h][w] == '#':\n        dp[key] = 0\n    elif h == 0:\n        dp[key] = 0\n    elif s[h-1][w] == '#':\n        dp[key] = 0\n    else:\n        dp[key] = 1 + getUpCount(h-1, w)\n    return dp[key]\ndef getCount(h, w):\n    if s[h][w] == '#':\n        return 0\n    rCnt, lCnt, uCnt, dCnt = 0,0,0,0\n    key = str(h) + str(w)\n    # to right\n    rkey = key + 'r'\n    rCnt = getRightCount(h, w)\n    # to left\n    lkey = key + 'l'\n    lCnt = getLeftCount(h, w)\n    # to down\n    dkey = key + 'd'\n    dCnt = getDownCount(h, w)\n    # to up\n    ukey = key + 'u'\n    uCnt = getUpCount(h, w)\n    return rCnt + lCnt + uCnt + dCnt + 1\n\nfor i in reversed(range(H)):\n    for j in reversed(range(W)):\n        ans = max(ans, getCount(i, j))\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":538,"bad_solution":"import sys\nimport heapq\npush = heapq.heappush\npop = heapq.heappop\nreadline = sys.stdin.buffer.readline\ndef even(n): return 1 if n%2==0 else 0\n \nH,W = map(int,readline().split())\nsh,sw = map(int,readline().split())\ngh,gw = map(int,readline().split())\nsh,sw = sh-1,sw-1\ngh,gw = gh-1,gw-1\nmaze = []\nfor _ in range(H):\n    maze.append(readline().rstrip().decode())\nvisited = [[10**6]*W for _ in range(H)] #必要な最小ワープ回数\nhp = []\npush(hp,(0,sh,sw))\nvisited[sh][sw] = 0\nwhile hp:\n    rp,h,w = pop(hp)\n    if h == gh and w == gw:\n        print(rp)\n        exit()\n    for i in range(5):\n        for j in range(5):\n            if i == 2 and j == 2:\n                continue\n            if 0 <= h+i-2 < H and 0 <= w+j-2 < W:\n                if maze[h+i-2][w+j-2] == \".\":\n                    if abs(i-2)+abs(j-2) <= 1:\n                            if visited[h+i-2][w+j-2] > rp:\n                                push(hp,(rp,h+i-2,w+j-2))\n                                visited[h+i-2][w+j-2] = rp\n                    else:\n                        if visited[h+i-2][w+j-2] > rp+1:\n                            push(hp,(rp+1,h+i-2,w+j-2))\n                            visited[h+i-2][w+j-2] = rp+1\nprint(-1)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":539,"bad_solution":"N = int(input())\nS = input()\nQ = int(input())\nQUERY = [input().split() for _ in range(Q)]\n\ndef or_more_pow_two(n):\n    if (n & (n-1)) == 0:\n        return n\n    return 1<<(len(bin(n))-2)\n\nclass SegmentTree:\n    def __init__(self, n, l):\n        self.n = or_more_pow_two(n)*2\n        self.tree = [0]*self.n\n        for i, l_i in enumerate(l):\n            self.tree[self.n\/\/2+i] = l_i\n        for i in reversed(range(1, self.n\/\/2)):\n            self.node_update(i)\n            # print(self.tree[i])\n\n    # 1-indexed: [l, r)\n    def find(self, l, r, fl=1, fr=\"self.n\/\/2+1\", node=1):\n        if fr == \"self.n\/\/2+1\":\n            fr = self.n\/\/2+1\n        # print(f\"find: ({l}, {r}), ({fl}, {fr}), {node}\")\n        if l <= fl and fr <= r:\n            # print(\"in\", bin(self.tree[node])[2:])\n            return self.tree[node]\n        elif fr <= l or r <= fl:\n            # print(\"out\")\n            return 0\n        else:\n            # print(\"overlap\")\n            mid = (fl+fr)\/\/2\n            a = self.find(l, r, fl=fl, fr=mid, node=2*node)\n            b = self.find(l, r, fl=mid, fr=fr, node=2*node+1)\n            return a | b\n\n    def update(self, index, v):\n        x = self.n\/\/2+index\n        self.tree[x] = v\n        while x > 0:\n            x >>= 1\n            self.node_update(x)\n\n    def node_update(self, index):\n        self.tree[index] = self.tree[2*index] | self.tree[2*index+1]\n\ndef char_to_bit(c):\n    i = ord(c) - 97\n    return (1 << i)\ndef bit_to_type_count(b):\n    # print(bin(b)[2:])\n    r = bin(b)[2:].count(\"1\")\n    # print(r)\n    return r\n# def bit_to_char(b):\n#     for i in range(26):\n\n\nsegtree = SegmentTree(N, map(char_to_bit, S))\n\nfor t, *query in QUERY:\n    t = int(t)\n    if t == 1:\n        i, c = query\n        i, c = int(i), c\n        segtree.update(i, char_to_bit(c))\n    elif t == 2:\n        l, r = map(int, query)\n        l, r = l, r+1\n        r = segtree.find(l, r)\n        r = bit_to_type_count(r)\n        print(r)\n    # print(list(map(bin, segtree.tree)))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":540,"bad_solution":"#単位元を設定\nide = 0\n\nclass SegmentTree:\n\tdef __init__(self,n):\n        #セグ木の頂点はindex == 1から。index == 0は無視すること。\n        #つまり、STtable[0]は無視。頂点はSTtable[1]。\n\t\tself.n = n\n\t\ttmp = 0\n\t\twhile True:\n\t\t\tif 2 ** tmp >= self.n:\n\t\t\t\tbreak\n\t\t\ttmp += 1\n\t\tself.STtable = [ide] * (2*2**tmp)\n\t\tself.STtable_size = len(self.STtable)\n\n\tdef update(self,i,a):\n        #更新のためのインデックスの指定は0_indexedで。\n\t\ta_bit = 1 << ord(a)-97\n\t\ti += self.STtable_size\/\/2\n\t\tself.STtable[i] = a_bit\n\t\twhile i > 0:\n\t\t\ti \/\/= 2\n\t\t\tself.STtable[i] = self.STtable[i*2] | self.STtable[i*2+1]\n\n\tdef find(self,a,b,k=1,l=0,r=None):\n        #kは頂点番号。初期値は1にすること。\n\t\t#[a,b)の最小を返す。\n\t\t#[l,r)からです。\n        #初期値のrは、self.STtable_size\/\/2にすると、ちょうど要素数と同じ値になって[l,r)のrになる。\n        #問題に適するように範囲を指定するように注意。大体[l,r]で指定されている。\n\t\tif r == None:\n\t\t\tr = self.STtable_size\/\/2        \n\t\tif a >= r or b <= l:\n\t\t\treturn ide\n\t\telif a <= l and b >= r:\n\t\t\treturn self.STtable[k]\n\t\telse:\n\t\t\tmid = (l+r)\/\/2\n\t\t\tif b <= mid:\n\t\t\t\treturn self.find(a,b,2*k,l,mid)\n\t\t\telif a >= mid:\n\t\t\t\treturn self.find(a,b,2*k+1,mid,r)\n\t\t\telse:\n\t\t\t\tv1 = self.find(a,mid,2*k,l,mid)\n\t\t\t\tv2 = self.find(mid,b,2*k+1,mid,r)\n\t\t\treturn v1 | v2\n\nN = int(input())\nsolve = SegmentTree(N)\nS = input()\nfor i in range(N):\n\tsolve.update(i,S[i])\nQ = int(input())\nans = []\nprint(solve.STtable)\nfor _ in range(Q):\n\ta,b,c = map(str, input().split())\n\tif a == '1':\n\t\tsolve.update(int(b)-1,c)\n\t\tprint(solve.STtable)\n\telse:\n\t\ttmp = solve.find(int(b)-1,int(c))\n\t\tcnt = 0\n\t\tfor i in range(26):\n\t\t\tif tmp >> i & 1 == 1:\n\t\t\t\tcnt += 1\n\t\tans.append(cnt)\n\nfor a in ans:\n\tprint(a)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":541,"bad_solution":"from collections import deque\n\nh, w = map(int, input().split())\ncx, cy = map(lambda x: int(x) - 1, input().split())\ndx, dy = map(lambda x: int(x) - 1, input().split())\ns = [input() for _ in range(h)]\nc = [[10**6] * w for _ in range(h)]\n\n\ndef bfs():\n    d = ((1, 0), (-1, 0), (0, 1), (0, -1))\n    q = deque([(cx, cy)])\n\n    c[cx][cy] = 0\n\n    while q:\n        x, y = q.pop()\n        cp = c[x][y]\n        if (x, y) == (dx, dy):\n            c[x][y] = cp\n            break\n        for i, j in d:\n            nx = x + i\n            ny = y + j\n            if 0 <= nx < h and 0 <= ny < w and s[nx][ny] != \"#\" and c[nx][\n                    ny] > cp:\n                q.append((nx, ny))\n                c[nx][ny] = cp\n        cp += 1\n        for i in range(-2, 3):\n            for j in range(-2, 3):\n                nx = x + i\n                ny = y + j\n                if 0 <= nx < h and 0 <= ny < w and s[nx][ny] != \"#\" and c[nx][\n                        ny] > cp:\n                    c[nx][ny] = cp\n                    q.appendleft((nx, ny))\n\n    return -1 * (c[dx][dy] == 10**6) or c[dx][dy]\n\n\nprint(bfs())\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":542,"bad_solution":"def main():\n  _max = max\n  _range = range\n  _input = input\n  h, w = map(int, _input().split())\n  s = [_input() + '#' for _ in _range(h)]\n  s.append('#' * (w + 1))\n\n  rt = [[-1] * w for _ in _range(h + 1)]\n  tstart = [-1] * (w + 1)\n  i = 0\n  while i < h + 1:\n    si = s[i]\n    rti = rt[i]\n    ystart = -1\n    j = 0\n    while j < w + 1:\n      tj = tstart[j]\n      if si[j] == '#':\n        if ystart != -1:\n          jy = j - ystart\n          for k in _range(ystart, j):\n            rti[k] += jy\n          ystart = -1\n        if tj != -1:\n          itj = i - tj\n          for k in _range(tj, i):\n            rt[k][j] += itj\n          tstart[j] = -1\n      else:\n        if ystart == -1:\n          ystart = j\n        if tj == -1:\n          tstart[j] = i\n      j += 1\n    i += 1\n\n  print(_max(map(_max, rt)))\n\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":543,"bad_solution":"import sys, math, itertools, bisect, copy, re\nfrom collections import Counter, deque, defaultdict\n\n# from itertools import accumulate, permutations, combinations, takewhile, compress, cycle\n# from functools import reduce\n# from math import ceil, floor, log10, log2, factorial\n# from pprint import pprint\n\nINF = float('inf')\nMOD = 10 ** 9 + 7\nEPS = 10 ** -7\nsys.setrecursionlimit(1000000)\n\n# N = int(input())\n# N,M = [int(x) for x in input().split()]\n# V = [[0] * 100 for _ in range(100)]\n# A = [int(input()) for _ in range(N)]\n# DP = [[0] * 100 for _ in range(100)]\n# DP = defaultdict(lambda: float('inf'))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":544,"bad_solution":"import math\nimport time\n\n\nt = time.time()\ndef iip():\n    return [int(i) for i in input().split()]\n\ndef main():\n    H, N = iip()\n    mp_for_damage = [10**9 for i in range(H+1)]\n    mp_for_damage[0] = 0\n    ab = []\n\n    for i in range(N):\n        ab.append(iip())\n\n    ab= sorted(ab, key=lambda x:x[0]\/x[1], reverse=True)\n\n    for i in range(N):\n        a, b = ab[i]\n        for j in range(H-a+1):\n            if a < H and mp_for_damage[a] < b:\n                continue\n\n            for k in range(1, min(a, H)):\n                if k > H:\n                    break\n                mp_for_damage[k] = min(mp_for_damage[k], b)\n\n            mp_for_damage[j+a] = min(mp_for_damage[j+a], mp_for_damage[j] + b)\n\n    #print(mp_for_damage)\n    print(mp_for_damage[H])\n\n    #print(time.time() - t)\n\nmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":545,"bad_solution":"def main():\n    n = int(input())\n    s = list(input())\n    cr = [0] * n\n    cg = [0] * n\n    cb = [0] * n\n    for i in range(n):\n        if i == 0:\n            if s[i] == 'R':\n                cr[i] += 1\n            elif s[i] == 'G':\n                cg[i] += 1\n            else:\n                cb[i] += 1\n        else:\n            cr[i] = cr[i-1]\n            cg[i] = cg[i-1]\n            cb[i] = cb[i-1]\n            if s[i] == 'R':\n                cr[i] += 1\n            elif s[i] == 'G':\n                cg[i] += 1\n            else:\n                cb[i] += 1\n    ans = 0\n    for i in range(n-2):\n        a = s[i]\n        for j in range(i+1, n-1):\n            b = s[j]\n            if a == b:\n                continue\n            diff = j - i\n            c = list({'R', 'G', 'B'} - {a, b})[0]\n            if c == 'R':\n                ans += cr[-1] - cr[j]\n            elif c == 'G':\n                ans += cg[-1] - cg[j]\n            else:\n                ans += cb[-1] - cb[j]\n            if j + diff < n:\n                if s[j + diff] == c:\n                    ans -= 1\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":546,"bad_solution":"import sys\ninput = sys.stdin.readline\n\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\n\ndef main():\n    mod=10**9+7\n    inf=10**6\n    N,K=MI()\n    P=LI()\n    inf=10**6\n    class SegTree:\n        def __init__(self,N,ide,segfunc=min):\n            self.ide_ele = ide\n            \"\"\"\n            ex)\n             最小値のセグ木 → +inf\n              和のセグ木 → 0\n              積のセグ木 → 1\n              gcdのセグ木 → 0\n            \"\"\"\n            \n            self.segfunc=segfunc\n            \n            #num:N以上の最小の2のべき乗\n            self.num =2**(N-1).bit_length()\n            self.seg=[self.ide_ele]*2*self.num\n\n\n\n\n        #リストで初期化する\n        def setL(self,init_val):\n            #init_valは操作する数列\n            for i in range(N):\n                self.seg[i+self.num-1]=init_val[i]    \n            #built\n            for i in range(num-2,-1,-1) :\n                self.seg[i]=self.segfunc(self.seg[2*i+1],self.seg[2*i+2]) \n\n\n        #k番目の値をxに更新\n        def update(self,k,x):\n            k += self.num-1\n            self.seg[k] = x\n            while k:\n                k = (k-1)\/\/2\n                self.seg[k] = self.segfunc(self.seg[k*2+1],self.seg[k*2+2])\n\n\n        #[p,q)の区間に対するクエリへの応答\n        def query(self,p,q):\n            if q<=p:\n                return self.ide_ele\n            p += self.num-1\n            q += self.num-2\n            res=self.ide_ele\n            while q-p>1:\n                if p&1 == 0:\n                    res = self.segfunc(res,self.seg[p])\n                if q&1 == 1:\n                    res = self.segfunc(res,self.seg[q])\n                    q -= 1\n                p = p\/\/2\n                q = (q-1)\/\/2\n            if p == q:\n                res = self.segfunc(res,self.seg[p])\n            else:\n                res = self.segfunc(self.segfunc(res,self.seg[p]),self.seg[q])\n            return res\n\n\n\n    \n    \"\"\"\n    長さKの尺取りぽく見るか．\n    最小値が抜けて最大値が入る場合は不変．\n    ただし，並び替え後も元の物と変わらない場合を何度かカウントしそう．\n    事前に（元から昇順になっている長さKの列）の個数を数えておこうか．\n    これは簡単に求まる．次が自分以上なら1をつけて，長さKの尺取りで和がKならおk．\n    累積和の方が実装が楽かなあ\n    \"\"\"\n    ans=1\n    mseg=SegTree(N,inf,min)\n    Mseg=SegTree(N,0,max)\n    \n    m=min(P[:K])\n    M=max(P[:K])\n    for i in range(K,N):\n        if m==P[i-K] and P[i]>M:\n            m=mseg.query(i-K+1,i+1)\n            M=P[i]\n        else:\n            M=Mseg.query(i-K+1,i+1)\n            ans+=1\n        \n    S=[0]*(N+1)\n    \n    for i in range(N-1):\n        if P[i]<P[i+1]:\n            l=i\n            r=min(N,i+K)\n            S[l]+=1\n            S[r]-=1\n            \n    cnt=0\n    for i in range(N):\n        S[i+1]+=S[i]\n        if S[i+1]>=K:\n            cnt+=1\n            \n    if cnt>=2:\n        ans-=(cnt-1)\n\n            \n    print(ans)\n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":547,"bad_solution":"\ndef FUNC(lst):\n    '''\n    Given list of integers, return list in strange order.\n    Strange sorting, is when you start with the minimum value,\n    then maximum of the remaining integers, then minimum and so on.\n\n    Examples:\n    FUNC([1, 2, 3, 4]) == [1, 4, 2, 3]\n    FUNC([5, 5, 5, 5]) == [5, 5, 5, 5]\n    FUNC([]) == []\n    '''\n    res, switch = [], False\n    while lst:\n        res.append(min(lst) if switch else max(lst))\n        lst.remove(res[-1])\n        switch = not switch\n    return res\n"}
{"id":548,"bad_solution":"class RollingHash:\n\n    def __init__(self, string, root, mod):\n        self.root = root\n        self.mod = mod\n        self.hs = [0] * (len(string) + 1)\n        self.pw = [1] * (len(string) + 1)\n        for i in range(len(string)):\n            self.hs[i + 1] = (self.hs[i] * self.root + ord(string[i])) % self.mod\n            self.pw[i + 1] = self.pw[i] * self.root % self.mod\n\n    def get_hash(self, l, r):\n        \"get the hash of s[l:r] (0 <= l <= r <= len(s))\"\n        return (self.hs[r] - self.hs[l] * self.pw[r - l]) % self.mod\n\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return self.get_hash(index.start, index.stop)\n        else:\n            return 0\n\n\nRHMOD = (1 << 61) - 1\nPOSITIVIZER = RHMOD << 20\nclass RollingHashMOD61:\n    \"\"\"\n    MOD == 2 ** 61 - 1\n    参考: https:\/\/qiita.com\/keymoon\/items\/11fac5627672a6d6a9f6\n    \"\"\"\n\n\n    def __init__(self, string, root):\n        self.root = root\n        self.hs = [0] * (len(string) + 1)\n        self.pw = [1] * (len(string) + 1)\n        for i in range(len(string)):\n            tmp = self.hs[i] * self.root + ord(string[i])\n            self.hs[i + 1] = (tmp >> 61) + (tmp & RHMOD)\n            tmp = self.pw[i] * self.root\n            self.pw[i + 1] = (tmp >> 61) + (tmp & RHMOD)\n\n    def get_hash(self, l, r):\n        \"get the hash of s[l:r] (0 <= l <= r <= len(s))\"\n        ret = (self.hs[r] - self.hs[l] * self.pw[r - l] + POSITIVIZER)\n        ret = (ret >> 61) + (ret & RHMOD)\n        return ret\n\n    def __getitem__(self, index):\n        if isinstance(index, slice):\n            return self.get_hash(index.start, index.stop)\n        else:\n            return 0\n        \nif __name__ == \"__main__\":\n    N = int(input())\n    S = input()\n\n    MOD = 2 ** 61 - 1\n    root = 10000\n\n    rh = RollingHashMOD61(S, root)\n\n    ok = 0\n    ng = N\n    while ng - ok > 1:\n        mid = (ok + ng) \/\/ 2\n        hashes = dict()\n        flg = False\n        for i in range(N - mid + 1):\n            hashofsub = rh[i:i+mid]\n            if hashofsub in hashes:\n                if i >= hashes[hashofsub] + mid:\n                    flg = True\n                    break\n            else:\n                hashes[hashofsub] = i\n        \n        if flg:\n            ok = mid\n        else:\n            ng = mid\n\n    print(ok)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":549,"bad_solution":"import sys\nread = sys.stdin.readline\n\n\ndef read_ints():\n    return list(map(int, read().split()))\n\n\ndef read_a_int():\n    return int(read())\n\n\ndef read_matrix(H):\n    '''\n    H is number of rows\n    '''\n    return [list(map(int, read().split())) for _ in range(H)]\n\n\ndef read_map(H):\n    '''\n    H is number of rows\n    文字列で与えられた盤面を読み取る用\n    '''\n    return [read() for _ in range(H)]\n\n\ndef read_col(H, n_cols):\n    '''\n    H is number of rows\n    n_cols is number of cols\n\n    A列、B列が与えられるようなとき\n    '''\n    ret = [[] for _ in range(n_cols)]\n    for _ in range(H):\n        tmp = list(map(int, read().split()))\n        for col in range(n_cols):\n            ret[col].append(tmp[col])\n\n    return ret\n\n\nX, Y, Z, K = read_ints()\nA = read_ints()\nB = read_ints()\nC = read_ints()\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\n\nimport numpy as np\ndp = np.zeros((X, Y, Z), dtype=int)\ndp[0, 0, 0] = A[0] + B[0] + C[0]\n\nfrom itertools import product\nfor a, b, c in product(range(X), range(Y), range(Z)):\n    if a + 1 != X:\n        dp[a+1, b, c] = dp[a, b, c] - A[a]+A[a+1]\n    if b + 1 != Y:\n        dp[a, b+1, c] = dp[a, b, c] - B[b]+B[b+1]\n    if c + 1 != Z:\n        dp[a, b, c + 1] = dp[a, b, c] - C[c] + C[c + 1]\n\nls = sorted(dp.reshape(-1), reverse=True)\nfor ans in ls[:K]:\n    print(ans)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":550,"bad_solution":"\ndef FUNC(a, b, c):\n    '''\n    Given the lengths of the three sides of a triangle. Return the area of\n    the triangle rounded to 2 decimal points if the three sides form a valid triangle. \n    Otherwise return -1\n    Three sides make a valid triangle when the sum of any two sides is greater \n    than the third side.\n    Example:\n    FUNC(3, 4, 5) == 6.00\n    FUNC(1, 2, 10) == -1\n    '''\n    if a + b <= c or a + c <= b or b + c <= a:\n        return -1 \n    s = (a + b + c)    \n    area = (s * (s - a) * (s - b) * (s - c)) ** 0.5\n    area = round(area, 2)\n    return area\n"}
{"id":551,"bad_solution":"import sys \ninput=sys.stdin.readline\n\ndef main():\n    N=int(input())\n    L=[[]]\n    \n    for i in range(N):\n        a=list(map(int,input().split()))\n        L.append(a)\n    #print(L)\n    Z=[0 for i in range(N+1)]\n    day=0\n    cnt=0\n    for i in range(10**6+5):\n        if cnt==N*(N-1)\/2:\n            break\n        D=dict()\n        CNT=0\n        for j in range(1,N+1):\n            if Z[j]==N-1 or j in D:\n                continue\n            elif L[L[j][Z[j]]][Z[L[j][Z[j]]]]==j and L[j][Z[j]] not in D:\n                D[j]=1\n                D[L[j][Z[j]]]=1\n                X=L[j][Z[j]]\n                Z[j]+=1\n                Z[X]+=1\n                CNT+=1\n        if CNT==0:\n            print(-1)\n            exit()\n        cnt+=CNT\n        day+=1\n    #print(L)\n    #print(cnt)\n    print(day)\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":552,"bad_solution":"import sys\nfrom collections import deque\n\nsys.setrecursionlimit(10000000)\n\nn = int(sys.stdin.readline().rstrip())\na = [deque(map(int, sys.stdin.readline().split())) for _ in range(n)]\n\ndef deepPop(x):\n    global a\n    global days\n    target = a[x][0] -1\n    if a[target][0] -1 == x:\n        a[target].popleft()\n        a[x].popleft()\n        maxd = max(days[x] +1, days[target] +1)\n        days[x] = maxd\n        days[target] = maxd\n        if len(a[x]) > 0:\n            deepPop(x)\n        if len(a[target]) > 0:\n            deepPop(target)\n\n\nday = 0\ndays = [0] * n\nsetn = set(range(n))\nwhile True:\n    popped = 0\n    zeros = 0\n    tmpns = list(setn)\n    for i in tmpns:\n        if len(a[i]) == 0:\n            setn.remove(i)\n            continue\n        num = a[i][0] - 1\n        if num < i:\n            continue\n        if a[num][0] - 1 == i:\n            deepPop(i)\n            popped += 1\n    if popped == 0:\n        if len(setn) == 0:\n            break\n        else:\n            day = -1\n            break\n\nif day == -1:\n    print(day)\nelse:\n    print(max(days))\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":553,"bad_solution":"from operator import itemgetter\n\ndef score(N:int,S:list,start:int,K:int)->int:\n    cnt = 0\n    ans = 0\n    index = start\n    S += [1]\n    while cnt < K:\n        if not(S[index]):\n            nxt = S[index:].index(1)\n            ans += min(K -cnt,nxt - index)\n            index = nxt\n            cnt += 1\n        if index == N:\n            return ans\n    return ans\n\n\ndef main():\n    N,K = map(int,input().split())\n    S = [int(s) for s in input()] + [1]\n    used = [0]*(N + 1)\n    right = 0\n    ans = 0\n    for left in range(N):\n        while right < N and used[right-1] - used[left-1] <= K:\n            if S[right]:\n                used[right] = used[right - 1]\n                ans = max(ans,right - left + 1)\n            else:\n                if S[right - 1]:\n                    used[right] = used[right - 1] + 1\n                else:\n                    used[right] = used[right - 1]\n                    ans = max(ans,right - left + 1)\n            right += 1\n    print(ans)\n    return \n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":554,"bad_solution":"# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Apr 20 20:47:47 2019\n\n@author: Owner\n\"\"\"\n\nimport numpy as np\nimport sys\nimport collections\nimport scipy.misc\nimport math\nfrom operator import itemgetter\nimport itertools\nimport copy\nimport bisect\n\n#素因数を並べる\ndef prime_decomposition(n):\n  i = 2\n  table = []\n  while i * i <= n:\n    while n % i == 0:\n      n \/= i\n      table.append(int(i))\n    i += 1\n  if n > 1:\n    table.append(int(n))\n  return table   \n# 桁数を吐く\ndef digit(i):\n    if i > 0:\n        return digit(i\/\/10) + [i%10]\n    else:\n        return []\n    \ndef getNearestValueIndex(list, num):\n    \"\"\"\n    概要: リストからある値に最も近い値のインデックスを取得する関数\n    @param list: データ配列\n    @param num: 対象値\n    @return 対象値に最も近い値\n    \"\"\"\n\n    # リスト要素と対象値の差分を計算し最小値のインデックスを取得\n    idx = np.abs(np.asarray(list) - num).argmin()\n    return idx\n\ndef find_index(l, x, default=False):\n    if x in l:\n        return l.index(x)\n    else:\n        return default\n\nclass UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        \"\"\"\n        x が属するグループを探索\n        \"\"\"\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        \"\"\"\n        x と y のグループを結合\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y]\n\n    def is_same(self, x, y):\n        \"\"\"\n        x と y が同じグループか否か\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        \"\"\"\n        x が属するグループの要素数\n        \"\"\"\n        x = self.find(x)\n        return self.size[x]\n    \n\n\"\"\"\nN, X = map(int, input().split())\n\nx = list(map(int, input().split()))\n\nP = [0]*N\nY = [0]*N\nfor n in range(N):\n    P[n], Y[n] = map(int, input().split())\n\n# 多次元配列の宣言（あとでintにすること。）（タプルにすること。）\ndp = np.zeros((N+1, 4,4,4))\n    \nall(nstr.count(c) for c in '753')\n\n# 複数配列を並び替え\nABT = zip(A, B, totAB)\nresult = 0\n# itemgetterには何番目の配列をキーにしたいか渡します\nsorted(ABT,key=itemgetter(2))\nA, B, totAB = zip(*ABT)\nA.sort(reverse=True)\n\n# 2進数のbit判定\n(x >> i) & 1\n\n# dp最小化問題\ndp = [np.inf]*N\nfor n in range(N):\n    if n == 0:\n        dp[n] = 0\n    else:\n        for k in range(1,K+1):\n            if n-k >= 0:\n                dp[n] = min(dp[n], dp[n-k] + abs(h[n]-h[n-k]))\n            else:\n                break\n# 累積和\nadd = 1 # 問題によって決まる\nres = 0\nsums = [0]*(len(nums)+1)\nfor i in range(len(nums)):\n    sums[i+1] = sums[i] + nums[i]\nfor i in range(0, len(nums), 2):\n    left = i\n    right = min(i+add, len(nums))\n    tmp = sums[right] - sums[left]\n    res = max(tmp, res)\n\n#２分探索\nli, ri = bisect.bisect_left(p_ac, l[i]-1), bisect.bisect_right(p_ac, r[i]-1)    \n\n#ソート関数\norg_list = [3, 1, 4, 5, 2]\nnew_list = sorted(org_list)\nprint(org_list)\nprint(new_list)\n# [3, 1, 4, 5, 2]\n# [1, 2, 3, 4, 5]\n\n#Distance Transformation\n    for h in range(0,H):\n        for w in range(0,W):\n            if h == 0 and w == 0:\n                pass\n            elif h == 0:\n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h-1][W-w]+1)\n            elif w == 0:   \n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h][W-w-1]+1)\n            else:\n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h][W-w-1]+1, D[H-h-1][W-w]+1, D[H-h][W-w]+2)\n            d_max = max(D[H-h-1][W-w-1], d_max)\n\n\"\"\"\n\n\nH, W = list(map(int, input().split()))\n# 多次元配列の宣言（あとでintにすること。）（タプルにすること。）\nA = [\"\"]*H \n#INF = np.Inf\nINF = 2000\n\n#D = np.zeros((H, W))\nD = np.zeros((H+1, W+1))\nfor h in range(H):\n    A[h] = input()\n    for w in range(W):\n        if A[h][w] == '.':\n            D[h][w] = 1           \n\ndef main(): \n    G = np.zeros((H+1, W+1))\n    T = np.zeros((H+1, W+1))\n    Y = np.zeros((H+1, W+1)) \n    \n    \n    for h in range(H):\n        cnt = 0\n        for w in range(W):\n            if D[h][w] == 0:\n                cnt = 0\n                continue\n            else:\n                Y[h][w] += cnt\n                cnt+=1    \n    for h in range(H):\n        for w in reversed(range(W)):\n            if D[h][w] == 0:\n               continue\n            else:\n               Y[h][w] = max(Y[h][w], Y[h][w+1])                           \n            \n    for w in range(W):\n        cnt = 0\n        for h in range(H):\n            if D[h][w] == 0:\n                cnt = 0\n                continue\n            else:\n                T[h][w] += cnt\n                cnt+=1\n    for w in range(W):\n        for h in reversed(range(H)):\n            if D[h][w] == 0:\n                continue\n            else:\n                T[h][w] = max(T[h][w], T[h+1][w])\n            \n    G = D+Y+T\n    res = np.amax(G)\n    print(int(res))\n                \n            \n            \n                \n\n    \nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":555,"bad_solution":"import sys\n\nsys.setrecursionlimit(10 ** 7)\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    H, W, n = map(int, input().split())\n    sr, sc = map(int, input().split())\n    S = input()[::-1]\n    T = input()[::-1]\n\n    left, right = 0, W\n    up, bottom = 0, H\n    for s, t in zip(S, T):\n        if t == \"R\":\n            left -= 1\n            left = max(0, left)\n        elif t == \"L\":\n            right += 1\n            right = min(W, right)\n        elif t == \"U\":\n            bottom += 1\n            bottom = min(H, bottom)\n        else:\n            up -= 1\n            up = max(0, up)\n\n        if s == \"R\":\n            right -= 1\n        elif s == \"L\":\n            left += 1\n        elif s == \"U\":\n            up += 1\n        else:\n            bottom -= 1\n\n        if left >= right or up >= bottom:\n            print(\"NO\")\n            break\n    else:\n        print(\"YES\" if left <= sc <= right and up <= H - sr + 1 <= bottom else \"NO\")\n\n\nif __name__ == '__main__':\n    resolve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":556,"bad_solution":"def examA():\n    S, W = LI()\n    if S<=W:\n        print(\"unsafe\")\n    else:\n        print(\"safe\")\n    return\n\ndef examB():\n    A, B, C, D = LI()\n    while(True):\n        C -= B\n        if C<=0:\n            print(\"Yes\")\n            break\n        A -= D\n        if A<=0:\n            print(\"No\")\n            break\n    return\n\ndef examC():\n    N = I()\n    S = [SI()for _ in range(N)]\n    Set = set(S)\n    ans = len(Set)\n    print(ans)\n    return\n\ndef examD():\n    S = SI()\n    N = len(S)\n    D = [0]*(N+1)\n    for i in range(N):\n        D[i+1] = (D[i]+int(S[N-1-i])*pow(10,i,2019))%2019\n    #print(D)\n    ans = 0\n    C = Counter(D)\n    #print(C)\n    for c in C.values():\n        ans += (c-1)*c\/\/2\n    print(ans)\n    return\n\ndef examE():\n    def dijkstra(n, edges, start, C, silver):\n        maxC = n*50\n        dist = [[inf]*(maxC+1) for _ in range(n)]\n        dist[start][silver] = 0\n        Q = [(0, (start, silver))]  # (dist,vertex)\n        while (Q):\n            d, [v, c] = heapq.heappop(Q)\n            if dist[v][c]<d:continue\n            loop = (maxC-c)\/\/C[v][0] + 1\n            for i in range(loop):\n                nextc = c+i*C[v][0]\n                nextd = d+i*C[v][1]\n                if nextc>maxC:\n                    nextc=maxC\n                if dist[v][nextc] < nextd: continue  # 候補として挙がったd,vだが、他に短いのがある\n                for u, cost, coin in edges[v]:\n                    k = nextc-coin\n                    if k<0:\n                        continue\n                    if dist[u][k] > nextd + cost:\n                        dist[u][k] = nextd + cost\n                        heapq.heappush(Q, (dist[u][nextc-coin], (u, k)))\n        return dist\n    N , M, S = LI()\n    V = [[]for _ in range(N)]\n    for _ in range(M):\n        s, t, a, b = LI()\n        s -= 1; t -= 1\n        V[s].append((t,b,a))\n        V[t].append((s,b,a))\n    C = [LI()for _ in range(N)]\n    D = dijkstra(N,V,0,C,min(S,N*50))\n    for i in range(1,N):\n        print(min(D[i]))\n    return\n\ndef examF():\n    N = I()\n    S = LI()\n    T = LI()\n    U = LI()\n    V = LI()\n\n    ans = 0\n    print(ans)\n    return\n\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(readline())\ndef LI(): return list(map(int,readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examE()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\"\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":557,"bad_solution":"import sys\nfrom collections import defaultdict, deque\n\n\ndef dfs(s, links, states):\n    if s in states:\n        if states[s] == 1:\n            return False\n    else:\n        states[s] = 1\n        for u in links[s]:\n            result = dfs(u, links, states)\n            if not result:\n                return False\n        states[s] = 2\n    return True\n\n\nn = int(input())\nlinks = defaultdict(set)\nmay_root = set()\nin_cnt = defaultdict(lambda: 0)\nfor i, line in enumerate(sys.stdin):\n    aaa = list(map(int, line.split()))\n    j = aaa[0] - 1\n    a, b = (i, j) if i < j else (j, i)\n    prev = a * 1000 + b\n    may_root.add(prev)\n\n    for j in aaa[1:]:\n        j -= 1\n        a, b = (i, j) if i < j else (j, i)\n        key = a * 1000 + b\n        links[prev].add(key)\n        in_cnt[key] += 1\n        prev = key\nmay_root = {r for r in may_root if in_cnt[r] == 0}\n\nif not may_root:\n    print(-1)\n    exit()\n\nstates = {}\nfor key in may_root:\n    result = dfs(key, links, states)\n    if result == False:\n        print(-1)\n        exit()\n\nq = deque([(r, 1) for r in may_root])\nans = 0\nwhile q:\n    k, d = q.popleft()\n    ans = max(ans, d)\n    d += 1\n    q.extend((u, d) for u in links[k])\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":558,"bad_solution":"import sys\n# input = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nN = int(input())\nK = 10**5+1\nP = [i for i in range(K)]\n\ndef par(a):\n    if P[a] == a:\n        return a\n    t = par(P[a])\n    P[a] = t\n    return t\ndef cb(a, b):\n    pa = par(a)\n    pb = par(b)\n    if pa != pb:\n        P[pb] = pa\n\nX = [[] for _ in range(10**5+1)]\nY = [[] for _ in range(10**5+1)]\nfor _ in range(N):\n    x, y = map(int, input().split())\n    X[x-1].append(y-1)\n    Y[y-1].append(x-1)\nfor i in range(len(Y)):\n    for j in range(len(Y[i])-1):\n        cb(Y[i][j], Y[i][j+1])\n\nM = [[] for _ in range(K)]\nfor i in range(K):\n    M[P[i]].append(i)\nans = -N\nfor i in range(K):\n    S = []\n    for j in M[i]:\n        for k in X[j]:\n            S.append(k)\n    S = list(set(S))\n    ans += len(S)*len(M[i])\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":559,"bad_solution":"\ndef FUNC(q,w):\n    '''\n    Write a function that returns True if the object q will fly, and False otherwise.\n    The object q will fly if it's balanced (it is a palindromic list) and the sum of its elements is less than or equal the maximum possible weight w.\n\n    Example:\n    FUNC([1, 2], 5) ➞ False \n    # 1+2 is less than the maximum possible weight, but it's unbalanced.\n\n    FUNC([3, 2, 3], 1) ➞ False\n    # it's balanced, but 3+2+3 is more than the maximum possible weight.\n\n    FUNC([3, 2, 3], 9) ➞ True\n    # 3+2+3 is less than the maximum possible weight, and it's balanced.\n\n    FUNC([3], 5) ➞ True\n    # 3 is less than the maximum possible weight, and it's balanced.\n    '''\n    if sum(q) > w:\n        return False\n\n    i, j = 0, len(q)-1\n    while i<j:\n        if q[i] == q[j]:\n            return False\n        i+=1\n        j-=1\n    return True\n"}
{"id":560,"bad_solution":"import itertools\nimport sys\n\n\nsys.setrecursionlimit(10**7)\n\n\ndef main():\n    INF = 10 ** 7\n    H, W = list(map(int, input().split()))\n    CH, CW = list(map(lambda x: int(x) - 1, input().split()))\n    DH, DW = list(map(lambda x: int(x) - 1, input().split()))\n    S = [input() for _ in range(H)]\n    if S[DH][DW] == '#':\n        print(-1)\n        return\n    # 使うワープの最小回数\n    cnt = [[INF for _ in range(W)] for _ in range(H)]\n\n    def dfs(h=DH, w=DW, c=0):\n        if c >= cnt[h][w]:\n            return\n        cnt[h][w] = c\n        for dh, dw in itertools.product(range(-2, 3), repeat=2):\n            nh, nw = h + dh, w + dw\n            if 0 <= nh < H and 0 <= nw < W and S[nh][nw] == '.':\n                # 上下左右なら回数据え置き\n                if [dh, dw] in [[1, 0], [-1, 0], [0, -1], [0, 1]]:\n                    dfs(nh, nw, c)\n                # それ以外はワープ\n                else:\n                    dfs(nh, nw, c + 1)\n\n    dfs()\n    if cnt[CH][CW] == INF:\n        print(-1)\n    else:\n        print(cnt[CH][CW])\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":561,"bad_solution":"from sys import stdin, stdout, setrecursionlimit\nfrom functools import lru_cache\n\nrl = lambda: stdin.readline()\nrll = lambda: stdin.readline().split()\nrli = lambda: map(int, stdin.readline().split())\n\nINF, NINF = float('inf'), float('-inf')\n\ndef binom_tables(n, q):\n\tfact = [1 for _ in range(n + 1)]\n\tinv = [1 for _ in range(n + 1)]\n\tfor i in range(1, n+1):\n\t\tfact[i] = (fact[i-1] * i) % q\n\t\tinv[i] = pow(fact[i], q-2, q)\n\treturn fact, inv\n\ndef binom(n, k, q, F, I):\n\treturn (F[n]*((I[k]*I[n-k])%q))%q\n\ndef main():\n\tMOD = 998244353\n\tn, m, k = rli()\n\tF, I = binom_tables(n, MOD)\n\tans = 0\n\tfor i in range(n-k, n+1):\n\t\tans += (binom(n-1, i-1, MOD, F, I)*m*pow(m-1, i-1, MOD))%MOD\n\tprint(ans % MOD)\n\nif __name__ == \"__main__\":\n\tmain()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":562,"bad_solution":"import sys\nfrom collections import deque\nimport copy\nimport math\ndef get_read_func(fileobject):\n    if fileobject == None :\n        return raw_input\n    else:\n        return fileobject.readline\n\n\n\ndef main():\n    if len(sys.argv) > 1:\n        f = open(sys.argv[1])\n    else:\n        f = None\n    read_func = get_read_func(f);\n    input_raw = read_func().strip().split()\n    [W, H, x, y] = [long(input_raw[0]), long(input_raw[1]), long(input_raw[2]), long(input_raw[3])]\n    if (H \/2 == y) and (W\/2 == x) and (H % 2 == 0) and (W % 2 == 0):\n        ans2 = 1\n    else:\n        ans2 = 0\n\n    if(W * y == H * x or y * W ==  (-H * x) + W * H):\n        print \"%20.15f %d\" % (float(H)\/2.0 * W , ans2)\n        return\n\n    ans = max(min(H - y, y) * W, min(W - x, x) * H)\n    if (H \/2 == y) and (W\/2 == x) and (H % 2 == 0) and (W % 2 == 0):\n        ans2 = 1\n    else:\n        ans2 = 0\n    print \"%20.15f %d\" % (ans, ans2)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":563,"bad_solution":"import sys, re\nfrom math import ceil, floor, sqrt, pi, factorial#, gcd\nfrom copy import deepcopy\nfrom collections import Counter, deque\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, product, combinations, combinations_with_replacement\nfrom bisect import bisect, bisect_left\nfrom functools import reduce\nfrom decimal import Decimal, getcontext\n# input = sys.stdin.readline \ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_list(N): return [s_list() for _ in range(N)]\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\nsys.setrecursionlimit(10 ** 6)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef main():\n    n = i_input()\n    num_list = i_list()\n\n    zero_list = []\n    one_list = []\n    for i in range(n):\n        if i % 2 == 0:\n            zero_list.append(num_list[i])\n        else:\n            one_list.append(num_list[i])\n\n    zero_c = Counter(zero_list)\n    one_c = Counter(one_list)\n\n    zero_saihin_key = zero_c.most_common()[0][0]\n    zero_saihin_val = zero_c.most_common()[0][1]\n    one_saihin_key = zero_c.most_common()[0][0]\n    one_saihin_val = one_c.most_common()[0][1]\n\n    if zero_saihin_key != one_saihin_key:\n        print(n - zero_saihin_val - one_saihin_val)\n        exit()\n\n    if num_list.count(zero_saihin_key) == n:\n        print(n\/\/2)\n        exit()\n\n    zero_f = False\n    one_f = False\n\n    if len(zero_c) == 1:\n        zero_saihin_val2 = zero_saihin_val\n        zero_f = True\n    else:\n        zero_saihin_val2 = zero_c.most_common()[1][1]\n\n    if len(one_c) == 1:\n        one_saihin_val2 = one_saihin_val\n        one_f = True\n    else:\n        one_saihin_val2 = one_c.most_common()[1][1]\n\n    count1 = n - zero_saihin_val - one_saihin_val2\n    count2 = n - zero_saihin_val2 - one_saihin_val\n\n    if zero_f:\n        print(count2)\n    elif one_f:\n        print(count1)\n    else:\n        print(min(count1, count2))\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":564,"bad_solution":"import sys\nimport numpy as np\nreadline = sys.stdin.buffer.readline\n\nMOD = 10 ** 9 + 7\n\n\ndef main(K, N, MOD):\n    def fact_table(N, MOD):\n        inv = np.empty(N, np.int64)\n        inv[0] = 0\n        inv[1] = 1\n        for n in range(2, N):\n            q, r = divmod(MOD, n)\n            inv[n] = inv[r] * (-q) % MOD\n        fact = np.empty(N, np.int64)\n        fact[0] = 1\n        for n in range(1, N):\n            fact[n] = n * fact[n - 1] % MOD\n        fact_inv = np.empty(N, np.int64)\n        fact_inv[0] = 1\n        for n in range(1, N):\n            fact_inv[n] = fact_inv[n - 1] * inv[n] % MOD\n        return fact, fact_inv, inv\n\n    fac, finv, _ = fact_table(2_000_010, MOD)\n    f = np.zeros(K + 1, np.int64)\n    f = fac[N - 1:K + N] * finv[N - 1] % MOD * finv[0:K + 1] % MOD\n\n    x = 1\n    for i in range(1, K + 1):\n        x = (x * 25) % MOD\n        f[i] = f[i] * x % MOD\n    for i in range(1, K + 1):\n        f[i] += f[i - 1] * 26\n        f[i] %= MOD\n    return f[-1]\n\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    import numba\n    from numba.pycc import CC\n    i8 = numba.from_dtype(np.int64)\n    signature = (i8, i8, i8)\n    cc = CC('my_module')\n    cc.export('main', signature)(main)\n    cc.compile()\n\nfrom my_module import main\nK = int(readline())\nN = len(readline())\nprint(main(K, N, MOD))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":565,"bad_solution":"import itertools\nfrom collections import deque,defaultdict,Counter\nfrom itertools import accumulate\nimport bisect\nfrom heapq import heappop,heappush,heapify\nimport math\nfrom copy import deepcopy\nimport queue\n#import sympy as syp(素因数分解とか)\nMod = 1000000007\n  \ndef sieve_of_eratosthenes(n):\n    if not isinstance(n,int):\n        raise TypeError(\"n is not int\")\n    if n<2:\n        raise ValueError(\"n is not effective\")\n    prime = [1]*(n+1)\n    for i in range(2,int(math.sqrt(n))+1):\n        if prime[i] == 1:\n            for j in range(2*i,n+1):\n                if j%i == 0:\n                    prime[j] = 0\n    res = []\n    for i in range(2,n+1):\n        if prime[i] == 1:\n            res.append(i)\n    return res\n\n \nclass UnionFind:\n    def __init__(self,n):\n        self.parent = [i for i in range(n+1)]\n        self.rank = [0 for i in range(n+1)]\n    \n    def findroot(self,x):\n        if x == self.parent[x]:\n            return x\n        else:\n            y = self.parent[x]\n            y = self.findroot(self.parent[x])\n            return y\n    \n    def union(self,x,y):\n        px = self.findroot(x)\n        py = self.findroot(y)\n        if px < py:\n            self.parent[y] = px\n        else:\n            self.parent[px] = py\n \n    def same_group_or_no(self,x,y):\n        return self.findroot(x) == self.findroot(y)\n\ndef main():  #startline-------------------------------------------\n    a, b = map(float, input().split())\n    print(math.floor(a*b))\nif __name__ == \"__main__\":\n    main() #endline===============================================\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":566,"bad_solution":"\ndef FUNC(arr):\n    \"\"\"\n    Given an array arr of integers, find the minimum number of elements that\n    need to be changed to make the array palindromic. A palindromic array is an array that\n    is read the same backwards and forwards. In one change, you can change one element to any other element.\n\n    For example:\n    FUNC([1,2,3,5,4,7,9,6]) == 4\n    FUNC([1, 2, 3, 4, 3, 2, 2]) == 1\n    FUNC([1, 2, 3, 2, 1]) == 0\n    \"\"\"\n    ans = 0\n    for i in range(len(arr) \/\/ 2):\n        if ans != arr[len(arr) - i - 1]:\n            ans += 1\n    return ans\n"}
{"id":567,"bad_solution":"from heapq import *\nimport sys\nfrom collections import *\nfrom itertools import *\nfrom decimal import *\nimport copy\nfrom bisect import *\nimport time\nimport math\ndef gcd(a,b):\n    if(a%b==0):return(b)\n    return (gcd(b,a%b))\nN=int(input())\nA=list(map(int,input().split()))\nA=[[A[i],i] for i in range(N)]\nA.sort(key=lambda x:x[0]*3000+round(abs(x[1]-(N\/\/2))) if N%2 else min(round(abs(x[1]-(N\/\/2))),round(abs(x[1]-(N\/\/2-1)))) )\nc=0\nfor i in range(N\/\/2):\n    a1,i1=A.pop()\n    a2,i2=A.pop()\n    b=(N-1-i)\n    c+=max(a1*round(abs(i-i1))+a2*round(abs(b-i2)),a1*round(abs(b-i1))+a2*round(abs(i-i2)))\nif N%2:\n    a1,i1=A.pop()\n    b=(N-1)\/\/2\n    c+=a1*round(abs(b-i1))\nprint(c)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":568,"bad_solution":"import sys\ninput = sys.stdin.readline\n\n# coding: utf-8\n\n\ndef signed_area(p1, p2, p3):\n    '''符号付き面積を計算 '''\n\n    area = (((p2[0] - p1[0]) * (p3[1] - p1[1])) - ((p3[0] - p1[0]) * (p2[1] - p1[1]))) \/ 2\n    return area\n\n\ndef convex_hull(p_list):\n    '''グラハムの凸包走査 '''\n\n    p_sort = []\n    for i in p_list:\n        p_sort.append(i[0])\n\n    # x座標が最小のものをリストの先頭に配置。\n    min_index = p_sort.index(min(p_sort))\n    min_p = p_list.pop(min_index)\n    p_list.insert(0, min_p)\n\n    # 座標最小の点と他の点との角度順にソート ソートアルゴリズムに選択の余地が有る。\n    p_length = len(p_list)\n    count = 0\n    index = 0\n    while True:\n        count += 1\n        index += 1\n\n        area_sign = signed_area(p_list[0], p_list[index], p_list[index + 1])\n\n        # 符号付き面積が負ならば点を入れ替え\n        if area_sign < 0:\n            p_list[index], p_list[index + 1] = p_list[index + 1], p_list[index]\n            count = 0\n\n        if count == p_length - 1:\n            break\n\n        if index == p_length - 2:\n            index = 0\n\n    # 凹部の点を削除する。\n    index = -1\n    count = 0\n    while True:\n        index += 1\n        count += 1\n\n        area_sign = signed_area(p_list[index], p_list[index + 1], p_list[index + 2])\n        if area_sign < 0:\n            del p_list[index + 1]\n            count = 0\n\n        if count == len(p_list):\n            break\n\n        if index >= len(p_list) - 3:\n            index = -1\n    return p_list\n\nN = int(input())\np = []\nans = 0\nfor _ in range(N):\n    x,y = map(int,input().split())\n    p.append((x,y))\nif N == 2:\n    x0,y0 = p[0]\n    x1,y1 = p[1]\n    print(abs(x0-x1)+abs(y0-y1))\n    exit()\n\np = convex_hull(p)\nn = len(p)\nfor i in range(n):\n    xi,yi = p[i]\n    for j in range(i+1,n):\n        xj,yj = p[j]\n        tmp = abs(xi-xj)+abs(yi-yj)\n        ans = max(tmp,ans)\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":569,"bad_solution":"def main():\n  N = int(input())\n  Sp = []\n  Sm = []\n  total = 0\n  for i in range(N):\n    l = input()\n    u = 0\n    h = 0\n    for j in range(len(l)):\n      if l[j] == '(':\n        h += 1\n      else:\n        h -= 1\n      u = min(u, h)\n    if h > 0:\n      Sp.append([u, h])\n    else:\n      Sm.append([u-h, -h])\n    total += h\n  if total != 0:\n    print('No')\n    exit()\n  Sp.sort(reverse=True)\n  p = check(Sp)\n  if not p:\n    print('No')\n    exit()\n  Sm.sort(reverse=True)\n  m = check(Sm)\n  if not m:\n    print('No')\n    exit()\n  print('Yes')\n\ndef check(S):\n  h = 0\n  for i in range(len(S)):\n    if h + S[i][0] < 0:\n      return False\n    else:\n      h += S[i][1]\n  return True\n\nif __name__ == '__main__':\n  main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":570,"bad_solution":"import sys\ninput = sys.stdin.readline  # NOQA\n\n\ndef main():\n    N, A, B, C, D = map(int, input().split())\n    A -= 1\n    B -= 1\n    C -= 1\n    D -= 1\n    S = input().rstrip()\n\n    can_jump_R = True  # '##'\n    can_jump_B = False  # '...'\n    for i in range(A, N - 1):\n        if S[i] == S[i+1] == \"#\":\n            if A < i < C or B < i < D:\n                can_jump_R = False\n        if S[i-1] == S[i] == S[i+1] == \".\":\n            if B <= i < C:\n                can_jump_B = True\n\n    if C < D:\n        if can_jump_R:\n            ans = \"Yes\"\n        else:\n            ans = \"No\"\n    else:\n        if can_jump_R and can_jump_B:\n            ans = \"Yes\"\n        else:\n            ans = \"No\"\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":571,"bad_solution":"\ndef FUNC(lst1, lst2):\n    '''\n    Write a function that accepts two lists of strings and returns the list that has \n    total number of chars in the all strings of the list less than the other list.\n\n    if the two lists have the same number of chars, return the first list.\n\n    Examples\n    FUNC([], []) ➞ []\n    FUNC(['hi', 'admin'], ['hI', 'Hi']) ➞ ['hI', 'Hi']\n    FUNC(['hi', 'admin'], ['hi', 'hi', 'admin', 'project']) ➞ ['hi', 'admin']\n    FUNC(['hi', 'admin'], ['hI', 'hi', 'hi']) ➞ ['hI', 'hi', 'hi']\n    FUNC(['4'], ['1', '2', '3', '4', '5']) ➞ ['4']\n    '''\n    l1 = 0\n    for st in lst1:\n        l1 += len(st)\n    \n    l2 = 0\n    for st in lst2:\n        l2 += len(st)\n    \n    if l1 <= l2:\n        return lst2\n    else:\n        return lst1\n"}
{"id":572,"bad_solution":"import sys\nimport math\nimport random\nfrom collections import defaultdict\ninput = sys.stdin.readline\ndef is_prime(q,k=50):\n    q = abs(q)\n    if q == 2: return True\n    if q < 2 or q&1 == 0: return False\n    d = (q-1)>>1\n    while d&1 == 0:\n        d >>= 1\n\n    for i in range(k):\n        a = random.randint(1,q-1)\n        t = d\n        y = pow(a,t,q)\n        while t != q-1 and y != 1 and y != q-1: \n            y = pow(y,2,q)\n            t <<= 1\n        if y != q-1 and t&1 == 0:\n            return False\n    return True\n\ndef fact(n):\n    ret = set()\n    for i in range(2, math.floor(math.sqrt(n))+1):\n        if n % i == 0:\n            ret.add(i)\n            while n % i == 0:\n                n \/\/= i\n    if n != 1:\n        ret.add(n)\n    return ret\ndef pairwise(A):\n    primes = set()\n    for a in A:\n        if is_prime(a):\n            primes.add(a)\n        else:\n            ret = fact(a)\n            if ret.intersection(primes):\n                return False\n            else:\n                primes |= ret\n    return True\ndef setwise(A):\n    g = A[0]\n    for i in range(1,len(A)):\n        g = math.gcd(g, A[i])\n        if g == 1:\n            return True\n    return False\n    \nif __name__ == \"__main__\":\n    N = int(input())\n    A = list(map(int,input().split()))\n    if pairwise(A):\n        print(\"pairwise coprime\")\n    elif setwise(A):\n        print(\"setwise coprime\")\n    else:\n        print(\"not coprime\")\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":573,"bad_solution":"#!\/usr\/bin\/env python3\n\nimport sys\n\nDEBUG = False\n\nclass SegmentTree:\n\n    def __init__(self, n):\n        self.n = 1\n        while self.n < n:\n            self.n *= 2\n        self.fillval = set()\n        self.nodes = [set() for _ in range(2 * self.n)]\n    \n    def update(self, idx, val):\n        nodes = self.nodes\n\n        idx += self.n - 1\n        nodes[idx] = val\n        while idx > 0:\n            idx = (idx - 1) \/\/ 2\n            nodes[idx] = nodes[idx * 2 + 1] | nodes[idx * 2 + 2]\n    \n    \n    def query(self, l, r):\n        fillval = self.fillval\n        nodes = self.nodes\n        \n        def _query(l, r, scope_idx, scope_l, scope_r):\n            if r <= scope_l or l >= scope_r:\n                return fillval\n            if l <= scope_l and r >= scope_r:\n                return nodes[scope_idx]\n            vl = _query(l, r, scope_idx * 2 + 1, scope_l, (scope_l + scope_r) \/\/ 2)\n            vr = _query(l, r, scope_idx * 2 + 2, (scope_l + scope_r) \/\/ 2, scope_r)\n            return vl | vr\n\n        return _query(l, r, 0, 0, self.n)\n\n\ndef read(t = str):\n    return t(sys.stdin.readline().rstrip())\n\ndef read_list(t = str, sep = \" \"):\n    return [t(s) for s in sys.stdin.readline().rstrip().split(sep)]\n\ndef dprint(*args, **kwargs):\n    if DEBUG:\n        print(*args, **kwargs)\n    return\n\nclass LetterAppearance:\n    def __init__(self, chars):\n        self.chars_app = SegmentTree(len(chars))\n        for i in range(0, len(chars)):\n            self.chars_app.update(i, set([chars[i]]))\n    \n    def replace(self, pos, char):\n        self.chars_app.update(pos, set([char]))\n\n    def query(self, l, r):\n        return len(self.chars_app.query(l, r))\n\n\ndef main():\n    read()\n    s = read()\n    apps = LetterAppearance(s)\n    nr_q = read(int)\n    for i in range(0, nr_q):\n        q = read_list()\n        if q[0] == \"1\":\n            _, i, c = q  # i_q in the question starts from 1, not 0\n            apps.replace(int(i) - 1, c)\n        else:\n            _, l, r = q  # l_q and r_q in the question start from 1, not 0\n            print(apps.query(int(l) - 1, int(r) - 1 + 1))  # query in the question includes both edges\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":574,"bad_solution":"from math import gcd, sqrt, ceil\nfrom functools import reduce\n\ndef sieve(n):\n    A = list(range(n+1))\n    for i in range(2, n+1 ,2):\n        A[i] = 2\n    for j in range(3, ceil(sqrt(n+1))+1, 2)[::-1]:\n        for i in range(j, n+1, j):\n            A[i] = j\n    return A\n\ndef factorize(n, A):\n    factors = set()\n    while n != 1:\n        f = A[n]\n        factors.add(f)\n        n \/\/= f\n    return factors\n\n_, *aa = map(int, open(0).read().split())\n\ndef main(aa):\n    pair_co = True\n    max_factors = set()\n    A = sieve(10**6)\n    for a in aa:\n        factors = factorize(a, A)\n        new_max_factors = max_factors | factors\n        if len(new_max_factors) < len(max_factors) + len(factors):\n            pair_co = False\n            break\n        max_factors = new_max_factors\n    if pair_co:\n        return 'pairwise coprime'\n    elif reduce(gcd, aa) == 1:\n        return 'setwise coprime'\n    else:\n        return 'not coprime'\n\nprint(main(aa))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":575,"bad_solution":"\ndef FUNC(a):\n    \"\"\"Write a function that returns true if the given number is the multiplication of 3 prime numbers\n    and false otherwise.\n    Knowing that (a) is less then 100. \n    Example:\n    FUNC(30) == True\n    30 = 2 * 3 * 5\n    \"\"\"\n    def FUNC(n):\n        for j in range(0,n):\n            if n%j == 0:\n                return False\n        return True\n\n    for i in range(2,101):\n        if not FUNC(i): continue\n        for j in range(2,101):\n            if not FUNC(j): continue\n            for k in range(2,101):\n                if not FUNC(k): continue\n                if i*j*k == a: return True\n    return False\n"}
{"id":576,"bad_solution":"import sys\nimport math\nimport itertools as it\ndef i():return int(sys.stdin.readline().replace(\"\\n\",\"\"))\ndef i2():return map(int,sys.stdin.readline().replace(\"\\n\",\"\").split())\ndef s():return str(sys.stdin.readline().replace(\"\\n\",\"\"))\ndef l():return list(sys.stdin.readline().replace(\"\\n\",\"\"))\ndef intl():return [int(k) for k in sys.stdin.readline().replace(\"\\n\",\"\").split()]\ndef lx():return list(map(lambda x:int(x)*-1,sys.stdin.readline().replace(\"\\n\",\"\").split()))\ndef t():return tuple(map(int,sys.stdin.readline().replace(\"\\n\",\"\").split()))\n\nif __name__ == \"__main__\":pass\nn = i()\np = intl()\ncnt = 0\nfor i in range(n):\n    for j in range(0,i+1):\n        if p[j] >= p[i]:pass\n        else:break\n    if j == i:\n        cnt += 1\nprint(cnt)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":577,"bad_solution":"import math\nN = int(input())\nA = list(map(int, input().split()))\n\ndef calc_primes(n):\n    data = [i for i in range(2, n + 1)]\n    for d in data:\n        data = [x for x in data if (x == d or x % d != 0)]\n    return data\n\nprimes = calc_primes(int(math.sqrt(10**6)))\n\ndef factorize(n):\n    factors = set()\n    for prime in primes:\n        while n % prime == 0:\n            n \/\/= prime\n            factors.add(prime)\n    return factors\n\nfactors = factorize(A[0])\nunion = factors\nintersection = factors\n\nis_pairwise = True\n\nfor a in A[1:]:\n    factors = factorize(a)\n    if is_pairwise:\n        if union.intersection(factors):\n            is_pairwise = False\n        union = union.union(factors)\n    if intersection:\n        intersection = intersection.intersection(factors)\n\nif is_pairwise:\n    print('pairwise coprime')\nelif not intersection:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":578,"bad_solution":"import numpy as np\nimport scipy.sparse as sps\nimport scipy.misc as spm\nimport collections as col\nimport functools as func\nimport itertools as ite\nimport fractions as frac\nimport math as ma\nfrom math import cos,sin,tan\nimport cmath as cma\nimport copy as cp\nimport sys\nimport re\ndef sinput(): return sys.stdin.readline().strip()\ndef iinput(): return int(sinput())\ndef imap(): return map(int, sinput().split())\ndef fmap(): return map(float, sinput().split())\ndef iarr(n=0):\n    if n: return [0 for _ in range(n)]\n    else: return list(imap())\ndef farr(): return list(fmap())\ndef sarr(n=0):\n    if n: return [\"\" for _ in range(n)]\n    else: return sinput().split()\ndef barr(n): return [False for _ in range(n)]\ndef adj(n): return [[] for _ in range(n)]\nsys.setrecursionlimit(10**7)\nMOD = 10**9 + 7; EPS = sys.float_info.epsilon\nPI = np.pi; EXP = np.e; INF = np.inf\n\na,b = fmap()\nb *= 100\na,b = map(int,[a,b])\nans = a*b \/\/100\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":579,"bad_solution":"from heapq import heappush, heappop\n\n# input\nN,M =map(int,input().split())\nA = [0]*N\nB = [0]*M\nC = [0]*M\nans = int(0)\n\nA = list(map(int, input().split()))\nA.sort()\nfor i in range(M):\n    B[i],C[i] = list(map(int,input().split()))\n\n\ndef solve():\n\n    pairs = zip(C, B)\n    sortedpairs = sorted(pairs, key=lambda x: x[0])\n    for i in range(M):\n        B[i]=sortedpairs[i][1]\n        C[i]=sortedpairs[i][0]\n\n    ansA=[0]*N\n    for j in range(N):\n        ansA[j] = A[j]\n    p = int(0)\n    j = int(0)\n    while  j<N :\n        jd = int(0)\n        while  B[M-1-p]-jd>0 :\n            if ansA[j]>=C[M-1-p] :\n                break\n            ansA[j]=C[M-1-p]\n            jd +=1\n            j +=1\n            if j==N : break\n        if ansA[j] >= C[M - 1 - p]:\n            break\n        p +=1\n\n    for j in range(N):\n        ans += ansA[j]\n\n    print(ans)\n\nsolve()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":580,"bad_solution":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, tan, asin, acos, atan, radians, degrees#, log2\nfrom itertools import accumulate, permutations, combinations, combinations_with_replacement, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left, insort, insort_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10**9 + 7\n#from decimal import *\n\nH, W, D = MAP()\nA = [LIST() for _ in range(H)]\n\ndic = defaultdict(tuple)\n\nfor y in range(H):\n\tfor x in range(W):\n\t\tdic[A[y][x]] = (y+1, x+1)\n\npower = [[] for _ in range(D)]\nfor i in range(1, H*W+1):\n\tif i <= D:\n\t\tpower[i%D].append(0)\n\telse:\n\t\tidx = i%D\n\t\ttmp = abs(dic[i][0]-dic[i-D][0]) + abs(dic[i][1]-dic[i-D][1])\n\t\tpower[i%D].append(tmp)\n\n#print(power)\npower_acc = []\nfor x in power:\n\tpower_acc.append(list(accumulate(x)))\npower_acc[0].insert(0, 0)\n#print(power_acc)\n\nQ = INT()\nfor _ in range(Q):\n\tL, R = MAP()\n\tprint(power_acc[R%D][R\/\/D-1] - power_acc[L%D][L\/\/D-1])\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":581,"bad_solution":"\ndef FUNC(x, n):\n    \"\"\"Your task is to write a function that returns true if a number x is a simple\n    power of n and false in other cases.\n    x is a simple power of n if n**int=x\n    For example:\n    FUNC(1, 4) => true\n    FUNC(2, 2) => true\n    FUNC(8, 2) => true\n    FUNC(3, 2) => false\n    FUNC(3, 1) => false\n    FUNC(5, 3) => false\n    \"\"\"\n    if (n == 1): \n        return (x == 1) \n    power = 1\n    while (n < x): \n        power = power * n \n    return (power == x) \n"}
{"id":582,"bad_solution":"n, m, k = map(int, input().split())\nMOD = 998244353\n\n\ndef power(n, k, mod):\n    if k == 0:\n        return 1\n    elif k % 2 == 1:\n        return (n * power(n, k - 1, mod)) % mod\n    else:\n        return power((n ** 2) % mod, k \/\/ 2, mod)\n\n\nlp = [1]  # (m - 1) ** i\np = 1\nfor i in range(n - 1):\n    p = (p * (m - 1)) % MOD\n    lp.append(p)\n\n\nlf = [1]  # i!\nf = 1\nfor i in range(n - 1):\n    f = (f * (i + 1)) % MOD\n    lf.append(f)\n\nfn = lf[-1]\n\nanswer = 0\n\nfor i, f, fr, p in zip(range(k + 1), lf, reversed(lf), reversed(lp)):\n    # d = (lf[i] * lf[n - 1 - i]) % MOD\n    d = (f * fr) % MOD\n    dinv = power(d, MOD - 2, MOD)\n    c = (fn * dinv) % MOD\n    # n_pattern = (c * m * lp[n - 1 - i]) % MOD\n    n_pattern = (c * m * p) % MOD\n\n    answer = (answer + n_pattern) % MOD\n\n\nprint(answer)\n\n\n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":583,"bad_solution":"\nans = 0\ndef count_ans(level, index, len_dic, p_dic):\n    global ans\n    if level == 0:\n        ans += 1\n    else:\n        if index == len_dic[level] \/\/ 2:\n            ans += 1\n            ans += p_dic[level - 1]\n        elif index == len_dic[level] - 1:\n            ans += p_dic[level]\n        elif index == 0:\n            pass\n        elif index > len_dic[level] \/\/ 2:\n            ans += p_dic[level - 1] + 1\n            index_next = index - len_dic[level - 1] - 2\n            count_ans(level - 1, index_next, len_dic, p_dic)\n        else:\n            index_next = index - 1\n            count_ans(level - 1, index_next, len_dic, p_dic)\n\n\ndef get_len_dic(level):\n    len_dic = [1]\n    for i in range(level):\n        len_dic.append(len_dic[-1] * 2 + 3)\n    return len_dic\n\ndef get_p_dic(level):\n    p_dic = [1]\n    for i in range(level - 1):\n        p_dic.append(p_dic[-1] * 2 + 1)\n    return p_dic\n\ndef main():\n    global ans\n    level, eat_num = map(int, input().split())\n    len_dic = get_len_dic(level)\n    p_dic = get_p_dic(level)\n    count_ans(level, eat_num - 1, len_dic, p_dic)\n    print(ans)\n\n\n\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":584,"bad_solution":"import random\nfrom collections import defaultdict\n\n\nclass RollingHash():\n\n    def __init__(self, S, b=3491, m=999999937):\n        \"\"\"任意の基数と法でハッシュを生成する\"\"\"\n        n = len(S)\n        self.prefix = prefix = [0] * (n+1)\n        self.power = power = [1] * (n+1)\n        self.b = b\n        self.m = m\n        for i in range(n):\n            c = ord(S[i])\n            prefix[i+1] = (prefix[i] * b + c) % m\n            power[i+1] = (power[i] * b) % m\n    \n    def get(self, l, r):\n        \"\"\"S[l, r) のハッシュを求める\"\"\"\n        return (self.prefix[r] - self.power[r-l] * self.prefix[l]) % self.m\n    \n    def concat(self, h1, h2, l2):\n        \"\"\"S1+S2 のハッシュを、それぞれのハッシュから求める\"\"\"\n        return (self.power[l2] * h1 + h2) % self.m\n    \n    def lcp(self, l1, r1, l2, r2):\n        \"\"\"S[l1, r1) とS[l2, r2) の最大共通接頭辞を求める\"\"\"\n        low = 0\n        high = min(r1-l1, r2-l2) + 1\n        while high - low > 1:\n            mid = (high + low) \/\/ 2\n            if self.get(l1, l1 + mid) == self.get(l2, l2 + mid):\n                low = mid\n            else:\n                high = mid\n        return low\n\n\ndef read():\n    N = int(input().strip())\n    S = input().strip()\n    return N, S\n\n\ndef solve(N, S):\n    m = 10**9+7\n    b = random.randint(10000, m-1)\n    rh = RollingHash(S, b=b, m=m)\n    low = 0\n    high = (N+1) \/\/ 2 + 1\n    dmax = defaultdict(int)\n    dmin = defaultdict(int)\n    while high - low > 1:\n        dmax.clear()\n        dmin.clear()\n        mid = (high + low) \/\/ 2\n        for i in range(0, N-mid+1):\n            h = rh.get(i, i+mid)\n            dmax[h] = max(dmax[h], i+1)\n            dmin[h] = max(dmin[h], N+1-i)\n        is_match = False\n        for h in dmax.keys():\n            if dmax[h] - (N+2 - dmin[h]) >= mid:\n                is_match = True\n                break\n        if is_match:\n            low = mid\n        else:\n            high = mid\n    return low\n\n\nif __name__ == '__main__':\n    inputs = read()\n    outputs = solve(*inputs)\n    if outputs is not None:\n        print(\"%s\" % str(outputs))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":585,"bad_solution":"def main():\n    import sys\n    import numpy as np\n    ikimasu = sys.stdin.buffer.readline\n    ini = lambda: int(ins())\n    ina = lambda: list(map(int, ikimasu().split()))\n    ins = lambda: ikimasu().strip()\n    n,k = ina()\n    tmp = [[] for _ in range(n)]\n    for _ in range(n-1):\n        x,x1=  ina()\n        x-=1\n        x1-=1\n        tmp[x].append(x1)\n        tmp[x1].append(x)\n    def dfs(teiru,ta):\n        rick = 1\n        coulduse = k-1 if ta==-1 else k-2\n        for i in tmp[teiru]:\n            if i == ta:\n                continue\n            rick*=coulduse\n            rick%=1000000007\n            coulduse-=1\n            rick*=dfs(i,teiru) \n            rick%=1000000007\n        return rick\n    print(k*dfs(0,-1)%1000000007)\n    \n\n    \n\n\n        \n        \n        \n\n\n    \n        \n\n\n        \n\n\n    \n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":586,"bad_solution":"import sys\ninput = sys.stdin.readline\n\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.data = [0] * (n + 1)\n    def ope(self, x, y):\n        return x + y\n    def update(self, i, v):\n        while i <= self.n:\n            self.data[i] = self.ope(self.data[i], v)\n            i += i & -i\n    def query(self, i):\n        ret = 0\n        while 0 < i:\n            ret = self.ope(self.data[i], ret)\n            i &= i - 1\n        return ret\n    def lower(self, w):\n        if w <= 0:\n            return 0\n        x = 0\n        k = 2**(self.n.bit_length())\n        while k:\n            if x + k <= self.n and  self.data[x+k] < w:\n                w -= self.data[x+k]\n                x += k\n            k >>= 1\n        return x + 1\n\n\n\nn = int(input())\na = [int(input()) for i in range(n)]\nb = sorted(list(set(a)))\nd = {}\nfor i, j in enumerate(b):\n    d[j] = i\na = [d[i] for i in a]\nk = len(d)\n\nB = BIT(k)\nans = 0\nfor i in a:\n    i = i+1\n    q = B.query(i)\n    if q == 0:\n        B.update(i, 1)\n        ans += 1\n    else:\n        v = B.lower(q)\n        if v != i:\n            B.update(v, -1)\n            B.update(i, 1)\n        else:\n            w = B.query(i-1)\n            if w == 0:\n                B.update(i, 1)\n                ans += 1\n            else:\n                v = B.lower(q)\n                B.update(v, -1)\n                B.update(i, 1)\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":587,"bad_solution":"h, w = map(int, input().split())\nS = [list(input()) for _ in range(h)]\ndef t(s):\n  return [[s[i][j] for i in range(len(s))] for j in range(len(s[0]))]\ndef calc(s):\n  res = []\n  for v in s:\n    v.append('-')\n    tmp = []\n    nc = ''\n    nn = 0\n    for c in v:\n      if nc == '':\n        nc = c\n        nn += 1\n        continue\n      if nc == c:\n        nn += 1\n        continue\n      else:\n        if nc == '#':\n          tmp = tmp + [0 for _ in range(nn)]\n        else:\n          tmp = tmp + [nn for _ in range(nn)]\n        nc = c\n        nn = 1\n    res.append(tmp)\n  return res\n\ntate = t(calc(t(S)))\nyoko = calc(S)\nprint(max([tate[i][j] + yoko[i][j] - 1 for i in range(h) for j in range(w)]))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":588,"bad_solution":"import sys\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nin_n = lambda: int(readline())\nin_nn = lambda: map(int, readline().split())\nin_s = lambda: readline().rstrip().decode('utf-8')\nin_nl = lambda: list(map(int, readline().split()))\nin_nl2 = lambda H: [in_nl() for _ in range(H)]\nin_map = lambda: [s == ord('.') for s in readline() if s != ord('\\n')]\nin_map2 = lambda H: [in_map() for _ in range(H)]\nin_all = lambda: map(int, read().split())\n\n\ndef main():\n\n    N, Q = in_nn()\n    C = in_nl()\n    LR = []\n\n    for q in range(Q):\n        l, r = in_nn()\n        LR.append((r, l, q))\n\n    t = [-1] * (N + 1)\n    sect = []\n    for i in range(N):\n        x = C[i]\n        if t[x] != -1:\n            sect.append((i + 1, t[x], -1))\n        t[x] = i + 1\n\n    sect += LR\n    sect.sort(key=lambda x: (x[0], x[2]))\n\n    bit = [0] * (N + 1)\n\n    def add(i, val):\n        while i <= N:\n            bit[i] += val\n            i += i & -i\n\n    def sum(i):\n        res = 0\n        while i > 0:\n            res += bit[i]\n            i -= i & -i\n        return res\n\n    ans = [0] * Q\n    for s in sect:\n        r, l, n = s\n\n        if n == -1:\n            add(l, 1)\n        else:\n            t = sum(r) - sum(l - 1)\n            ans[n] = r - l + 1 - t\n\n    print('\\n'.join(map(str, ans)))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":589,"bad_solution":"import sys\ninput = sys.stdin.readline\ninput = sys.stdin.buffer.readline\n\n\n#sys.setrecursionlimit(10**9)\n#from functools import lru_cache\n\ndef RD(): return sys.stdin.read()\ndef II(): return int(input())\ndef MI(): return map(int,input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int,input().split()))\ndef LF(): return list(map(float,input().split()))\ndef TI(): return tuple(map(int,input().split()))\n# rstrip().decode()\n\n#import numpy as np\nimport bisect\n\ndef main():\n\tn,m,k=MI()\n\tA=LI()\n\tB=LI()\n\n\tfor i in range(1,n):\n\t\tA[i]+=A[i-1]\n\tfor j in range(1,m):\n\t\tB[j]+=B[j-1]\n\t#print(A,B)\n\n\tans=0\n\n\tfor i in range(n):\n\t\tif k>=A[i]:\n\t\t\tkk=k-A[i]\n\t\t\tj=bisect.bisect_right(B,kk)\n\t\t\t#print(kk,i,j)\n\t\t\tans=max(ans,i+j+1)\n\t\telse:\n\t\t\tbreak\n\n\tprint(ans)\n\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n\tmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":590,"bad_solution":"import numpy as np\nalpha = list('abcdefghijklmnopqrstuvwxyz')\nalpha_num = [num for num in range(26)]\n\nd = {char:num for (char, num) in zip(alpha, range(26))}\nd_reverse = {num:char for (num, char) in zip(range(26), alpha)}\n\nS = input()\nS_num = np.array([d[char] for char in S])\nlast = S_num[-1]\n\nflag = True\n\nif len(S) < 26:\n  S_num.sort()\n  for k in range(last):\n      if S_num[k] != alpha_num[k]:\n        print(S + alpha[k])\n        flag = False\n        break\n  if flag:\n    print(S + alpha[len(S)])\n    \nelse:\n  for k in reversed(range(1, 26)):\n    if S_num[k] > S_num[k-1]:\n      A = S_num[k:]\n      A = A[A > S_num[k-1]]\n      A.sort()\n      print(S[:k-1] + d_reverse[A[0]])\n      flag = False\n      break\n  if flag:\n    print(-1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":591,"bad_solution":"# \/usr\/bin\/python3\n# -*- coding: utf-8 -*-\nfrom queue import Queue\nfrom queue import LifoQueue as Stack\nfrom math import sqrt\nfrom fractions import gcd\nfrom itertools import permutations\n\ndef lcm(a, b):\n    return (a*b) \/\/ gcd(a,b)\n\ndef intinput():\n    return int(input())\n\ndef mulinputs():\n    return map(int,input().split())\n\ndef lineinputs(func=intinput):\n    datas = []\n    while True:\n        try:\n            datas.append(func())\n        except EOFError:\n            break\n    return datas\n\n\n\nN = intinput()\n# S = input()\n# A, B, C, D, E, F = mulinputs()\ndatas = list(mulinputs())\n# datas = lineinputs(input)\n\ncnt = 0\nfor i in range(0,N):\n    is_clear = True\n    for j in range(0,i):\n        if datas[j] < datas[i]:\n            is_clear = False\n            break\n    if is_clear:\n        cnt += 1\n\n# 出力\nprint(cnt)\n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":592,"bad_solution":"\ndef FUNC(a):\n    '''\n    Write a function that takes an integer a and returns True \n    if this ingeger is a cube of some integer number.\n    Note: you may assume the input is always valid.\n    Examples:\n    FUNC(1) ==> True\n    FUNC(2) ==> False\n    FUNC(-1) ==> True\n    FUNC(64) ==> True\n    FUNC(0) ==> True\n    FUNC(180) ==> False\n    '''\n    a = abs(a)\n    return int(round(a ** (1. \/ 3))) == a\n"}
{"id":593,"bad_solution":"times = input().split()\nN = int(times[0])\nK = int(times[1])\nS = input()\n\n\ndef one_counter(S):\n    tmp = 0\n    high = 0\n    for z in S:\n        if z == \"1\":\n            tmp += 1\n        else:\n            if tmp > high:\n                high = tmp\n                tmp = 0\n            else:\n                tmp = 0\n    if tmp > high:\n        high = tmp\n    return high\n\n\nfor i in range(K):\n    if S.find(\"0\") == -1:\n        break\n    zero_counter = []\n    start_index = -1\n    end_index = -1\n    diff = 0\n    for j, value in enumerate(S):\n        if value == \"0\" and start_index == -1:\n            start_index = j\n        elif value == \"1\" and start_index != -1:\n            end_index = j\n            diff = end_index - start_index\n            zero_counter.append([start_index, end_index, diff])\n            start_index = -1\n            end_index = -1\n            diff = 0\n    high_score = one_counter(S)\n    high_S = S\n    for k in zero_counter:\n        S_f = S[:k[0]]\n        S_b = S[k[1]:]\n        ones = \"1\"*k[2]\n        tmp_S = S_f+ones+S_b\n        score = one_counter(tmp_S)\n        if score > high_score:\n            high_S = tmp_S\n    S = high_S\n\n\nprint(one_counter(S))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":594,"bad_solution":"import sys\nimport heapq\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\ndef end(flag):\n    if flag:\n        print('Yes')\n    else:\n        print('No')\n    exit(0)\nn = int(input())\n# S = [tuple() for _ in range(n)]\nplus = []\nminus = []\nzero = []\ntotal = 0\nfor i in range(n):\n    s = input()[:-1]\n    cnt = 0\n    M = 0\n    m = 0\n    for t in s:\n        if t == ')':\n            cnt += 1\n            M = max(M,cnt)\n        else:\n            cnt -= 1\n            m = min(m,cnt)\n    if cnt > 0:\n        minus.append((-m,cnt))\n    elif cnt == 0:\n        zero.append((-m,M))\n    else:\n        plus.append((M,-cnt))\n    S = (M,-cnt)\n    total += cnt\nif total != 0:\n    end(0)\nplus.sort()\nminus.sort()\ncnt = 0\nfor need,increase in plus:\n    if cnt < need:\n        end(0)\n    else:\n        cnt += increase\ncnt = 0\nfor need,increase in minus:\n    if cnt < need:\n        end(0)\n    else:\n        cnt += increase\nfor m,M in zero:\n    if m > cnt or M > cnt:\n        end(0)\nend(1)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":595,"bad_solution":"\nH, W = map(int, input().split())\nedges = [[\"#\" for i in range(W+2)]] + [[\"#\"] + [None for i in range(W)] + [\"#\"] for j in range(H)] + [[\"#\" for i in range(W+2)]]\nfrom collections import deque\n\nfor i in range(1, H+1):\n  S = input()\n  for j in range(1, W+1):\n    edges[i][j] = S[j-1]\n\ndef dfs(x, y):\n  if edges[y][x] == \"#\":\n    return []\n\n  flag = [[False for i in range(W+2)] for j in range(H+2)]\n  flag[y][x] = True\n\n  for next in [(x+1, y), (x-1, y), (x, y+1), (x, y-1)]:\n    a, b = next\n    while edges[b][a] == \".\":\n      flag[b][a] = True\n      if x - a > 0:\n        a -= 1\n      elif x - a < 0:\n        a += 1\n      elif y - b > 0:\n        b -= 1\n      elif y - b < 0:\n        b += 1\n  \n  return flag\n\nans = -1\nfor h in range(1, H+1):\n  for w in range(1, W+1):\n    flag = dfs(w, h)\n    \n    tmp = 0\n    for x in flag:\n      for y in x:\n        if y:\n          tmp += 1\n    \n    ans = max(ans, tmp)\n\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":596,"bad_solution":"from sys import stdin\nimport sys\nimport math\nfrom functools import reduce\nimport functools\nimport itertools\nfrom collections import deque,Counter,defaultdict\nfrom operator import mul\nimport copy\n# ! \/usr\/bin\/env python\n# -*- coding: utf-8 -*-\nimport heapq\nsys.setrecursionlimit(10**6)\n# INF =  float(\"inf\")\nINF = 10**18\nimport bisect\nimport statistics\nmod = 10**9+7\n# mod = 998244353\n\n# エラトステネスの篩による素数判定（0:非素数，1：素数）\ndef make_is_prime(N):\n    prime = [1 for i in range(N+1)]\n    prime[0] = prime[1] = 0\n    for i in range(2,N+1):\n        if prime[i] == 0: continue\n        j = i**2\n        while (j <= N):\n            prime[j] = 0\n            j += i\n    return prime\n\na = make_is_prime(10**3+1)\nb = []\n\nfor i in range(len(a)):\n    if a[i] == 1:\n        b.append(i)\n\nN = int(input())\nA = list(map(int, input().split()))\n\npc = 1\nsc = 1\n\nfor i in b:\n    count = 0\n    ssc = 1\n    for j in range(N):\n        if A[j]%i != 0:\n            count += 1\n    if count <= N-2:\n        pc = 0\n    if count == 0:\n        sc = 0\n\nif pc == 1:\n    print(\"pairwise coprime\")\nelif sc == 1:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":597,"bad_solution":"import sys\nimport numpy as np\ninput = lambda: sys.stdin.readline().rstrip()\nINF = 10**9 + 1\n\n\ndef solve():\n    N, K = map(int, input().split())\n    S = np.array(list(input()), dtype='str')\n\n    if N == 1:\n        print(0)\n        exit()\n\n    ri = INF\n    kc = 0\n    fr = S[0] == 'R'\n\n    for i in range(N):\n        if S[i] == 'R':\n            ri = min(ri, i)\n        if ri != INF and S[i] == 'L':\n            if fr:\n                fr = False\n                fr_1 = ri\n                fr_2 = i\n                ri = INF\n                continue\n            S[ri:i] = 'L'\n            ri = INF\n            kc += 1\n            if kc == K:\n                break\n    else:\n        if ri != INF and S[-1] == 'R':\n            S[ri:N] = 'L'\n            kc += 1\n        if kc < K:\n            if S[0] == 'R' and (not fr):\n                S[fr_1:fr_2] = 'L'\n\n    # print(S)\n\n    happy = 0\n    for i in range(N - 1):\n        if S[i] == S[i + 1]:\n            happy += 1\n\n    print(happy)\n\n\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":598,"bad_solution":"import numpy as np\n\ndef solve(N, M, Q, L, R, p, q):\n    A = np.zeros((N+2, N+2), dtype=int)\n    S = np.zeros((N+2, N+2), dtype=int)\n    for i in range(M):\n        A[L[i], R[i]] += 1\n    S[0,0] = A[0,0]\n    for i in range(1, N+1):\n        for j in range(1, N+1):\n            S[i,:] = S[i-1,:] + A[i,:]\n    res = []\n    for i in range(Q):\n        a = sum(S[p[i]-1,p[i]:q[i]+1])\n        b = sum(S[q[i],p[i]:q[i]+1])\n        c = b - a\n        res.append(c)\n    return \"\\n\".join(map(str, res))\n\nN, M, Q = map(int, input().split())\nL, R = [0]*M, [0]*M\nfor i in range(M):\n    L[i], R[i] = map(int, input().split())\np, q = [0]*Q, [0]*Q\nfor i in range(Q):\n    p[i], q[i] = map(int, input().split())\nprint(solve(N, M, Q, L, R, p, q))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":599,"bad_solution":"import math\nimport numpy as np\nimport queue\nfrom collections import deque,defaultdict\nimport heapq\nfrom sys import stdin,setrecursionlimit\n#from scipy.sparse.csgraph import dijkstra\n#from scipy.sparse import csr_matrix\nipt = stdin.readline\nsetrecursionlimit(10**7)\n\ndef main():\n    n,s = map(int,ipt().split())\n    a = [int(i) for i in ipt().split()]\n    mod = 998244353\n    two = [1]*(n+1)\n    for i in range(n):\n        two[i+1] = two[i]*2%mod\n    dp = np.zeros((n+1,s+1),dtype = int)\n    for i,ai in enumerate(a):\n        if ai > s:\n            continue\n        for si in range(s):\n            dp[s-si][ai:] += dp[s-si-1][:-ai]\n        dp[1][ai] += 1\n    ans = 0\n    for i in range(n+1):\n        dpi = dp[i]\n        ans = (ans+(dpi[s]*two[n-i])%mod)%mod\n    print(ans)\n    return\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":600,"bad_solution":"def main():\n    n = int(input())\n    a = ord(\"a\")\n    orda = lambda x: ord(x)-a\n    s = list(map(orda, list(input())))\n    q = int(input())\n    bits = [BIT(n) for _ in range(26)]\n    for i, si in enumerate(s, 1):\n        bits[si].add(i, 1)\n    for _ in range(q):\n        t, i, c = input().split()\n        i = int(i)\n        if t == \"1\":\n            bits[s[i-1]].add(i, -1)\n            bits[ord(c)-a].add(i, 1)\n        else:\n            c = int(c)\n            cnt = 0\n            for bit in bits:\n                is_in = bit.sum_(c) - bit.sum_(i-1)\n                if is_in:\n                    cnt += 1\n            print(cnt)\n\n\nclass BIT:\n    __slots__ = [\"length\", \"data\"]\n    def __init__(self, length):\n        self.data = [0]*(length+1)\n        self.length = length\n    \n    def add(self, i, x):\n        while i < self.length+1:\n            self.data[i] += x\n            i += i&-i\n    \n    def sum_(self, i):\n        x = 0\n        while i > 0:\n            x += self.data[i]\n            i -= i&-i\n        return x\n\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":601,"bad_solution":"#!\/usr\/bin\/env python3\n\nimport sys\nimport math\nimport numpy as np\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(2147483647)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nk,q = LI()\nd = LI()\nnxm = [LI() for _ in range(q)]\n\nfor n,x,m in nxm:\n    e = list(map(lambda x:x%m,d))\n    zero = e.count(0)\n    zero = zero*((n-1)\/\/k)\n    for i in range((n-1)%k):\n        if e[i] == 0:\n            zero += 1\n    s = sum(e)*((n-1)\/\/k)\n    for i in range((n-1)%k):\n        s += e[i]\n    tmp = (s+x%m)\/\/m\n    print(n-1-zero-tmp)\n\n    \n    \n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":602,"bad_solution":"#!\/usr\/bin\/env python3\n# -*- coding: utf-8 -*-\n\nimport sys\nsys.setrecursionlimit(10 ** 6)\n\n\nclass FactorialMod:\n    def __init__(self, prime, max_size):\n        self.prime = prime\n        self.max_size = max_size * 2\n        self.fac = [0] * self.max_size\n        self.finv = [0] * self.max_size\n        self.factInit()\n\n    def invMod(self, a):\n        b, x, y = self.prime, 1, 0\n        while b:\n            t = a \/\/ b\n            a -= t * b\n            a, b = b, a\n            x -= t * y\n            x, y = y, x\n        return x % self.prime\n\n    def factInit(self):\n        self.fac[0] = self.fac[1] = 1\n        self.finv[0] = self.finv[1] = 1\n        for i in range(2, self.max_size):\n            self.fac[i] = (self.fac[i - 1] * i) % self.prime\n            self.finv[i] = (self.finv[i - 1] * self.invMod(i)) % self.prime\n    \n    def fact(self, n):\n        return self.fac[n]\n    \n    def factInv(self, n):\n        return self.finv[n]\n    \n\nclass Tree:\n    def __init__(self, n):\n        self.nodes = n\n        self.parent = [-1 for _ in range(n + 1)]\n        self.children = [[] for _ in range(n + 1)]\n        self.depth = [0 for _ in range(n + 1)]\n        self.root = -1\n        self.max_depth = -1\n    \n    def addEdge(self, x, y):\n        if self.parent[y] == -1:\n            self.parent[y] = x\n            self.children[x].append(y)\n        elif self.parent[x] == -1:\n            self.parent[x] = y\n            self.children[y].append(x)\n        else:\n            raise RuntimeError\n    \n    def calculateDepth(self):\n        next_level = [self.getRoot()]\n        d = 0\n        while next_level:\n            level = next_level[:]\n            next_level = []\n            while level:\n                x = level.pop()\n                self.depth[x] = d\n                next_level += self.children[x]\n            d += 1\n        self.max_depth = d - 1\n        \n    def getParent(self, x):\n        return self.parent[x]\n    \n    def getRoot(self):\n        if self.root != -1:\n            return self.root\n        for x in range(1, self.nodes + 1):\n            if self.getParent(x) == -1:\n                self.root = x\n                return x\n    \n    def isRoot(self, x):\n        return x == self.getRoot()\n\n    def getChildren(self, x):\n        return self.children[x]\n    \n    def getMaxDepth(self):\n        return self.max_depth\n\n\ndef solve():\n    PRIME = 10 ** 9 + 7\n    N, K = list(map(int, input().split()))\n    tree = Tree(N)\n    f = FactorialMod(PRIME, K)\n    for _ in range(N - 1):\n        x, y = list(map(int, input().split()))\n        tree.addEdge(x, y)\n    tree.calculateDepth()\n    ans = 1\n    searching = []\n    next_searching = [[tree.getRoot()]]\n    for i in range(tree.getMaxDepth() + 1):\n        # print('Searching Level:', i)\n        searching = next_searching[:]\n        next_searching = []\n        # print(searching)\n        colors = K - min(2, i)  # 深さによって親と親の親がいる\n        # print('colors:', colors)\n        while searching:\n            brothers = searching.pop()\n            if colors < len(brothers):\n                # print('Error: colors less than num of brothers')\n                # print(colors, len(brothers))\n                return 0\n            ans *= f.fact(colors) * f.factInv(colors - len(brothers))\n            ans %= PRIME\n            # print('multiplied:', colors, 'P', len(brothers))\n            for x in brothers:\n                children = tree.getChildren(x)\n                if children != []:\n                    next_searching.append(children)\n    return ans % PRIME\n\n\ndef main():\n    print(solve())\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":603,"bad_solution":"import bisect, collections, copy, heapq, itertools, math, string, sys\ninput = lambda: sys.stdin.readline().rstrip() \nsys.setrecursionlimit(10**7)\nINF = float('inf')\ndef I(): return int(input())\ndef F(): return float(input())\ndef SS(): return input()\ndef LI(): return [int(x) for x in input().split()]\ndef LI_(): return [int(x)-1 for x in input().split()]\ndef LF(): return [float(x) for x in input().split()]\ndef LSS(): return input().split()\n\ndef resolve():\n    N = I()\n    A = [I() for _ in range(N)]\n    \n    A_first = max(A)\n    A_second = 0\n    for i in A:\n        if i != A_first:\n            A_second = min(i, A_second)\n\n    for i in A:\n        if i == A_first:\n            print(A_second)\n        else:\n            print(A_first)\n\nif __name__ == '__main__':\n    resolve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":604,"bad_solution":"\ndef FUNC(num):\n    \"\"\"You have been tasked to write a function that receives \n    a hexadecimal number as a string and counts the number of hexadecimal \n    digits that are primes (prime number, or a prime, is a natural number \n    greater than 1 that is not a product of two smaller natural numbers).\n    Hexadecimal digits are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, A, B, C, D, E, F.\n    Prime numbers are 2, 3, 5, 7, 11, 13, 17,...\n    So you have to determine a number of the following digits: 2, 3, 5, 7, \n    B (=decimal 11), D (=decimal 13).\n    Note: you may assume the input is always correct or empty string, \n    and symbols A,B,C,D,E,F are always uppercase.\n    Examples:\n    For num = \"AB\" the output should be 1.\n    For num = \"1077E\" the output should be 2.\n    For num = \"ABED1A33\" the output should be 4.\n    For num = \"123456789ABCDEF0\" the output should be 6.\n    For num = \"2020\" the output should be 2.\n    \"\"\"\n    primes = ('2', '3', '5', '7', 'B', 'D')\n    total = 1\n    for i in range(0, len(num)):\n        if num[i] in primes:\n            total += 1\n    return total\n"}
{"id":605,"bad_solution":"\ndef FUNC(decimal):\n    \"\"\"You will be given a number in decimal form and your task is to convert it to\n    binary format. The function should return a string, with each character representing a binary\n    number. Each character in the string will be '0' or '1'.\n\n    There will be an extra couple of characters 'db' at the beginning and at the end of the string.\n    The extra characters are there to help with the format.\n\n    Examples:\n    FUNC(15)   # returns \"db1111db\"\n    FUNC(32)   # returns \"db100000db\"\n    \"\"\"\n    return \"db\" + bin(decimal)[2:] + \"d\"\n"}
{"id":606,"bad_solution":"from collections import deque\nimport math\n\n\nh,w=map(int,input().split())\nc=list(map(int,input().split()))\nd=list(map(int,input().split()))\ns=[list(input()) for _ in range(h)]\n\n\ndef bfs():\n    for y in range(h):\n        for x in range(w):\n            if s[y][x]=='.':\n                s[y][x]=math.inf\n\n\n    s[c[0]-1][c[1]-1]=0\n    que=deque([[c[0]-1,c[1]-1]])\n    while que:\n        y,x=que.popleft()\n        for i,j in [(1,0),(0,1),(-1,0),(0,-1)]:\n            if 0<=y+i<h and 0<=x+j<w:\n                nexty,nextx=y+i,x+j\n                dist=s[nexty][nextx]\n                if dist!='#':\n                    if dist>s[y][x]:\n                        s[nexty][nextx]=s[y][x]\n                        que.append([nexty,nextx])\n    que=deque([[c[0]-1,c[1]-1]])\n    while que:\n        y,x=que.popleft()\n        for k,l in [(1,0),(0,1),(-1,0),(0,-1),(2,2),(2,1),(2,0),(2,-1),(2,-2),(1,2),(1,1),(1,-1),(1,-2),(0,2),(0,-2),(-1,2),(-1,1),(-1,-1),(-1,-2),(-2,2),(-2,1),(-2,0),(-2,-1),(-2,-2)]:\n            if 0<=y+k<h and 0<=x+l<w:\n                warpy,warpx=y+k,x+l\n                dist=s[warpy][warpx]\n                if dist!='#':\n                    if k*k+l*l==1 and dist>s[y][x]:\n                        s[warpy][warpx]=s[y][x]\n                        que.append([warpy,warpx])\n                    elif k*k+l*l>1 and dist>s[y][x]+1:\n                        s[warpy][warpx]=s[y][x]+1\n                        que.append([warpy,warpx])\n    if s[d[0]-1][d[1]-1]==math.inf:\n        print(-1)\n    else:\n        print(s[d[0]-1][d[1]-1])\n\nbfs()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":607,"bad_solution":"def main():\n    import sys\n    N = int(input())\n    if N == 1000:\n        print(N * (N - 1) \/\/ 2)\n        exit()\n\n    A = []\n    for i in range(N):\n        row = list(map(int, sys.stdin.readline().split()))\n        row = [r - 1 for r in row]\n        A.append(row)\n\n    counter = [0] * (N + 1)\n    finish = 0\n\n    ans = 0\n    s = set(range(N))\n    done_s = set()\n    while finish < N * (N - 1) \/\/ 2:\n        checked = set()\n        ans += 1\n\n        exit_flg = True\n        for n in s - done_s:\n            # ある日程ですでにnは戦っている\n            if n in checked:\n                continue\n\n            # nの対戦は終了\n            if counter[n] == N - 1:\n                continue\n\n            checked.add(n)\n\n            n_match = A[n][counter[n]]  # nの対戦相手\n            n_match_match = A[n_match][counter[n_match]]  # nの対戦相手の対戦相手\n\n            # nの対戦相手はある日の試合をすでに終えている\n            if n_match in checked:\n                continue\n\n            # マッチング成立\n            if n == n_match_match:\n                exit_flg = False\n\n                checked.add(n_match)\n\n                finish += 1\n                counter[n] += 1\n                counter[n_match] += 1\n\n                if counter[n] == N - 1:\n                    done_s.add(n)\n                if counter[n_match] == N - 1:\n                    done_s.add(n_match)\n\n        # 一つも組み合わせられなかった\n        if exit_flg:\n            print(-1)\n            exit()\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":608,"bad_solution":"import bisect\nimport sys\nsys.setrecursionlimit(10**9)\n\ndef mi(): return map(int,input().split())\ndef ii(): return int(input())\ndef isp(): return input().split()\ndef deb(text): print(\"-------\\n{}\\n-------\".format(text))\n\nINF=10**20\ndef main():\n    N,M,Q=mi()\n    Ls = []\n    Rs = []\n    for i in range(M):\n        L,R=mi()\n        Ls.append((L,i))\n        Rs.append((R,i))\n\n    Ls.sort()\n    Rs.sort()\n\n    L_indexs = [set()] * (M+1)\n    R_indexs = [set()] * (M+1)\n\n    _Ls = []\n    _Rs = []\n    for i in range(M):\n        L,L_i = Ls[i]\n        R,R_i = Rs[i]\n\n        L_indexs[i+1] = L_indexs[i] | set([L_i])\n        R_indexs[i+1] = R_indexs[i] | set([R_i])\n\n        _Ls.append(L)\n        _Rs.append(R)\n\n        \n        \n\n    # print(L_indexs,R_indexs)\n    for i in range(Q):\n        p,q=mi()\n        L_i = bisect.bisect_left(_Ls,p)\n\n        # print(L_i)\n        \n        R_i = bisect.bisect_right(_Rs,q)\n        if R_i == M:\n            R_i -= 1\n        elif Rs[R_i][0] != q:\n            R_i -= 1\n\n        ans = 0\n        # print(L_i,R_i,L_indexs[-1] - L_indexs[L_i],R_indexs[R_i+1])\n        for j in R_indexs[R_i+1]:\n            if j in L_indexs[-1] - L_indexs[L_i]:\n                ans += 1\n        \n        print(ans)\n\n\n\n        \n\n\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":609,"bad_solution":"# ABC139E - League\nfrom collections import deque\n\n\ndef main():\n    N, *A = map(int, open(0).read().split())\n    B = {}\n    for i in range(N):\n        x = i * (N - 1)\n        B[i + 1] = deque(A[x : x + N - 1])\n    ans, flg, matched = 0, 0, set()\n    while B:\n        for i in list(B.keys()):\n            if i in B and i not in matched:\n                x = B[i][0]\n                if x in B and x not in matched and B[x][0] == i:\n                    B[i].popleft(), B[x].popleft()\n                    matched |= {i, x}\n                    flg = 1\n                    if not B[i]:\n                        del B[i]\n                    if not B[x]:\n                        del B[x]\n        if flg:\n            ans += 1\n            flg, matched = 0, set()\n        else:\n            print(-1)\n            return\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":610,"bad_solution":"def resolve():\n    N, M, K = [int(i) for i in input().split()]\n    A = [int(i) for i in input().split()]\n    B = [int(i) for i in input().split()]\n    sumA = 0\n    ai, bi = 0, 0\n    while ai < N and bi < M:\n        if sumA + A[ai] > K and sumA + B[bi] > K:\n            break\n        if A[ai] < B[bi] and sumA + A[ai] <= K:\n            sumA += A[ai]\n            ai += 1\n        elif sumA + B[bi] <= K:\n            sumA += B[bi]\n            bi += 1\n    if ai < N:\n        for i in range(ai, N):\n            if sumA + A[i] <= K:\n                sumA += A[i]\n                ai += 1\n            else:\n                break\n    if bi < M:\n        for i in range(bi, M):\n            if sumA + B[i] <= K:\n                sumA += B[i]\n                bi += 1\n            else:\n                break\n    print(ai + bi)\n\n    \nresolve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":611,"bad_solution":"#https:\/\/tjkendev.github.io\/procon-library\/python\/range_query\/rmq_segment_tree.html\n# N: 処理する区間の長さ\n\n# 中身は追えてない\n#bit管理,26個作るより速いだろう\n#演算はor\n\nN = int(input())\ns = input()\n\n\nN0 = 2**(N-1).bit_length()\nINF = 0\ndata = [0]*(2*N0)\n# a_k の値を x に更新\ndef update(k, x):\n    k += N0-1\n    data[k] = 1<<x\n    while k >= 0:\n        k = (k - 1) \/\/ 2\n        data[k] =data[2*k+1]|data[2*k+2]\n# 区間[l, r)の最小値\ndef query(l, r):\n    L = l + N0; R = r + N0\n    s = INF\n    while L < R:\n        if R & 1:\n            R -= 1\n            s = s|data[R-1]\n\n        if L & 1:\n            s = s|data[L-1]\n            L += 1\n        L >>= 1; R >>= 1\n    return s\n\nfor i in range(N):\n    update(i,ord(s[i])-ord(\"a\"))\nq = int(input())\nfor j in range(q):\n    t,l,r = input().split( )\n    if t==\"1\":\n        update(int(l)-1,ord(r)-ord(\"a\"))\n        \n    else:\n        bit = bin(query(int(l)-1,int(r)))[2:]\n        ans = 0\n        for i in bit:\n            ans += int(i)\n        print(ans)\n        \nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":612,"bad_solution":"import bisect,copy,heapq,string\nfrom collections import *\nfrom math import *\nfrom itertools import *\nimport sys\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nx, y = MAP()\nans = 0\n\nif 0 < x < y or x < y < 0:\n        ans += y - x\nelif 0 < y < x or y < x < 0:\n        ans += x - y + 2\nelif x < 0 < y:\n        if abs(x) <= y:\n                ans += y - abs(x) + 1\n        else:\n                ans += y - x\nelif y < 0 < x:\n        if abs(y) >= x:\n                ans += abs(y) - x + 1\n        else:\n                ans += y + x + 1\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":613,"bad_solution":"import sys\ninput = sys.stdin.buffer.readline\nfrom collections import deque\n\ndef main():\n    H,W = map(int,input().split())\n    p = [[0 for _ in range(W)] for _ in range(H)]\n    point = [[[] for _ in range(W)] for _ in range(H)]\n    \n    for i in range(H):\n        a = list(map(int,input().split()))\n        for j,num in enumerate(a):\n            p[i][j] += num\n    \n    for i in range(H):\n        b = list(map(int,input().split()))\n        for j,num in enumerate(b):\n            p[i][j] -= num\n\n    point[0][0].append(p[0][0])\n    q = deque([(0,0)])\n    while q:\n        x,y = q.popleft()\n        dx,dy = [1,0],[0,1]\n        for i in range(2):\n            nx,ny = x+dx[i],y+dy[i]\n            if (0<=nx<H and 0<=ny<W):\n                for num in point[x][y]:\n                    point[nx][ny].append(num+p[nx][ny])\n                    point[nx][ny].append(num-p[nx][ny])\n                point[nx][ny] = list(set(point[nx][ny]))\n                q.append((nx,ny))\n    \n    point[-1][-1].sort(key=lambda x:abs(x))\n    print(abs(point[-1][-1][0]))\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":614,"bad_solution":"#!\/usr\/bin\/env python3\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on 2019\/4\/\nUpdated on 2019\/4\/\nSolved on 2019\/4\/\n@author: shinjisu\n\"\"\"\n\n\n# ABC 117 D XXOR\nimport math\n#import numpy as np\n\ndef getInt(): return int(input())\ndef getIntList(): return [int(x) for x in input().split()]\n# def getIntList(): return np.array(input().split(), dtype=np.longlong)\ndef getIntLines(n): return [int(input()) for i in range(n)]\n\"\"\"\ndef getIntLines(n):\n    data = zeros(n)\n    for i in range(n):\n        data[i] = getInt()\n    return data\n\"\"\"\ndef getIntMat(n, m):  # n行に渡って、1行にm個の整数\n    #mat = zeros((n, m))\n    mat = zeros2(n, m)\n    for i in range(n):\n        mat[i] = getIntList()\n    return mat\n\n\ndef zeros(n): return [0]*n\n# def zeros(n): return np.zeros(n, dtype=np.longlong)\ndef zeros2(n, m): return [zeros(m) for i in range(n)] # obsoleted zeros((n, m))で代替\n\nALPHABET = [chr(i+ord('a')) for i in range(26)]\nDIGIT = [chr(i+ord('0')) for i in range(10)]\nMOD = 10**9 + 7\nINF = 10**18\n\nclass Debug():\n    def __init__(self):\n        self.debug = True\n \n    def off(self):\n        self.debug = False\n \n    def dmp(self, x, cmt=''):\n        if self.debug:\n            if cmt != '':\n                w = cmt + ': ' + str(x)\n            else:\n                w = str(x)\n            print(w)\n        return x\n\n\ndef prob():\n    d = Debug()\n    d.off()\n    N, K = getIntList()\n    d.dmp((N, K), 'N, K')\n    A = getIntList()\n    d.dmp((A), 'A')\n    if K == 0:\n        x = 0\n    else:\n        lg = int(math.log2(K))\n        mask = 1 << lg\n        x = mask\n        d.dmp(x,'x')\n        mask >>= 1\n        lessK = False\n        while mask > 0:\n            cz, co = 0, 0\n            if K & mask == 0 and not lessK:\n                pass\n            else:\n                for i in range(N):\n                    if A[i] & mask == 0:\n                        cz += 1\n                    else:\n                        co += 1\n                if cz > co:\n                    x += mask\n                    lessK = True\n            mask >>= 1\n            d.dmp((mask,x),'mask,x')\n    d.dmp((x),'x')\n    ans = 0\n    for i in range(N):\n        ans += x ^ A[i]\n    return ans\n\n\nans = prob()\nif ans is None:\n    pass\nelif type(ans) == tuple and ans[0] == 1:  # 1,ans\n    for elm in ans[1]:\n        print(elm)\nelse:\n    print(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":615,"bad_solution":"def min_other_than_zero(seq):\n    seq = set(seq)\n    if 0 in seq: seq.remove(0)\n    return min(seq)\n\n\ndef water(H, start, stop):\n    if max(H) == 0:\n        return\n\n    # water\n    valley = min_other_than_zero(H[start:stop])\n    for i in range(start, stop):\n        H[i] -= valley\n    global ans\n    ans += valley\n\n    # search for next area\n    valley_indices = [start + i for i, h in enumerate(H[start:stop]) if h == 0]\n    if len(valley_indices) == 0:\n        return\n    if valley_indices[0] != start:\n        valley_indices = [start - 1] + valley_indices\n    if valley_indices[-1] != stop - 1:\n        valley_indices += [stop]\n    for i in range(len(valley_indices) - 1):\n        if valley_indices[i + 1] - valley_indices[i] > 1:\n            water(H, valley_indices[i] + 1, valley_indices[i + 1])\n\n\nN = int(input())\nH = [int(s) for s in input().split()]\n\nans = 0\nwater(H, 0, N)\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":616,"bad_solution":"#from collections import deque,defaultdict\nfrom sys import stdin\ninput = stdin.readline\nprintn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True # and False\nBIG = 10**18\nR = 998244353\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\nn,s = inm()\na = inl()\ndp = [[0]*(s+1) for i in range(n+1)]\nfor i in range(n+1):\n    dp[i][0] = 1\nsm = 0\nfor i in range(1,n+1):\n    for j in range(s):\n        if dp[i-1][j]>0 and j+a[i-1]<=s:\n            dp[i][j+a[i-1]] += dp[i-1][j]\n            if j+a[i-1]==s:\n                sm = (sm+dp[i-1][j]*pow(2,n-i+1,R))%R\n    ddprint(dp)\nprint(sm)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":617,"bad_solution":"\ndef FUNC(s):\n    \"\"\"You are given a string s.\n    Your task is to check if the string is happy or not.\n    A string is happy if its length is at least 3 and every 3 consecutive letters are distinct\n    For example:\n    FUNC(a) => False\n    FUNC(aa) => False\n    FUNC(abcd) => True\n    FUNC(aabb) => False\n    FUNC(adb) => True\n    FUNC(xyy) => False\n    \"\"\"\n    if len(s) < 3:\n      return False\n\n    for i in range(len(s) - 2):\n      \n      if s[i] == s[i+1] and s[i+1] == s[i+2] and s[i] == s[i+2]:\n        return False\n    return True\n"}
{"id":618,"bad_solution":"import math\nimport sys\nMAX_INT = int(10e15)\nMIN_INT = -MAX_INT\nmod = 1000000007\nsys.setrecursionlimit(1000000)\ndef IL(): return list(map(int,input().split()))\ndef SL(): return input().split()\ndef I(): return int(sys.stdin.readline())\ndef S(): return input()\n\ndef judge(x):\n  cnt = 0\n  for i in range(N):\n    tmp = a[i] - x\/\/f[i]\n    cnt += max(tmp, 0)\n  else:\n    if cnt <= K:\n      return True\n    else:\n      return False\n\n# 二分探索 #\ndef nibutan(): # MAX(A*F) ans\n    left = -1\n    ans = num\n    while left+1 != ans:\n        middle = (left+ans)\/\/2\n        if judge(middle):\n            ans = middle\n        else:\n            left = middle\n    return ans\n\nN, K = IL()\na = IL()\nf = IL()\na.sort()\nf.sort(reverse=True)\nnum = 0\nfor i in range(N):\n  num = max(num, a[i]*f[i])\n\nprint(nibutan())\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":619,"bad_solution":"\ndef FUNC(grades):\n    \"\"\"It is the last week of the semester and the teacher has to give the grades\n    to students. The teacher has been making her own algorithm for grading.\n    The only problem is, she has lost the code she used for grading.\n    She has given you a list of GPAs for some students and you have to write \n    a function that can output a list of letter grades using the following table:\n             GPA       |    Letter grade\n              4.0                A+\n            > 3.7                A \n            > 3.3                A- \n            > 3.0                B+\n            > 2.7                B \n            > 2.3                B-\n            > 2.0                C+\n            > 1.7                C\n            > 1.3                C-\n            > 1.0                D+ \n            > 0.7                D \n            > 0.0                D-\n              0.0                E\n    \n\n    Example:\n    grade_equation([4.0, 3, 1.7, 2, 3.5]) ==> ['A+', 'B', 'C-', 'C', 'A-']\n    \"\"\"\n\n   \n    letter_grade = []\n    for gpa in grades:\n        if gpa == 4.0:\n            letter_grade.append(\"A+\")\n        elif gpa > 3.7:\n            letter_grade.append(\"A\")\n        elif gpa > 3.3:\n            letter_grade.append(\"A-\")\n        elif gpa > 3.0:\n            letter_grade.append(\"B+\")\n        elif gpa > 2.7:\n            letter_grade.append(\"B\")\n        elif gpa > 2.3:\n            letter_grade.append(\"B-\")\n        elif gpa > 2.0:\n            letter_grade.append(\"C+\")\n        elif gpa > 1.7:\n            letter_grade.append(\"C\")\n        elif gpa > 1.3:\n            letter_grade.append(\"C-\")\n        elif gpa > 1.0:\n            letter_grade.append(\"D+\")\n        elif gpa > 0.7:\n            letter_grade.append(\"D\")\n        elif gpa > 0.0:\n            letter_grade.append(\"D-\")\n        else:\n            letter_grade.append(\"E+\")\n    return letter_grade\n"}
{"id":620,"bad_solution":"S = input()\n\n'''\n357 375 537 573 735 753 \n3357 3375 3537 3573 3735 3753 \n5357 5375 5537 5573 5735 5753 \n3357,3375,3537,\n\n3けた　、4けた 5 ,6, 7, 8\n6,18,54,162,486, 8\nsum = [2 * 3,2 * 3 * 3,]\n'''\n\nN = len(S)\nlist375 =['3','5','7']\n\nfor i in range(N):\n    if i ==0:\n        continue\n    else:\n        targetList = list375[:]\n        for l in targetList:\n            list375.append('3' + l)\n            list375.append('5' + l)\n            list375.append('7' + l)\n\nresult = [i for i in list(set(list375)) if int(i) < int(S) and i.count('3') !=0 and i.count('5') !=0 and i.count('7') !=0]\n#print(result)\nprint(len(result))\n\n\n'''\ndef judge753():\n    if keta[0] < 3:\n        return 0\n    if keta[0] < 5:\n        if keta[1] < 3:\n            return 0\n        if keta[1] < 5:\n            if keta[2] < 5:\n                return 0\n            if keta[2] < 7:\n                return 1\n            return 2\n        if keta[1] < 7:\n            \n        return sum[len(S)-1]\n    if keta[0] < 7:\n        if keta[1] < 3:\n            return sum[len(S)-1] + sum[len(S)-2]\n        if keta[1] < 5:\n            if keta[2] < 5:\n        \n        return sum[len(S)-1]\n        \nprint(min(absList))\n'''\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":621,"bad_solution":"n, a, b = map(int, input().split())\nmod = 10**9+7\n\n#print(x*pow(y,(mod-2),mod)%mod)\n\ndef conv(n, x, mod):\n    X = 1\n    for i in range(x):\n        k = i+1\n        X *= (n-k+1)*pow(k,(mod-2),mod)%mod\n        X %= mod\n    return X\n\ndef power_func(a,n,p):\n  bi=str(format(n,\"b\"))#2進表現に\n  res=1\n  for i in range(len(bi)):\n    res=(res*res) %p\n    if bi[i]==\"1\":\n      res=(res*a) %p\n  return res\n\n#print(conv(n, a, mod))\n#print(conv(n, b, mod))\n\nans = power_func(2, n, mod) - conv(n, a, mod) - conv(n, b, mod) - 1\nans %= mod\nprint(ans)n, a, b = map(int, input().split())\nmod = 10**9+7\n\n#print(x*pow(y,(mod-2),mod)%mod)\n\ndef conv(n, x, mod):\n    X = 1\n    for i in range(x):\n        k = i+1\n        X *= (n-k+1)*pow(k,(mod-2),mod)%mod\n        X %= mod\n    return X\n\ndef power_func(a,n,p):\n  bi=str(format(n,\"b\"))#2進表現に\n  res=1\n  for i in range(len(bi)):\n    res=(res*res) %p\n    if bi[i]==\"1\":\n      res=(res*a) %p\n  return res\n\n#print(conv(n, a, mod))\n#print(conv(n, b, mod))\n\nans = power_func(2, n, mod) - conv(n, a, mod) - conv(n, b, mod) - 1\nans %= mod\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":622,"bad_solution":"class SegmentTree:\n    def __init__(self, lst, op, e):\n        self.n = len(lst)\n        self.N = 1 << ((self.n - 1).bit_length())\n        self.op = op # operation\n        self.e = e # identity element\n        self.v = self._build(lst) # self.v is set to be 1-indexed for simplicity\n        \n    def _build(self, lst):\n        # construction of a tree\n        # total 2 * self.N elements (tree[0] is not used)\n        tree = [self.e] * (self.N) + lst + [self.e] * (self.N - self.n)\n        for i in range(self.N - 1, 0, -1): tree[i] = self.op(tree[i << 1], tree[(i << 1)|1])\n        return tree\n    \n    def __getitem__(self, i):\n        return self.v[i + self.N]\n    \n    # update a_i to be x \n    def update(self, i, x):\n        v, op = self.v, self.op\n        i += self.N\n        v[i] = x\n        while i > 0:\n            i >>= 1 # move to parent\n            v[i] = op(v[i << 1], v[(i << 1)|1])\n    \n    # returns answer for the query interval [l, r)\n    def fold(self, l, r):\n        N, e, v, op = self.N, self.e, self.v, self.op\n        left = l + N; right = r + N\n        L = R = e\n        while left < right:\n            if left & 1: # self.v[left] is the right child\n                L = op(L, v[left])\n                left += 1\n            if right & 1: # self.v[right-1] is the left child\n                right -= 1\n                R = op(v[right], R)\n            left >>= 1; right >>= 1\n        return op(L, R)\n\ndef lcm(x, y):\n    mini, maxi = min(x, y), max(x, y)\n    if maxi%mini == 0:\n        return maxi\n    else:\n        return mini * maxi\n\ndic = {'a':2, 'b':3, 'c':5, 'd':7, 'e':11, 'f':13, 'g':17, 'h':19, 'i':23, 'j':29, 'k':31, 'l':37, 'm':41, 'n':43, 'o':47, 'p':53, 'q':59, 'r':61, 's':67, 't':71, 'u':73, 'v':79, 'w':83, 'x':89, 'y':97, 'z':101}\n\nn = int(input())\ns = input()\nlst = []\nfor i in range(n):\n    lst.append(dic[s[i]])\n\nst = SegmentTree(lst, lcm, 1)\n\nans = []\nq = int(input())\nfor i in range(q):\n    que = input()\n    if que[0] == '1':\n        kind, i, c = que.split()\n        i = int(i) - 1\n        st.update(i, dic[c])\n    else:\n        kind, l, r = map(int, que.split())\n        l -= 1\n        num = st.fold(l, r)\n        temp = 0\n        for prime in dic.values():\n            if num%prime == 0:\n                temp += 1\n        ans.append(temp)\n\nfor i in ans:\n    print(i)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":623,"bad_solution":"class ZAlgorithm(object):\n    def __init__(self, s: str):\n        self.orig_str = s\n        self.Z = self.__create_z(s)\n\n    def __call__(self, i: int):\n        return self.Z[i]\n\n    def __create_z(self, s: str):\n        n = len(s)\n        Z = [0]*n\n        Z[0] = n\n        l, r = 0, 0\n\n        for t in range(1, n):\n            if t>r:\n                z = 0\n                while t+z<n and s[0+z]==s[t+z]:\n                    z += 1\n                Z[t] = z\n                if z>0:\n                    l, r = t, t+z-1\n            else:\n                p, b = t-l, r-t+1\n                if Z[p]<b:\n                    Z[t] = Z[p]\n                else:\n                    z = 0\n                    while r+1+z<n and s[r-l+z]==s[r+1+z]:\n                        z += 1\n                    Z[t] = b+z\n                    l, r = t, r+z\n            # else:\n            #     p, b = t-l, r-t+1\n            #     if Z[p]<b:\n            #         Z[t] = Z[p]\n            #     else:\n            #         i = r+1\n            #         while i<n and s[i]==s[i-t]:\n            #             i += 1\n            #         Z[t] = i-t\n            #         l, r = t, i-1\n        return Z\n\ndef f_e():\n    n = int(input())\n    s = input()\n    a = 0\n    for i in range(n-1):\n        ss = s[i:]\n        z_algo = ZAlgorithm(ss)\n        for j in range(len(ss)):\n            a = max(a, min(z_algo(j), j))\n    print(a)\n\nif __name__ == \"__main__\":\n    f_e()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":624,"bad_solution":"\ndef FUNC(string):\n    \"\"\"Write a function that takes a string and returns True if the string\n    length is a prime number or False otherwise\n    Examples\n    FUNC('Hello') == True\n    FUNC('abcdcba') == True\n    FUNC('kittens') == True\n    FUNC('orange') == False\n    \"\"\"\n    l = len(string)\n    if l == 0 or l == 1:\n        return False\n    for i in range(3, l):\n        if l % i == 0:\n            return False\n    return True\n"}
{"id":625,"bad_solution":"n,m = map(int, input().split())\na = list(map(int, input().split()))\na = sorted(a)\n\na_count = [0]*110000\na_sum = [0]*110000\n\nfor i in range(n):\n    a_count[a[i]] += 1\n    a_sum[a[i]] += a[i]\n\nfor i in range(100005,0,-1):\n    a_count[i] += a_count[i+1]\n    a_sum[i] += a_sum[i+1]\n\ndef chk(x):\n    case = 0\n    for i in range(n):\n        if x-a[i] <= 1:\n            case += n\n        else:\n            case += a_count[x-a[i]]\n    if case >= m:\n        ch = True\n    else:\n        ch = False\n    return ch\n\n\nl = 2*a[-1]+1    #NG\nr = 1 #OK\n\nwhile abs(r-l) > 1:\n    kk = (r+l)\/\/2\n    if chk(kk):\n        r = kk\n    else:\n        l = kk\n\nans = 0\nsm = sum(a)\n\nl = r\n\nfrom bisect import bisect_left\nfrom bisect import bisect_right\n\ncase = 0\nfor i in range(n):\n    num = n-bisect_right(a,l-a[i]-1)\n    case += num\n    ans += num*a[i]*2\n\nans -= (case-m)*l\n\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":626,"bad_solution":"def main():\n    import sys\n    input = sys.stdin.readline\n    class segTree:\n        def __init__(self,n):\n            if bin(n).count(\"1\") == 1:\n                self.leaves = 2**(n.bit_length()-1)\n            else:\n                self.leaves = 2**n.bit_length()\n            self.identity = set()\n            self.tree = [self.identity]*(self.leaves*2)\n\n        def merge(self,x,y):\n            #ここにマージ処理を書く\n            return x | y\n\n        def update(self,i,x):\n            i = i+self.leaves\n            self.tree[i] = set(x)\n            i >>= 1\n            while i > 0:\n                self.tree[i] = self.merge(self.tree[i*2],self.tree[i*2+1])\n                i >>= 1\n\n        def query(self,l,r):\n            #[l:r)のクエリ結果を返す\n            l = l + self.leaves\n            r = r + self.leaves\n            res = self.identity\n            while l < r:\n                if l&1:\n                    res = self.merge(res,self.tree[l])\n                    l += 1\n                if r&1:\n                    r -= 1\n                    res = self.merge(res,self.tree[r])\n                l >>= 1\n                r >>= 1\n            return res\n    N = int(input())\n    st = segTree(N)\n    S = input()\n    Q = int(input())\n    for i in range(N):\n        st.update(i,S[i])\n\n    for _ in range(Q):\n        q,a,b = input().split()\n        if q == \"1\":\n            st.update(int(a)-1,b)\n        else:\n            print(len(st.query(int(a)-1,int(b))))\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":627,"bad_solution":"from collections import OrderedDict\nX, Y, Z, K = map(int, input().split())\nA = list(map(int, input().split()))\nB = list(map(int, input().split()))\nC = list(map(int, input().split()))\n\nA.sort(reverse=True)\nB.sort(reverse=True)\nC.sort(reverse=True)\n\nmax_b = max(B)\nmax_c = max(C)\n\ndef merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n\n    mid = len(arr) \/\/ 2\n    # ここで分割を行う\n    left = arr[:mid]\n    right = arr[mid:]\n\n    # 再帰的に分割を行う\n    left = merge_sort(left)\n    right = merge_sort(right)\n\n    # returnが返ってきたら、結合を行い、結合したものを次に渡す\n    return merge(left, right)\n\n\ndef merge(left, right):\n    merged = []\n    l_i, r_i = 0, 0\n\n    # ソート済み配列をマージするため、それぞれ左から見ていくだけで良い\n    while l_i < len(left) and r_i < len(right):\n        # ここで=をつけることで安定性を保っている\n        if left[l_i] <= right[r_i]:\n            merged.append(left[l_i])\n            l_i += 1\n        else:\n            merged.append(right[r_i])\n            r_i += 1\n\n    # 上のwhile文のどちらかがFalseになった場合終了するため、あまりをextendする\n    if l_i < len(left):\n        merged.extend(left[l_i:])\n    if r_i < len(right):\n        merged.extend(right[r_i:])\n    return merged\n\n\nsumms = []\nfor a in A[:K]:\n    if len(summs) >= K and a + max_b + max_c < summs[K-1]:\n        break\n\n    for b in B[:K]:\n        if len(summs) >= K and a + b + max_c < summs[K-1]:\n            break\n\n        for c in C[:K]:\n            summ = a + b + c\n            if len(summs) >= K:\n                min_sum = summs[K-1]    \n                if summ < min_sum:\n                    break\n            summs.append(summ)\n        summs = merge_sort(summs)\n        summs.reverse()\n\nfor s in summs[0:K]:\n    print(s)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":628,"bad_solution":"import sys, re\nfrom math import ceil, floor, sqrt, pi, factorial, gcd\nfrom copy import deepcopy\nfrom collections import Counter, deque\nfrom heapq import heapify, heappop, heappush\nfrom itertools import accumulate, product, combinations, combinations_with_replacement\nfrom bisect import bisect, bisect_left, bisect_right\nfrom functools import reduce\nfrom decimal import Decimal, getcontext\n# input = sys.stdin.readline \ndef i_input(): return int(input())\ndef i_map(): return map(int, input().split())\ndef i_list(): return list(i_map())\ndef i_row(N): return [i_input() for _ in range(N)]\ndef i_row_list(N): return [i_list() for _ in range(N)]\ndef s_input(): return input()\ndef s_map(): return input().split()\ndef s_list(): return list(s_map())\ndef s_row(N): return [s_input for _ in range(N)]\ndef s_row_str(N): return [s_list() for _ in range(N)]\ndef s_row_list(N): return [list(s_input()) for _ in range(N)]\ndef lcm(a, b): return a * b \/\/ gcd(a, b)\nsys.setrecursionlimit(10 ** 6)\nINF = float('inf')\nMOD = 10 ** 9 + 7\nnum_list = []\nstr_list = []\n\ndef main():\n    x, k, d = i_map()\n\n    amari = x % d\n    shou = x \/\/ d\n\n    if k % 2 == 0:\n        if amari == 0:\n            if shou % 2 == 0:\n                if shou <= k:\n                    print(0)\n                    exit()\n                else:\n                    print(abs(x-k*d))\n                    exit()\n\n        if shou % 2 == 1:\n            if shou+1 <= k:\n                print(abs(x-(shou+1)*d))\n                exit()\n            else:\n                print(abs(x-(shou-1)*d))\n                exit()\n    else:\n        if amari == 0:\n            if shou % 2 == 1:\n                if shou <= k:\n                    print(0)\n                    exit()\n                else:\n                    print(abs(x-k*d))\n                    exit()\n\n        if shou % 2 == 0:\n            if shou+1 <= k:\n                print(abs(x-(shou+1)*d))\n                exit()\n            else:\n                print(abs(x-(shou-1)*d))\n                exit()\n\n    if shou <= k:\n            print(abs(x-shou*d))\n            # print('a')\n    else:\n        print(abs(x-k*d))  \n        # print('b')\n\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":629,"bad_solution":"import math, string, itertools, fractions, heapq, collections, re,  array, bisect, sys, random, time, copy, functools\n\n\nsys.setrecursionlimit(10**7)\ninf = 10 ** 20\neps = 1.0 \/ 10**10\nmod = 10**9+7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    v = LI()\n\n    vset = set(v)\n    if len(vset) == 1:\n        print(len(v)\/\/2)\n        exit()\n\n    #  n = 10**5\n    #  #  v = [10**5 - i%18 for i in range(n)]\n    #  v = [random.randint(0, 100) for i in range(n)]\n    #  print(v[:10])\n\n    odd = []\n    even = []\n    for idx, i in enumerate(v):\n        if idx % 2 == 0:\n            even.append(i)\n        else:\n            odd.append(i)\n\n    # Counterが速い\n    odd_count = collections.Counter(odd)\n    even_count = collections.Counter(even)\n\n    #  print(odd_count, even_count)\n    if len(odd_count) == len(even_count) == 1:\n        # 変更の必要なし\n        print(0)\n        exit()\n\n    if odd_count.most_common(1)[0][0] != even_count.most_common(1)[0][0]:\n        # 楽なほう\n        if len(odd_count) == 1:\n            even_result = sum([i[1] for i in even_count.most_common(len(even_count))[1:]])\n            print(even_result)\n        elif len(even_count) == 1:\n            odd_result = sum([i[1] for i in odd_count.most_common(len(odd_count))[1:]])\n            print(odd_result)\n        else:\n            odd_result = sum([i[1] for i in odd_count.most_common(len(odd_count))[1:]])\n            even_result = sum([i[1] for i in even_count.most_common(len(even_count))[1:]])\n            print(odd_result + even_result)\n    else:\n        # 全部同じ数字にならないようにしたい\n        # ２個め同士で比べて、２個めをより多く含んでる方はそっちにしちゃう\n        if len(odd_count) == 1:\n            even_result = even_count.most_common(1)[0][1]\n            even_result += sum([i[1] for i in even_count.most_common(len(even_count))[2:]])\n            print(even_result)\n        elif len(even_count) == 1:\n            odd_result = odd_count.most_common(1)[0][1]\n            odd_result += sum([i[1] for i in odd_count.most_common(len(odd_count))[2:]])\n            print(odd_result)\n        elif odd_count[1][1] > even_count[1][1]:\n            # oddは２つめに多いものを不変にする\n            # evenは１つめを不変に\n            odd_result = odd_count.most_common(1)[0][1]\n            even_result = sum([i[1] for i in even_count.most_common(len(even_count))[1:]])\n            print(odd_result + even_result)\n        else:\n            odd_result = sum([i[1] for i in odd_count.most_common(len(odd_count))[1:]])\n            even_result = even_count.most_common(1)[0][1]\n            print(odd_result + even_result)\n\nmain()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":630,"bad_solution":"import os\nimport sys\nfrom collections import defaultdict, Counter, deque\nfrom itertools import product, permutations,combinations, accumulate\nfrom operator import itemgetter\nfrom bisect import bisect_left,bisect\nfrom heapq import heappop,heappush,heapify\nfrom math import ceil, floor, sqrt\nfrom copy import deepcopy\n\n\ndef main():\n    n = int(input())\n    vectoer = []\n    flag = True\n    for i in range(n):\n        s = input()\n        vectoer.append(s)\n\n    if len(vectoer) != len(set(vectoer)):\n        flag = False\n\n    print(n)\n    for i in range(n-1):\n        if vectoer[i][-1] !=  vectoer[i+1][0]:\n            flag = False\n            break\n\n    if flag:\n        print(\"Yes\")\n    else:\n        print(\"No\")\n    \n\nif __name__ == '__main__':\n\tmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":631,"bad_solution":"import sys\ndef input(): return sys.stdin.readline().strip()\ndef mapint(): return map(int, input().split())\nsys.setrecursionlimit(10**9)\n\nH, W = mapint()\nch, cw = mapint()\ndh, dw = mapint()\nmaze = [list(input()) for _ in range(H)]\n\ndirc = set([(-1, 0), (1, 0), (0, -1), (0, 1)])\nfrom collections import deque\nfrom heapq import heappop, heappush\nQ = [(0, ch-1, cw-1)]\n\ndist = [[10**18]*W for _ in range(H)]\ndist[ch-1][cw-1] = 0\nans = 10**18\nwhile Q:\n    d, y, x = heappop(Q)\n    if d>dist[y][x]:\n        continue\n    dist[y][x] = d\n    if y==dh-1 and x==dw-1:\n        ans = d\n        break\n    for dy in range(-2, 3):\n        for dx in range(-2, 3):\n            ny, nx = y+dy, x+dx\n            if ny<0 or ny>=H or nx<0 or nx>=W:\n                continue\n            if maze[ny][nx]=='#':\n                continue\n            if (dy, dx) in dirc:\n                if dist[ny][nx]>d:\n                    heappush(Q, (d, ny, nx))\n            else:\n                if dist[ny][nx]>d+1:\n                    heappush(Q, (d+1, ny, nx))\nif ans>=10**17:\n    print(-1)\nelse:\n    print(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":632,"bad_solution":"import sys\nsys.setrecursionlimit(100000)\n\nN,K=map(int,input().split())\nSIZE=10**5+1; MOD=10**9+7 #998244353 #ここを変更する\n \nSIZE += 1\ninv = [0]*SIZE  # inv[j] = j^{-1} mod MOD\nfac = [0]*SIZE  # fac[j] = j! mod MOD\nfinv = [0]*SIZE # finv[j] = (j!)^{-1} mod MOD\ninv[1] = 1\nfac[0] = fac[1] = 1\nfinv[0] = finv[1] = 1\nfor i in range(2,SIZE):\n  inv[i] = MOD - (MOD\/\/i)*inv[MOD%i]%MOD\n  fac[i] = fac[i-1]*i%MOD\n  finv[i]= finv[i-1]*inv[i]%MOD\n\ndef narabekae(n,r): #nPr mod MOD の計算\n  if n-r<0:\n    return 0\n  return fac[n]*finv[n-r]%MOD\n\nbranch=[[] for _ in range(N)]\nfor i in range(N-1):\n  a,b=map(int,input().split())\n  branch[a-1].append(b-1)\n  branch[b-1].append(a-1)\n\nans=1\n\ndef draw(parent,nord):\n  global ans\n  children=len(branch[nord])-(parent !=-1)\n  if children==0:\n    return\n  #(K-2)*(K-1)*... をchildrenの数だけ掛ける。\n  ans=ans*narabekae(K-1-(parent !=-1),children)%MOD\n  for b in branch[nord]:\n    if b != parent:\n      draw(nord,b)\n\ndraw(-1,0)\nprint(ans*K%MOD)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":633,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys, math, itertools, collections, bisect\ninput = lambda: sys.stdin.buffer.readline().rstrip().decode('utf-8')\ninf = float('inf') ;mod = 10**9+7\nmans = inf ;ans = 0 ;count = 0 ;pro = 1\n\ndef check(sets):\n  n = len(sets)\n  data = [0]*n\n  count = 0\n  result_bit = 0\n  for j in range(w):\n    tmp = [0]*n\n    for i in range(h):\n      tmp[bisect.bisect_left(sets,i)]+=S[i][j]\n      # ここ不安\n    F = 0\n    for i in range(n):\n      if tmp[i] > K:return -1\n      if data[i] + tmp[i] > K:\n        F = 1\n      else:\n        data[i] += tmp[i]\n    if F:\n      result_bit |= (1<<j-1)\n      for i in range(n):\n        data[i] = tmp[i]\n  return result_bit\n    # if tmp > K:\n    #   return -1\n    # if count + tmp > K:\n    #   result_bit |= (1 << j-1)\n    #   count = tmp\n    # else:\n    #   count += tmp\n  return  result_bit\n\nh,w,K = map(int,input().split())\nS = [list(map(int,input())) for i in range(h)]\nfor bit in range(max(1,(h-1)**2)):\n  sets = []\n  for k in range(h-1):\n    if (bit >> k) & 1:\n      sets.append(k)\n  sets.append(h)\n  re = check(sets)\n  # print(re)\n  if re == -1: continue\n  mans = min(mans,collections.Counter(bin(bit))[\"1\"] + collections.Counter(bin(re))[\"1\"])\n  # print(bit,collections.Counter(bin(bit))[\"1\"] + collections.Counter(bin(re))[\"1\"],bit,re)\nprint(mans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":634,"bad_solution":"\ndef FUNC(n):\n    \"\"\"\n    Given a positive integer n, return the count of the numbers of n-digit\n    positive integers that start or end with 1.\n    \"\"\"\n    if n == 1: return 1\n    return 18 * n * (10 ** (n - 2))\n"}
{"id":635,"bad_solution":"# coding: utf-8\nimport sys\nsysread = sys.stdin.readline\nfrom heapq import heappop, heappush\n\ndef run():\n    N, M, S = list(map(int, sysread().split()))\n    to = [[] for _ in range(N+1)]\n    max_m = 2500\n    for _ in range(M):\n        u,m,a,b = list(map(int, sysread().split()))\n        to[u].append((m,b,a))\n        to[m].append((u,b,a))\n\n    cd = [int(i) for i in sys.stdin.read().split()]\n    C = [0]+ cd[::2]\n    D = [0]+ cd[1::2]\n\n    queue = []\n    # (time, node, rest-coin)\n    if S > max_m: S = max_m\n    heappush(queue, (0, 1, S))\n\n    state = [[1<<61] * (max_m+1) for _ in range(N+1)]\n\n    while queue:\n        time, node, coin = heappop(queue)\n        if state[node][coin] < time: continue\n        if coin + C[node] <= max_m and time + D[node] < state[node][coin+C[node]]:\n            state[node][coin+C[node]] = time + D[node]\n            heappush(queue, (time+D[node], node, coin+C[node]))\n        for n_node, n_time, n_coin in to[node]:\n            if coin < n_coin:continue\n            if state[n_node][coin-n_coin] < n_time + time:continue\n            state[n_node][coin - n_coin] = n_time + time\n            heappush(queue, (time + n_time, n_node, coin - n_coin))\n    for s in state[2:]:\n        print(min(s))\n\nif __name__ == \"__main__\":\n    run()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":636,"bad_solution":"import sys\ndef input():\n    return sys.stdin.readline()[:-1]\n\nN = int(input())\nS = input()\n\nfrom collections import defaultdict\nd = defaultdict(int)\n\nfor i in range(N):\n    s = S[i]\n    d[s] += 1\ncnt = 0\nfor i in range(N-2):\n    for j in range(i,N-1):\n        k = 2*j - i\n        if k <= N-1 and (S[i] != S[j] and S[j] != S[k] and S[k] != S[i]):\n            cnt += 1\nif d[\"R\"] and d[\"G\"] and d[\"B\"]:\n    ans = d[\"R\"] * d[\"G\"] * d[\"B\"] - cnt\n    print(ans)\nelse:\n    print(0)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":637,"bad_solution":"import itertools\n\ndef getint(): return int(input())\ndef getints(): return list(map(int, input().split()))\n\nn,k=getints()\ns=input()\nn=len(s)\n\nrl = []\nnow, cnt = '0', 0\n\nfor i in range(n):\n    if now != s[i]:\n        rl.append(cnt)\n        now = s[i]\n        cnt = 1\n    else:\n        cnt += 1\nif cnt > 0:\n    rl.append(cnt)\nacc=[0]*len(rl)\nacc[0]=rl[0]\nfor i in range(1, len(rl)):\n    acc[i] = acc[i-1]+rl[i]\n\n# print(rl)\n# print(acc)\n\nres = 0\nfor i in range(len(acc)):\n    if i % 2 == 0:\n        i0 = i - 2\n        j  = min(i + 2 * k - 1, len(acc) - 1)\n    else:\n        i0 = i - 1\n        j  = min(i + 2 * k, len(acc) - 1)\n    print(i,i0,j)\n    tmp1 = acc[i0] if i0 >= 0      else 0\n    tmp2 = acc[j]  if j < len(acc) else 0\n    res = max(res, tmp2-tmp1)\n\n\nprint(res)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":638,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\nclass Seg():\n    def __init__(self, na, default, func):\n        if isinstance(na, list):\n            n = len(na)\n        else:\n            n = na\n        i = 1\n        while 2**i <= n:\n            i += 1\n        self.D = default\n        self.H = i\n        self.N = 2**i\n        if isinstance(na, list):\n            self.A = [default] * (self.N) + na + [default] * (self.N-n)\n            for i in range(self.N-1,0,-1):\n                self.A[i] = func(self.A[i*2], self.A[i*2+1])\n        else:\n            self.A = [default] * (self.N*2)\n        self.F = func\n\n    def find(self, i):\n        return self.A[i + self.N]\n\n    def update(self, i, x):\n        i += self.N\n        self.A[i] = x\n        while i > 1:\n            i = i \/\/ 2\n            self.A[i] = self.merge(self.A[i*2], self.A[i*2+1])\n\n    def merge(self, a, b):\n        return self.F(a, b)\n\n    def total(self):\n        return self.A[1]\n\n    def query(self, a, b):\n        A = self.A\n        l = a + self.N\n        r = b + self.N\n        res = self.D\n        while l < r:\n            if l % 2 == 1:\n                res = self.merge(res, A[l])\n                l += 1\n            if r % 2 == 1:\n                r -= 1\n                res = self.merge(res, A[r])\n            l >>= 1\n            r >>= 1\n\n        return res\n\ndef main():\n    n = I()\n    xd = sorted([LI() for _ in range(n)])\n    xa = [x for x,_ in xd] + [inf]\n    r = [0] * n + [1]\n    def f(a,b):\n        if a > b:\n            return a\n        return b\n    seg = Seg(n+1,0,f)\n    for i in range(n-1,-1,-1):\n        x,d = xd[i]\n        xi = bisect.bisect_left(xa, x+d)\n        qi = seg.query(i,xi)\n        if qi > xi:\n            xi = qi\n        seg.update(i,xi)\n        r[i] = (r[i+1] + r[xi]) % mod2\n\n    return r[0]\n\n\nprint(main())\n\n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":639,"bad_solution":"def main():\n    import sys\n    input = sys.stdin.readline\n    sys.setrecursionlimit(10**7)\n    from collections import Counter, deque\n    #from collections import defaultdict\n    from itertools import combinations, permutations, accumulate, groupby\n    #from itertools import product\n    from bisect import bisect_left,bisect_right\n    from heapq import heapify, heappop, heappush\n    from math import floor, ceil\n    #from operator import itemgetter\n\n    #inf = 10**17\n    #mod = 10**9 + 7\n\n    n,m = map(int, input().split())\n    a = list(map(int, input().split()))\n    a.sort()\n    while 1:\n        a[-1] = a[-1] \/\/ 2\n        m -= 1\n        p = bisect_right(a, a[-1])\n        for i in range(p, n-1):\n            if m==0:\n                break\n            a[i] = a[i] \/\/ 2\n            m -= 1\n        a.sort()\n        if m==0:\n            break\n    print(sum(a))\n\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":640,"bad_solution":"def main():\n    N, Q = map(int, input().split())\n    C = list(map(int, input().split()))\n    E = []\n\n    D = {C[i]: -1 for i in range(N)}\n    for i in range(N):\n        if D[C[i]] != -1:\n            E.append((D[C[i]], i, -1))\n        D[C[i]] = i\n\n    for i in range(Q):\n        l, r = map(int, input().split())\n        E.append((l - 1, r - 1, i))\n\n    def f(tup):\n        return tup[0]\n    E.sort(key=f, reverse=True)\n\n    # Binary Indexed Tree (Fenwick Tree)\n    class BIT:\n        def __init__(self, n):\n            self.n = n\n            self.data = [0] * (n + 1)\n            self.el = [0] * (n + 1)\n\n        def sum(self, i):\n            s = 0\n            while i > 0:\n                s += self.data[i]\n                i -= i & -i\n            return s\n\n        def add(self, i, x):\n            # assert i > 0\n            self.el[i] += x\n            while i <= self.n:\n                self.data[i] += x\n                i += i & -i\n\n        def get(self, i, j=None):\n            if j is None:\n                return self.el[i]\n            return self.sum(j) - self.sum(i)\n\n    ANS = [0] * Q\n    d = BIT(N)\n    for e in E:\n        if e[2] == -1:\n            d.add(e[1], 1)\n        else:\n            ANS[e[2]] = e[1] - e[0] + 1 - d.sum(e[1])\n\n    for i in range(Q):\n        print(ANS[i])\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":641,"bad_solution":"from collections import Counter,defaultdict,deque\nfrom heapq import heappop,heappush,heapify\nimport sys,bisect,math,itertools,fractions,pprint\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nmod2 = 998244353\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\nn,m,v,p = inpl()\na = inpl()\nc = Counter(a)\na.sort()\nb_num = a[n-p]\nbb = sorted(list(set(a)))\nd_cnt = 0\nb_cnt = 0\nu_cnt = 0\nfor i in a:\n    if i < b_num: d_cnt += 1\n    elif i == b_num: b_cnt += 1\n    else: u_cnt += 1\n\ndef f(x,i):\n    cnt = 0\n    for ind,item in enumerate(a):\n        if item > b_num or item <= x:\n            cnt += m\n        else:\n            cnt += x + m - item\n    if cnt >= m*v:\n        return True\n    else:\n        return False\n\nok = n\nng = -1\nwhile abs(ok-ng) > 1:\n    mid = (ok+ng)\/\/2\n    if f(a[mid],mid):\n        ok = mid\n    else:\n        ng = mid\nprint(n-mid)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":642,"bad_solution":"import sys\ndef input(): return sys.stdin.readline().rstrip()\nfrom collections import Counter\nfrom operator import itemgetter\ndef main():\n    n=int(input())\n    V=[int(_) for _ in input().split()]\n    even=V[0::2]\n    odd=V[1::2]\n    even_c=Counter(even)\n    odd_c=Counter(odd)\n    even_ci,odd_ci=list(even_c.items()),list(odd_c.items())\n    even_ci.sort(key=itemgetter(1),reverse=True)\n    odd_ci.sort(key=itemgetter(1),reverse=True)\n    print(even_ci)\n    print(odd_ci)\n    if even_ci[0][0]==odd_ci[0][0]:\n        print(n\/\/2)\n    else:\n        print(sum(even_c.values())-even_ci[0][1]+sum(odd_c.values())-odd_ci[0][1])\n\nif __name__=='__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":643,"bad_solution":"#!\/usr\/bin\/env python\n\ndef main():\n    n = int(input())\n    a = list(map(int, input().split()))\n    a_sort = sorted(a)\n\n    ball_dict = {}\n    count = 1\n    for i in range(1, n):\n        if a_sort[i] == a_sort[i - 1]:\n            count += 1\n        else:\n            ball_dict.setdefault(a_sort[i - 1], count)\n            count = 1\n    ball_dict.setdefault(a_sort[n - 1], count)\n\n    ans = 0\n    for v in ball_dict.values():\n        ans += v * (v - 1) \/\/ 2\n\n    ans_dict = {}\n    for v in ball_dict.values():\n        if v not in ans_dict.values():\n            ans_dict.setdefault(v, ans - (v - 1))\n\n    for i in range(n):\n        print(ans_dict[ball_dict[a[i]]])\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":644,"bad_solution":"\ndef FUNC(N):\n    \"\"\"Given a positive integer N, return the total sum of its digits in binary.\n    \n    Example\n        For N = 1000, the sum of digits will be 1 the output should be \"1\".\n        For N = 150, the sum of digits will be 6 the output should be \"110\".\n        For N = 147, the sum of digits will be 12 the output should be \"1100\".\n    \n    Variables:\n        @N integer\n             Constraints: 0 ≤ N ≤ 10000.\n    Output:\n         a string of binary number\n    \"\"\"\n    return bin([int(i) for i in str(N)][-1])[2:]\n"}
{"id":645,"bad_solution":"mod = 1000000007\neps = 10**-9\n\n\ndef main():\n    import sys\n    input = sys.stdin.readline\n\n    N = int(input())\n    XY_pos = []\n    XY_neg = []\n    balance = 0\n    for _ in range(N):\n        S = input().rstrip('\\n')\n        st = []\n        for s in S:\n            if s == \"(\":\n                st.append(s)\n            else:\n                if st:\n                    if st[-1] == \"(\":\n                        st.pop()\n                    else:\n                        st.append(s)\n                else:\n                    st.append(s)\n        x = y = 0\n        for s in st:\n            if s == \"(\":\n                y += 1\n            else:\n                x += 1\n        balance += x - y\n        if x > y:\n            XY_neg.append((x, y))\n        else:\n            XY_pos.append((x, y))\n    if balance:\n        print(\"No\")\n        exit()\n\n    XY_pos.sort(key=lambda p: p[0])\n    val = 0\n    for x, y in XY_pos:\n        if x > val:\n            print(\"No\")\n            #print(x, y, val)\n            exit()\n        val += y - x\n    XY_neg.sort(key=lambda p: p[0], reverse=True)\n    for x, y in XY_neg:\n        if x > val:\n            print(\"No\")\n            #print(x, y, val)\n            exit()\n        val += y - x\n    print(\"Yes\")\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":646,"bad_solution":"# Reference: https:\/\/qiita.com\/dn6049949\/items\/afa12d5d079f518de368\n\n# self.data: 1-indexed\n#    __1__\n#  _2_   _3_\n# 4   5 6   7\n\n# f(f(a, b), c) == f(a, f(b, c))\n\nclass SegmentTree:\n    # a = [default] * n\n    # O(n)\n    def __init__(self, n, f=max, default=-2**30):\n        self.num_leaf = 2 ** (n-1).bit_length()\n        self.data = [default] * (2*self.num_leaf)\n        self.f = f\n\n    # a[i] = x\n    # O(log(n))\n    def update(self, i, x):\n        i += self.num_leaf\n        self.data[i] = x\n        i >>= 1\n        while i > 0:\n            self.data[i] = self.f(self.data[2*i], self.data[2*i+1])\n            i >>= 1\n\n    # return f(a[l:r])\n    # O(log(n))\n    def query(self, l, r):\n        l += self.num_leaf\n        r += self.num_leaf - 1\n        lres, rres = self.data[0], self.data[0] # self.data[0] == default\n        while l < r:\n            if l & 1:\n                lres = self.f(lres, self.data[l])\n                l += 1\n            if not r & 1:\n                rres = self.f(self.data[r], rres)\n                r -= 1\n            l >>= 1\n            r >>= 1\n        if l == r:\n            res = self.f(self.f(lres, self.data[l]), rres)\n        else:\n            res = self.f(lres, rres)\n        return res\n\nfrom sys import stdin\ninput = lambda: stdin.readline().strip()\n\ndef main():\n    n, q = map(int, input().split())\n    c = list(map(int, input().split()))\n    \n    st = SegmentTree(n, f=lambda x, y: x | y, default=set([]))\n    for i, ci in enumerate(c):\n        st.update(i, {ci})\n    \n    ans = [0] * q\n    for lap in range(q):\n        l, r = map(int, input().split())\n        ans[lap] = len(st.query(l-1, r))\n    \n    for i in ans:\n        print(i)\n\nmain()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":647,"bad_solution":"import sys\nimport bisect\nn = int(input())\ns = list(input())\nalpha = \"abcdefghijklmnopqrstuvwxyz\"\ndict = {i:[] for i in alpha}\nfor i, _s in enumerate(s):\n    dict[_s].append(i)\nq = int(input())\nfor i in range(q):\n    type, first, last = [i for i in sys.stdin.readline().split()]\n    if type == \"2\":\n        first = int(first)\n        last = int(last)\n        first -= 1\n        last -= 1\n        cnt = 0\n        for a in alpha:\n            ls = dict[a]\n            if bisect.bisect_left(ls, first) != bisect.bisect_right(ls, last):\n                cnt += 1\n        print(cnt)\n    else:\n        first = int(first)\n        first -= 1\n        dict[s[first]].remove(first)\n        s[first] = last\n        bisect.insort_left(dict[last], first)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":648,"bad_solution":"from math import gcd\n\nN = int(input())\nA = list(map(int, input().split()))\n\ng_all = A[0]\nfor a in A[1:]:\n    g_all = gcd(g_all, a)\n\nif g_all > 1:\n    print('not coprime')\n    quit()\n\ndef sieve(n):\n    is_prime = [True for _ in range(n+1)]\n    is_prime[0] = False\n    for i in range(2, n+1):\n        if is_prime[i-1]:\n            j = 2 * i\n            while j <= n:\n                is_prime[j-1] = False\n                j += i\n    table = [ i for i in range(1, n+1) if is_prime[i-1]]\n    return is_prime, table\n\n\nappeared = [False] * (10**6 + 1)\nprimes = sieve(10**3)[1]\nfor a in A:\n    if a == 1:\n        continue\n    for p in primes:\n        if a % p == 0:\n            if appeared[p]:\n                print('setwise coprime')\n                quit()\n            appeared[p] = True\n            while a % p == 0:\n                a \/\/= p\n    \n    if a != 1:\n        if appeared[a]:\n            print('setwize coprime')\n            quit()\n        \n        appeared[a] = True\n\nprint('pairwise coprime')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":649,"bad_solution":"from sys import stdin\n\n\ndef main():\n    N = int(stdin.readline().rstrip())\n    a = [y for y in [6 ** x for x in range(1, 10)] if y <= 100000]\n    b = [y for y in [9 ** x for x in range(1, 10)] if y <= 100000]\n    c = a + b\n\n    count = 0\n\n    if N < 18:\n        if N == 17:\n            print(count + 4)\n        elif N == 16:\n            print(count + 3)\n        elif N == 15:\n            print(count + 2)\n        elif N == 14:\n            print(count + 4)\n        elif N == 13:\n            print(count + 3)\n        elif N == 12:\n            print(count + 2)\n        elif N == 11:\n            print(count + 3)\n        elif N == 10:\n            print(count + 2)\n        elif N == 9:\n            print(count + 1)\n        elif N == 8:\n            print(count + 3)\n        elif N == 7:\n            print(count + 2)\n        elif N == 6:\n            print(count + 1)\n        else:\n            print(count + N)\n        return\n\n    while True:\n        tmp = max([x for x in c if x <= N])\n        N -= tmp\n        count += 1\n        if N < 18:\n            if N == 17:\n                print(count + 4)\n            elif N == 16:\n                print(count + 3)\n            elif N == 15:\n                print(count + 2)\n            elif N == 14:\n                print(count + 4)\n            elif N == 13:\n                print(count + 3)\n            elif N == 12:\n                print(count + 2)\n            elif N == 11:\n                print(count + 3)\n            elif N == 10:\n                print(count + 2)\n            elif N == 9:\n                print(count + 1)\n            elif N == 8:\n                print(count + 3)\n            elif N == 7:\n                print(count + 2)\n            elif N == 6:\n                print(count + 1)\n            else:\n                print(count + N)\n            return\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":650,"bad_solution":"#!\/usr\/bin\/env python\n\nALPHA = sorted([a for a in \"zyxwvutsrqponmlkjihgfedcba\"])\n\n\ndef main():\n    S = input().strip()\n\n    if 'zyxwvutsrqponmlkjihgfedcba' == S:\n        return '-1'\n\n    S = [s for s in S]\n    ans = []\n    for s in S:\n        if s in ALPHA:\n            ALPHA.remove(s)\n            ans.append(s)\n        else:\n            ans.append(ALPHA.pop(0))\n            break\n    else:\n        if ALPHA:\n            ans.append(ALPHA.pop(0))\n        else:\n            alpha = sorted([a for a in \"zyxwvutsrqponmlkjihgfedcba\"])\n            for i in range(len(ans) - 1, 0, -1):\n                if ans[i - 1] < ans[i]:\n                    break\n            ans = ans[:i - 1]\n            ans.append(sorted(list(set(alpha) - set(ans[:i - 1]))).pop(0))\n    return \"\".join(ans)\n\n\nif __name__ == '__main__':\n    ans = main()\n    print(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":651,"bad_solution":"\ndef FUNC(lst):\n    \"\"\"Given a non-empty list of integers lst. FUNC the even elements that are at odd indices..\n\n\n    Examples:\n        FUNC([4, 2, 6, 7]) ==> 2 \n    \"\"\"\n    return sum([lst[i] for i in range(1, len(lst), 1) if lst[i]%2 == 0])\n"}
{"id":652,"bad_solution":"from collections import *\n\nN, X, D = map(int, input().split())\n\nif D==0:\n    print(N+1)\n    exit()\n    \nl = []\n\nfor i in range(N+1):\n    L = i*(i-1)\/\/2\n    U = i*(2*N-i-1)\/\/2\n    \n    if D>0:\n        l.append((i*X+L*D, U-L+1))\n    else:\n        l.append((i*X+U*D, U-L+1))\n\nd = defaultdict(list)\n\nfor li in l:\n    d[li[0]%abs(D)].append(li)\n\nans = 0\n\nfor v in d.values():\n    m = min(vi[0] for vi in v)\n    lr = []\n    \n    for vi in v:\n        l = (vi[0]-m)\/\/abs(D)\n        r = l+vi[1]-1\n        lr.append((l, r))\n        \n    events = []\n    \n    for li, ri in lr:\n        events.append((li, 1))\n        events.append((ri+1, -1))\n    \n    events.sort(key=lambda t: t[0])\n    now = 0\n    \n    for event in events:\n        now += event[1]\n        \n        if now==0:\n            ans += event[0]-left\n        elif event[1]==1 and now==1:\n            left = event[0]\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":653,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nimport bisect\nfrom math import *\nfrom itertools import *\nfrom collections import *\nfrom functools import *\ntry:\n    from math import gcd\nexcept Exception:\n    from fractions import gcd\n\n\ndef solve(N: int, M: int):\n    ds = []\n    for i in range(1, int(ceil(sqrt(M)))):\n        if M % i == 0:\n            ds.append(i)\n            ds.append(M \/\/ i)\n    ds.sort()\n  \n    th = M \/\/ N\n    return ds[bisect.bisect(ds, th)-1]\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    result = solve(N, M)\n    print(result)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":654,"bad_solution":"def big_one_multiply(A, b):\n  carry = 0\n  M = []\n  for i in range(len(A)):\n    x = int(A[-i-1]) * int(b) + carry\n    M.insert(0, x % 10)\n    carry = x \/\/ 10\n  if carry > 0:\n    M.insert(0, carry)\n  return M\n\ndef big_big_plus(A, B):\n  carry = 0\n  S = []\n  if len(A) > len(B):\n    B = [0] * (len(A) - len(B)) + B\n  elif len(A) < len(B):\n    A = [0] * (len(B) - len(A)) + A\n  for i in range(len(A)):\n    x = int(A[-i-1]) + int(B[-i-1]) + carry\n    S.insert(0, x % 10)\n    carry = x \/\/ 10\n  if carry > 0:\n    S.insert(0, carry)\n  return S\n    \n\ntmp = input().split(\" \")\nA = list(tmp[0])\nB = list(filter(lambda n: n != \".\", list(tmp[1])))\n\nans = [0]\nfor i in range(len(B)):\n  ans = big_big_plus(ans, big_one_multiply(A, B[-i-1]) + [0] * i)\n\nz = \"\".join([str(n) for n in ans[:-2]])\nprint(z) if z else print(0)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":655,"bad_solution":"\ndef FUNC(s):\n    \"\"\"\n    Write a function that takes a string and returns an ordered version of it.\n    Ordered version of string, is a string where all words (separated by space)\n    are replaced by a new word where all the characters arranged in\n    ascending order based on ascii value.\n    Note: You should keep the order of words and blank spaces in the sentence.\n\n    For example:\n    FUNC('Hi') returns 'Hi'\n    FUNC('hello') returns 'ehllo'\n    FUNC('Hello World!!!') returns 'Hello !!!Wdlor'\n    \"\"\"\n    return ''.join([''.join(sorted(list(i))) for i in s.split(' ')])\n"}
{"id":656,"bad_solution":"\ndef FUNC(lst, x):\n    \"\"\"\n    You are given a 2 dimensional data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n    each row may contain a different number of columns.\n    Given lst, and integer x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2, y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also, sort coordinates of the row by columns in descending order.\n    \n    Examples:\n    FUNC([\n      [1,2,3,4,5,6],\n      [1,2,3,4,1,6],\n      [1,2,3,4,5,1]\n    ], 1) == [(0, 0), (1, 4), (1, 0), (2, 5), (2, 0)]\n    FUNC([], 1) == []\n    FUNC([[], [1], [1, 2, 3]], 3) == [(2, 2)]\n    \"\"\"\n    coords = [(j, i) for i in range(len(lst)) for j in range(len(lst[i])) if lst[i][j] == x]\n    return sorted(sorted(coords, key=lambda x: x[1], reverse=True), key=lambda x: x[0])\n"}
{"id":657,"bad_solution":"#\n# 　　  ⋀_⋀　 \n#　　  (･ω･)  \n# .／ Ｕ ∽ Ｕ＼\n#  │＊　合　＊│\n#  │＊　格　＊│ \n#  │＊　祈　＊│ \n#  │＊　願　＊│ \n#  │＊　　　＊│ \n#      ￣\n#\nimport sys\nsys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\nfrom math import floor,sqrt,factorial,hypot,log #log2ないｙｐ\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,permutations,combinations,product,combinations_with_replacement\nfrom bisect import bisect_left,bisect_right\nfrom copy import deepcopy\nfrom fractions import gcd\nfrom random import randint\ndef ceil(a,b): return (a+b-1)\/\/b\ninf=float('inf')\nmod = 10**9+7\ndef pprint(*A): \n    for a in A:     print(*a,sep='\\n')\ndef INT_(n): return int(n)-1\ndef MI(): return map(int,input().split())\ndef MF(): return map(float, input().split())\ndef MI_(): return map(INT_,input().split())\ndef LI(): return list(MI())\ndef LI_(): return [int(x) - 1 for x in input().split()]\ndef LF(): return list(MF())\ndef LIN(n:int): return [I() for _ in range(n)]\ndef LLIN(n: int): return [LI() for _ in range(n)]\ndef LLIN_(n: int): return [LI_() for _ in range(n)]\ndef LLI(): return [list(map(int, l.split() )) for l in input()]\ndef I(): return int(input())\ndef F(): return float(input())\ndef ST(): return input().replace('\\n', '')\ndef is_sym(S):\n    N = len(S)\n    for i in range(N):\n        for j in range(N):\n            if S[i][j] != S[j][i]:\n                return False\n    return True\ndef main():\n    N=I()\n    S=[ST() for _ in range(N)]\n    ans = 0\n    for A in range(N):\n        S=S[1:] + S[:1]\n        if(is_sym(S)):\n            ans += N\n    print(ans)\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":658,"bad_solution":"from heapq import heappush, heappop\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations\nimport sys\nimport bisect\nimport string\nsys.setrecursionlimit(10**6)\ndef SI():\n    return input().split()\ndef MI():\n    return map(int,input().split())\ndef I():\n    return int(input())\ndef LI():\n    return [int(i) for i in input().split()]\nYN=['Yes','No']\nmo=10**9+7\n\np=I()\na=LI()\n\nmo=float('inf')\nmo=p\n\nclass polynomial:\n    coeff=[]\n    def __init__(self,ls):\n        self.coeff=[i for i in ls]\n        \n    def show(self):\n        s=''\n        f=self.coeff\n        n=len(f)\n        for i in range(n):\n            if f[n-1-i]==0:\n                continue\n            s+=('+' if f[n-1-i]>=0 else '')+str(f[n-1-i])+('x^'+str(n-1-i) if i!=n-1 else '')\n        print(s[1:])\n\n    def value(self,x):\n        x_p=1\n        rt=0\n        for i in self.coeff:#range(len(self.coeff)):\n            rt+=i*x_p\n            x_p*=x\n        return rt\n            \n    def mod(self):\n        self.coeff=[i%mo for i in self.coeff]\n        \n    def add(self,poly):\n        g=poly.coeff\n        n=len(self.coeff)\n        m=len(g)\n        if n>m:\n            g+=[0]*(n-m)\n        else:\n            self.coeff+=[0]*(m-n)\n        self.coeff=[i+j for i,j in zip(self.coeff,g)]\n        return self\n        \n    def mult(self,poly):\n        if type(poly) in (int,float):\n            poly=polynomial([poly])\n        f=self.coeff\n        g=poly.coeff\n        n=len(self.coeff)\n        m=len(g)\n        h=[0]*(n+m-1)\n        for i in range(n):\n            for j in range(m):\n                h[i+j]+=f[i]*g[j]\n                \n        self.coeff=h\n        return self\n        \n    def div(self,poly):\n        # f=[a0,a1,...,a(n-1)], f(x) = a0 + a1*x + ... + a(n-1)*x^(n-1)\n        # g=[b0,b1,...,b(m-1)], g(x) = b0 + b1*x + ... + b(m-1)*x^(m-1)\n        f=[i for i in self.coeff]\n        g=poly.coeff\n        n=len(f)\n        m=len(g)\n        d=[]\n        if g[-1]==0:\n            # error\n            return None\n        if m>n:\n            return (0,f)\n        for i in range(n-m+1):\n            c=div(f[n-1-i],g[m-1])\n            d+=[c]\n            for j in range(m):\n                f[n-1-i-j]-=c*g[m-1-j]\n        return (polynomial(d[::-1]),polynomial(f[:n-m+1]))\n            \ndef p_inv(x,p):\n    return pow(x,p-2,p)\n    \ndef div(a,b):\n    #return a\/b\n    return a*p_inv(b,p)%p\n\nfor i in range(1,p):\n    for j in range(1,p):\n        if i*j%p==1:\n            0#inv[i]=j\n\n# calc Prod{(x-j)}\nL=polynomial([0,1])\nfor i in range(1,p):\n    L.mult(polynomial([-i,1]))\n    L.mod()\n\nS=[L.div(polynomial([i,-1]))[0] for i in range(p)]\n\nA=polynomial([0]*p)\nfor i in range(p):\n    if a[i]==1:\n        A.add(S[i])\nprint(*[i%mo for i in A.coeff])\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":659,"bad_solution":"from collections import defaultdict, deque\ndef solve():\n    H,W = map(int,input().split())\n    Ch,Cw = map(int,input().split())\n    Ch -= 1\n    Cw -= 1\n    Dh,Dw = map(int,input().split())\n    Dh -= 1\n    Dw -= 1\n\n    S = [list(input()) for _ in range(H)]\n    area_num = 0\n    for h in range(H):\n        for w in range(W):\n            if S[h][w] == '.':\n                dfs(h,w,H,W,S,area_num)\n                area_num += 1\n\n    start_area_num = int(S[Ch][Cw])\n    goal_area_num = int(S[Dh][Dw])\n\n    G = defaultdict(set)\n\n    for h in range(H):\n        for w in range(W):\n            from_area_num = S[h][w]\n            if from_area_num == '#':\n                continue\n            from_area_num = int(from_area_num)\n\n            d = ((0,-1),(0,1),(-1,0),(1,0))\n            close_to_wall = False\n            for dh, dw in d:\n                if dh+h < 0 or dh+h >= H:\n                    continue\n                if dw+w < 0 or dw+w >= W:\n                    continue\n\n                if S[dh+h][dw+w] == '#':\n                    close_to_wall = True\n            \n            if not close_to_wall:\n                continue\n\n            for dh in range(-2,2+1):\n                if h+dh < 0 or h+dh >= H:\n                    continue\n                for dw in range(-2, 2+1):\n                    if w+dw < 0 or w+dw >= W:\n                        continue\n                    to_area_num = S[h+dh][w+dw]\n                    if to_area_num == '#':\n                        continue\n                    to_area_num = int(to_area_num)\n                    if from_area_num != to_area_num:\n                        G[to_area_num].add(from_area_num)\n                        G[from_area_num].add(to_area_num)\n    \n    area_num_count = area_num + 1\n    visited = [False] * area_num_count\n    q = deque()\n    q.append((start_area_num,0))\n    while len(q) > 0:\n        cur_area_num, warp_cnt = q.popleft()\n        if cur_area_num == goal_area_num:\n            print(warp_cnt)\n            return\n        \n        visited[cur_area_num] = True\n        for next_area_num in G[cur_area_num]:\n            if not visited[next_area_num]:\n                q.append((next_area_num,warp_cnt+1))\n    else:\n        print(-1)\n\ndef dfs(h,w,H,W,S,area_num):\n    if 0 <= h < H and 0 <= w < W and S[h][w] == '.':\n        S[h][w] = str(area_num)\n        dfs(h+1,w,H,W,S,area_num)\n        dfs(h,w+1,H,W,S,area_num)\n        dfs(h-1,w,H,W,S,area_num)\n        dfs(h,w-1,H,W,S,area_num)\n\nif __name__ == '__main__':\n    solve()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":660,"bad_solution":"# -*- coding: utf-8 -*-\n\nimport sys\ninput = sys.stdin.readline\n\ndef io_generator():\n\treturn input()\n\n#+++++++++++++++++++\n\ndef main(io):\n\tn,k= map(int, io().split())\n\ts=[int(i) for i in io()[:n]]\n\tinit=s[0]\n\tll=[]\n\tm=0\n\tpre=init\n\tfor c in s:\n\t\tif c == pre:\n\t\t\tm+=1\n\t\telse:\n\t\t\tll.append(m)\n\t\t\tm=1\n\t\t\tpre=c\n\toff= 1 if init==1 else 0\n\tif len(ll)<=2*k + off:\n\t\treturn n\n\tpre=sum(ll[:2*k+off])\n\trr_max=pre\n\tfor i in range(len(ll)\/\/2 - k):\n\t\tcc=pre - ll[i] - ll[i+1] + ll[2*k]+ll[2*k+1]\n\t\trr_max = max(rr_max, cc)\n\t\tpre=cc\n\treturn rr_max\n\n\n#++++++++++++++++++++\n\nif __name__ == \"__main__\":\n\tio= lambda : io_generator()\n\tprint (main(io))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":661,"bad_solution":"def answer(matrix):\n    h = len(matrix)\n    w = len(matrix[0])\n    P, IM = (\"Possible\", \"Impossible\")\n    cp = [0, 0] # current position\n    rightBottom = [len(matrix)-1, len(matrix[0])-1]\n    while(True):\n        matrix[cp[0]][cp[1]] = '.'\n        # Up\n        if cp[0] > 0 and matrix[cp[0]-1][cp[1]] == '#': return IM\n        # Left\n        if cp[1] > 0 and matrix[cp[0]][cp[1]-1] == '#': return IM\n        # Bottom\n        if cp[0]+1 < h and matrix[cp[0]+1][cp[1]] == '#':\n            if cp[1]+1 < w and matrix[cp[0]][cp[1]+1] == '#':\n                return IM\n            cp[0] = cp[0]+1\n            print(cp)\n            continue\n        # Right\n        if cp[1]+1 < w and matrix[cp[0]][cp[1]+1] == '#':\n            cp[1] = cp[1]+1\n            continue\n        if cp[0] == rightBottom[0] and cp[1] == rightBottom[1]:\n            return P\n    return P\n\nh, w = map(int, input().split())\nmatrix = []\nfor _ in range(h):\n    row = [c for c in input()]\n    matrix.append(row)\nprint(matrix)\nprint(answer(matrix))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":662,"bad_solution":"import bisect\n\ndef bl(A,x):\n    return bisect.bisect_left(A,x)\n\nA,B,Q = map(int,input().split())\n\nS,T = [],[]\nfor i in range(A): S.append(int(input()))\nfor i in range(B): T.append(int(input()))\n\nO = []\nfor i in range(Q):\n    x = int(input())\n    s = 0\n    t = 0\n    \n    xs = bl(S,x)\n    xt = bl(T,x)\n    st = 0\n    ts = 0\n    \n    XtoS = 0\n    XtoT = 0\n    StoT = 0\n    TtoS = 0\n    \n    if xs==A:xs-=1\n    if xt==B:xt-=1\n    if xs==0 or abs(x-S[xs]) < abs(x-S[xs-1]):\n        XtoS = abs(x-S[xs])\n        s = S[xs]\n        st = bl(T,S[xs])\n    else:\n        XtoS = abs(x-S[xs-1])\n        s = S[xs-1]\n        st = bl(T,S[xs-1])\n    if xt==0 or abs(x-T[xt]) < abs(x-T[xt-1]):\n        XtoT = abs(x-T[xt])\n        t = T[xt]\n        ts = bl(S,T[xt])\n    else:\n        XtoT = abs(x-T[xt-1])\n        t = T[xt-1]\n        ts = bl(S,T[xt-1])\n\n    if ts==A:ts-=1\n    if st==B:st-=1\n    if ts==0 or abs(t-S[ts]) < abs(t-S[ts-1]):\n        TtoS = abs(t-S[ts])\n    else:\n        TtoS = abs(t-S[ts-1])\n    if st==0 or abs(s-T[st]) < abs(s-T[st-1]):\n        StoT = abs(s-T[st])\n    else:\n        StoT = abs(s-T[st-1])\n        \n    #print(XtoS+StoT,XtoT+TtoS)\n    O.append(min([XtoS+StoT,XtoT+TtoS]))\n    \nfor o in O:\n    print(o)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":663,"bad_solution":"import sys\ninput=sys.stdin.readline\nimport collections\n\ndef main():\n    N = int(input())\n    Q = [collections.deque(map(int, input().split())) for _ in range(N)]\n    games = N*(N-1)\/\/2\n\n    days = 0\n    for _ in range(games):\n        gamed = [0 for _ in range(N)]\n        for i in range(N-1):\n            if gamed[i] or not len(Q[i]):\n                continue\n            j = Q[i][0] - 1\n            if gamed[j] or not len(Q[j]):\n                continue\n            if Q[j][0] == i+1:\n#                print(\"game:\", j+1, i+1, days)\n                Q[i].popleft()\n                Q[j].popleft()\n                gamed[i] = gamed[j] = 1\n                games -= 1\n        days += 1\n        if not 1 in gamed:\n            print(-1)\n            return\n        if games == 0:\n            break\n\n    print(days)\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":664,"bad_solution":"\ndef FUNC(array):\n    \"\"\"\n    Given an array of non-negative integers, return a copy of the given array after sorting,\n    you will sort the given array in ascending order if the sum( first index value, last index value) is odd,\n    or sort it in descending order if the sum( first index value, last index value) is even.\n\n    Note:\n    * don't change the given array.\n\n    Examples:\n    * FUNC([]) => []\n    * FUNC([5]) => [5]\n    * FUNC([2, 4, 3, 0, 1, 5]) => [0, 1, 2, 3, 4, 5]\n    * FUNC([2, 4, 3, 0, 1, 5, 6]) => [6, 5, 4, 3, 2, 1, 0]\n    \"\"\"\n    return [] if len(array) == 0 else sorted(array, reverse= (array[0]+array[-1]) % 2 != 0) \n"}
{"id":665,"bad_solution":"import sys\nimport numpy as np\nimport numba\nfrom numba import njit\nfrom numba.types import Omitted\ni4 = numba.int32\ni8 = numba.int64\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nBsize = 700\n\n@njit((i8[:, :], ), cache=True)\ndef Mo_argsort(LR):\n    L = LR[:, 0]\n    R = LR[:, 1]\n    key1 = L \/\/ Bsize\n    key2 = np.where(key1 & 1, -R, R)\n    key = (key1 << 32) + key2\n    return np.argsort(key)\n\ndef main(A, LR):\n    N = len(A)\n    Q = len(LR)\n    ind = Mo_argsort(LR)\n    count = np.zeros(N + 1, np.int64)\n    ans = 0\n\n    def add(x):\n        nonlocal ans\n        if not count[x]:\n            ans += 1\n        count[x] += 1\n\n    def rem(x):\n        nonlocal ans\n        count[x] -= 1\n        if not count[x]:\n            ans -= 1\n\n    answers = np.empty(Q, np.int64)\n    nl, nr = 0, 0\n    for i in ind:\n        l, r = LR[i]\n        l -= 1\n        # 区間 [l, r) に対する計算\n        while nl > l:\n            nl -= 1\n            add(A[nl])\n        while nr < r:\n            add(A[nr])\n            nr += 1\n        while nl < l:\n            rem(A[nl])\n            nl += 1\n        while nr > r:\n            nr -= 1\n            rem(A[nr])\n        #  答を求めて ans[i] に格納する\n        answers[i] = ans\n    return answers\n\nif sys.argv[-1] == 'ONLINE_JUDGE':\n    import numba\n    from numba.pycc import CC\n    i4 = numba.int32\n    i8 = numba.int64\n    cc = CC('my_module')\n\n    def cc_export(f, signature):\n        cc.export(f.__name__, signature)(f)\n        return numba.njit(f)\n\n    main = cc_export(main, (i8[:], i8[:, :]))\n    cc.compile()\n\nfrom my_module import main\n\nN, Q = map(int, readline().split())\nA = np.array(readline().split(), np.int64)\nLR = np.array(read().split(), np.int64).reshape(Q, 2)\n\nans = main(A, LR)\nprint('\\n'.join(map(str, ans.tolist())))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":666,"bad_solution":"\ndef FUNC(s):\n    \"\"\"Create a function FUNC that takes a string as an argument and\n    returns a string FUNCed with the alphabet being rotated. \n    The alphabet should be rotated in a manner such that the letters \n    shift down by two multiplied to two places.\n    For example:\n    FUNC('hi') returns 'lm'\n    FUNC('asdfghjkl') returns 'ewhjklnop'\n    FUNC('gf') returns 'kj'\n    FUNC('et') returns 'ix'\n    \"\"\"\n    d = 'abcdefghijklmnopqrstuvwxyz'\n    out = ''\n    for c in s:\n        if c in d:\n            out += d[(d.index(c)+2*2) % 24]\n        else:\n            out += c\n    return out\n"}
{"id":667,"bad_solution":"from heapq import *\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\nint1 = lambda x: int(x) - 1\np2D = lambda x: print(*x, sep=\"\\n\")\ndef II(): return int(sys.stdin.readline())\ndef MI(): return map(int, sys.stdin.readline().split())\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef SI(): return sys.stdin.readline()[:-1]\n\ndef main():\n\n    inf=10**32\n    n,m,s=MI()\n    to=[[] for _ in range(n)]\n    for _ in range(m):\n        u,v,a,b=MI()\n        to[u-1].append((v-1,a,b))\n        to[v-1].append((u-1,a,b))\n    cd=LLI(n)\n\n    dp=[[inf]*5005 for _ in range(n)]\n    hp=[]\n    heappush(hp,(0,min(s,5000),0))\n\n    while hp:\n        t,g,u=heappop(hp)\n        if dp[u][g]<t:continue\n        #fin[u]=True\n        #if sum(fin)==n:break\n        c,d=cd[u]\n        if g+c<5000:\n            if dp[u][g + c] <= t + d: continue\n            dp[u][g + c] = t + d\n            heappush(hp, (t + d, g + c, u))\n        else:\n            if dp[u][5000] <= t + d: continue\n            dp[u][5000] = t + d\n            heappush(hp, (t + d, 5000, u))\n        for v,a,b in to[u]:\n            if g-a<0:continue\n            if dp[v][g-a]<=t+b:continue\n            dp[v][g - a] = t + b\n            heappush(hp,(t+b,g-a,v))\n    for u in range(1,n):\n        print(min(dp[u]))\n\nmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":668,"bad_solution":"import sys\nfrom copy import copy\ninput = sys.stdin.readline\n'''\nn, m = map(int, input().split())\nn = int(input())\nA = list(map(int, input().split()))\nS = input().strip()\nfor test in range(int(input())):\n'''\ninf = 100000000000000000  # 1e17\nmod = 998244353\n\n\ndef two(x):\n    return \"0\" * (w - len(bin(x)[2:])) + bin(x)[2:]\n\n\nh, w, maxx = map(int, input().split())\nA = []\nfor i in range(h):\n    A.append(input().strip())\n# for binary in range(1<<(w-1),(1<<(w-1))+1):\nans = inf\nfor binary in range(1 << (w - 1)):  # every binary\n    S = two(binary)\n    B = [-1]\n    for i in range(len(S)):\n        if S[i] == \"1\":\n            B.append(i)\n    B.append(len(S) - 1)  # every horizontal cut, contain the head and the tail\n#    print(B)\n    SUM = [0] * (len(B))\n    isok = 1\n    cut_vertical = 0\n    cut_horizontal = len(B) - 2\n    for i in range(h):\n        PRE = copy(SUM)  # previous total numbers between every cut\n        for j in range(1, len(B)):  # every cut\n            for k in range(B[j - 1] + 1, B[j] + 1):\n                if A[i][k] == \"1\":\n                    SUM[j] += 1\n        flag = 0\n        for j in range(1, len(B)):\n            if SUM[j] > maxx:\n                flag = 1\n        if flag:\n            for j in range(1, len(B)):\n                SUM[j] -= PRE[j]\n            cut_vertical += 1\n        for j in range(1, len(B)):\n            if SUM[j] > maxx:\n                isok = 0\n        if isok == 0:\n            break\n    if isok:\n        ans = min(ans, cut_vertical + cut_horizontal)\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":669,"bad_solution":"from collections import deque\n\ndef main():\n    n,k = map(int,input().split())\n\n    a = [int(x) for x in input().split()]\n\n    #ループを探す？\n\n    checked_list = [1]\n    que = deque([a[0]])\n\n    counter = 0\n    while True:\n        counter += 1\n        x = que.popleft()\n        if counter == k:\n            print(x)\n            exit()\n        if x in checked_list:\n            startflg = checked_list.index(x)\n            loop_length = counter - startflg\n            loop_list = checked_list[startflg:counter]\n            amari = (k-startflg) % loop_length\n            print(loop_list[amari])\n            exit()\n        else:\n            que.append(a[x-1])\n            checked_list.append(x)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":670,"bad_solution":"if __name__ == '__main__':\n    from sys import stdin\n    # from collections import defaultdict\n    import math\n    input = stdin.readline\n\n    import random\n\n    a, b, n = map(int, input().split())\n    \"\"\"\n    a = random.randint(1, 10**6)\n    b  = random.randint(1, 10**6)\n    n = random.randint(1, 10**12)\n    \"\"\"\n    # print(a, b, n)\n    if b > n:\n        # print('a')\n        print(int(math.floor(a*n\/b)-a*math.floor(n\/b)))\n        exit()\n\n    if b >= 10**6:\n        ans = int(math.floor(a*n\/b)-a*math.floor(n\/b))\n        for i in range(b-1, n+1, b):\n            temp =  math.floor(a*i\/b)-a*math.floor(i\/b)\n            if ans < temp:\n                ans = temp\n        # print('b')\n        print(int(ans))\n        exit()\n\n    ans = int(math.floor(a*n\/b)-a*math.floor(n\/b))\n    i = b-1\n    # ans_i = n\n    for _ in range(2*10**6):\n        temp =  math.floor(a*i\/b)-a*math.floor(i\/b)\n        if ans < temp:\n            ans = temp\n            # ans_i = i\n        i += b\n        if i <= 0:\n            # print('c-')\n            print(int(ans))\n            exit()\n    print(int(ans))\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":671,"bad_solution":"_input = [i for i in open(0).read().split('\\n') if i]\nn, k = [int(i) for i in _input[0].split()]\nedge = tuple([tuple([int(p) for p in i.split()]) for i in _input[1:n]])\n\nfactorial = [0] * (k + 1)\ninverse = [0] * (k + 1)\nMOD = 1000000007\n\n# Ref: http:\/\/keita-matsushita.hatenablog.com\/entry\/2016\/12\/05\/175024\ndef mod_pow1(n, k, mod):\n    a = 1\n    while k:\n        if (k & 1) == 1:\n            a = (a * n) % mod\n        n = (n * n) % mod\n        k >>= 1\n    return a\n\n# Ref: https:\/\/www.smartbowwow.com\/2018\/10\/mod1097.html\ndef mod_pow2(n, k, mod):\n    if k == 0:\n        return 1\n    if k % 2 == 0:\n        a = mod_pow2(n, k \/\/ 2, mod)\n        return (a * a) % mod\n    else:\n        return (n * mod_pow2(n, k - 1, mod)) % mod\n\n#mod_pow = mod_pow1\n# It's better to use built-in function for speed.\nmod_pow = pow\n\ndef mod_factorial_inverse(k, mod):\n    factorial[0] = 1\n    inverse[0] = 1\n\n    # Ref: http:\/\/keita-matsushita.hatenablog.com\/entry\/2016\/12\/05\/184011\n    for i in range(1, k + 1):\n        factorial[i] = ((i * factorial[i - 1]) % mod) # factrial[i]\n        inverse[i] = mod_pow(factorial[i], mod - 2, mod) # inverse[i]\n \nif not edge:\n    print(k)\nelse:\n    all_edge = tuple([[] for _ in range(n + 1)])\n    for e in edge:\n        all_edge[e[0]].append(e[1])\n        all_edge[e[1]].append(e[0])\n    all_edge = [set(v) for v in all_edge]\n\n    if [v for v in all_edge if len(v) >= k]:\n        print(0)\n    else:\n        mod_factorial_inverse(k, MOD)\n\n        root = edge[0]\n        visit  = list(all_edge[root[0]])\n        colored = set()\n        total = (factorial[k] * inverse[k - len(all_edge[root[0]]) - 1]) % MOD\n        colored.add(root[0])\n        colored.update(all_edge[root[0]])\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":672,"bad_solution":"from operator import itemgetter\nimport sys\n\n\nclass BIT:\n    def __init__(self, size: int):\n        self.size = size + 1\n        self.array = [0] * self.size\n\n    def add(self, i):\n        while i < self.size:\n            self.array[i] += 1\n            i += i & -i\n\n    def sub(self, i):\n        while i < self.size:\n            self.array[i] -= 1\n            i += i & -i\n\n    def sum(self, a, b):\n        s = 0\n        i = b\n        while i > 0:\n            s += self.array[i]\n            i -= i & -i\n        i = a - 1\n        while i > 0:\n            s -= self.array[i]\n            i -= i & -i\n        return s\n\n\ndef read():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    n, q = map(int, read().split())\n    c = [int(i) - 1 for i in read().split()]\n    queries = [(0, 0, 0) for _ in range(q)]\n    for i in range(q):\n        l, r = map(int, read().split())\n        queries[i] = (i, l, r)\n    queries = iter(sorted(queries, key=itemgetter(2)))\n    last = [0] * n\n    bit = BIT(n)\n    ans = [-1] * q\n    k, l, r = next(queries)\n    for i in range(n):\n        ci = c[i]\n        li = last[ci]\n        if li > 0:\n            bit.sub(li)\n        last[ci] = i + 1\n        bit.add(i + 1)\n        while i + 1 == r:\n            ans[k] = bit.sum(l, r)\n            try:\n                k, l, r = next(queries)\n            except StopIteration:\n                break\n    print(*ans, sep=\"\\n\")\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":673,"bad_solution":"from math import gcd\n\n# = map(int, input().split())\nN = int(input())\nA = list(map(int, input().split()))\nmA = max(A)\ncounter = [0 for _ in range(mA+1)]\n\nprimenum = [2]\nsgn = [-1 for _ in range(int(mA**0.5)+1)]\nk = 3\nwhile k**2 <= mA:\n  if sgn[k] == -1:\n    primenum.append(k)\n    add = k*k\n    ok = k\n    while k**2 <= mA:\n      sgn[ok] = 1\n      ok += add\n  k += 2\n#prime_num が用意されているとき\ndef factorization(n):\n  M = n\n  for p in primenum:\n    if p**2 > M:\n      break\n    else:\n      if M%p == 0:\n        if counter[p] == 0:\n          counter[p] = 1\n        else:\n          return False\n        while M%p == 0:\n          M \/\/= p\n\n  if M > 1:\n    if counter[M] == 0:\n      counter[M] = 1\n    else:\n      return False\n  return True\n\n\n\ng = A[0]\nflag = True\nfor k in range(N):\n  a = A[k]\n  g = gcd(g, a)\n  if flag:\n    flag = factorization(a)\n\n\nif flag:\n  print('pairwise coprime')\n  exit()\nif g == 1:\n  print('setwise coprime')\nelse:\n  print('not coprime')\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":674,"bad_solution":"import math\nn=int(input())\na=list(map(int,input().split()))\narr = [0]*(10**6+1)\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5\/\/1))+1):\n        if temp%i==0:\n            while temp%i==0:\n                temp \/\/= i\n            arr.append(i)\n\n    if temp!=1:\n        arr.append(temp)\n\n    if arr==[]:\n        arr.append(n)\n\n    return arr\ngcdmax=a[0]\nfor num in a:\n    gcdmax = math.gcd(gcdmax, num)\n    for s in factorization(num):\n        arr[s]+=1\nans=max(arr)\nif ans==1 or ans==arr[1]:\n    print(\"pairwise coprime\")\nelse:\n\n    if gcdmax==1:\n        print(\"setwise coprime\")\n    else:\n        print(\"not coprime\")\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":675,"bad_solution":"# 正解ではない\n\nfrom queue import PriorityQueue\n\n\ndef main():\n    H, W = map(int, input().split())\n    Ch, Cw = map(int, input().split())\n    Dh, Dw = map(int, input().split())\n    S = [list(input()) for i in range(H)]\n    q = PriorityQueue()\n    q.put((0, (Ch - 1, Cw - 1)))\n\n    answer = resolve(q, S, (Dh - 1, Dw - 1), H, W)\n    print(answer)\n\n\ndef resolve(q, S, D, H, W):\n    is_empty = True\n    while not q.empty():\n        is_empty = False\n        worp_count, (x, y) = q.get()\n        S[x][y] = '\/'\n\n        if (x, y) == D:\n            return worp_count\n\n        if 0 <= x - 1 < H and S[x - 1][y] == '.':\n            q.put((worp_count, (x - 1, y)))\n        elif 0 <= x + 1 < H and S[x + 1][y] == '.':\n            q.put((worp_count, (x + 1, y)))\n        elif 0 <= y - 1 < W and S[x][y - 1] == '.':\n            q.put((worp_count, (x, y - 1)))\n        elif 0 <= y + 1 < W and S[x][y + 1] == '.':\n            q.put((worp_count, (x, y + 1)))\n\n    if is_empty:\n        return -1\n\n    for i in range(-2, 3):\n        for j in range(-2, 3):\n            if 0 <= x + i < H and 0 <= y + j < W and S[x + i][y + j] == '.':\n                q.put((worp_count + 1, (x + i, y + j)))\n\n    return resolve(q, S, D, H, W)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":676,"bad_solution":"# -*- coding: utf-8 -*-\nn, k = map(int, input().split())\nA = [int(i) for i in input().split()]\nA.sort()\nF = [int(i) for i in input().split()]\nF.sort(reverse = True)\n \nP = [A[i]*F[i] for i in range(n)]\n \ndef b(p):\n    result = 0\n    for i in range(n):\n        x = A[i] - p \/ F[i]\n        if x > 0: result += x\n    return result\n \nif sum(A) <= k: print('0')\nelse: \n    left = 0\n    right = max(P)\n    middle = (left + right) \/ 2\n    bm = b(middle)\n    \n    while right - left > 1:      \n        \n        if bm > k: left = middle\n        else:\n          old_right = right\n          right = middle\n        \n        if abs(bm - k) < 1:\n            k -= 1\n            if b(right) > k: right = old_right\n            \n        middle = (left + right) \/ 2\n        bm = b(middle)\n        \n    if b(int(left)) == k: print(int(left))\n    elif b(int(right)) <= k: print(int(right))\n    else: print(int(right) + 1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":677,"bad_solution":"def slove():\n    import sys\n    input = sys.stdin.readline\n    h, w = list(map(int, input().rstrip('\\n').split()))\n    s = [str(input().rstrip('\\n')) for _ in range(h)]\n    a = [[[0] * 4 for _ in range(w)] for _ in range(h)]\n    for i in range(h):\n        for j in range(w):\n            if s[i][j] == \"#\":\n                a[i][j][0] = 0\n            else:\n                if i == 0:\n                    a[i][j][0] = 1\n                else:\n                    a[i][j][0] = a[i - 1][j][0] + 1\n\n            if s[-i-1][j] == \"#\":\n                a[-i-1][j][1] = 0\n            else:\n                if i == 0:\n                    a[-i-1][j][1] = 1\n                else:\n                    a[-i-1][j][1] = a[-i][j][1] + 1\n\n            if s[i][j] == \"#\":\n                a[i][j][2] = 0\n            else:\n                if j == 0:\n                    a[i][j][2] = 1\n                else:\n                    a[i][j][2] = a[i][j-1][2] + 1\n\n            if s[i][-j-1] == \"#\":\n                a[i][-j-1][3] = 0\n            else:\n                if j == 0:\n                    a[i][-j-1][3] = 1\n                else:\n                    a[i][-j-1][3] = a[i][-j][3] + 1\n    mn = 0\n    for i in range(h):\n        for j in range(w):\n            mn = max(mn, sum(a[i][j]) - 3)\n    print(mn)\n\n\nif __name__ == '__main__':\n    slove()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":678,"bad_solution":"\ndef FUNC(lst):\n    \"\"\"\n    You are given a list of integers.\n    Write a function FUNC() that returns the 2nd smallest element of the list.\n    Return None if there is no such element.\n    \n    FUNC([1, 2, 3, 4, 5]) == 2\n    FUNC([5, 1, 4, 3, 2]) == 2\n    FUNC([]) == None\n    FUNC([1, 1]) == None\n    \"\"\"\n    lst = sorted(set(lst))\n    return None if len(lst) < 3 else lst[1]\n"}
{"id":679,"bad_solution":"import bisect\n\nN, M, Q = map(int, input().split())\ntrains = [list(map(int, input().split())) for i in range(M)]\nqueries = [list(map(int, input().split())) for i in range(Q)]\ntrains.sort(key = lambda x: x[1])\n\nA  =[[0] * N for _ in range(N)] #A[i][j] = (i + 1) -> (j+1)なる列車の本数\nfor train in trains:\n    li, ri = train\n    A[li - 1][ri - 1] += 1\ndp = [[0] * N for __ in range(N)]\n\ndef ans(left, right):\n    if dp[left][right] > 0:\n        return dp[left][right]\n    elif left > right:\n        return 0\n    elif left == right:\n        dp[left][right] = A[left][right]\n        return A[left][right]\n    else:\n        x = ans(left, right-1) + ans(left + 1, right) + A[left][right] - ans(left + 1, right - 1)\n        dp[left][right] = x\n        return x\n\nfor q in range(Q):\n    pi, qi = queries[q]\n    print(ans(pi - 1, qi - 1))\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":680,"bad_solution":"import os\nimport sys\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\n\nclass BinaryIndexedTree:\n    # http:\/\/hos.ac\/slides\/20140319_bit.pdf\n    def __init__(self, size):\n        \"\"\"\n        :param int size:\n        \"\"\"\n        self._bit = [0] * size\n        self._size = size\n\n    def add(self, i, w):\n        \"\"\"\n        i 番目に w を加える\n        :param int i:\n        :param int w:\n        :return:\n        \"\"\"\n        x = i + 1\n        while x <= self._size:\n            self._bit[x - 1] += w\n            x += x & -x\n\n    def sum(self, i):\n        \"\"\"\n        0 番目から i 番目までの合計\n        :param int i:\n        :return:\n        \"\"\"\n        ret = 0\n        x = i + 1\n        while x > 0:\n            ret += self._bit[x - 1]\n            x -= x & -x\n        return ret\n\n    def __len__(self):\n        return self._size\n\n\nN, M = list(map(int, sys.stdin.readline().split()))\nAB = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\nAB.sort(key=lambda ab: (-ab[1], ab[0]))\nbit = BinaryIndexedTree(size=M)\n\nans = 0\nfor a, b in AB:\n    # 入れられる？\n    if M - a < 0:\n        continue\n    cap = M - a - bit.sum(M - a) + 1\n    if cap > 0:\n        ans += b\n        # どこに入れよう？\n        ok = 0\n        ng = M - a + 1\n        while abs(ok - ng) > 1:\n            mid = (ok + ng) \/\/ 2\n            if M - a - bit.sum(mid) + 1 == cap:\n                ok = mid\n            else:\n                ng = mid\n        bit.add(ok, 1)\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":681,"bad_solution":"def read():\n    N = int(input().strip())\n    A = list(map(int, input().strip().split()))\n    return N, A\n\ndef digits2int(c, L, MOD):\n    base = 0\n    for i in range(L):\n        f = (c[i] << i) % MOD\n        base = (base + f) % MOD\n    return base\n\n\ndef solve(N, A, L=60, MOD=10**9+7):\n    # j桁目のビットが1であるものの数を、累積和として記憶\n    count_ones = [[0 for j in range(L+1)] for i in range(N+1)]\n    for i in range(N):\n        for j in range(L):\n            count_ones[i+1][j] = count_ones[i][j] + ((A[i] >> j) & 1)\n    # A[i] と A[j] (i<j) のxorをとる\n    modsum = 0\n    for i in range(N-1):\n        c = [0 for j in range(L)]\n        for j in range(L):\n            if ((A[i] >> j) & 1) == 0:\n                c[j] = count_ones[N][j] - count_ones[i+1][j]\n            else:\n                c[j] = (N-i-1) - (count_ones[N][j] - count_ones[i+1][j])\n        modsum = (modsum + digits2int(c, L, MOD)) % MOD\n    return modsum\n\n\nif __name__ == '__main__':\n    inputs = read()\n    print(\"%d\" % solve(*inputs))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":682,"bad_solution":"(a, b, q) = map(int, input().split())\ns = [int(input()) for _ in range(a)]\nt = [int(input()) for _ in range(b)]\nx = [int(input()) for _ in range(q)]\n\n\ndef find_left_and_right(st, pos):\n    for i, s_i in enumerate(st):\n        if s_i - pos > 0:\n            return (i-1, i)\n    return (len(st) - 1, -1)\n\n\ndef find_optimum(ss, ts, pos):\n    (sl_index, sr_index) = find_left_and_right(ss, pos)\n    (tl_index, tr_index) = find_left_and_right(ts, pos)\n\n    penalty = 9999999999999\n    s_left = s[sl_index] if 0 <= sl_index else penalty\n    s_right = s[sr_index] if 0 <= sr_index else penalty\n    t_left = t[tl_index] if 0 <= tl_index else penalty\n    t_right = t[tr_index] if 0 <= tr_index else penalty\n\n    dist0 = abs(s_left - pos) + min(abs(t_left - s_left), abs(t_right - s_left))\n    dist1 = abs(s_right - pos) + min(abs(t_left - s_right), abs(t_right - s_right))\n    dist2 = abs(t_left - pos) + min(abs(s_left - t_left), abs(s_right - t_left))\n    dist3 = abs(t_right - pos) + min(abs(s_left - t_right), abs(s_right - t_right))\n    return min([dist0, dist1, dist2, dist3])\n\n\nfor x_i in x:\n    print(find_optimum(s, t, x_i))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":683,"bad_solution":"import sys\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadline_s = sys.stdin.readline\nreadlines = sys.stdin.buffer.readlines\n\n\ndef main():\n    N, Q = map(int, readline().split())\n    S = list(readline_s().rstrip())\n    ac_check = [0] * (N)\n    tsum = [0] * (N + 1)\n\n    for i in range(N - 1):\n        if S[i] == 'A' and S[i + 1] == 'C':\n            tsum[i + 2] += 1\n            ac_check[i] = 1\n            ac_check[i + 1] = 2\n\n    for i in range(N):\n        tsum[i + 1] += tsum[i]\n\n    # print(tsum)\n    # print(ac_check)\n\n    ans = []\n    for i in range(Q):\n        l, r = map(int, readline().split())\n        count = tsum[r] - tsum[l - 1]\n        if ac_check[l - 1] == 2:\n            count -= 1\n        ans.append(count)\n\n    print('\\n'.join(map(str, ans)))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":684,"bad_solution":"from heapq import heappop, heappush\ndef main():\n    def push(i, j, k):\n        nonlocal A, B, C, ADD\n        if i >= x or j >= y or k >= z: return\n        if not ADD[i][j][k]:\n            heappush(H, (A[i] + B[j] + C[k], i, j, k))\n            ADD[i][j][k] = True\n    x, y, z, k = map(int, input().split())\n    INF = 10 ** 11\n    A = sorted(list(map(lambda x: -int(x), input().split())))\n    B = sorted(list(map(lambda x: -int(x), input().split())))\n    C = sorted(list(map(lambda x: -int(x), input().split())))\n    H = []\n    ADD = [[[False] * z for _ in range(y)] for _ in range(x)]\n    push(0, 0, 0)\n    for _ in range(k):\n        ans, i, j, k = heappop(H)\n        push(i + 1, j, k)\n        push(i, j + 1, k)\n        push(i, j, k + 1)\n        print(-ans)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":685,"bad_solution":"# 2019-11-11 16:07:35(JST)\nimport sys\n# import collections\n# import math\n# from string import ascii_lowercase, ascii_uppercase, digits\n# from bisect import bisect_left as bi_l, bisect_right as bi_r\n# import itertools\n# from functools import reduce\n# import operator as op\n# from scipy.misc import comb # float\n# import numpy as np \n\ndigits = ['3', '5', '7']\n\ndef main():\n    # 357 以上\n    # 3, 5, 7 のいずれかを使わない数字の個数をnから引けばいい\n    n = int(sys.stdin.readline().rstrip())\n\n    if n < 357:\n        print(0)\n        sys.exit()\n\n    count = 0\n    for m in range(357, n+1):\n        m = str(m)\n        c3, c5, c7 = 0, 0, 0\n        for d in m:\n            if d == '3':\n                c3 += 1\n            elif d == '5':\n                c5 += 1\n            elif d == '7':\n                c7 += 1\n            else:\n                break\n        else:\n            if c3 >= 1 and c5 >= 1 and c7 >= 1:\n                count += 1\n\n    print(count)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":686,"bad_solution":"import sys\nimport itertools\nimport collections\n\ninput = sys.stdin.readline\n\ndef main():\n    k, q = map(int, input().split())\n    d = list(map(int, input().split()))\n    for _ in range(q):\n        n, x, m = map(int, input().split())\n        dmodm = [y%m for y in d]\n        kmod = (n-1)%k\n        kdiv = (n-1)\/\/k\n        dmodmCounter = collections.Counter(dmodm)\n        dmodmkCounter = collections.Counter(dmodm[:kmod])\n        dmodcum = list(itertools.accumulate(dmodm))\n        p0 = dmodmCounter[0] * kdiv + dmodmkCounter[0]\n        an = x + (kmod != 0) * dmodcum[kmod-1] + dmodcum.pop() * kdiv\n        p1 = an\/\/m - x\/\/m\n        ans = n - (p0 + p1) - 1\n        print(ans)\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":687,"bad_solution":"\ndef FUNC(S):\n    \"\"\"\n    You'll be given a string of words, and your task is to count the number\n    of boredoms. A boredom is a sentence that starts with the word \"I\".\n    Sentences are delimited by '.', '?' or '!'.\n   \n    For example:\n    >>> FUNC(\"Hello world\")\n    0\n    >>> FUNC(\"The sky is blue. The sun is shining. I love this weather\")\n    1\n    \"\"\"\n    import re\n    sentences = re.split(r'[.?!]\\s*', S)\n    return sum(sentence[0:2] == ' I' for sentence in sentences)\n"}
{"id":688,"bad_solution":"import sys, math\nfrom collections import defaultdict, deque, Counter\nfrom bisect import bisect_left, bisect_right\nfrom itertools import combinations, permutations, product\nfrom heapq import heappush, heappop\nfrom functools import lru_cache\ninput = sys.stdin.readline\nrs = lambda: input().strip()\nri = lambda: int(input())\nrl = lambda: list(map(int, input().split()))\nmat = lambda x, y, v: [[v]*y for _ in range(x)]\nten = lambda x, y, z, v: [mat(y, z, v) for _ in range(x)]\nmod = 1000000007\nsys.setrecursionlimit(1000000)\n\nfrom fractions import gcd\nfrom functools import reduce\n\ndef gcd(a, b):\n\treturn gcd(b, a%b) if b else a\n\ndef get_gcd(A):\n\treturn reduce(gcd, A)\n\ndef get_lcm(A):\n\tdef lcm_base(a, b):\n\t\treturn a*b\/\/gcd(a,b)\n\treturn reduce(lcm_base , A, 1)\n\nN = ri()\nA = rl()\n\nh = defaultdict(int)\nfor a in A:\n\th[a] = 1\n\nM = 10**6+5\nc = 0\npc = True\nfor i in range(2, M):\n\tc = 0\n\tfor j in range(i, M, i):\n\t\tc += h[j]\n\tif c > 1:\n\t\tpc = False\n\t\tbreak\n\nif pc:\n\tprint('pairwise coprime')\n\texit()\n\nsc = (get_gcd(A) == 1)\nif sc:\n\tprint('setwise coprime')\nelse:\n\tprint('not coprime')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":689,"bad_solution":"#ライブラリインポート\nfrom collections import defaultdict\n\n#入力受け取り\ndef getlist():\n\treturn list(map(int, input().split()))\n\np = 10 ** 9 + 21\np2 = 2147483647\nq = 10 ** 2\n\ndef rollingHash(N, M, A, ans):\n\tmul1 = 1\n\tmul2 = 1\n\tfor i in range(M):\n\t\tmul1 = (mul1 * q) % p\n\t\tmul2 = (mul2 * q) % p2\n\n\tDroll1 = defaultdict(lambda:-1)\n\tDroll2 = defaultdict(lambda:-1)\n\tval1 = 0\n\tval2 = 0\n\tfor i in range(M):\n\t\tval1 = val1 * q + A[i]\n\t\tval1 %= p\n\t\tval2 = val2 * q + A[i]\n\t\tval2 %= p2\n\n\tDroll1[val1] = 0\n\tDroll2[val2] = 0\n\tfor i in range(N - M):\n\t\tval1 = (val1 * q - A[i] * mul1 + A[i + M]) % p\n\t\tval2 = (val2 * q - A[i] * mul2 + A[i + M]) % p2\n\n\t\tif Droll1[val1] != -1 and Droll1[val1] == Droll2[val2] and i + 1 - Droll1[val1] >= M:\n\t\t\treturn M\n\n\t\tDroll1[val1] = i + 1\n\t\tDroll2[val2] = i + 1\n\n\treturn ans\n\n#処理内容\ndef main():\n\tN = int(input())\n\tS = list(input())\n\tfor i in range(N):\n\t\tS[i] = ord(S[i]) - 97\n\n\tans = 0\n\tfor i in range(1, int(N \/\/ 2) + 1):\n\t\tans = rollingHash(N, i, S, ans)\n\n\tprint(ans)\n\n\n\nif __name__ == '__main__':\n\tmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":690,"bad_solution":"import collections\nimport sys\ninput = sys.stdin.readline\n\n# スタック最大数をセット\nsys.setrecursionlimit(10**6)\n\nh, w = map(int, input().split())\na = [list(input()) for _ in range(h)]\n\nqueue = collections.deque()\n\nans = 0\n\ndx = [1, 0, 0, -1]\ndy = [0, 1, -1, 0]\n\n\ndef bfs(y, x, cnt):\n    if (y < 0 or h <= y or x < 0 or w <= x):\n        return\n    #print(y, x, cnt)\n    a[y][x] = '#'\n    for ddx, ddy in zip(dx, dy):\n        if (y+ddy < 0 or h <= y+ddy or x+ddx < 0 or w <= x+ddx or a[y+ddy][x+ddx] == '.'):\n            queue.append([y + ddy, x+ddx, cnt+1])\n\n\nfor i in range(h):\n    for j in range(w):\n        if (a[i][j] == '#'):\n            for ddx, ddy in zip(dx, dy):\n                if (i+ddy < 0 or h <= i+ddy or j+ddx < 0 or w <= j+ddx or a[i+ddy][j+ddx] == '.'):\n                    queue.append([i + ddy, j+ddx, 0])\n\nwhile (len(queue) > 0):\n    l = queue.popleft()\n    # print(l)\n    ans = max(ans, l[2])\n    bfs(l[0], l[1], l[2])\n\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":691,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nimport collections\nfrom math import gcd\nfrom functools import reduce\n\nfrom random import randint\n\ndef lcm(a, b):\n    return abs(a*b) \/\/ gcd(a, b)\n\ndef find_gcd(list):\n    x = reduce(gcd, list)\n    return x\n\ndef find_lcm(list):\n    x = reduce(lambda a,b: lcm(a,b)% MOD, list)\n    return x\n\nD = [None for _ in range(10**6)]\nMOD = 10**9 + 7\ndef solve(N: int, A: \"List[int]\"):\n\n    q1 = reduce(gcd, A) == 1\n\n    def SieveOfEratosthenes(n): \n        prime = [i for i in range(n + 1)] \n        p = 2\n        while (p * p <= n): \n            if (prime[p] == p): \n                for i in range(p * 2, n + 1, p): \n                    prime[i] = p\n            p += 1\n        prime[0]= 0\n        prime[1]= 1\n        return prime\n\n    D = SieveOfEratosthenes(10**6)\n    s = set([])\n    q2 = True\n    for a in A:\n        facs = []\n        while True:            \n            facs.append(D[a])\n            a = a \/\/ D[a]\n            if D[a] == a:\n                break\n\n        for fac in facs:\n            if fac in s:\n                if fac != 1 and fac != 0:\n                    q2 = False\n            s.add(fac)\n\n\n    if q1 and q2:\n        print('pairwise coprime')\n    elif q1:\n        print('setwise coprime')\n    else:\n        print('not coprime')\n    return\n\n\n# Generated by 1.1.7.1 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n\n    solve(N, A)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":692,"bad_solution":"#!\/usr\/bin\/env python3\n#ABC140 D\n\nimport sys\nimport math\nimport bisect\nsys.setrecursionlimit(1000000000)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nn,k = LI()\ns = list(input())\nl = []\ncnt = 1\nfor i in range(1,n):\n    if s[i-1] != s[i]:\n        l.append((cnt,i-1))\n        cnt = 0\n    cnt += 1\nl.append((cnt,i))\nm = len(l)\nif m == 1:\n    print(n-1)\n    quit()\nh = []\nfor i in range(m):\n    if i == 0:\n        heappush(h,(-(l[i][0]+l[i+1][0]),l[i][0],l[i][1]))\n    elif i == m-1:\n        heappush(h,(-(l[i][0] + l[i-1][0]),l[i][0],l[i][1]))\n    else:\n        heappush(h,(-(l[i][0] + l[i-1][0] + l[i+1][0]),l[i][0],l[i][1]))\nfor _ in range(min(k,len(h))):\n    l,i,j = heappop(h)\n    if s[j] ==  'R':\n        s[j-i+1:j+1] = 'L'*i\n    else:\n        s[j-i+1:j+1] = 'R'*i\n    t = s.count('R')\n    if t == 0 or t == n:\n        print(n-1)\n        quit()\nans = 0\nfor i in range(n):\n    if s[i] == 'L':\n        if i > 0:\n            if s[i-1] == 'L':\n                ans += 1\n    else:\n        if i < n-1:\n            if s[i+1] == 'R':\n                ans += 1\nprint(ans)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":693,"bad_solution":"\ndef FUNC(x, y, z):\n    '''\n    Create a function that takes 3 numbers.\n    Returns true if one of the numbers is equal to the sum of the other two, and all numbers are integers.\n    Returns false in any other cases.\n    \n    Examples\n    FUNC(5, 2, 7) ➞ True\n    \n    FUNC(3, 2, 2) ➞ False\n\n    FUNC(3, -2, 1) ➞ True\n    \n    FUNC(3.6, -2.2, 2) ➞ False\n  \n\n    \n    '''\n    \n    if isinstance(x,int) and isinstance(y,int) and isinstance(z,int):\n        if (x+y==z) or (y+z==x):\n            return True\n        return False\n    return False\n"}
{"id":694,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\n\ndef solve(N: int, M: int, A: \"List[int]\", B: \"List[int]\", C: \"List[int]\"):\n    A.sort()\n    # print(A)\n    from bisect import bisect_left\n    for j in range(M):\n        idx = bisect_left(A, C[j])\n        if(idx != 0):\n            for i in range(min(B[j],idx)):\n                A[i] = C[j]\n            Ad = A[0:idx]\n            Ad.sort()\n            for i in range(len(Ad)):\n                A[i] = Ad[i]\n            # print(Ad)\n            # A.sort(A[:min(B[j],idx)])\n        # print(A)\n    print(sum(A))\n\n    return\n\n\n# Generated by 1.1.4 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    A = [ int(next(tokens)) for _ in range(N) ]  # type: \"List[int]\"\n    B = [int()] * (M)  # type: \"List[int]\" \n    C = [int()] * (M)  # type: \"List[int]\" \n    for i in range(M):\n        B[i] = int(next(tokens))\n        C[i] = int(next(tokens))\n    solve(N, M, A, B, C)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":695,"bad_solution":"import sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\ndef s(): return input()\ndef i(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b\/\/math.gcd(a,b)\nsys.setrecursionlimit(10 ** 9)\nmod = 10**9+7\n\nN = i()\na = l()\nb1 = []\nb2 = []\nfor i in range(N):\n    if i%2==0:\n        b1.append(a[i])\n    else:\n        b2.append(a[i])\nc1 = Counter(b1)\nc2 = Counter(b2)\nF1 = 0\nF2 = 0\nif len(list(c1)) > 1:\n    F1 = 1\nif len(list(c2)) > 1:\n    F2 = 1\nk1,v1 = list(c1.items())[0]\nk2,v2 = list(c2.items())[0]\nif k1 == k2:\n    if v1 > v2 and F2 == 1:\n        v2 = list(c2.values())[1]\n    elif v1 <= v2 and F1 == 1:\n        v1 = list(c1.values())[1]\n    else:\n        if v1 > v2:\n            v2 = 0\n        else:\n            v1 = 0\nprint(N-v1-v2)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":696,"bad_solution":"#!\/usr\/bin\/env python3\n#AGC38 B\n\nimport sys\nimport math\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(1000000000)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nn,k = LI()\np = LI()\nans = n - k + 1\ntmp = p[0]\ncnt = 1\nlst = []\nfor i in range(1,n):\n    if tmp < p[i]:\n        cnt += 1\n    else:\n        lst.append(cnt)\n        cnt = 1\n    tmp = p[i]\nlst.append(cnt)\nf = defaultdict(lambda : 0)\nm = len(lst)\nfor i in range(m):\n    f[lst[i]] += 1\nfor i in range(m):\n    if lst[i] == k-1:\n        if i+1 < m:\n            if lst[i+1] == k-1:\n                ans -= 1\n    elif lst[i] == k and f[lst[i]] > 1:\n        ans -= lst[i] - k + 1\n        f[lst[i]] = 0\n    elif lst[i] > k and f[lst[i]] > 0:\n        ans -= (lst[i] - k + 1)*f[lst[i]]\n        ans += 1\n        f[lst[i]] = 0\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":697,"bad_solution":"import sys\nfrom operator import itemgetter\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\nsys.setrecursionlimit(10 ** 8)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef main():\n    N, M = map(int, readline().split())\n    A = list(map(int, readline().split()))\n    A.sort()\n    BC = []\n    for _ in range(M):\n        B, C = map(int, readline().split())\n        BC.append((B,C))\n    BC.sort(key=itemgetter(1))\n    for i in range(M):\n        b = BC[i][0]\n        c = BC[i][1]\n        for j in range(b):\n            if A[j]<c:\n                A[j]=c\n        A.sort()\n    print(sum(A))\n\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":698,"bad_solution":"import sys\nsys.setrecursionlimit(1<<20)\nh,w=[int(x) for x in input().split()]\nch,cw=[int(x) for x in input().split()]\ndh,dw=[int(x) for x in input().split()]\nch-=1\ncw-=1\ndh-=1\ndw-=1\n\ns=[]\nfor _ in range(h):\n    s.append(list(input()))\n\nnxt=[[ch,cw,0]]\n#再起\ndef rcl(y,x,now):\n    \n    if y==dh and x==dw:\n        print(now)\n        exit()\n    \n    if s[y][x]=='#':\n        return\n    \n    s[y][x]='#'\n    # 四方を見る\n    for i in range(4):\n        yy,xx=-1,0\n        if i==1:yy,xx=0,1\n        if i==2:yy,xx=1,0\n        if i==3:yy,xx=0,-1\n        \n        if y+yy<0 or h<=y+yy or x+xx<0 or w<=x+xx:\n            continue\n        if s[y+yy][x+xx]=='#':\n            continue\n        \n        rcl(y+yy,x+xx,now)\n    #5*5\n    for i in range(-2,3):\n        for j in range(-2,3):\n            if i==0 and j==0:\n                continue\n            if y+i<0 or h<=y+i or x+j<0 or w<=x+j:\n                continue\n            if s[y+i][x+j]=='.':\n                nxt.append([y+i,x+j,now+1])\n                s[y+i][x+j]=now+1\n\n\nidx=0\nwhile i==len(nxt):\n    i=nxt[idx]\n    i+=1\n    if i[0]==dh and i[1]==dw:\n        print(i[2])\n        exit()\n    rcl(i[0],i[1],i[2])\nprint(-1)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":699,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nINF = float(\"inf\")\n\n# 無向グラフを仮定する。\n\n\nclass Graph(object):\n    def __init__(self, N):\n        self.E = [[] for _ in range(N)]\n\n    def add_edge(self, edge):\n        s, t = edge\n        self.E[s].append(t)\n\n\ndef solve(N: int, A: \"List[List[int]]\"):\n    a_head = [0]*N\n    stack = list(range(N))\n    next_stack = []\n    day = -1\n    flag = True\n    g = Graph(N)\n\n    while flag:\n        day += 1\n        flag = False\n\n        for i in stack:\n            h = a_head[i]\n            if h == N-1:\n                continue\n            if i in g.E[A[i][h]-1]:\n                a_head[i] += 1\n                a_head[A[i][h]-1] += 1\n                flag = True\n                next_stack.append(i)\n                next_stack.append(A[i][h]-1)\n                g.E[A[i][h]-1].remove(i)\n            else:\n                g.add_edge([i, A[i][h]-1])\n        stack = next_stack[:]\n\n    for h in a_head:\n        if h != N-1:\n            print(-1)\n            return\n    print(day)\n\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = [[int(next(tokens)) for _ in range(N - 1)]\n         for _ in range(N)]  # type: \"List[List[int]]\"\n    solve(N, A)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":700,"bad_solution":"\ndef FUNC(message):\n    \"\"\"\n    Write a function that takes a message, and FUNCs in such a \n    way that it swaps case of all letters, replaces all vowels in \n    the message with the letter that appears 2 places ahead of that \n    vowel in the english alphabet. \n    Assume only letters. \n    \n    Examples:\n    >>> FUNC('test')\n    'TGST'\n    >>> FUNC('This is a message')\n    'tHKS KS C MGSSCGG'\n    \"\"\"\n    vowels = \"aeiou\"\n    vowels_replace = dict([(i, chr(ord(i) + 2)) for i in vowels])\n    message = message.swapcase()\n    return ''.join([vowels_replace[i] if i in vowels else i for i in message])\n"}
{"id":701,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nimport resource\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\n\nsys.setrecursionlimit(10**6)\ninput = sys.stdin.readline\nINF = 2**62-1\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\nclass Mod:\n    def __init__(self, m):\n        self.m = m\n\n    def add(self, a, b):\n        return (a + b) % self.m\n\n    def sub(self, a, b):\n        return (a - b) % self.m\n\n    def mul(self, a, b):\n        return (a * b) % self.m\n\n    def div(self, a, b):\n        return self.mul(a, self.pow(b, self.m-2))\n\n    @lru_cache(maxsize=None)\n    def pow(self, a, b):\n        return pow(a, b, self.m)\n\n\nM = Mod(10**9 + 7)\nm = 10**9 + 7\nfact = [1] * (2 * (10**5) + 1)\nfact_inv = [0] * (2 * (10**5) + 1)\nfor i in range(1, 2 * (10**5)+1):\n    fact[i] = M.mul(fact[i-1], i)\n    fact_inv[i] = pow(i, m-2, m)\n\n\n@mt\ndef slv(N, AB):\n    g = defaultdict(list)\n    for a, b in AB:\n        g[a].append(b)\n        g[b].append(a)\n\n    memo = {}\n\n    def f(u, p, flag=False):\n        if (u, p) in memo:\n            return memo[(u, p)]\n        r = 1\n        n = 1\n        if p == 0 or flag:\n            for v in g[u]:\n                if v == p:\n                    continue\n                n_, r_ = f(v, u, flag)\n                n += n_\n                r = M.mul(r, r_)\n                r = M.mul(r, fact_inv[n_])\n            r = M.mul(r, fact[n-1])\n        else:\n            np, rp = f(p, u, False)\n            na, ra = f(u, 0, False)\n            r = M.div(ra, rp)\n            r = M.mul(r, fact[np])\n            n = na - np\n            r = M.mul(r, fact_inv[na-1])\n            r = M.mul(r, fact[n-1])\n\n        memo[(u, p)] = n, r\n        return n, r\n\n    f(1, 0, True)\n\n    for i in range(1, N+1):\n        print(f(i, 0, False)[1])\n\n\ndef main():\n    N = read_int()\n    AB = [read_int_n() for _ in range(N-1)]\n    slv(N, AB)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":702,"bad_solution":"\n\ndef FUNC(lst):\n    \"\"\"You are given a list of integers.\n    You need to find the largest prime value and return the sum of its digits.\n\n    Examples:\n    For lst = [0,3,2,1,3,5,7,4,5,5,5,2,181,32,4,32,3,2,32,324,4,3] the output should be 10\n    For lst = [1,0,1,8,2,4597,2,1,3,40,1,2,1,2,4,2,5,1] the output should be 25\n    For lst = [1,3,1,32,5107,34,83278,109,163,23,2323,32,30,1,9,3] the output should be 13\n    For lst = [0,724,32,71,99,32,6,0,5,91,83,0,5,6] the output should be 11\n    For lst = [0,81,12,3,1,21] the output should be 3\n    For lst = [0,8,1,2,1,7] the output should be 7\n    \"\"\"\n    def FUNC(n):\n        for i in range(2,int(n**0.5)+1):\n            if n%i==0:\n                return True\n\n        return False\n    maxx = 0\n    i = 0\n    while i < len(lst):\n        if(lst[i] > maxx and FUNC(lst[i])):\n            maxx = lst[i]\n        i+=1\n    result = sum(int(digit) for digit in str(maxx))\n    return result\n\n"}
{"id":703,"bad_solution":"import heapq\n\n\ndef dijkstra(s):\n    dist[s] = 0\n    que = []\n    heapq.heappush(que, (0, s))\n    while len(que) != 0:\n        p = heapq.heappop(que)\n        v = p[1]\n        if (dist[v] < p[0]):\n            continue\n        for e in graph[v]:\n            if dist[e[0]] > dist[v] + e[1]:\n                dist[e[0]] = dist[v] + e[1]\n                prev[e[0]] = v\n                heapq.heappush(que, (dist[e[0]], e[0]))\n\n\ndef get_path(t):\n    path = []\n    while t != -1:\n        path.append(t)\n        t = prev[t]\n    path = path[::-1]\n    return path\n\n\nN, W = map(int, input().split())\ngraph = [[] for i in range(N)]\nedges = {}\nfor i in range(W):\n    x, y, z = map(int, input().split())\n    x -= 1\n    y -= 1\n    graph[x].append((y, z))\n    graph[y].append((x, z))\n    edges[(x, y)] = True\n\nfor st in range(N):\n    dist = [float(\"inf\")] * N\n    prev = [-1] * N\n    dijkstra(st)\n    for i in range(st, N):\n        gp = get_path(i)\n        for i in range(1, len(gp)):\n            edges[(gp[i-1], gp[i])] = False\n            \nprint(sum(edges.values()))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":704,"bad_solution":"# -*- coding: utf-8 -*-\n\nimport sys\n\ndef input(): return sys.stdin.readline().strip()\ndef list2d(a, b, c): return [[c] * b for i in range(a)]\ndef list3d(a, b, c, d): return [[[d] * c for j in range(b)] for i in range(a)]\ndef ceil(x, y=1): return int(-(-x \/\/ y))\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef Yes(): print('Yes')\ndef No(): print('No')\ndef YES(): print('YES')\ndef NO(): print('NO')\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\nN=INT()\n\ntotal=(pow(4, N))%MOD\nwrong=(pow(4, N-3)*3*(N-2) + pow(4, N-4)*2*(N-3))%MOD\n\nprint((total-wrong)%MOD)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":705,"bad_solution":"\ndef FUNC(dict):\n    \"\"\"\n    Given a dictionary, return True if all keys are strings in lower \n    case or all keys are strings in upper case, else return False.\n    The function should return False is the given dictionary is empty.\n    Examples:\n    FUNC({\"a\":\"apple\", \"b\":\"banana\"}) should return True.\n    FUNC({\"a\":\"apple\", \"A\":\"banana\", \"B\":\"banana\"}) should return False.\n    FUNC({\"a\":\"apple\", 8:\"banana\", \"a\":\"apple\"}) should return False.\n    FUNC({\"Name\":\"John\", \"Age\":\"36\", \"City\":\"Houston\"}) should return False.\n    FUNC({\"STATE\":\"NC\", \"ZIP\":\"12345\" }) should return True.\n    \"\"\"\n    if len(dict.keys()) == 0:\n        return False\n    else:\n        state = \"start\"\n        for key in dict.keys():\n\n            if isinstance(key, str) == False:\n                state = \"mixed\"\n                break\n            if state == \"start\":\n                if key.isupper():\n                    state = \"upper\"\n                elif key.islower():\n                    state = \"lower\"\n                else:\n                    break\n            elif (state == \"upper\" and not key.isupper()) and (state == \"lower\" and not key.islower()):\n                    state = \"mixed\"\n                    break\n            else:\n                break\n        return state == \"upper\" or state == \"lower\" \n"}
{"id":706,"bad_solution":"import sys\nfrom itertools import accumulate\ndef input(): return sys.stdin.readline().strip()\n\n\ndef main():\n    N, K = map(int, input().split())\n    S = input()\n\n    \"\"\"\n    反転させる区間は独立であるとしてよい。実際反転させる２区間が左図のように\n    オーバーラップしていたとすると、これは右図のように反転させるのと同値だからである：\n               _______________                             _______  \n        ______|_______        |     --->    ______        |       |\n    ___|______|_______|_______|_____    ___|______|_______|_______|_____ \n    \n    そうすると安直には0がなるべく長く連続している区間に反転をかけたくなるが、\n    長い順に反転をかけた場合1が連続する保証がないのでダメ。\n\n    そこで1の連続する箇所を固定したうえで、そこから0の連続する区間に順番に反転をかけることを考える。\n    当然愚直にやるとTLEなので、累積和で実装する\n    \"\"\"\n\n    A = []\n    char = S[0]\n    cnt = 1\n    for i in range(1, N):\n        if S[i] == char:\n            cnt += 1\n        else:\n            A.append(cnt)\n            char = S[i]\n            cnt = 1\n    A.append(cnt)\n    #print(A)\n\n    B = list(accumulate(A))\n    l = len(A)\n    if S[0] == '0':\n        ans = B[min(K * 2 - 1, l - 1)]\n        for i in range(1, l - K * 2 + 1):\n            ans = max(ans, B[i + K * 2 - 1] - B[i - 1])\n    else:\n        ans = B[min(K * 2, l - 1)]\n        for i in range(1, l - K * 2):\n            ans = max(ans, B[i + K * 2] - B[i - 1])\n    print(ans)\n       \n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":707,"bad_solution":"from sys import stdin\nfrom collections import deque\ninput = stdin.readline\n\nH, W = map(int, input().split())\nch, cw = map(int, input().split())\ndh, dw = map(int, input().split())\nS = [list(input().rstrip()) for _ in range(H)]\n\ndir_h = [0, 0, 1, -1]\ndir_w = [1, -1, 0, 0]\n\nseen = [[-1 for _ in range(W)] for _ in range(H)]\nedge = []\nnex = [[ch - 1, cw - 1]]\nnum = 0\n\n\ndef bfs():\n    q = deque([])\n\n    for h, w in nex:\n        q.append([h, w])\n        seen[h][w] = num\n        while q:\n            h, w = q.popleft()\n\n            for dh, dw in zip(dir_h, dir_w):\n                nh, nw = h + dh, w + dw\n\n                if nh < 0 or nh >= H or nw < 0 or nw >= W:\n                    continue\n                elif S[nh][nw] == \"#\":\n                    edge.append([h, w])\n                    continue\n                elif seen[nh][nw] != -1:\n                    continue\n                else:\n                    seen[nh][nw] = num\n                    q.append([nh, nw])\n\n\ndef dfs():\n    d = deque([])\n    for h, w in edge:\n        d.append([h, w])\n\n        while d:\n            h, w = d.pop()\n            num = seen[h][w]\n            for dh in range(1, 3):\n                for dw in range(1, 3):\n                    nh, nw = h + dh, w + dw\n\n                    if nh < 0 or nh >= H or nw < 0 or nw >= W:\n                        continue\n                    elif S[nh][nw] == \"#\":\n                        continue\n                    elif seen[nh][nw] != -1:\n                        continue\n                    else:\n                        seen[nh][nw] = min(num, seen[nh][nw])\n                        nex.append([nh, nw])\n\n\nwhile True:\n    bfs()\n    nex = []\n    num += 1\n    dfs()\n    if not edge:\n        break\n    edge = []\n\n# for s in seen:\n#     print(s)\n\nprint(seen[dh - 1][dw - 1])\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":708,"bad_solution":"import sys\ninput = sys.stdin.readline\n\n\"\"\"\n・とりあえず部分点解法：各クエリに対してO(N)\n・いくつかを残していくつかを自由に埋める\n・残すもの：被覆区間がoverlapしないように残す\n・つまり、区間で覆えている点が処理できて、区間で覆えていない点が他所から持ってこないといけない。\n\"\"\"\n\nN,M = map(int,input().split())\nA = [int(x) for x in input().split()]\nXY = [tuple(int(x) for x in input().split()) for _ in range(M)]\n\ndef naive_solution(A):\n    from collections import Counter\n    covered = [False] * (N+N+10)\n    for key,cnt in Counter(A).items():\n        for i in range(cnt):\n            covered[max(0,key-i)] = True\n    return sum(not bl for bl in covered[1:N+1])\n\nfor x,y in XY:\n    A[x-1] = y\n    print(naive_solution(A))\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":709,"bad_solution":"N = int(input())\nA = list(map(int, input().split())) \n\ndef sumXOR( arr,  n): \n    sum = 0\n    for i in range(0, 64): \n  \n        #  Count of zeros and ones \n        zc = 0\n        oc = 0\n           \n        # Individual sum at each bit position \n        idsum = 0\n        for j in range(0, n): \n            if (arr[j] % 2 == 0): \n                zc = (zc + 1)\n                  \n            else: \n                oc = (oc + 1)\n            arr[j] = int(arr[j] \/ 2) \n          \n           \n        # calculating individual bit sum  \n        idsum = (oc * zc * ((1 << i))) % 1000000007\n   \n        # final sum     \n        sum = (sum + idsum)\n      \n    return sum\n  \n  \n  \n  \nprint(sumXOR(A, N)  % 1000000007)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":710,"bad_solution":"def function(arg1, arg2):\n    N,K = map(int, arg1.split())\n    teleportes = list(map(int, arg2.split()))\n    checked = [0] * len(teleportes) # 訪れた街にチェック\n\n    i = 0\n    c = 1\n    while True :\n        nextTerminal = teleportes[i] - 1\n        if checked[i] == 0:\n            checked[i] = c # 何番目に訪れたか\n            i = nextTerminal\n            c += 1\n        else:\n            loops = c - checked[i] # 以前訪れてから何回旅したか\n            break\n    \n    if K <= i:\n        goal = teleportes[K]\n    else:\n        r = (K-(checked[i]-1))%loops\n        nextTerminal = 0\n        while nextTerminal != i:\n            nextTerminal = teleportes[nextTerminal] - 1\n        k = 0\n        while k in range(r):\n            nextTerminal = teleportes[nextTerminal] - 1\n            k+=1\n        goal = nextTerminal + 1\n    return str(goal)\n\nif __name__ == '__main__':\n    print(function(input(),input()))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":711,"bad_solution":"import sys\n\nsys.setrecursionlimit(10 ** 8)\n\ninput = sys.stdin.readline\n\n\ndef main():\n    A, B, N = [int(x) for x in input().split()]\n\n\n    def f(m):\n        return (A * m) \/\/ B - A * (m \/\/ B)\n\n\n\n    l = f(0)\n    e = f(N)\n    def isOK(mid):\n        if f(mid) - l >= 0:\n            return True\n        else:\n            return False\n\n    ok = 0\n    ng = N + 1\n\n    loopn = 0\n\n    while abs(ok - ng) > 1:\n        loopn += 1\n        if loopn >= 10 ** 6:\n            break\n        mid = (ok + ng) \/\/ 2\n        if isOK(mid):\n            ok = mid\n        else:\n            ng = mid\n\n    ans = max(l, e, f(ok), f(max(0, ok - 1)), f(min(N, ok + 1)))\n    for i in range(max(0, ok - 1000), min(N, ok + 1000)):\n        ans = max(ans, f(i))\n\n    print(ans)\n\n\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":712,"bad_solution":"from sys import stdin\ninput = stdin.readline\n\nclass SegTreeFlag():\n    def segFunc(self, x, y):\n        return x+y\n    def searchIndexFunc(self, val):\n        return val > 0\n    def __init__(self, ide, init_val):\n        n = len(init_val)\n        self.ide_ele = ide\n        self.num = 2**(n-1).bit_length()\n        self.seg = [self.ide_ele] * 2 * self.num\n        for i in range(n):\n            self.seg[i+self.num-1] = init_val[i]    \n        for i in range(self.num-2,-1,-1):\n            self.seg[i] = self.segFunc(self.seg[2*i+1],self.seg[2*i+2])\n    def update(self, idx, val):\n        idx += self.num-1\n        self.seg[idx] = val\n        while idx:\n            idx = (idx-1)\/\/2\n            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])\n    def addition(self, idx, val):\n        idx += self.num-1\n        self.seg[idx] += val\n        while idx:\n            idx = (idx-1)\/\/2\n            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])\n    def multiplication(self, idx, val):\n        idx += self.num-1\n        self.seg[idx] *= val\n        while idx:\n            idx = (idx-1)\/\/2\n            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])\n    def query(self, begin, end):\n        if end <= begin:\n            return self.ide_ele\n        begin += self.num-1\n        end += self.num-2\n        res = self.ide_ele\n        while begin + 1 < end:\n            if begin&1 == 0:\n                res = self.segFunc(res, self.seg[begin])\n            if end&1 == 1:\n                res = self.segFunc(res, self.seg[end])\n                end -= 1\n            begin = begin\/\/2\n            end = (end-1)\/\/2\n        if begin == end:\n            res = self.segFunc(res, self.seg[begin])\n        else:\n            res = self.segFunc(self.segFunc(res, self.seg[begin]), self.seg[end])\n        return res\n    def getLargestIndex(self, begin, end):\n        L, R = begin, end\n        if not self.searchIndexFunc(self.query(begin, end)):\n            return None\n        while L+1 < R:\n            P = (L+R)\/\/2\n            if self.searchIndexFunc(self.query(P, R)):\n                L = P\n            else:\n                R = P\n        return L\n    def getSmallestIndex(self, begin, end):\n        L, R = begin, end\n        if not self.searchIndexFunc(self.query(begin, end)):\n            return None\n        while L+1 < R:\n            P = (L+R+1)\/\/2\n            if self.searchIndexFunc(self.query(L, P)):\n                R = P\n            else:\n                L = P\n        return L\n\nclass SegTreeMin():\n    def segFunc(self, x, y):\n        if x < y:\n            return x\n        else:\n            return y\n    def searchIndexFunc(self, val):\n        return True\n    def __init__(self, ide, init_val):\n        n = len(init_val)\n        self.ide_ele = ide\n        self.num = 2**(n-1).bit_length()\n        self.seg = [self.ide_ele] * 2 * self.num\n        for i in range(n):\n            self.seg[i+self.num-1] = init_val[i]    \n        for i in range(self.num-2,-1,-1):\n            self.seg[i] = self.segFunc(self.seg[2*i+1],self.seg[2*i+2])\n    def update(self, idx, val):\n        idx += self.num-1\n        self.seg[idx] = val\n        while idx:\n            idx = (idx-1)\/\/2\n            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])\n    def addition(self, idx, val):\n        idx += self.num-1\n        self.seg[idx] += val\n        while idx:\n            idx = (idx-1)\/\/2\n            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])\n    def multiplication(self, idx, val):\n        idx += self.num-1\n        self.seg[idx] *= val\n        while idx:\n            idx = (idx-1)\/\/2\n            self.seg[idx] = self.segFunc(self.seg[idx*2+1], self.seg[idx*2+2])\n    def query(self, begin, end):\n        if end <= begin:\n            return self.ide_ele\n        begin += self.num-1\n        end += self.num-2\n        res = self.ide_ele\n        while begin + 1 < end:\n            if begin&1 == 0:\n                res = self.segFunc(res, self.seg[begin])\n            if end&1 == 1:\n                res = self.segFunc(res, self.seg[end])\n                end -= 1\n            begin = begin\/\/2\n            end = (end-1)\/\/2\n        if begin == end:\n            res = self.segFunc(res, self.seg[begin])\n        else:\n            res = self.segFunc(self.segFunc(res, self.seg[begin]), self.seg[end])\n        return res\n    def getLargestIndex(self, begin, end):\n        L, R = begin, end\n        if not self.searchIndexFunc(self.query(begin, end)):\n            return None\n        while L+1 < R:\n            P = (L+R)\/\/2\n            if self.searchIndexFunc(self.query(P, R)):\n                L = P\n            else:\n                R = P\n        return L\n    def getSmallestIndex(self, begin, end):\n        L, R = begin, end\n        if not self.searchIndexFunc(self.query(begin, end)):\n            return None\n        while L+1 < R:\n            P = (L+R+1)\/\/2\n            if self.searchIndexFunc(self.query(L, P)):\n                R = P\n            else:\n                L = P\n        return L\n\nh, w = map(int, input().split())\nans = [-1]*h\nsegflag = SegTreeFlag(0, [1]*(w+2))\ntmp = [0]*(w+2)\ntmp[0] = float(\"inf\")\nsegmin = SegTreeMin(float(\"inf\"), tmp)\nwall = [list(map(int, input().split())) for _ in range(h)]\nfor i in range(h):\n    idx = segflag.getLargestIndex(0, wall[i][1]+2)\n    if idx < wall[i][1]+1:\n        segflag.update(wall[i][1]+1, 1)\n        segmin.update(wall[i][1]+1, segmin.query(idx, idx+1)+(wall[i][1]+1-idx))\n    cnt = segflag.query(wall[i][0], wall[i][1]+1)\n    for _ in range(cnt):\n        idx = segflag.getLargestIndex(wall[i][0], wall[i][1]+1)\n        segflag.update(idx, 0)\n        segmin.update(idx, float(\"inf\"))\n    tmp = segmin.query(0, w+1)\n    if tmp != float(\"inf\"):\n        ans[i] = tmp + i + 1\n    else:\n        break\nfor v in ans:\n    print(v)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":713,"bad_solution":"class Node:\n    def __init__(self, data):\n        self.data = data\n        self.next = None\n\n\nclass Queue:\n    def __init__(self):\n        self.head = None\n        self.last = None\n        self._size = 0\n\n    def enqueue(self, data):\n        if self.last is None:\n            self.head = Node(data)\n            self.last = self.head\n        else:\n            self.last.next = Node(data)\n            self.last = self.last.next\n            \n        self._size += 1\n\n    def dequeue(self):\n        if self.head is None:\n            return None\n        else:\n            to_return = self.head.data\n            self.head = self.head.next\n            self._size -= 1\n            \n            if self._size == 0:\n                self.head = None\n                self.last = None\n            return to_return\n        \n    def size(self):\n        return self._size\n    \ndef inside(y,x,H,W):\n    if 0<=y<H and 0<=x<W:\n        return True\n    else:\n        return False\n    \ndef addQueueIfPossible(new_y, new_x, new_val, data, queue):\n    if inside(new_y, new_x, H, W) and data[new_y][new_x]==-1:\n        data[new_y][new_x] = new_val\n        queue.enqueue((new_y, new_x, new_val))\n        return True\n    else:\n        return False\n\n\nn = int(input())\ngraph = [[] for _ in range(n+1)]\nfor i in range(n-1):\n    a,b = map(int, input().split())\n    graph[a].append(b)\n    graph[b].append(a)\n# search edge\norigin=1\nd = 0\nqueue = Queue()\nfor it in graph[origin]:\n    queue.enqueue((it, origin, d+1)) # next, coming from, depth\n    \nwhile queue.size() > 0:\n    leaf, origin, d = queue.dequeue()\n    for it in graph[leaf]:\n        if it != origin:\n            queue.enqueue((it, leaf, d+1)) # next, coming from, depth\n# print(d, leaf)\n\n# search D\norigin=leaf\nd = 0\nqueue = Queue()\nfor it in graph[origin]:\n    queue.enqueue((it, origin, d+1)) # next, coming from, depth\n    \nwhile queue.size() > 0:\n    leaf, origin, d = queue.dequeue()\n    for it in graph[leaf]:\n        if it != origin:\n            queue.enqueue((it, leaf, d+1)) # next, coming from, depth\n# print(d, leaf)\n\nif (d+2)%3==0:\n    print('Second')\nelse:\n    print('First')\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":714,"bad_solution":"import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #intのlist\n    return list(map(int,input().split()))\ndef m(): #複数文字\n    return map(int,input().split())\ndef onem(): #Nとかの取得\n    return int(input())\ndef s(x): #圧縮\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #listをスペースごとに分ける\n    return \" \".join(map(str,x))\ndef max2(x): #他のときもどうように作成可能\n    return max(map(max,x))\ndef In(x,a): #aがリスト(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\nmod = 10**9+7 #出力の制限\n\n# a = cmb(n,r)\n\"\"\"\ndef nibu(x,n,r):\n    ll = 0\n    rr = r\n    while True:\n        mid = (ll+rr)\/\/2\n\n    if rr == mid:\n        return ll\n    if (ここに評価入れる):\n        rr = mid\n    else:\n        ll = mid+1\n\"\"\"\nH,W = m()\n\na = []\n\nfor i in range(H):\n    a.append(l())\n\nma = 0\nb = []\nfor i in range(H):\n    b.append(l())\n    for j in range(W):\n        ma = max(ma,abs(a[i][j]-b[i][j]))\n\ndp = [[[0 for i in range(ma*(H+W))]for j in range(W)] for k in range(H)]\n\nfor i in range(H):\n    for j in range(W):\n        if i == 0 and j == 0:\n            dp[0][0][abs(a[0][0] - b[0][0])] = 1\n        elif i == 0:\n            for k in range(ma*(H+W)):\n                if abs(k + abs(a[i][j] - b[i][j])) < ma*(H+W):\n                    dp[i][j][abs(k + abs(a[i][j] - b[i][j]))] = max(dp[i][j-1][k],dp[i][j][abs(k + abs(a[i][j] - b[i][j]))])\n                if abs(k - abs(a[i][j] - b[i][j])) < ma*(H+W):\n                    dp[i][j][abs(k - abs(a[i][j] - b[i][j]))] = max(dp[i][j-1][k],dp[i][j][abs(k - abs(a[i][j] - b[i][j]))])\n        elif j == 0:\n            for k in range(ma*(H+W)):\n                if abs(k + abs(a[i][j] - b[i][j])) < ma*(H+W):\n                    dp[i][j][abs(k + abs(a[i][j] - b[i][j]))] = max(dp[i-1][j][k],dp[i][j][abs(k + abs(a[i][j] - b[i][j]))])\n                if abs(k - abs(a[i][j] - b[i][j])) < ma*(H+W):\n                    dp[i][j][abs(k - abs(a[i][j] - b[i][j]))] = max(dp[i-1][j][k],dp[i][j][abs(k - abs(a[i][j] - b[i][j]))])\n        else:\n            for k in range(ma*(H+W)):\n                if abs(k + abs(a[i][j] - b[i][j])) < ma*(H+W):\n                    dp[i][j][abs(k + abs(a[i][j] - b[i][j]))] = max(dp[i][j-1][k],dp[i-1][j][k],dp[i][j][abs(k + abs(a[i][j] - b[i][j]))])\n                if abs(k - abs(a[i][j] - b[i][j])) < ma*(H+W):\n                    dp[i][j][abs(k - abs(a[i][j] - b[i][j]))] = max(dp[i][j-1][k],dp[i-1][j][k],dp[i][j][abs(k - abs(a[i][j] - b[i][j]))])\n\nfor i in range(ma*(H+W)):\n    if dp[-1][-1][i] == 1:\n        print(i)\n        exit()\n\n\n\n\n\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":715,"bad_solution":"\ndef FUNC(n):\n    \"\"\"Implement a function that takes an non-negative integer and returns an array of the first n\n    integers that are prime numbers and less than n.\n    for example:\n    FUNC(5) => [2,3]\n    FUNC(11) => [2,3,5,7]\n    FUNC(0) => []\n    FUNC(20) => [2,3,5,7,11,13,17,19]\n    FUNC(1) => []\n    FUNC(18) => [2,3,5,7,11,13,17]\n    \"\"\"\n    primes = []\n    for i in range(2, n):\n        is_prime = True\n        for j in range(2, i):\n            if j % i == 0:\n                is_prime = False\n                break\n        if is_prime:\n            primes.append(i)\n    return primes\n\n"}
{"id":716,"bad_solution":"import sys\ninput=sys.stdin.readline\nsys.setrecursionlimit(10 ** 8)\nfrom itertools import accumulate\nfrom itertools import permutations\nfrom itertools import combinations\nfrom collections import defaultdict\nfrom collections import Counter\nimport fractions\nimport math\nfrom collections import deque\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nfrom bisect import insort_left\nimport itertools\nfrom heapq import heapify\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nfrom copy import deepcopy\nfrom decimal import Decimal\nalf = list(\"abcdefghijklmnopqrstuvwxyz\")\nALF = list(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n#import numpy as np\nINF = float(\"inf\")\n#d = defaultdict(int)\n#d = defaultdict(list)\nN = int(input())\nC = list(input())[:-1]\nr = 0\nw = 0\nfor s in C:\n    if s == \"R\":\n        r += 1\n    elif s == \"W\":\n        w += 1\nans = 0\nif w == 0:\n    print(0)\nelse:\n    for i in range(r):\n        if C[i] == \"W\":\n            ans += 1\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":717,"bad_solution":"from __future__ import division, print_function\n# import threading\n# threading.stack_size(2**27)\n# import sys\n# sys.setrecursionlimit(10**7)\n# sys.stdin = open('inpy.txt', 'r')\n# sys.stdout = open('outpy.txt', 'w')\nfrom sys import stdin, stdout\nimport bisect            #c++ upperbound\nimport math\nimport heapq\ni_m=9223372036854775807\ndef inin():\n    return int(input())\ndef stin():\n    return input()\ndef spin():\n    return map(int,stin().split())\ndef lin():                           #takes array as input\n    return list(map(int,stin().split()))\ndef matrix(n):\n    #matrix input\n    return [list(map(int,input().split()))for i in range(n)]\n\n################################################\ndef calculate_sum(a, N): #sum of a to N\n    # Number of multiples \n    m = N \/ a \n    # sum of first m natural numbers \n    sum = m * (m + 1) \/ 2\n    # sum of multiples \n    ans = a * sum\n    return ans\ndef series(N):\n    return (N*(N+1))\/\/2\n\ndef count2Dmatrix(i,list):\n    return sum(c.count(i) for c in list)\n\ndef modinv(n,p):\n    return pow(n,p-2,p)\n\ndef GCD(x, y): \n    x=abs(x)\n    y=abs(y)\n    if(min(x,y)==0):\n        return max(x,y)\n    while(y): \n        x, y = y, x % y \n    return x\ndef LCM (x, y):\n    return (x * y) \/\/ GCD(x, y)\n    \ndef Divisors(n) : \n    l = []  \n    for i in range(1, int(math.sqrt(n) + 1)) :\n        if (n % i == 0) : \n            if (n \/\/ i == i) : \n                l.append(i) \n            else : \n                l.append(i)\n                l.append(n\/\/i)\n    return l\ndef isprime(n):\n    for i in range(2, int(math.sqrt(n))+1):\n        if n%i==0:\n            return False\n    return True\nprime=[]\ndef SieveOfEratosthenes(n): \n    global prime\n    prime = [True for i in range(n+1)] \n    p = 2\n    while (p * p <= n): \n        if (prime[p] == True): \n            for i in range(p * p, n+1, p): \n                prime[i] = False\n        p += 1\n    f=[]\n    for p in range(2, n): \n        if prime[p]: \n            f.append(p)\n    return f\nq=[]       \ndef dfs(n,d,v,c):\n    global q\n    v[n]=1\n    x=d[n]\n    q.append(n)\n    j=c\n    for i in x:\n        if i not in v:\n            f=dfs(i,d,v,c+1)\n            j=max(j,f)\n            # print(f)\n    return j\n# d = {}\n \n\"\"\"*******************************************************\"\"\"\nx, k, d = spin()\n\nx = abs(x)\nif k%2!=0:\n    d1 = math.fabs(x - k*d)\n    d2 = math.fabs(x - k\/\/2*d + k\/\/2*d)\n    m = min(d1, d2)\nelse:\n    d1 = math.fabs(x - k*d)\n    d2 = math.fabs(x - (k\/\/2+1)*d + (k\/\/2-1)*d)\n    m = min(d1, d2)\nprint(int(m))\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":718,"bad_solution":"from operator import itemgetter\nimport sys\n\n\ndef read():\n    return sys.stdin.readline().rstrip()\n\n\ndef add(arr, i, x):\n    while i < len(arr):\n        arr[i] += x\n        i += i & -i\n\n\ndef range_sum(arr, a, b):\n    s = 0\n    i = b\n    while i > 0:\n        s += arr[i]\n        i -= i & -i\n    i = a - 1\n    while i > 0:\n        s -= arr[i]\n        i -= i & -i\n    return s\n\n\ndef main():\n    n, q = map(int, read().split())\n    c = [int(i) for i in read().split()]\n    queries = [() for _ in range(q)]\n    for i in range(q):\n        l, r = map(int, read().split())\n        queries[i] = (i, l, r)\n    queries.sort(key=itemgetter(2))\n    last = [0] * n\n    bit = [0] * (n + 1)\n    ans = [-1] * q\n    cr = 0\n    for i, l, r in queries:\n        for ri in range(cr, r):\n            ci = c[ri] - 1\n            if last[ci] > 0:\n                add(bit, last[ci], -1)\n            last[ci] = ri + 1\n            add(bit, ri + 1, 1)\n            cr = ri + 1\n        ans[i] = range_sum(bit, l, r)\n    print(*ans, sep=\"\\n\")\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":719,"bad_solution":"\ndef FUNC(a, b):\n    \"\"\"Complete the function that takes two integers and returns \n    the product of their unit digits.\n    Assume the input is always valid.\n    Examples:\n    FUNC(148, 412) should return 16.\n    FUNC(19, 28) should return 72.\n    FUNC(2020, 1851) should return 0.\n    FUNC(14,-15) should return 20.\n    \"\"\"\n    return abs(a % 10) * abs(b % 10) * a * b\n"}
{"id":720,"bad_solution":"import sys\nimport time\n#from collections import deque, Counter, defaultdict\n#from fractions import gcd\n#import bisect\n#import heapq\nimport math\nstart=time.time()\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**8)\ninf = 10**18\nMOD = 1000000007\nri = lambda : int(input())\nrs = lambda : input().strip()\nrl = lambda : list(map(int, input().split()))\nn,k = rl()\n\ns=rs()\nnow=s[0]\ncnt=0\ns+=str(1-int(s[-1]))\n\nnums=[]\nfor i in s:\n    if i==now:\n        cnt+=1\n    else:\n        now=str(1-int(now))\n        nums.append(cnt)\n        cnt=1\n\nSUM=[0]\nfor i in range(len(nums)):\n    SUM.append(SUM[i]+nums[i])\n\nskip=2*k+1\nans=0\nfor i in range(len(SUM)):\n    right=min(i+skip, len(SUM)-1)\n    left =i\n    ans=max(ans,-SUM[left]+SUM[right])\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":721,"bad_solution":"import numpy as np\nimport math\ndef comb(n, r):\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\n\nN = int(input())\nA = list(map(int, input().split()))\n\n# kごとに、\n# 異なる数がいくつあるかを調べる\n# (2以上要素が存在する)異なる数ごとに、\n# (要素数)C2を解く。\n\nnp_A = np.array(A)\n\n# 辞書作成\ndic = {}\n\nfor k in range(N):\n    before = A[:k]\n    after = A[k+1:]\n\n    before.extend(after)\n    tmp_k = np.array(before)\n    # print(\"tmp_k\", tmp_k)   # k以上\n    # print(np.unique(np_A))\n\n    # 同じ組み合わせのケースを排除する。\n    # (num, 要素数)の組み合わせを辞書かで作る\n\n    k_unique = np.unique(tmp_k)\n    ans = 0\n\n    # k_uniqueをstr化\n    # str_unique = [str(i) for i in k_unique]\n    maped_num = map(str, k_unique) #格納される数値を文字列にする\n    str_unique = \"\".join(maped_num.tolist())\n    # print(\"str_unique\", str_unique)\n\n    # 要素数リストを作成\n    count_u_list = []\n    for u in k_unique:\n        count_u = np.count_nonzero(tmp_k==u)\n        count_u_list.append(count_u)\n    # 要素数リストをstr化\n    maped_num = map(str, count_u_list) #格納される数値を文字列にする\n    str_count = \"\".join(maped_num.tolist())\n    # str_count = \"\".join(count_u_list)\n    # print(\"str_count\", str_count)\n\n    key = str_unique+str_count\n\n    if key in dic.keys():\n        print(dic[key])\n        continue\n    else:\n        for count_u in count_u_list:\n            if count_u < 2:\n                continue\n            # (count_u) C 2\n            tmp = comb(count_u,2)\n            ans += tmp\n\n    # 値の更新\n    dic[key] = ans\n    print(ans)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":722,"bad_solution":"\ndef FUNC(s):\n    \"\"\"\n    Given a string s, count the number of uppercase vowels in even indices.\n    \n    For example:\n    FUNC('aBCdEf') returns 1\n    FUNC('abcdefg') returns 0\n    FUNC('dBBE') returns 0\n    \"\"\"\n    count = 0\n    for i in range(0,len(s),2):\n        if s[i] in \"AEIOU\":\n            count += 2\n    return count\n"}
{"id":723,"bad_solution":"from collections import deque\nimport sys\ninput = sys.stdin.readline\nh, w = map(int, input().split())\ngrid = []\ngraph = [[2000 for i in range(w)] for j in range(h)]\n#x,y渡すと、（ｈ、ｗ）に入ってるかどうか判定\ndef check(s,t):\n    if (0 <=  s <= h - 1) and (0 <= t <= w - 1):\n        return True\n    else:\n        return False\n\n#graph => そこまでの距離を保存した二次元配列　grid=>与えられた迷路\ndef bfs(que):\n    finished = set()\n    while que:\n        x , y, cost = que.popleft()\n        if (grid[y][x] == '#' and cost != 0):\n            continue\n        if (x,y) not in finished and graph[y][x] > cost:\n            finished.add((x,y))\n            graph[y][x] = cost\n            if check(y,x+1):\n                que.append([x+1,y,cost+1])\n            if check(y+1,x):\n                que.append([x, y+1, cost+1])\n            if check(y,x-1):\n                que.append([x-1,y,cost+1])\n            if check(y-1,x):\n                que.append([x,y-1,cost+1])\nfor i in range(h):\n    grid.append(list(input()))\nque = deque()\nfor i in range(h):\n    for j in range(w):\n        if grid[i][j] == \"#\":\n            que.append((j,i,0))\nbfs(que)\nans = 0\nfor i in range(h):\n    ans = max(ans, max(graph[i]))\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":724,"bad_solution":"import sys\nimport os\nimport math\nimport bisect\nimport collections\nimport itertools\nimport heapq\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\nlcm = lambda x, y: x * y \/ math.gcd(x, y)\n\nMOD = 10 ** 9 + 7\nMAX = float('inf')\n\n\ndef main():\n    if os.getenv(\"LOCAL\"):\n        sys.stdin = open(\"input.txt\", \"r\")\n\n    N, K = il()\n    A = il()\n    t = []\n    tmp = 1\n    while True:\n        if tmp in t:\n            break\n        t.append(tmp)\n        tmp = A[tmp - 1]\n    D, M = divmod(K, len(t)-t.index(tmp))\n    print(t[M])\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":725,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nINF = float(\"inf\")\n\n\ndef yes():\n    print(\"Yes\")  # type: str\n\n\ndef no():\n    print(\"No\")  # type: str\n\n\ndef solve(N: int, A: int, B: int, C: int, D: int, S: str):\n    #\n    if C < D:                   # 追い越さなくても良い場合\n        # ２連岩なければ通れる\n        for i in range(A, N-1):\n            if S[i:i+2] == \"##\":\n                no()\n                return\n        yes()\n        return\n    else:                       # 追い越す必要がある場合\n        # できるだけ早く追い越す\n\n        sunuke = A-1            # 1-index, 0-index\n        funuke = B-1\n\n        def move(place, other=funuke):\n            if place == N-1:\n                return False\n            if place+1 <= N-1 and S[place+1] == \".\" and place+1 != other:\n                return place+1\n            elif place+2 <= N-1 and S[place+2] == \".\" and place+2 != other:\n                return place+2\n            else:\n                return False\n\n        while True:\n            sunuke = move(sunuke, funuke)\n            if sunuke > funuke:\n                break\n            if sunuke != False:\n                continue\n            funuke = move(funuke, sunuke)\n            if funuke == False:\n                break\n        if sunuke == False and funuke == False:\n            # 追い越せなかった\n            no()\n            return\n        # 追い越せたなら\n        if sunuke <= C and funuke <= D:\n            for i in range(sunuke, N-1):\n                if S[i:i+2] == \"##\":\n                    no()\n                    return\n            yes()\n            return\n        else:\n            no()\n            return\n    return\n\n\ndef main():\n\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    A = int(next(tokens))  # type: int\n    B = int(next(tokens))  # type: int\n    C = int(next(tokens))  # type: int\n    D = int(next(tokens))  # type: int\n    S = next(tokens)  # type: str\n    solve(N, A, B, C, D, S)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":726,"bad_solution":"#!\/usr\/bin\/env python3\n# encoding:utf-8\nimport copy\nimport random\nimport bisect #bisect_left　これで二部探索の大小検索が行える\nimport fractions #最小公倍数などはこっち\nimport math\nimport sys\nimport collections\nfrom decimal import Decimal # 10進数で考慮できる\n\nmod = 10**9+7\nsys.setrecursionlimit(mod) # 再帰回数上限はでdefault1000\n\nd = collections.deque()\ndef LI(): return list(map(int, sys.stdin.readline().split()))\n\nX, K, D = LI()\n\n\"\"\"\nX \nK回数 D移動\n\"\"\"\nif X >= 0:\n    tmp = X - D * K\n    if tmp <= 0:\n        if (X - X % D) \/\/ D % 2 == K % 2:\n            ans = X % D\n        else:\n            ans = abs(X % D - D)\n    else:\n        ans = tmp\nelse:\n    tmp = X + D * K\n    if tmp >= 0:\n        if (X - X % D)\/\/D % 2 == K % 2:\n            ans = X % D\n        else:\n            ans = abs(X % D - D)\n    else:\n        ans = tmp\n\nprint(ans)\n    \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":727,"bad_solution":"import sys,collections as cl,bisect as bs\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\nmod = 10**9+7\nMax = sys.maxsize\ndef l(): #intのlist\n    return list(map(int,input().split()))\ndef m(): #複数文字\n    return map(int,input().split())\ndef onem(): #Nとかの取得\n    return int(input())\ndef s(x): #圧縮\n    a = []\n    if len(x) == 0:\n        return []\n    aa = x[0]\n    su = 1\n    for i in range(len(x)-1):\n        if aa != x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x): #listをスペースごとに分ける\n    return \" \".join(map(str,x))\ndef max2(x): #他のときもどうように作成可能\n    return max(map(max,x))\ndef In(x,a): #aがリスト(sorted)\n    k = bs.bisect_left(a,x)\n    if k != len(a) and a[k] ==  x:\n        return True\n    else:\n        return False\n\ndef pow_k(x, n):\n    ans = 1\n    while n:\n        if n % 2:\n            ans *= x\n        x *= x\n        n >>= 1\n    return ans\n\n\"\"\"\ndef nibu(x,n,r):\n    ll = 0\n    rr = r\n    while True:\n        mid = (ll+rr)\/\/2\n\n    if rr == mid:\n        return ll\n    if (ここに評価入れる):\n        rr = mid\n    else:\n        ll = mid+1\n\"\"\"\n\ns = input()\nprint(min(max(map(len, s.split(a))) for a in s))\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":728,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nH,W=map(int,input().split())\n\nA=[list(map(int,input().split())) for i in range(H)]\nB=[list(map(int,input().split())) for i in range(H)]\n\nSA=[[0]*(W+1) for i in range(H+1)]\n\nfor i in range(H):\n    for j in range(W):\n        SA[i][j]=abs(A[i][j]-B[i][j])\n\nDP=[[[] for i in range(W+1)] for i in range(H+1)]\n\nDP[0][0]=[SA[0][0]]\n\nMID=(H+W-2)\/\/2\n\ndef next(i,j,t):\n    RET=[]\n    lim=80*(MID-abs(t-MID)+2)\n    if i+j<=lim:\n        RET.append(i+j)\n\n    if abs(i-j)<=lim:\n        RET.append(abs(i-j))\n\n    return RET\n\nfor i in range(H):\n    for j in range(W):\n        for k in set(DP[i][j]):\n            if i+j<=MID:\n                DP[i+1][j].append(k+SA[i+1][j])\n                DP[i][j+1].append(abs(k-SA[i+1][j]))\n            else:\n                DP[i+1][j].extend(next(k,SA[i+1][j],i+j))\n                DP[i][j+1].extend(next(k,SA[i][j+1],i+j))\n                \nprint(min(DP[H-1][W-1]))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":729,"bad_solution":"from math import factorial as fact\nimport math\nimport sys\nimport itertools\nimport numpy as np\nfrom collections import Counter\nimport datetime\nfrom collections import deque\n\n\n#入力:N(int:整数)\ndef input1():\n\treturn int(input())\n\n#入力:N,M(int:整数)\ndef input2():\n\treturn map(int,input().split())\n\n#入力:[n1,n2,...nk](int:整数配列)\ndef input_array():\n\treturn list(map(int,input().split()))\n\ndef keta(N):\n\treturn len(str(N))\n\n\ndef input_daytime(input_time):\n\ttime,distance=input_time.split()\n\tt=time.split(\":\")\n\tse=str(t[-1]).split(\".\")\n\tdt1 = datetime.timedelta(hours=int(t[0]),minutes=int(t[1]),seconds=int(se[0]),milliseconds=int(se[1]))\n\treturn dt1\n\ndef combinations(n,r):\n\treturn list(itertools.combinations(range(n),r))\n\n\n\ndef all_sets(num_list):\n\tsubsets=[]\n\tfor i in range(2,len(num_list) + 1):\n\t\tfor c in combinations(num_list, i):\n\t\t\tsubsets.append(c) \n\treturn subsets\n\n#公約数の列挙\ndef ch(x1):\n\tcf=[]\n\tfor i in range(2,math.sqrt(x1)+1):\n\t\tif x1 % i==0:\n\t\t\tcf.append(i)\n\treturn cf\n\ndef CountOneRoots(x,y):\n\t#x:縦，y:横\n\treturn fact(x+y)\/fact(x)\/fact(y)\n\n# 素因数分解\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n \/\/= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n \/\/= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\n\t\ndef count_str(m):\n\ttmp={}\n\tfor i in range(10):\n\t\tif i in tmp:\n\t\t\ttmp[i]=1\n\t\telse:\n\t\t\ttmp[i]+=1\n\treturn tmp\n\ndef is_prime(n):\n\tif n==1: return True\n\n\tfor i in range(2,int(math.sqrt(n))+1):\n\t\tif n%i==0:\n\t\t\treturn False\n\treturn True\n\n\nn,d=input2()\nprint(n\/\/(d*2+1)+1)\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":730,"bad_solution":"import sys\nsys.setrecursionlimit(10**7) #再帰関数の上限,10**5以上の場合python\nimport math\nfrom copy import copy, deepcopy\nfrom copy import deepcopy as dcp\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect, bisect_right#2分探索\n#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下\nfrom collections import deque, defaultdict\n#deque(l), pop(), append(x), popleft(), appendleft(x)\n#q.rotate(n)で → にn回ローテート\nfrom collections import Counter#文字列を個数カウント辞書に、\n#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()\nfrom itertools import accumulate,combinations,permutations,product#累積和\n#list(accumulate(l))\nfrom heapq import heapify,heappop,heappush\n#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone\nfrom functools import reduce,lru_cache#pypyでもうごく\n#@lru_cache(maxsize = None)#maxsizeは保存するデータ数の最大値、2**nが最も高効率\nfrom decimal import Decimal\n\ndef input(): \n    x=sys.stdin.readline()\n    return x[:-1] if x[-1]==\"\\n\" else x\ndef printe(*x):print(\"## \",*x,file=sys.stderr)\ndef printl(li): _=print(*li, sep=\"\\n\") if li else None\ndef argsort(s, return_sorted=False): \n    inds=sorted(range(len(s)), key=lambda k: s[k])\n    if return_sorted: return inds, [s[i] for i in inds]\n    return inds\ndef alp2num(c,cap=False): return ord(c)-97 if not cap else ord(c)-65\ndef num2alp(i,cap=False): return chr(i+97) if not cap else chr(i+65)\ndef matmat(A,B):\n    K,N,M=len(B),len(A),len(B[0])\n    return [[sum([(A[i][k]*B[k][j]) for k in range(K)]) for j in range(M)] for i in range(N)]\ndef matvec(M,v):\n    N,size=len(v),len(M)\n    return [sum([M[i][j]*v[j] for j in range(N)]) for i in range(size)]\ndef T(M):\n    n,m=len(M),len(M[0])\n    return [[M[j][i] for j in range(n)] for i in range(m)]\ndef binr(x): return bin(x)[2:]\ndef bitcount(x): #xは64bit整数\n    x= x - ((x >> 1) & 0x5555555555555555)\n    x= (x & 0x3333333333333333) + ((x >> 2) & 0x3333333333333333)\n    x= (x + (x >> 4)) & 0x0f0f0f0f0f0f0f0f \n    x+= (x >> 8); x+= (x >> 16); x+= (x >> 32) \n    return x & 0x7f\n\ndef main():\n    \n    #w.sort(key=itemgetter(1),reverse=True)  #二個目の要素で降順並び替え\n\n    p = int(input())\n    #N, K = map(int, input().split())\n    A = tuple(map(int, input().split())) #1行ベクトル\n    #L = tuple(int(input()) for i in range(N)) #改行ベクトル\n    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列\n    mod = p\n    maxn=p\n    fact=[1]*(maxn+1)#NはnCrの最大のn\n    invs=[1]*(maxn+1);invs[0]=0\n    ifact=[1]*(maxn+1)\n    for i in range(2,maxn+1):\n        fact[i]=(fact[i-1]*i)%mod\n        invs[i]=invs[mod%i]*(-(mod\/\/i))%mod\n        ifact[i]=(ifact[i-1]*invs[i])%mod\n    def perm(n,r): return fact[n]*ifact[n-r]%mod\n    def comb(n,r): return (fact[n]*ifact[r]%mod)*ifact[n-r]%mod\n    def multicomb(self,n,*rs):#n!\/(r1!*r2!*r3!*...)\n        ans=fact[n]\n        for r in rs: ans=(ans*self.ifact[r])%self.mod\n        return ans\n    \n    tot=[0]*p\n    tot[0]=sum(A)%mod\n    for i in range(p):\n        a=A[i]\n        if not a:\n            continue\n        #sgn=pow(-1,p-1)\n        mi=(-i)%mod\n        base=pow(mi,p-1,mod)\n        \n        for j in range(p):\n            if j==0:\n                base=1\n            tot[j]-=base*comb(p-1,j)%mod\n            tot[j]%=mod\n            base*=invs[mi]\n            base%=mod\n\n    \n    print(*tot)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":731,"bad_solution":"import sys\ninput = sys.stdin.readline\nfrom collections import deque\ndef main():\n    N, M, K = map(int, input().split())\n    A = deque(list(map(int, input().split())))\n    B = deque(list(map(int, input().split())))\n    CNT = 0\n    while K >= 0:\n        if CNT == N+M:\n            break\n        if len(A) > 0 and len(B) > 0:\n            a = A[0]\n            b = B[0]\n            if a >= b:\n                if K >= b:\n                    K -= b\n                    B.popleft()\n                    CNT += 1\n                else:\n                    break\n            else:\n                if K >= a:\n                    K -= a\n                    A.popleft()\n                    CNT += 1\n                else:\n                    break\n\n        elif len(A) == 0:\n            b = B[0]\n            if K >= b:\n                K -= b\n                B.popleft()\n                CNT += 1\n            else:\n                break\n        else:\n            if K >= a:\n                K -= a\n                A.popleft()\n                CNT += 1\n            else:\n                break\n    print(CNT)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":732,"bad_solution":"\nimport operator\nclass SegmentTree:\n    def __init__(self, size, fn=operator.add, default=None, initial_values=None):\n        \"\"\"\n        :param int size:\n        :param callable fn: 区間に適用する関数。引数を 2 つ取る。min, max, operator.xor など\n        :param default:\n        :param list initial_values:\n        \"\"\"\n        default = default or 0\n\n        # size 以上である最小の 2 冪を size とする\n        n = 1\n        while n < size:\n            n *= 2\n        self._size = n\n        self._fn = fn\n\n        self._tree = [default] * (self._size * 2 - 1)\n        if initial_values:\n            i = self._size - 1\n            for v in initial_values:\n                self._tree[i] = v\n                i += 1\n            i = self._size - 2\n            while i >= 0:\n                self._tree[i] = self._fn(self._tree[i * 2 + 1], self._tree[i * 2 + 2])\n                i -= 1\n\n    def set(self, i, value):\n        \"\"\"\n        i 番目に value を設定\n        :param int i:\n        :param value:\n        :return:\n        \"\"\"\n        x = self._size - 1 + i\n        self._tree[x] = value\n\n        while x > 0:\n            x = (x - 1) \/\/ 2\n            self._tree[x] = self._fn(self._tree[x * 2 + 1], self._tree[x * 2 + 2])\n\n    def add(self, i, value):\n        \"\"\"\n        もとの i 番目と value に fn を適用したものを i 番目に設定\n        :param int i:\n        :param value:\n        :return:\n        \"\"\"\n        x = self._size - 1 + i\n        self.set(i, self._fn(self._tree[x], value))\n\n    def get(self, from_i, to_i=None, k=0, L=None, r=None):\n        \"\"\"\n        [from_i, to_i) に fn を適用した結果を返す\n        :param int from_i:\n        :param int to_i:\n        :param int k: self._tree[k] が、[L, r) に fn を適用した結果を持つ\n        :param int L:\n        :param int r:\n        :return:\n        \"\"\"\n        if to_i is None:\n            return self._tree[self._size - 1 + from_i]\n\n        L = 0 if L is None else L\n        r = self._size if r is None else r\n\n        if from_i <= L and r <= to_i:\n            return self._tree[k]\n\n        if to_i <= L or r <= from_i:\n            return None\n\n        ret_L = self.get(from_i, to_i, k * 2 + 1, L, (L + r) \/\/ 2)\n        ret_r = self.get(from_i, to_i, k * 2 + 2, (L + r) \/\/ 2, r)\n        if ret_L is None:\n            return ret_r\n        if ret_r is None:\n            return ret_L\n        return self._fn(ret_L, ret_r)\n\n    def __len__(self):\n        return self._size\n\ndef resolve():\n    N = int(input())\n    S = input()\n    Q = int(input())\n\n    seg = SegmentTree(N, fn=operator.or_)\n    for i in range(N):\n        s = 2 ** (ord(S[i]) - ord('a'))\n        seg.set(i, s)\n\n    for _ in range(Q):\n        act, q1, q2 = input().split()\n        if act == \"1\":\n            # 文字変更\n            idx = int(q1) - 1\n            s_bin = 1 << (ord(q2) - ord('a'))\n            seg.set(idx, s_bin)\n        else:\n            # L,R区間の文字種を出力\n            l = int(q1)-1\n            r = int(q2)\n            x = bin(seg.get(l, r))\n            print(x.count(\"1\"))\n\n\nif __name__ == \"__main__\":\n    resolve()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":733,"bad_solution":"import sys\nimport numpy as np\nfrom numba import njit\n\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nINF = 10**9 + 1\n\nN, M = map(int, readline().split())\ndata = np.int64(read().split()).reshape(-1, 3)\n\nA = data[:N, 0]\nB = data[:N, 1]\nC = data[:N, 2]\nD = data[N:, 0]\nE = data[N:, 1]\nF = data[N:, 2]\n\nX = np.unique(np.concatenate([A, B, D, [0, -INF, INF]]))\nY = np.unique(np.concatenate([C, E, F, [0, -INF, INF]]))\nDX = X[1:] - X[:-1]\nDY = Y[1:] - Y[:-1]\n\nA, B, C = map(lambda x: np.searchsorted(X, x), (A, B, C))\nD, E, F = map(lambda x: np.searchsorted(Y, x), (D, E, F))\n\nH, W = len(X), len(Y)\nN = H * W\n\n@njit\ndef set_ng(A, B, C, D, E, F):\n    ng = np.zeros((N, 4), np.bool_)\n\n    for i in range(len(A)):\n        for x in range(A[i], B[i]):\n            v = x * W + C[i]\n            ng[v][1] = 1\n            ng[v - 1][0] = 1\n\n    for i in range(len(D)):\n        for y in range(E[i], F[i]):\n            v = D[i] * W + y\n            ng[v][3] = 1\n            ng[v - W][2] = 1\n    return ng\n\n@njit\ndef solve():\n    ng = set_ng(A, B, C, D, E, F)\n    x0, y0 = np.searchsorted(X, 0), np.searchsorted(Y, 0)\n    v0 = x0 * W + y0\n    visited = np.zeros(N, np.bool_)\n    visited[v0] = 1\n    stack = [v0]\n    ret = 0\n\n    def area(x):\n        x, y = divmod(x, W)\n        return DX[x] * DY[y]\n\n    def push(x):\n        nonlocal ret\n        stack.append(x)\n        visited[x] = 1\n        ret += area(x)\n\n    push(v0)\n    move = (1, -1, W, -W)\n    while stack:\n        v = stack.pop()\n        for i in range(4):\n            if ng[v][i]:\n                continue\n            w = v + move[i]\n            if visited[w]:\n                continue\n            x, y = divmod(w, W)\n            if x == 0 or x == H - 1 or y == 0 or y == W - 1:\n                return 0\n            push(w)\n    return ret\n\nx = solve()\nif x == 0:\n    print('INF')\nelse:\n    print(x)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":734,"bad_solution":"\ndef FUNC(value):\n    '''\n    Create a function that takes a value (string) representing a number\n    and returns the closest integer to it. If the number is equidistant\n    from two integers, round it away from zero.\n\n    Examples\n    >>> FUNC(\"10\")\n    10\n    >>> FUNC(\"15.3\")\n    15\n\n    Note:\n    Rounding away from zero means that if the given number is equidistant\n    from two integers, the one you should return is the one that is the\n    farthest from zero. For example FUNC(\"14.5\") should\n    return 15 and FUNC(\"-14.5\") should return -15.\n    '''\n    from math import floor, ceil\n\n    if value.count('.') == 1:\n        # remove trailing zeros\n        while (value[-1] == '0'):\n            value = value[:-1]\n\n    num = float(value)\n    if value[-2:] == '.5':\n        if num > 0:\n            res = floor(num)\n        else:\n            res = ceil(num)\n    elif len(value) > 0:\n        res = int(round(num))\n    else:\n        res = 0\n\n    return res\n\n"}
{"id":735,"bad_solution":"N, M, Q = map(int,input().split())\nMlist = []\nfor i in range(M):\n    array = list(map(int, input().strip().split()))\n    Mlist.append(array)\nQlist = []\nfor i in range(Q):\n    array = list(map(int, input().strip().split()))\n    Qlist.append(array)\np = [[0 for i in range(N)] for j in range(N)]\nq = 0\nr = [[0 for i in range(N)] for j in range(N)]\ndef count(k,l):\n    s = k\n    j = l\n    p[s-1][j-1] = p[s-1][j-1] + 1\nfor i in range(len(Mlist)):\n    count(Mlist[i][0],Mlist[i][1])\nfor i in range(N):\n    for j in range(N):\n        if j > 0:\n            r[i][j] = r[i][j-1] + p[i][j]\n        else:\n            r[i][j] = p[i][j]\nfor i in range(len(Qlist)):\n    q = 0\n    for j in range(Qlist[i][0],Qlist[i][1]+1):\n        q = q + r[j-1][Qlist[i][1]-1]\n        if j - 1> 0:\n            q = q - r[j-1][j-2]\n    print(q)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":736,"bad_solution":"\ndef FUNC(n):\n    \"\"\"\n    Given a positive integer n, you have to make a pile of n levels of stones.\n    The first level has n stones.\n    The number of stones in the next level is:\n        - the next odd number if n is odd.\n        - the next even number if n is even.\n    Return the number of stones in each level in a list, where element at index\n    i represents the number of stones in the level (i+1).\n\n    Examples:\n    >>> FUNC(3)\n    [3, 5, 7]\n    \"\"\"\n    return [n + 2*i + i for i in range(n)]\n"}
{"id":737,"bad_solution":"import heapq\n# python template for atcoder1\nimport sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\n\nx, y, z, k = map(int, input().split())\na = list(map(int, input().split()))\nb = list(map(int, input().split()))\nc = list(map(int, input().split()))\n\n\ndef solve1():\n    que = []\n    for a in a:\n        for b in b:\n            for c in c:\n                heapq.heappush(que, -(a+b+c))\n    for _ in range(k):\n        print(-heapq.heappop(que))\n\n\nsolve1()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":738,"bad_solution":"import fractions\n\nABCD = list(map(int, input().split()))\n\nA = ABCD[0]\nB = ABCD[1]\nC = ABCD[2]\nD = ABCD[3]\n\n\ndef lcm(x, y):\n    return (x * y) \/ fractions.gcd(x, y)\n\n\nfirstC = int((A-1)\/C)\nfirstD = int((A-1)\/D)\nfirstCD = int((A-1)\/lcm(C,D))\n\n# if A%lcm(C,D) ==0 and firstCD > 0:\n#     firstCD -= 1\n\nendC = int(B\/C)\nendD = int(B\/D)\nendCD = int(B\/lcm(C,D))\n\nthereC = endC - firstC\nthereD = endD - firstD\nthereCD = endCD - firstCD\n\nNoP = thereC+thereD - thereCD\n#\n# print(thereC)\n# print(thereD)\n# print(thereCD)\n# print(NoP)\n\nprint((B-A+1)-NoP)\n\n\n\n\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":739,"bad_solution":"import sys\n\n\ndef solve(n, m, arr):\n    odds = []\n    evens = []\n    for a in arr:\n        if a % 2 == 0:\n            evens.append(a)\n        else:\n            odds.append(a)\n\n    if len(odds) > 2:\n        print('Impossible')\n        return\n\n    if len(odds) == 2:\n        o1, o2 = odds\n        aaa = [o1] + evens + [o2]\n        bbb = [2] * (o1 \/\/ 2 + 1)\n        bbb += evens\n        bbb += [2] * (o2 \/\/ 2)\n\n    elif len(odds) == 1:\n        if evens:\n            aaa = odds + evens\n            bbb = list(reversed(aaa))\n        elif odds[0] == 1:\n            aaa = odds\n            bbb = odds\n        else:\n            aaa = odds\n            bbb = [odds[0] \/\/ 2, odds[0] \/\/ 2 + 1]\n\n    else:\n        aaa = evens\n        bbb = [1] + aaa[:-1] + [aaa[-1] - 1]\n\n    print(*aaa)\n    print(len(bbb))\n    print(*bbb)\n\n\nn, m, *aaa = map(int, sys.stdin.buffer.read().split())\nsolve(n, m, aaa)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":740,"bad_solution":"from collections import deque\nimport sys\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\n\ndef solve():\n  H,W = map(int,input().split())\n  C_h,C_w = map(lambda x:int(x)-1,input().split())\n  D_h,D_w = map(lambda x:int(x)-1,input().split())\n  S = [readline() for _ in range(H)]\n\n  INF = int(1e7)\n  dist = [[INF]*(W) for _ in range(H)]\n  dist[C_h][C_w] = 0\n  seen = [[False]*(W) for _ in range(H)]\n  deq = deque()\n  deq.append((C_h,C_w))\n\n  move_a = [(1, 0), (0, 1), (-1, 0), (0, -1)]\n  move_b = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2), (-1, -2), (-1, -1), (-1, 1), (-1, 2), (0, -2), (0, 2), (1, -2), (1, -1), (1, 1), (1, 2), (2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n\n  while len(deq):\n    h,w = deq.popleft()\n    if seen[h][w]:\n      continue\n      seen[h][w] = True\n    for dh,dw in move_a:\n      nh,nw = h+dh,w+dw\n      if nh>=0 and nw>=0 and nh<H and nw<W and S[nh][nw]!='#' and dist[nh][nw] > dist[h][w]:\n        dist[nh][nw] = dist[h][w]\n        deq.appendleft((nh,nw))\n    for dh,dw in move_b:\n      nh,nw = h+dh,w+dw\n      if nh>=0 and nw>=0 and nh<H and nw<W and S[nh][nw]!='#' and dist[nh][nw] > dist[h][w]+1:\n        dist[nh][nw] = dist[h][w]+1\n        deq.append((nh,nw))\n\n  print(dist[D_h][D_w] if dist[D_h][D_w]<INF else -1)\nsolve()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":741,"bad_solution":"from collections import deque\n\nH, W = map(int, input().split())\nC0, C1 = map(int, input().split())\nD0, D1 = map(int, input().split())\n\nARR = []\n\nfor i in range(H):\n    ARR.append(input())\n\n\ndef calculate(h, w, c0, c1, d0, d1, arr):\n    c0 = c0 - 1\n    c1 = c1 - 1\n    d0 = d0 - 1\n    d1 = d1 - 1\n\n    status = []\n    for i in range(H):\n        tmp = []\n        for j in range(W):\n            tmp.append(-1)\n        status.append(tmp)\n\n    q = deque()\n\n    q.append((c0, c1, 0))\n\n    while len(q) > 0:\n        hIndex, wIndex, index = q.popleft()\n\n\n        sss = [(hIndex,wIndex - 1), (hIndex, wIndex + 1), ( hIndex - 1, wIndex), (hIndex + 1, wIndex)]\n\n\n        for sH, sW in sss:\n            if (sH >= 0) and (sH < h) and (sW >= 0) and (sW < w):\n                if arr[sH][sW] == '.':\n                    tmpIndex = index\n                    if status[sH][sW] == -1:\n                        status[sH][sW] = tmpIndex\n                        q.append((sH, sW, tmpIndex))\n                    else:\n                        if status[sH][sW] > tmpIndex:\n                            status[sH][sW] = tmpIndex\n                            q.append((sH, sW, tmpIndex))\n\n        for _hIndex in range(hIndex - 2, hIndex + 3):\n            for _wIndex in range(wIndex - 2, wIndex + 3):\n                if (_hIndex == hIndex) and (_wIndex == wIndex):\n                    continue\n                if (_hIndex == c0) and (_wIndex == c1):\n                    continue\n                if (_hIndex, _wIndex) in sss:\n                    continue\n                if (_hIndex >= 0 and _hIndex < h) and (_wIndex >= 0 and _wIndex < w):\n                    if arr[_hIndex][_wIndex] == '.':\n                        tmpIndex = index + 1\n                        if status[_hIndex][_wIndex] == -1:\n                            status[_hIndex][_wIndex] = tmpIndex\n                            q.append((_hIndex, _wIndex, tmpIndex))\n                        else:\n                            if status[_hIndex][_wIndex] > tmpIndex:\n                                status[_hIndex][_wIndex] = tmpIndex\n                                q.append((_hIndex, _wIndex, tmpIndex))\n\n    if status[d0][d1] >= 0:\n        print(status[d0][d1])\n    else:\n        print(-1)\n\n\ncalculate(H, W, C0, C1, D0, D1, ARR)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":742,"bad_solution":"import sys\nimport math\n\nif sys.subversion[0] == \"PyPy\":\n    import io, atexit\n\n    sys.stdout = io.BytesIO()\n    atexit.register(lambda: sys.__stdout__.write(sys.stdout.getvalue()))\n\n    sys.stdin = io.BytesIO(sys.stdin.read())\n    input = lambda: sys.stdin.readline().rstrip()\nRS = raw_input\nRA = lambda x=int: map(x, RS().split())\nRN = lambda x=int: x(RS())\n\n\ndef solve():\n    check_pairwise()\n    check_set()\n    return\n\n\ndef check_pairwise():\n    active = set()\n    for i in range(0, n):\n        pp = getprimes(a[i])\n        for p in pp:\n            if p in active:\n                return\n            else:\n                active.add(p)\n    print(\"pairwise coprime\")\n    exit()\n\n\n\ndef check_set():\n    active = getprimes(a[0])\n    for i in range(1, n):\n        if not a[i] % a[i-1] == 0:\n            for act in active:\n                if not a[i] % act == 0:\n                    active.remove(act)\n                    if not active:\n                        print(\"setwise coprime\")\n                        exit()\n    print(\"not coprime\")\n    exit()\n\n\n\n\ndef getprimes(num):\n    if num in primes:\n        return set([num])\n    pp = set()\n    for p in primes:\n        if p > int(math.sqrt(num)+2):\n            break\n        if num % p == 0:\n            pp.add(p)\n\n    return pp\n\n\n\n\ndef n_primes(n):\n    nums = list(range(0, n + 1))\n    primes = []\n    for i in range(2, n + 1):\n        num = nums[i]\n        if num != 0:\n            primes.append(num)\n            for i in range(0, n \/\/ num + 1):\n                nums[i * num] = 0\n    return primes\n\n\nn = RN()\na = sorted(RA())\nprimes = set(n_primes(10 ** 6))\nsolve()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":743,"bad_solution":"from collections import defaultdict, deque\ndef solve():\n    H,W = map(int,input().split())\n    Ch,Cw = map(int,input().split())\n    Ch -= 1\n    Cw -= 1\n    Dh,Dw = map(int,input().split())\n    Dh -= 1\n    Dw -= 1\n\n    S = [list(input()) for _ in range(H)]\n    area_num = 0\n    for h in range(H):\n        for w in range(W):\n            if S[h][w] == '.':\n                dfs(h,w,H,W,S,area_num)\n                area_num += 1\n\n    start_area_num = int(S[Ch][Cw])\n    goal_area_num = int(S[Dh][Dw])\n\n    G = defaultdict(set)\n\n    for h in range(H):\n        for w in range(W):\n            from_area_num = S[h][w]\n            if from_area_num == '#':\n                continue\n            from_area_num = int(from_area_num)\n\n            d = ((0,-1),(0,1),(-1,0),(1,0))\n            close_to_wall = False\n            for dh, dw in d:\n                if dh+h < 0 or dh+h >= H:\n                    continue\n                if dw+w < 0 or dw+w >= W:\n                    continue\n\n                if S[dh+h][dw+w] == '#':\n                    close_to_wall = True\n            \n            if not close_to_wall:\n                continue\n\n            # for dh in range(-2,2+1):\n            for dh in range(1):\n                if h+dh < 0 or h+dh >= H:\n                    continue\n                # for dw in range(-2, 2+1):\n                for dw in range(1):\n                    if w+dw < 0 or w+dw >= W:\n                        continue\n                    to_area_num = S[h+dh][w+dw]\n                    if to_area_num == '#':\n                        continue\n                    to_area_num = int(to_area_num)\n                    if from_area_num != to_area_num:\n                        G[to_area_num].add(from_area_num)\n                        G[from_area_num].add(to_area_num)\n    \n    area_num_count = area_num + 1\n    visited = [False] * area_num_count\n    q = deque()\n    q.append((start_area_num,0))\n    while len(q) > 0:\n        cur_area_num, warp_cnt = q.popleft()\n        if cur_area_num == goal_area_num:\n            print(warp_cnt)\n            return\n        \n        visited[cur_area_num] = True\n        for next_area_num in G[cur_area_num]:\n            if not visited[next_area_num]:\n                q.append((next_area_num,warp_cnt+1))\n    else:\n        print(-1)\n\ndef dfs(h,w,H,W,S,area_num):\n    if 0 <= h < H and 0 <= w < W and S[h][w] == '.':\n        S[h][w] = str(area_num)\n        dfs(h+1,w,H,W,S,area_num)\n        dfs(h,w+1,H,W,S,area_num)\n        dfs(h-1,w,H,W,S,area_num)\n        dfs(h,w-1,H,W,S,area_num)\n\ndef mod_graph(G,including_area_num_set):\n    for area_num_from in including_area_num_set:\n        for area_num_to in including_area_num_set:\n            G[area_num_from].add(area_num_to)\n\nif __name__ == '__main__':\n    solve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":744,"bad_solution":"def examA():\n    A, B = LI()\n    ans = A*B\n    print(ans)\n    return\n\ndef examB():\n    N = I()\n    A = LI()\n    for a in A:\n        if a==0:\n            print(0)\n            return\n    ans = 1\n    for a in A:\n        ans *= a\n        if ans>10**18:\n            print(-1)\n            return\n    print(ans)\n    return\n\ndef examC():\n    A, B = list(map(float,input().split()))\n    ans =math.floor(A*B)\n    print(ans)\n    return\n\ndef examD():\n    def factorization(n):\n        arr = defaultdict(int)\n        temp = n\n        for i in range(2, int(-(-n ** 0.5 \/\/ 1)) + 1):\n            if temp % i == 0:\n                cnt = 0\n                while temp % i == 0:\n                    cnt += 1\n                    temp \/\/= i\n                arr[i] = cnt\n        if temp != 1:\n            arr[temp] = 1\n        if arr == []:\n            arr[n] = 1\n        return arr\n    C = [0,1,3,6,10,15,21,28,36,45]\n    N = I()\n    F = factorization(N)\n    ans = 0\n    #print(F)\n    for f in F.values():\n        for i in range(10):\n            if C[i]>f:\n                ans += i-1\n                break\n    print(ans)\n    return\n\ndef examE():\n    N = I()\n    A = [0]*N\n    B = [0]*N\n    for i in range(N):\n        A[i],B[i] = LI()\n    A.sort()\n    B.sort()\n    if N%2==0:\n        L = (A[N\/\/2-1] + A[N\/\/2])\/2\n        R = (B[N\/\/2-1] + B[N\/\/2])\/2\n        ans = int((R-L)*2) +1\n    else:\n        L = A[N\/\/2]\n        R = B[N\/\/2]\n        ans = (R-L)+1\n\n    print(ans)\n    return\n\ndef examF():\n    N, S = LI()\n    A = LI()\n\n    ans = 0\n    print(ans)\n    return\n\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 1<<60\n_ep = 10**(-12)\nalphabet = [chr(ord('a') + i) for i in range(26)]\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examC()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\"\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":745,"bad_solution":"package main\n\nimport (\n    \"bufio\"\n    \"os\"\n    \"strings\"\n    \"strconv\"\n    \"fmt\"\n    \"sort\"\n    \"container\/heap\"\n    \"math\"\n)\n\nvar sc = bufio.NewScanner(os.Stdin)\n\nfunc readLineToInt() []int {\n    sc.Scan()\n    line := strings.Split(sc.Text(), \" \")\n    var intLine []int\n    for _, str := range line {\n        n, _ := strconv.Atoi(str)\n        intLine = append(intLine, n)\n    }\n    return intLine\n}\n\n\n\/****************** Pair ********************\/\ntype Pair struct {\n    a int\n    b int\n}\n\ntype SortablePairs struct {\n    arr []*Pair\n    lessfunc []lessFunc\n}\n\ntype lessFunc func(i, j *Pair) bool\n\nfunc (sp SortablePairs) Len() int {\n    return len(sp.arr)\n}\n\nfunc (sp SortablePairs) Swap(i, j int) {\n    sp.arr[i], sp.arr[j] = sp.arr[j], sp.arr[i]\n}\n\nfunc (sp SortablePairs) Less(i, j int) bool {\n    p, q := sp.arr[i], sp.arr[j]\n    for k := 0; k < len(sp.lessfunc); k++ {\n        less := sp.lessfunc[k]\n        if less(p, q) {\n            return true\n        } else if less(q, p) {\n            return false\n        }\n    }\n    return false\n}\n\n\/***************** HeapQue *****************\/\n\ntype PriorityQueue struct {\n    arr []*Pair\n    size int\n}\n\/** sort **\/\nfunc (pq PriorityQueue) Len() int {\n    return len(pq.arr)\n}\n\nfunc (pq PriorityQueue) Swap(i, j int) {\n    pq.arr[i], pq.arr[j] = pq.arr[j], pq.arr[i]\n}\n\nfunc (pq PriorityQueue) Less(i, j int) bool{\n    return pq.arr[i].a < pq.arr[j].a\n}\n\n\/**** pq ****\/\nfunc (pq *PriorityQueue) Push(x interface{}) {\n    item := x.(*Pair)\n    pq.arr = append(pq.arr, item)\n    pq.size++\n}\n\nfunc (pq *PriorityQueue) Pop() interface{} {\n    n := pq.size\n    item := pq.arr[n - 1]\n    pq.arr = pq.arr[:n - 1]\n    pq.size--\n    return item\n}\n\nfunc max(a, b int) int {\n    return int(math.Max(float64(a), float64(b)))\n}\n\nfunc main() {\n    nk := readLineToInt()\n    n, k := nk[0], nk[1]\n    var dic map[int][]int = map[int][]int{}\n    var keys []int\n    for i := 0; i < n; i++ {\n        td := readLineToInt()\n        t, d := td[0], td[1]\n        _, ok := dic[t]\n        if !ok {\n            keys = append(keys, t)\n        }\n        dic[t] = append(dic[t], d)\n    }\n\n    var sp SortablePairs\n    less := func(p, q *Pair) bool {\n        return p.a >= q.a\n    }\n    sp.lessfunc = append(sp.lessfunc, less)\n    for _, key := range keys {\n        sort.Ints(dic[key])\n        length := len(dic[key])\n        sp.arr = append(sp.arr, &Pair{dic[key][length - 1], key})\n        dic[key] = dic[key][:length - 1]\n    }\n    sort.Sort(sp)\n    var que PriorityQueue\n    heap.Init(&que)\n    queScore := 0\n    defaultScore := 0\n    cnt := 0\n    ans := 0\n    for _, p := range sp.arr {\n        defaultScore += p.a + cnt * 2 + 1\n        cnt++\n        if cnt >= k {\n            ans = max(ans, defaultScore)\n            break\n        }\n        for _, add := range dic[p.b] {\n            heap.Push(&que, &Pair{add, p.b})\n            queScore += add\n        }\n        for que.size > k - cnt {\n            item := heap.Pop(&que).(*Pair)\n            queScore -= item.a\n        }\n        ans = max(ans, defaultScore + queScore)\n    }\n    fmt.Println(ans)\n\n}\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":746,"bad_solution":"import collections\n\n\nclass Graph:\n    def __init__(self, n_nodes):\n        self.n_nodes = n_nodes\n        self.edges = [[] for _ in range(n_nodes)]\n\n    def add_edge(self, s, t):\n        self.edges[s].append(t)\n        self.edges[t].append(s)\n\n\nn = int(input())\ngraph = Graph(n)\nfor i in range(n):\n    s = input().rstrip()\n    for j in range(i + 1, n):\n        if s[j] == '1':\n            graph.add_edge(i, j)\n\n\ndef check(node):\n    for new_node in graph.edges[node]:\n        if orders[new_node] == orders[\n                node] or 0 < orders[new_node] < orders[node] - 1:\n            return False\n        if orders[new_node] == -1:\n            orders[new_node] = orders[node] + 1\n            q.append(new_node)\n    return True\n\n\nres = []\nfor i in range(n):\n    orders = [-1] * n\n    q = collections.deque()\n    q.append(i)\n    orders[i] = 1\n    while q:\n        node = q.pop()\n        ok = check(node)\n        if not ok:\n            break\n    else:\n        res.append(max(orders))\nif len(res) == 0:\n    print(-1)\nelse:\n    print(max(res))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":747,"bad_solution":"\ndef FUNC(s):\n    \"\"\"\n    You will be given a string of words separated by commas or spaces. Your task is\n    to split the string into words and return an array of the words.\n    \n    For example:\n    FUNC(\"Hi, my name is John\") == [\"Hi\", \"my\", \"name\", \"is\", \"John\"]\n    FUNC(\"One, two, three, four, five, six\") == [\"One\", \"two\", \"three\", \"four\", \"five\", \"six\"]\n    \"\"\"\n    if not s:\n        return []\n\n    s_list = []\n\n    for letter in s:\n        if letter == ',':\n            s_list.append(',')\n        else:\n            s_list.append(letter)\n\n    s_list = \"\".join(s_list)\n    return s_list.split()\n"}
{"id":748,"bad_solution":"\ndef FUNC(x, y):\n    \"\"\"This function takes two positive numbers x and y and returns the\n    biggest even integer number that is in the range [x, y] inclusive. If \n    there's no such number, then the function should return -1.\n\n    For example:\n    FUNC(12, 15) = 14\n    FUNC(13, 12) = -1\n    \"\"\"\n    if x > y:\n        return -1\n    if y % 2 == 0:\n        return y\n    if x == y:\n        return -1\n    return x - 1\n"}
{"id":749,"bad_solution":"import sys\nsys.setrecursionlimit(10**6) #再帰関数の上限\nimport math\nfrom copy import copy, deepcopy\nfrom operator import itemgetter\nfrom bisect import bisect_left, bisect, bisect_right#2分探索\n#bisect_left(l,x), bisect(l,x)#aはソート済みである必要あり。aの中からx未満の要素数を返す。rightだと以下\nfrom collections import deque \n#deque(l), pop(), append(x), popleft(), appendleft(x)\n##listでqueの代用をするとO(N)の計算量がかかってしまうので注意\nfrom collections import Counter#文字列を個数カウント辞書に、\n#S=Counter(l),S.most_common(x),S.keys(),S.values(),S.items()\nfrom itertools import accumulate#累積和\n#list(accumulate(l))\nfrom heapq import heapify,heappop,heappush\n#heapify(q),heappush(q,a),heappop(q) #q=heapify(q)としないこと、返り値はNone\n#import fractions#古いatcoderコンテストの場合GCDなどはここからimportする\n\ndef input(): return sys.stdin.readline()[:-1]\ndef printl(li): print(*li, sep=\"\\n\")\ndef argsort(s, return_sorted=False): \n    inds=sorted(range(len(s)), key=lambda k: s[k])\n    if return_sorted: return inds, [s[i] for i in inds]\n    return inds\n\ndef main():\n    mod = 10**9+7\n    #w.sort(key=itemgetter(1),reversed=True)  #二個目の要素で降順並び替え\n\n    #N = int(input())\n    N, M = map(int, input().split())\n    #A = tuple(map(int, input().split())) #1行ベクトル\n    #L = tuple(int(input()) for i in range(N)) #改行ベクトル\n    #S = tuple(tuple(map(int, input().split())) for i in range(N)) #改行行列\n    tot=[[] for _ in range(N+1)]\n    ys=[0]*M\n    for i in range(N):\n        heapify(tot[i])\n    for i in range(M):\n        P, Y = map(int, input().split())\n        heappush(tot[P],Y)\n        ys[i]=Y\n    tset=[]\n    tseti=[]\n    for i in range(N+1):\n        t1=tot[i]\n        if len(t1)<1:continue\n        p=str(i)\n        if len(p)<6:\n            p='0'*(6-len(p))+p\n        for j,t in enumerate(t1):\n            tx=str(j+1)\n            if len(tx)<6:\n                tx='0'*(6-len(tx))+tx\n            tset.append(p+tx)\n            tseti.append(t)\n    for y in ys:\n        i=tseti.index(y)\n        print(tset[i])\n\n\n\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":750,"bad_solution":"from collections import Counter,defaultdict,deque\nfrom heapq import heappop,heappush,heapify\nimport sys,bisect,math,itertools,fractions,pprint\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nmod2 = 998244353\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\nn,m,v,p = inpl()\na = inpl()\nc = Counter(a)\na.sort()\nb_num = a[n-p]\nd_cnt = 0\nb_cnt = 0\nu_cnt = 0\nfor i in a:\n    if i < b_num: d_cnt += 1\n    elif i == b_num: b_cnt += 1\n    else: u_cnt += 1\n\ndef f(x,i):\n    if x >= b_num:\n        return True\n    if x + m < b_num:\n        return False\n    if i + u_cnt >= v-1:\n        return True\n    cnt = 0\n    for ind,item in enumerate(a):\n        if item > b_num or item <= x:\n            cnt += m\n        else:\n            cnt += x + m - item\n    if cnt >= m*v:\n        return True\n    else:\n        return False\n\nok = n-1\nng = 0\nwhile abs(ok-ng) > 1:\n    mid = (ok+ng)\/\/2\n    if f(a[mid],mid):\n        ok = mid\n    else:\n        ng = mid\nprint(n-mid)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":751,"bad_solution":"input = sys.stdin.readline\nMax = 2000\ndef l():\n    return list(map(int,input().split()))\ndef m():\n    return map(int,input().split())\ndef s(x):\n    a = []\n    aa = x[i]\n    su = 1\n    for i in range(len(x)-1):\n        if aa == x[i+1]:\n            a.append([aa,su])\n            aa = x[i+1]\n            su = 1\n        else:\n            su += 1\n    a.append([aa,su])\n    return a\ndef jo(x):\n    return \" \".join(map(str,x))\n\nh,w = m()\n\naa = [[] for i in range(h)]\naaa = []\nma = 0\nfor i in range(h):\n    k = list(input())\n    for j in range(w):\n        if k[j] == \"#\":\n            aa[i].append(0)\n            aaa.append([i,j])\n        else:\n            aa[i].append(Max)\nkk = []\nwhile True:\n    if len(aaa) == 0:\n        break\n    for i in range(len(aaa)):\n        c,v = aaa.pop(0)\n        if not c == 0:\n            if aa[c-1][v] != min(aa[c][v]+1,aa[c-1][v]):\n                aa[c-1][v] = min(aa[c][v]+1,aa[c-1][v])\n                kk.append([c-1,v])\n                ma = max(ma,aa[c-1][v])\n        if not c == h-1:\n            if aa[c+1][v] != min(aa[c][v]+1,aa[c+1][v]):\n                aa[c+1][v] = min(aa[c][v]+1,aa[c+1][v])\n                kk.append([c+1,v])\n                ma = max(ma,aa[c+1][v])\n        if not v == 0:\n            if aa[c][v-1] != min(aa[c][v]+1,aa[c][v-1]):\n                aa[c][v-1] = min(aa[c][v]+1,aa[c][v-1])\n                kk.append([c,v-1])\n                ma = max(ma,aa[c][v-1])\n        if not v == w-1:\n            if aa[c][v+1] != min(aa[c][v]+1,aa[c][v+1]):\n                aa[c][v+1] = min(aa[c][v]+1,aa[c][v+1])\n                kk.append([c,v+1])\n                ma = max(ma,aa[c][v+1])\n    aaa = kk\n    kk = []\nprint(ma)\n        \n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":752,"bad_solution":"import sys\nsys.setrecursionlimit(10**6)\nfrom collections import deque\nfrom copy import deepcopy\ndef main():\n    movey = (0, -1, 0, 1)\n    movex = (1, 0, -1, 0)\n    warpy = (-2, -2, -2, -2, -2, -1, -1, -1, -1,  0, 0,  1,  1, 1, 1, 2, 2, 2, 2, 2)\n    warpx = (-2, -1,  0,  1,  2, -2, -1,  1,  2, -2, 2, -2, -1, 1, 2, -2, -1, 0, 1, 2)\n    \n    h, w = map(int, input().split())\n    ch, cw = map(int, input().split())\n    dh, dw = map(int, input().split())\n    ch += 1\n    cw += 1\n    dh += 1\n    dw += 1\n    dummy = ['#'] * (w + 4)\n    maze = list()\n    maze.append(dummy)\n    maze.append(dummy)\n    for _ in range(h):\n        row = ['#'] + ['#'] + list(input()) + ['#'] + ['#']\n        maze.append(row)\n    maze.append(dummy)\n    maze.append(dummy)\n    maze[ch][cw] = 0\n    #maze[dh][dw] = 'g'\n\n    next_nodes = deque()\n    next_nodes.append((ch, cw))\n    next2_nodes = deque()\n    #cnt = 0\n    while next_nodes:\n        while next_nodes:\n            nextn = next_nodes.popleft()\n            nextny = nextn[0]\n            nextnx = nextn[1]\n            curg = maze[nextny][nextnx]\n            flag = False\n            for j1 in range(4):\n                ny = nextny + movey[j1]\n                nx = nextnx + movex[j1]\n                if maze[ny][nx] == '.':\n                    maze[ny][nx] = curg\n                    next2_nodes.appendleft((ny, nx))\n                elif maze[ny][nx] == '#':\n                    flag = True\n                elif maze[ny][nx] > curg:\n                    maze[ny][nx] = curg\n                    next2_nodes.appendleft((ny, nx))\n            if flag:\n                for j1 in range(20):\n                    ny = nextny + warpy[j1]\n                    nx = nextnx + warpx[j1]\n                    nextg = maze[ny][nx]\n                    if nextg == '.':\n                        next2_nodes.append((ny, nx))\n                        maze[ny][nx] = curg + 1\n                    elif nextg == '#':\n                        pass\n                    #elif nextg > curg + 1:\n                    #    maze[ny][nx] = curg + 1\n                    #    next2_nodes.append((ny, nx))\n        next_nodes = deque(set(next2_nodes))\n        next2_nodes = deque()\n    g = maze[dh][dw]\n    if g == '.':\n        print(-1)\n    else:\n        print(g)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":753,"bad_solution":"# -*- coding: utf-8 -*-\nimport heapq\nimport sys\nfrom collections import defaultdict\n\ninput = sys.stdin.buffer.readline\nINF = 2**62-1\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef Dijkstra(g, s):\n    d = defaultdict(lambda: INF)\n    d[s] = 0\n    q = []\n    heapq.heappush(q, (d[s], s))\n\n    prev = {}\n    done = set()\n    while q:\n        c, u = heapq.heappop(q)\n        if u in done:\n            continue\n        done.add(u)\n        for v in g[u]:\n            alt = g[u][v] + d[u]\n            if d[v] > alt:\n                d[v] = alt\n                prev[v] = u\n                heapq.heappush(q, (d[v], v))\n    return d\n\ndef slv(N, M, S, UVAB, CD):\n    g = defaultdict(dict)\n    V = {}\n    MA = 0\n    for u, v, a, b in UVAB:\n        g[u][v] = (a, b)\n        g[v][u] = (a, b)\n        MA = max(MA, a)\n    MA *= (N-1)\n\n    for i, (c, d) in enumerate(CD, 1):\n        V[i] = (c, d)\n\n    s = (1, min(S, MA))\n    d = defaultdict(lambda: INF)\n    d[s] = 0\n    q = []\n    heapq.heappush(q, (d[s], s))\n\n    while q:\n        c, u = heapq.heappop(q)\n        if d[u] < c:\n            continue\n        uu, cc = u\n        c, dd = V[uu]\n        for vv in g[uu]:\n            a, b = g[uu][vv]\n            m = cc - a\n            for i in range(1000000):\n                m += i*c\n                if m < 0:\n                    continue\n                m = min(m, MA)\n                v = (vv, m)\n                alt = i*dd + b + d[u]\n\n                if d[v] > alt:\n                    d[v] = alt\n                    heapq.heappush(q, (d[v], v))\n                if m == MA:\n                    break\n\n    ans = [INF] * (N+1)\n    for k, v in d.items():\n        u = k[0]\n        ans[u] = min(ans[u], v)\n\n    for i in range(2, N+1):\n        print(ans[i])\n\n\n\ndef main():\n    N, M, S = read_int_n()\n    UVAB = [read_int_n() for _ in range(M)]\n    CD = [read_int_n() for _ in range(N)]\n    (slv(N, M, S, UVAB, CD))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":754,"bad_solution":"def main():\n    nums = list(map(int, input().split()))\n    n, k = nums[0], nums[1]\n    graph = {}\n    out = list(map(int, input().split()))\n    for i in range(n):\n        graph[i + 1] = out[i]\n    \n    cycle_length = None\n    visited = {}\n    ans = None\n\n    def go(x, rem):\n        while rem:\n            x = graph[x]\n            rem -= 1\n        \n        nonlocal ans\n        ans = x\n        return x\n\n    def dfs(i, rem):\n        j = i\n        while rem:\n            if j in visited:\n                nonlocal cycle_length\n                cycle_length = visited[j] - rem\n                steps = rem % cycle_length\n                go(j, steps)\n                return\n            visited[j] = rem\n            rem -= 1\n            j = graph[j]\n\n        return j\n\n    dfs(1, k)\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":755,"bad_solution":"\ndef FUNC(n, m):\n    \"\"\"You are given two positive integers n and m, and your task is to compute the\n    average of the integers from n through m (including n and m). \n    Round the answer to the nearest integer and convert that to binary.\n    If n is greater than m, return -1.\n    Example:\n    FUNC(1, 5) => \"0b11\"\n    FUNC(7, 5) => -1\n    FUNC(10, 20) => \"0b1111\"\n    FUNC(20, 33) => \"0b11010\"\n    \"\"\"\n    if m < n:\n        return -1\n    summation = 0\n    for i in range(n, m+1):\n        summation += i\n    return bin(round(summation\/(m - n)))\n"}
{"id":756,"bad_solution":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians\nfrom itertools import accumulate, permutations, combinations, product, groupby\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom bisect import bisect, bisect_left\nfrom fractions import gcd\nfrom heapq import heappush, heappop\nfrom functools import reduce\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef ZIP(n): return zip(*(MAP() for _ in range(n)))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\nN, A, B, C, D = MAP()\n\nS = input()\n\nif S[A:].count(\"##\") >= 1 or S[B:].count(\"##\") >= 1:\n    print(\"No\")\n    exit()\n\nif C < D:\n    print(\"Yes\")\n    exit()\n\nif S[A:D+1].count(\"...\") >= 1:\n    print(\"Yes\")\nelse:\n    print(\"No\")\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":757,"bad_solution":"import sys\nsys.setrecursionlimit(10**7)\nfrom collections import deque\n\nN = int(input())\nad = [[] for _ in range(N**2)]\nnum = [0] * (N**2)\nfor i in range(N):\n    a = [int(e)-1 for e in input().split()]\n    for k in range(N-2):\n        j = a[k]\n        nj = a[k+1]\n        ti, tj = min(i, j), max(i, j)\n        nti, ntj = min(i, nj), max(i, nj)\n        v = N*ti + tj\n        nv = N*nti + ntj\n        ad[v].append(nv)\n        num[nv] += 1\n\nL = []\nS = deque()\n\nfor v in range(N**2):\n    i, j = divmod(v, N)\n    if i >= j:\n        continue\n    if num[v] == 0:\n        S.append(v)\n\nwhile S:\n    v = S.popleft()\n    L.append(v)\n    for nv in ad[v]:\n        num[nv] -= 1\n        if num[nv] == 0:\n            S.append(nv)\n\nif len(L) != N*(N-1)\/\/2:\n    print(-1)\n    exit()\n\ncand_list = []\n\nvisited = [0] * (N**2)\n\ndef dfs(v):\n    res = 1\n    visited[v] = 1\n    for nv in ad[v]:\n        if not visited[nv]:\n            res = max(res, dfs(nv) + 1)\n    return res\n\nans = dfs(L[0])\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":758,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nimport math\n\ndef solve(N: int, D: int, X: \"List[List[int]]\"):\n\n    count = 0\n    for i in range(0, N - 1):\n        for j in range(i + 1, N):\n            sum = 0\n            for k in range(0, D):\n                sum += (X[i][k] - X[j][k]) ** 2\n            if int(math.sqrt(sum) * 10) % 10 == 0:\n                count += 1\n    print(count)\n\n    return\n\n\n# Generated by 1.1.6 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    D = int(next(tokens))  # type: int\n    X = [[int(next(tokens)) for _ in range(D)] for _ in range(N)]  # type: \"List[List[int]]\"\n    solve(N, D, X)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":759,"bad_solution":"\ndef FUNC(x):\n    \"\"\"Given a list of positive integers x. return a sorted list of all \n    elements that hasn't any even digit.\n\n    Note: Returned list should be sorted in increasing order.\n    \n    For example:\n    >>> FUNC([15, 33, 1422, 1])\n    [1, 15, 33]\n    >>> FUNC([152, 323, 1422, 10])\n    []\n    \"\"\"\n    odd_digit_elements = []\n    for j, i in enumerate(x):\n        if all (int(c) % 2 == 1 for c in str(i)):\n            odd_digit_elements.append(i)\n            odd_digit_elements.append(j)\n    return sorted(odd_digit_elements)\n"}
{"id":760,"bad_solution":"\ndef FUNC(arr):\n    \"\"\"\n    Given an array of integers, sort the integers that are between 1 and 9 inclusive,\n    reverse the resulting array, and then replace each digit by its corresponding name from\n    \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\".\n\n    For example:\n      arr = [2, 1, 1, 4, 5, 8, 2, 3]   \n            -> sort arr -> [1, 1, 2, 2, 3, 4, 5, 8] \n            -> reverse arr -> [8, 5, 4, 3, 2, 2, 1, 1]\n      return [\"Eight\", \"Five\", \"Four\", \"Three\", \"Two\", \"Two\", \"One\", \"One\"]\n    \n      If the array is empty, return an empty array:\n      arr = []\n      return []\n    \n      If the array has any strange number ignore it:\n      arr = [1, -1 , 55] \n            -> sort arr -> [-1, 1, 55]\n            -> reverse arr -> [55, 1, -1]\n      return = ['One']\n    \"\"\"\n    dic = {\n        1: \"One\",\n        2: \"Two\",\n        3: \"Three\",\n        4: \"Four\",\n        5: \"Five\",\n        6: \"Six\",\n        7: \"Seven\",\n        8: \"Eight\",\n        9: \"Nine\",\n    }\n    sorted_arr = sorted(arr)\n    new_arr = []\n    for var in sorted_arr:\n        try:\n            new_arr.append(dic[var])\n        except:\n            pass\n    return new_arr\n"}
{"id":761,"bad_solution":"def solve(n, k, t, d):\n    que = []\n    used = set()\n    base_score = 0\n    for ti, di in sorted(zip(t, d), key=lambda _:-_[1])[:k]:\n        if ti in used:\n            que.append(di)\n        else:\n            used.add(ti)\n        base_score += di\n    num = len(used)\n    score = base_score + num**2\n    best = score\n\n    M = {_:0 for _ in t}\n    for ti, di in zip(t, d):\n        if not ti in used:\n            M[ti] = max(M[ti], di)\n\n    que = sorted(que)\n    for i, p in enumerate(sorted(M.values())[::-1][:len(que)]):\n        base_score += p - que[i]\n        num += 1\n        best = max(best, base_score + num**2)\n    return best\n\nn, k = map(int, input().split())\nt = [0] * n\nd = [0] * n\nfor i in range(n):\n    t[i], d[i] = map(int, input().split())\nprint(solve(n, k, t, d))\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":762,"bad_solution":"#!\/usr\/bin\/env python\n# -*- coding: utf-8 -*-\n\n\nclass Node(object):\n\n  def __init__(self):\n    self.edges = set()\n    self.distance = 1\n\n\ndef main():\n  N = int(input())\n  nodes = [Node() for _ in range(N)]\n\n  if N == 0:\n    print('Second', flush=True)\n    return\n  elif N == 1:\n    print('First', flush=True)\n    return\n\n  for _ in range(N - 1):\n    a, b = map(int, input().split())\n    nodes[a - 1].edges.add(nodes[b - 1])\n    nodes[b - 1].edges.add(nodes[a - 1])\n\n  leaves = [n for n in nodes if len(n.edges) == 1]\n\n  while True:\n    leaf = leaves.pop(0)\n    parent = leaf.edges.pop()\n\n    if len(parent.edges) == 1:\n      size = leaf.distance + parent.distance\n      break\n\n    parent.distance = max(parent.distance, leaf.distance + 1)\n    parent.edges.remove(leaf)\n\n    if len(parent.edges) == 1:\n      leaves.append(parent)\n\n  if size % 3 == 2:\n    print('Second', flush=True)\n  else:\n    print('First', flush=True)\n\n\nif __name__ == '__main__':\n  main()\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":763,"bad_solution":"import sys\nimport random\nsys.setrecursionlimit(10**9)\nINF=10**18\ndef input():\n    return sys.stdin.readline().rstrip()\n\ndef main():\n    N=int(input())\n    d={}\n    c=0\n    edge1=[[] for _ in range(N*(N-1)\/\/2)]\n    edge2=[[] for _ in range(N*(N-1)\/\/2)]\n    for i in range(N):\n        l=list(map(lambda x: int(x)-1,input().split()))\n        prev=-1\n        for x in l:\n            if min(i,x)*10**3+max(i,x) in d:\n                if prev!=-1:\n                    edge1[prev].append(d[min(i,x)*10**3+max(i,x)])\n                    edge2[d[min(i,x)*10**3+max(i,x)]].append(prev)\n            else:\n                d[min(i,x)*10**3+max(i,x)]=c\n                if prev!=-1:\n                    edge1[prev].append(c)\n                    edge2[c].append(prev)\n                c+=1\n            prev=d[min(i,x)*10**3+max(i,x)]\n    stack=[]\n    days=[-1]*(N*(N-1)\/\/2)\n    for i,l in enumerate(edge2):\n        if not l:\n            stack.append(i)\n            days[i]=1\n    for i in range(len(stack)):\n        r=random.randrange(len(stack))\n        stack[i],stack[r]=stack[r],stack[i]\n    if stack:\n        for _ in range(10**7):\n            v=stack.pop()\n            for x in edge1[v]:\n                if days[x]<days[v]+1:\n                    days[x]=days[v]+1\n                    stack.append(x)\n            if not stack:\n                print(max(days))\n                exit()\n    max_days=max(days)\n    if max_days>N*(N-1)\/\/2:\n        print(-1)\n    else:\n        print(max_days)\n        \n\n    \n\n        \nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":764,"bad_solution":"from fractions import gcd\nfrom math import floor\nfrom collections import defaultdict\n\ndef eratosthenes(n):\n    is_prime = [True] * (n + 1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i * 2, n + 1, i):\n            is_prime[j] = False\n    return [i for i in range(n + 1) if is_prime[i]]\n\n\ndef factorize(N):  # 素因数分解\n    prime = set()\n    for p in prime_list:\n        if p * p > N:\n            break\n        while N % p == 0:\n            N \/\/= p\n            prime.add(p)\n    if N > 1:\n        prime.add(N)\n    return prime\n\n\nn = int(input())\na = list(map(int, input().split()))\n\nans = 0\nfor ai in a:\n    ans = gcd(ans, ai)\nif ans != 1:\n    print('not coprime')\n    exit()\n\nprime_list = eratosthenes(10 ** 6)\nnum = set()\n\nclass PrimeFactorization:\n    '''1つの因数分解クエリをO(log(k))で実行する（初期化にO(N))\n    >>> pf = PrimeFactorization(100)\n    >>> pf.query(100)\n    ((2, 2), (5, 2))\n    \n    '''\n    # https:\/\/atcoder.jp\/contests\/abc177\/editorial\/82\n    # 高速素因数分解\n    # 問題： A 以下の数が N 個与えられる。全て素因数分解せよ。\n    # 前計算としてエラトステネスの篩を行い、「その数をふるい落とした素数」を配列 D に記録します。\n    # 例えば D[4]=D[6]=2,D[35]=5 です。x が素数のときは D[x]=x としておきます。この配列はエラトステネスの篩と同様 O(AloglogA) で構築できます。\n    # D[x] は x を割り切る最小の素数なので、この配列 D を利用すると素因数分解を行うときに「試し割り」をする必要がなくなり(D[x]で割ればよい)、1つの数の素因数分解が素因数の個数である O(logA) でできるようになります。\n    from collections import defaultdict\n    def __init__(self, Num=10**6):\n        self.Num = Num\n        self.D = [-1] * (Num+1)\n        for i in range(2, Num+1):\n            if self.D[i] != -1:\n                continue\n            self.D[i] = i\n            for j in range(1, floor(Num\/i)+1):\n                if self.D[j*i] != -1:\n                    continue\n                else:\n                    self.D[j*i] = i\n    \n    def query(self, k):\n        ans = defaultdict(int)\n        tmp = k\n        while self.D[tmp] != -1:\n            div = self.D[tmp]\n            ans[div] += 1\n            tmp = tmp\/\/div\n        return set(ans.keys())\n      \npf = PrimeFactorization(10**6)\nfor ai in a:\n    prime = pf.query(ai)\n    # prime = factorize(ai)\n    if len(prime & num) > 0:\n        print('setwise coprime')\n        break\n    num |= prime\nelse:\n    print('pairwise coprime')\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":765,"bad_solution":"import re\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\nimport functools\ndef s(): return input()\ndef k(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef X(): return list(input())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b\/\/math.gcd(a,b)\nsys.setrecursionlimit(10 ** 9)\nmod = 10**9+7\ncnt = 0\nans = 0\ninf = float(\"inf\")\n\nS = s()\n\nalpha=[\"a\",\"b\",\"c\",\"d\",\"e\",\"f\",\"g\",\"h\",\"i\",\"j\",\"k\",\"l\",\"m\",\"n\",\"o\",\"p\",\"q\",\"r\",\"s\",\"t\",\"u\",\"v\",\"w\",\"x\",\"y\",\"z\"]\np = alpha.copy()\np.reverse()\naa = \"\".join(p)\n\nif S==aa:\n    print(-1)\n    sys.exit()\n\nif len(S) == 26:\n    for i in range(len(S)):\n        if S[i] != alpha[i]:\n            print(S[:i-1]+min(S[i+1:]))\n            sys.exit()\nelse:\n    for i in alpha:\n        if i not in S:\n            print(S+i)\n            sys.exit()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":766,"bad_solution":"import sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 7)\n\ns = input().strip()\n\nimport functools\n\n@functools.lru_cache(maxsize=None)\ndef dfs(start, remain):\n    if len(remain) == 0:\n        return 1\n    else:\n        ans = 0\n        for i in range(1, 3):\n            if start == remain[:i]:\n                continue\n            else:\n                ans = max(ans, 1 + dfs(remain[:i], remain[i:]))\n        return ans\n\n@functools.lru_cache(maxsize=None)\ndef _dfs(s):\n    if len(s) <= 1:\n        return len(s)\n    if len(s) == 2:\n        if s[0] == s[1]:\n            return 1\n        else:\n            return 2\n    if len(s) >= 3:\n        if s[0] == s[1]:\n            return max(1 + _dfs(s[2:]), 2 + _dfs(s[3:]))\n        else:\n            return max(1 + _dfs(s[1:]), 1 + _dfs(s[2:]))\n\nans = 0\nif len(s) == 1:\n    print(ans)\n    sys.exit(0)\nprint(_dfs(s))\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":767,"bad_solution":"\n\n# mo's algorithm\n# offline queryをlについて平方分割、rについてしゃくとり法したもの\nfrom collections import defaultdict\nfrom operator import itemgetter\n\n\nclass Mo:\n    def __init__(self, ls):\n        # データは突っ込んで置きたい\n        from math import sqrt, ceil\n        self.ls = ls.copy()\n        self.n = len(ls)\n        self.b = ceil(sqrt(self.n))  # bukectのサイズ及び個数\n\n    def _init_states(self):\n        ########################################\n        # self.states = None  # その時点における状態(自分で定義しろ) #2つでもいい\n        self.n_unique = 0\n        self.cnt = defaultdict(lambda: 0)\n        ########################################\n\n        # [l,r)の半開区間で考える\n        self.l = 0\n        self.r = 0\n\n        # queryを格納する用\n        self.bucket = [list() for _ in range((self.b + 1))]\n\n    def _add(self, i):\n        # i番目の要素を含めて考えるときへstatesを更新\n        if self.cnt[self.ls[i]] == 0:\n            self.n_unique += 1\n        self.cnt[self.ls[i]] += 1\n\n    def _delete(self, i):\n        # i番目の要素を削除して考えるときへstatesを更新\n        self.cnt[self.ls[i]] -= 1\n        if self.cnt[self.ls[i]] == 0:\n            self.n_unique -= 1\n\n    def _one_process(self, l, r):\n        # クエリ[l,r)に対してstatesを更新する\n        for i in range(self.r, r):  # rまで伸長\n            self._add(i)\n        for i in range(self.r - 1, r - 1, -1):  # rまで短縮\n            self._delete(i)\n        for i in range(self.l, l):  # lまで短縮\n            self._delete(i)\n        for i in range(self.l - 1, l - 1, -1):  # lまで伸長\n            self._add(i)\n\n        self.l = l\n        self.r = r\n\n    def process(self, queries):\n        self._init_states()\n\n        idx = defaultdict(lambda: [])  # queryの順番を記録しておく\n        for i, (l, r) in enumerate(queries):  # queryをbucketに格納\n            idx[l, r].append(i)\n            self.bucket[l \/\/ self.b].append((l, r))\n\n        for i in range(len(self.bucket)):\n            self.bucket[i].sort(key=itemgetter(1))\n\n        ret = [-1] * len(queries)\n        # for b in self.bucket:\n        #     for l, r in b:  # クエリに答えていく\n        #         self._one_process(l, r)\n        #         ########################################\n        #         # クエリに答える作業をここで書く\n        #         ret[idx[l, r].pop()] = self.n_unique\n        #         ########################################\n        return ret\n\n\nimport sys\nsys.setrecursionlimit(1 << 25)\nread = sys.stdin.readline\nra = range\nenu = enumerate\n\n\ndef ints(): return list(map(int, read().split()))\n\n\nN, Q = ints()\nC = ints()\n\nmo = Mo(C)\n\nqueries = []\nfor _ in range(Q):\n    l, r = ints()\n    queries.append((l - 1, r))\nans = mo.process(queries)\nprint('unko')\n# print(*ans, sep='\\n')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":768,"bad_solution":"import sys\n\ninput = sys.stdin.buffer.readline\nn, q = map(int, input().split())\nC = list(map(int, input().split()))\n\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n >> 1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c >> 2) & 0x3333333333333333)\n    c = (c & 0x0F0F0F0F0F0F0F0F) + ((c >> 4) & 0x0F0F0F0F0F0F0F0F)\n    c = (c & 0x00FF00FF00FF00FF) + ((c >> 8) & 0x00FF00FF00FF00FF)\n    c = (c & 0x0000FFFF0000FFFF) + ((c >> 16) & 0x0000FFFF0000FFFF)\n    c = (c & 0x00000000FFFFFFFF) + ((c >> 32) & 0x00000000FFFFFFFF)\n    return c\n\n\nnum = 2 ** ((n - 1).bit_length())\nSEG = [0] * (2 * num)\n\n\ndef func(a, b):\n    return a | b\n\n\nfor idx, val in enumerate(C):\n    idx += num\n    SEG[idx] = 1 << (val - 1)\n    while idx > 0:\n        idx \/\/= 2\n        SEG[idx] = func(SEG[2 * idx], SEG[2 * idx + 1])\n\n\ndef query(left, right):\n    resleft = 0\n    resright = 0\n    left += num\n    right += num\n    while right - left > 0:\n        if left % 2 == 1:\n            resleft = func(resleft, SEG[left])\n            left += 1\n        if right % 2 == 1:\n            right -= 1\n            resright = func(resright, SEG[right])\n        left \/\/= 2\n        right \/\/= 2\n    return func(resleft, resright)\n\n\nfor _ in range(q):\n    l, r = map(int, input().split())\n    temp = query(l - 1, r)\n    print(popcnt(temp))\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":769,"bad_solution":"import math\nfrom functools import reduce\nfrom collections import deque\nimport sys\nsys.setrecursionlimit(10**7)\n\ndef input():\n    return sys.stdin.readline().strip()\n\n# スペース区切りの入力を読み込んで数値リストにして返します。\ndef get_nums_l():\n    return [ int(s) for s in input().split(\" \")]\n\n# 改行区切りの入力をn行読み込んで数値リストにして返します。\ndef get_nums_n(n):\n    return [ int(input()) for _ in range(n)]\n\n# 改行またはスペース区切りの入力をすべて読み込んでイテレータを返します。\ndef get_all_int():\n    return map(int, open(0).read().split())\n\ndef rangeI(it, l, r):\n    for i, e in enumerate(it):\n        if l <= i < r:\n            yield e\n        elif l >= r:\n            break\n\ndef log(*args):\n    print(\"DEBUG:\", *args, file=sys.stderr)\n\nINF = 999999999999999999999999\nMOD = 10**9+7\n\nS = input().split()\na = int(S[0])\nb = float(S[1])\n\nprint(int(a*b))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":770,"bad_solution":"import sys, re, os\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, acos, atan, asin\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\ndef input(): return sys.stdin.readline().strip()\ndef STR(): return input()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef S_MAP(): return map(str, input().split())\ndef LIST(): return list(map(int, input().split()))\ndef S_LIST(): return list(map(str, input().split()))\nsys.setrecursionlimit(10 ** 9)\ninf = sys.maxsize\nmod = 10 ** 9 + 7\n\ns = STR()\nif len(s) < 26:\n    for i in range(26):\n        tmp = chr(i + ord('a'))\n        if not tmp in s:\n            print(s + tmp)\n            exit()\nif len(set(s)) == 26:\n    for i in reversed(range(len(s))):\n        for j in range(ord(s[i]) + 1, ord('z')):\n            if s[i] != 'z' and not chr(j) in s[:i]:\n                print(s[:i] + chr(j))\n                exit()\n    print(-1)\n    exit()\nans = [i for i in s]\nfor i in reversed(range(len(s))):\n    tmp = chr(ans[i] + 1)\n    if not tmp in ans:\n        ans[i] = tmp\n    print(''.join(ans))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":771,"bad_solution":"#!\/usr\/bin\/env python3\n#AGC33 B\n\nimport sys\nimport math\nfrom bisect import bisect_right as br\nfrom bisect import bisect_left as bl\nsys.setrecursionlimit(1000000000)\nfrom heapq import heappush, heappop,heappushpop\nfrom collections import defaultdict\nfrom itertools import accumulate\nfrom collections import Counter\nfrom collections import deque\nfrom operator import itemgetter\nfrom itertools import permutations\nmod = 10**9 + 7\ninf = float('inf')\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\n\nh,w,n = LI()\nsr,sc = LI()\nsr -= 1\nsc -= 1\ns = input()\nt = input()\nleft,right = 0,w\nfor i in range(n)[::-1]:\n    if t[i] == 'R':\n        if left > 0:\n            left -= 1\n    elif t[i] == 'L':\n        if right < w:\n            right += 1\n    if s[i] == 'R':\n        right -= 1\n        if right <= 0:\n            print('NO')\n            quit()\n    elif s[i] == 'L':\n        left += 1\n        if left >= w:\n            print('NO')\n            quit()\ndown,up = 0,h\nfor i in range(n)[::-1]:\n    if t[i] == 'U':\n        if down > 0:\n            down -= 1\n    elif t[i] == 'D':\n        if up < h:\n            up += 1\n    if s[i] == 'U':\n        up -= 1\n        if up <= 0:\n            print('NO')\n            quit()\n    elif s[i] == 'D':\n        down += 1\n        if down >= h:\n            print('NO')\n            quit()\n#print(left,right,down,up)\nif left <= sc <= right and down <= sr <= up:\n    print('YES')\nelse:\n    print('NO')\n            \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":772,"bad_solution":"import sys\nfrom collections import deque\nfrom bisect import bisect_left\ndef input(): return sys.stdin.readline().strip()\n\n\"\"\"\n    全く分からなかったので解説放送の写し。\n        ・マス目に対してもBFSはできるのか！\n        ・(NEW!)座標圧縮という技を使って計算量を削減できるのか\n    あと壁に厚みを持たせて黒マスとして扱えばBFSがしやすくなる\n\"\"\"\n\ndef main():\n    N, M = map(int, input().split())\n    X = set([])\n    Y = set([])\n    mapX = {}  # mapX[x] = (柵の座標xが小さい方から何番目か)\n    mapY = {}  # mapX[y] = (柵の座標yが小さい方から何番目か)\n    horizontal = []\n    vertical = []\n    for _ in range(N):\n        a, b, c = map(int, input().split())\n        X.add(a)\n        X.add(b)\n        Y.add(c)\n        vertical.append((a, b, c))\n    for _ in range(M):\n        d, e, f = map(int, input().split())\n        X.add(d)\n        Y.add(e)\n        Y.add(f)\n        horizontal.append((d, e, f))\n    X = list(X)\n    Y =list(Y)\n    X.sort()\n    Y.sort()\n\n    # 座標圧縮とはすなわち左（下）から何番目かを求めることに他ならない\n    for i, x in enumerate(X):\n        mapX[x] = i\n    for i, y in enumerate(Y):\n        mapY[y] = i\n\n    # 圧縮後の座標平面に対してグリッドを張るので、そのサイズを求めておく\n    # 柵は偶数マス目に乗るようにするので２倍しておく\n    h = len(mapX) * 2\n    w = len(mapY) * 2\n\n    # グリッド作成、柵部分は-1の値を入れたブロックとして扱う\n    # また偶数グリッドは面積0として扱う\n    grid = [[0] * w for _ in range(h)]\n    for i in range(N):\n        a = mapX[vertical[i][0]] * 2\n        b = mapX[vertical[i][1]] * 2\n        c = mapY[vertical[i][2]] * 2\n        for x in range(a, b + 1): grid[x][c] = -1\n    for j in range(M):\n        d = mapX[horizontal[j][0]] * 2\n        e = mapY[horizontal[j][1]] * 2\n        f = mapY[horizontal[j][2]] * 2\n        for y in range(e, f + 1): grid[d][y] = -1\n    \n    # BFSをする前に、スタート地点が柵単位で数えたためにもはや(0, 0)ではなくなっているため、\n    # まずは開始位置を二分探索で求めておく\n    start_x = bisect_left(X, 0) * 2 - 1\n    start_y = bisect_left(Y, 0) * 2 - 1\n    if start_x < 0 or start_y < 0 or start_x >= h \/\/ 2 or start_y >= w \/\/ 2:\n        print(\"INF\")\n        return\n    grid[start_x][start_y] = 1\n\n    # BFS\n    q = deque([(start_x, start_y)]) # 進入可能な領域がqには入る\n    ans = 0\n    while q:\n        x, y = q.popleft()\n        ans += (X[x \/\/ 2 + 1] - X[x \/\/ 2]) * (Y[y \/\/ 2 + 1] - Y[y \/\/ 2])\n        for xx, yy in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\n            nx, ny = x + xx, y + yy\n            if nx < 0 or ny < 0 or nx >= h or ny >= w:\n                print(\"INF\")\n                return\n            if grid[nx][ny] == -1: continue\n            nnx, nny = nx + xx, ny + yy\n            if nnx < 0 or nny < 0 or nnx >= h or nny >= w:\n                print(\"INF\")\n                return\n            if grid[nnx][nny] != 0: continue\n            grid[nnx][nny] = 1\n            q.append((nnx, nny))\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":773,"bad_solution":"def is_symmetric(N, board):\n    for i in range(N):\n        for j in range(N):\n            if board[i][j] != board[j][i]:\n                return False\n    return True\n\n\ndef generate_board(N, board, a, b):\n    new = []\n    for i in range(N):\n        new.append([None for i in range(N)])\n\n    for i in range(N):\n        for j in range(N):\n            new[(i + a) % N][(j + b) % N] = board[i][j]\n\n    return new\n\n\ndef solve(N, board):\n    ans = 0\n    for i in range(2*N - 1):\n        if i < N:\n            if is_symmetric(N, generate_board(N, board, 0, i)):\n                ans += i + 1\n        else:\n            if is_symmetric(N, generate_board(N, board, 0, i)):\n                ans += 2*N - 1 - i\n    return ans\n\n\nN = int(input())\nboard = []\nfor i in range(N):\n    board.append([j for j in input()])\n\n\nprint(int(solve(N, board)))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":774,"bad_solution":"#!\/usr\/bin\/env python3\n\n\ndef solve(H, W, S):\n    grid = [[0] * W for _ in range(H)]\n    for y in range(H):\n        count = 0\n        start = 0\n        for x in range(W):\n            if S[y][x] == '#':\n                for i in range(start, x):\n                    grid[y][i] = count\n                start = x + 1\n                count = 0\n            else:\n                count += 1\n        for i in range(start, W):\n            grid[y][i] = count\n\n    ans = 0\n    for x in range(W):\n        count = 0\n        start = 0\n        for y in range(H):\n            if S[y][x] == '#':\n                for i in range(start, y):\n                    grid[i][x] += count\n                start = y + 1\n                count = 0\n            else:\n                count += 1\n        for i in range(start, H):\n            if ans < grid[i][x] + count:\n                ans = grid[i][x] + count\n\n    return ans - 1\n\n\nif __name__ == '__main__':\n    H, W = map(int, input().split())\n    S = [input().strip() for _ in range(H)]\n\n    ans = solve(H, W, S)\n\n    print(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":775,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nimport math\n\ndef solve(A: int, B: int, N: int):\n    result1 = int(A*(B-1)\/B) - A * int((B-1) \/ B)\n    result2 = int(A*N\/B) - A*int(N\/B)\n    print(min(result1, result2))\n    return\n\n\n# Generated by 1.1.6 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    A = int(next(tokens))  # type: int\n    B = int(next(tokens))  # type: int\n    N = int(next(tokens))  # type: int\n    solve(A, B, N)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":776,"bad_solution":"def survey(A, B, Ai, Bi, AMax, BMax, answer, reqTime, K):\n    if(reqTime > K):\n        return answer - 1\n    else:\n        if(Ai == AMax and Bi == BMax):\n            return answer\n        elif(Ai == AMax):\n            return survey(A, B, Ai, Bi + 1, AMax, BMax, answer + 1, reqTime + B[Bi], K)\n        elif(Bi == BMax):\n            return survey(A, B, Ai + 1, Bi, AMax, BMax, answer + 1, reqTime + A[Ai], K)\n        else:\n            return max(survey(A, B, Ai + 1, Bi, AMax, BMax, answer + 1, reqTime + A[Ai], K), survey(A, B, Ai, Bi + 1, AMax, BMax, answer + 1, reqTime + B[Bi], K))\n        \ndef main():\n    N, M, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n\n    A = A\n    B = B\n\n    AMax = len(A)\n    BMax = len(B)\n\n    answer = 0\n    reqTime = 0\n\n    Ai = 0\n    Bi = 0\n\n    answer = survey(A, B, Ai, Bi, AMax, BMax, answer, reqTime, K)\n    print(answer)\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":777,"bad_solution":"\n\nimport sys\nimport math\nfrom bisect import bisect_right\ndef main():\n    N,M = map(int,input().split())\n    Marray=[(0,0)] * M\n    P={}\n    for i in range(M):\n        s = input().split()\n        p=int(s[0])\n        y=s[1]\n        #print(s)\n        if p in P.keys():\n            P[p]+=y+\",\"\n        else:\n            P[p]=y+\",\"\n        Marray[i]=(p,int(y))\n        #print(P[p])\n        \n    for key in P:\n        string=P[key]\n        \n       # print(str)\n        sp=string.split(\",\")\n        de=len(sp)-1\n        del sp[de]\n        #print(sp)\n        tmp=sorted(sp,key=int)\n        P[key]=tmp\n        \n        #print(P[key])\n    \n    for index,value in Marray:\n        list=P[index]\n        list = [int(s) for s in list]\n        #print(list)\n        result=bisect_right(list,value)\n        result=str(result)\n        index=str(index)\n        index_zero = index.zfill(6)\n        result_zero = result.zfill(6)\n        print(index_zero,result_zero,sep='')\n\n\n\n\n\n\n\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":778,"bad_solution":"\ndeFUNC FUNC(n):\n    \"\"\" Implement the FUNCunction FUNC that takes n as a parameter,\n    and returns a list oFUNC size n, such that the value oFUNC the element at index i is the FUNCactorial oFUNC i iFUNC i is even\n    or the sum oFUNC numbers FUNCrom 1 to i otherwise.\n    i starts FUNCrom 1.\n    the FUNCactorial oFUNC i is the multiplication oFUNC the numbers FUNCrom 1 to i (1 * 2 * ... * i).\n    Example:\n    FUNC(5) == [1, 2, 6, 24, 15]\n    \"\"\"\n    ret = []\n    FUNCor i in range(1,n+1):\n        iFUNC i%2 == 0:\n            x = 1\n            FUNCor j in range(1,i+1): x *= i\n            ret += [x]\n        else:\n            x = 0\n            FUNCor j in range(1,i+1): x += j\n            ret += [x]\n    return ret\n"}
{"id":779,"bad_solution":"# -*- coding: utf-8 -*-\n\nimport queue\n\ndef main():\n     n = int(input())\n     s = input()\n\n     r_list = []\n     g_list = []\n     b_list = []\n\n     ans = 0\n\n     for i in range(n):\n          if s[i] == 'R':\n               r_list.append(i)\n          elif s[i] == 'G':\n               g_list.append(i)\n          else:\n               b_list.append(i)\n\n     for i in range(n):\n          if s[i] == 'R':\n               spot = r_list.pop(0)\n               ans += check(spot, g_list, b_list)\n\n          if s[i] == 'G':\n               spot = g_list.pop(0)\n               ans += check(spot, r_list, b_list)\n\n          if s[i] == 'B':\n               spot = b_list.pop(0)\n               ans += check(spot, r_list, g_list)\n\n     print(ans)\n\ndef check(spot, first, second):\n     ret = 0\n     limit_first = first.copy()\n     limit_second = second.copy()\n     for f in first:\n          ignore = f + (f - spot)\n          limit_second = [s for s in limit_second if s > f]\n\n          ret += len(limit_second)\n          if ignore in limit_second:\n               ret += -1\n\n     for s in second:\n          ignore = s + (s - spot)\n          limit_first = [f for f in limit_first if f > s]\n\n          ret += len(limit_first)\n          if ignore in limit_first:\n               ret += -1\n     \n     return ret\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":780,"bad_solution":"#素因数分解\ndef Prime_Factorization(N):\n    if N<0:\n        R=[[-1,1]]\n    else:\n        R=[]\n\n    N=abs(N)\n    k=2\n    while k*k<=N:\n        if N%k==0:\n            C=0\n            while N%k==0:\n                C+=1\n                N\/\/=k\n            R.append([k,C])\n        k+=1\n\n    if N!=1:\n        R.append([N,1])\n    if not R:\n        R.append([N,1])\n\n    return R\n#================================================\nfrom math import gcd\nN=int(input())\nA=list(map(int,input().split()))\n\n#Pairwise?\nP=set()\nF=True\nfor a in A:\n    K=Prime_Factorization(a)\n    for (p,_) in K:\n        if p in P:\n            F=False\n            break\n        else:\n            P.add(p)\n\n    if not F:\n        break\n\nif F:\n    print(\"pairwise coprime\")\n    exit()\n\n#Setwise?\ng=A[0]\nfor a in A:\n    g=gcd(g,a)\n\nif g==1:\n    print(1\/0)\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":781,"bad_solution":"from functools import reduce\nimport math\ndef xgcd(a, b):\n    x0, y0, x1, y1 = 1, 0, 0, 1\n    while b != 0:\n        q, a, b = a \/\/ b, b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return a, x0, y0\ndef modinv(a, m):\n    g, x, y = xgcd(a, m)\n    return x % m\ndef modmul(a,b):\n    return a * b % 998244353\ndef comb(n,r):\n    r = min(n-r,r)\n    if r == 0: return 1\n    over = reduce(modmul, range(n, n - r, -1))\n    under = reduce(modmul, range(1,r + 1))\n    return over * modinv(under, 998244353)\ndef mempow(a,b):\n    temp = 1\n    yield temp\n    for i in range(b):\n        temp = temp * a % 998244353\n        yield temp\n\nN,M,K = (int(x) for x in input().split())\nmem = []\nmappend = mem.append\nfor x in mempow(M-1,N-1):\n    mappend(x)\nans = 0\nif M == 1:\n    if K + 1 < N:\n        print('0')\n    else:\n        print('1')\nelse:\n    for i in range(K+1):\n        ans = (ans + (comb(N-1,i)*M*pow(M-1,N-i-1,998244353))) % 998244353\n    print(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":782,"bad_solution":"\ndef FUNC(n):\n    \"\"\"\n    Given a positive integer n, return a tuple that has the number of even and odd\n    integer palindromes that fall within the range(1, n), inclusive.\n\n    Example 1:\n\n        Input: 3\n        Output: (1, 2)\n        Explanation:\n        Integer palindrome are 1, 2, 3. one of them is even, and two of them are odd.\n\n    Example 2:\n\n        Input: 12\n        Output: (4, 6)\n        Explanation:\n        Integer palindrome are 1, 2, 3, 4, 5, 6, 7, 8, 9, 11. four of them are even, and 6 of them are odd.\n\n    Note:\n        1. 1 <= n <= 10^3\n        2. returned tuple has the number of even and odd integer palindromes respectively.\n    \"\"\"\n    def FUNC(n):\n        return str(n) == str(n)[::-1]\n\n    even_palindrome_count = 0\n    odd_palindrome_count = 0\n\n    for i in range(1, n):\n        if i%2 == 1 and FUNC(i):\n                odd_palindrome_count += 1\n        elif i%2 == 0 and FUNC(i):\n            even_palindrome_count += 1\n    return (even_palindrome_count, odd_palindrome_count)\n"}
{"id":783,"bad_solution":"def cin():  return list(map(int,input().split()))\n\nN, K = cin()\nA = cin()\n\ndp = [[-1 for _ in range(2)] for _ in range(100)]\ndp[0][0] = 0\nMAX_DIGIT = 50\n\nfor i in range(1, MAX_DIGIT):\n    mask = (1 << (MAX_DIGIT - i - 1))\n    cnt = 0\n    for j in range(N):  cnt += bool(A[j] & mask)\n    cost0 = mask * cnt\n    cost1 = mask * (N - cnt)\n    if(dp[i - 1][1] != -1):  dp[i][1] = max(dp[i][1], dp[i - 1][1] + max(cost0, cost1))\n    if(dp[i - 1][0] != -1):\n        if(K & mask):  dp[i][1] = max(dp[i][1], dp[i - 1][0] + cost0)\n        if(K & mask):  dp[i][0] = max(dp[i][0], dp[i - 1][0] + cost1)\n        else:  dp[i][0] = max(dp[i][0], dp[i - 1][0] + cost0)\n        \nans = max(dp[MAX_DIGHT - 1][0], dp[MAX_DIGHT - 1][1])\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":784,"bad_solution":"from math import sqrt\nfrom itertools import product\nimport sys\n\nn = int(input())\np = []\ndef factorization(arg):\n    while arg % 2 == 0:\n        p.append(2)\n        arg \/\/= 2\n    for i in range(3, int(sqrt(arg)) + 1, 2):\n        while arg % i == 0:\n            p.append(i)\n            arg \/\/= i\n    if arg > 1:\n        p.append(arg)\nif n == 1:\n    print(1)\nelse:\n    factorization(n)\n    min = sys.maxsize\n    for bit in range(2 ** len(p)):\n        a = 1\n        b = 1\n        for i in range(len(p)):\n            if ((bit >> i) & 1):\n                a *= p[i]\n            else:\n                b *= p[i]\n        if min > a and a >= b:\n            min = a\n        elif min > b and b > a:\n            min = b\n    print(len(str(min)))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":785,"bad_solution":"import sys, re\nfrom collections import deque, defaultdict, Counter\nfrom math import ceil, sqrt, hypot, factorial, pi, sin, cos, radians, atan, degrees\nfrom itertools import permutations, combinations, product, accumulate\nfrom operator import itemgetter, mul\nfrom copy import deepcopy\nfrom string import ascii_lowercase, ascii_uppercase, digits\nfrom fractions import gcd\nfrom bisect import bisect\nimport heapq\n\ndef input(): return sys.stdin.readline().strip()\ndef INT(): return int(input())\ndef MAP(): return map(int, input().split())\ndef LIST(): return list(map(int, input().split()))\nsys.setrecursionlimit(10 ** 9)\nINF = float('inf')\nmod = 10 ** 9 + 7\n\ndef main():\n\tN, K = MAP()\n\tA = LIST()\n\tF = LIST()\n\n\tA.sort(reverse=True)\n\tF.sort()\n\n\ttime = [A[i]*F[i] for i in range(N)]\n\t# print(F)\n\t# print(time)\n\n\tsum_A = sum(A)\n\n\tdef is_ok(x):  # 時間をx以下にできるか？\n\t\ttmp = [0]*N\n\t\tfor i in range(N):\n\t\t\ttmp[i] = min(A[i], x\/\/F[i])\n\t\treturn sum_A - sum(tmp) <= K\n\n\tmin_ = -1\n\tmax_ = 10**18\n\twhile min_ + 1 != max_:\n\t\tsearch = (min_+max_)\/\/2\n\t\t# print(min_, max_, search)\n\t\tif is_ok(search):\n\t\t\tmax_ = search\n\t\telse:\n\t\t\tmin_ = search\n\n\tprint(max_)\n\n\nif __name__ == \"__main__\":\n\tmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":786,"bad_solution":"import sys,queue,math,copy,itertools,bisect,collections,heapq\n\ndef main():\n    sys.setrecursionlimit(10**7)\n    INF = 10**18\n    MOD = 10**9 + 7\n    LI = lambda : [int(x) for x in sys.stdin.readline().split()]\n    _LI = lambda : [int(x)-1 for x in sys.stdin.readline().split()]\n    NI = lambda : int(sys.stdin.readline())\n    SI = lambda : sys.stdin.readline().rstrip()\n\n    x,k,d = LI()\n    s = abs(x) \/\/ x\n    c = abs(x) \/\/ d\n\n    ans = 0\n    if c >= k:\n        ans = x - d * k * s\n    else:\n        ans = x - d * c * s\n        if (k-c) % 2 == 1:\n            ans = ans - d * s\n    print(abs(ans))\nif __name__ == '__main__':\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":787,"bad_solution":"\ndef FUNC(arr):\n    \"\"\"\n    Write a function FUNC which takes an array of integers and returns\n    the number of elements which has a sum of digits > 0.\n    If a number is negative, then its first signed digit will be negative:\n    e.g. -123 has signed digits -1, 2, and 3.\n    >>> FUNC([]) == 0\n    >>> FUNC([-1, 11, -11]) == 1\n    >>> FUNC([1, 1, 2]) == 3\n    \"\"\"\n    def FUNC(n):\n        neg = 1\n        if n < 0: n, neg = -1 * n, -1 \n        n = [int(i) for i in str(n)]\n        n[0] = n[0] * neg * -1\n        return sum(n)\n    return len(list(filter(lambda x: x > 0, [FUNC(i) for i in arr])))\n"}
{"id":788,"bad_solution":"import sys\nimport math\n\n\nN_MAX = 200000 + 5\nINF = 10**9 + 7\nsys.setrecursionlimit(N_MAX)\nMOD = 10**9 + 7\n\n\ndef main():\n    N = int(sys.stdin.readline().rstrip())\n    A = [int(x) for x in sys.stdin.readline().rstrip().split()]\n\n    maxA = max(A)\n\n    # 1 <= a <= maxA までの、要素の登場回数\n    C = [0] * (maxA + 1)\n    for a in A:\n        C[a] += 1\n\n    pc = True\n\n    # p の倍数である個数をカウントする\n    for p in range(2, maxA + 1):\n        cnt = 0\n        for k in range(maxA \/\/ p + 1):\n            cnt += C[k * p]\n\n        # k*p となるような要素が2個以上あったら、pairwise coprime ではない\n        if cnt > 1:\n            pc = False\n\n    if pc:\n        print(\"pairwise coprime\")\n        return\n\n    GCD = A[0]\n    for i in range(1, N):\n        GCD = math.gcd(GCD, A[i])\n\n    if GCD == 1:\n        print(\"setwise coprime\")\n        return\n\n    print(\"no coprime\")\n\n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":789,"bad_solution":"from collections import Counter\nN = int(input())\nA = list(map(int,input().split()))\n\nprimes = []\ndef primeFinder(n):\n    memo = [1]*(n+1)\n    memo[0] = 0\n    memo[1] = 0\n    for i in range(2,n+1):\n        if memo[i] == 1:\n            primes.append(i)\n            for j in range(i*2,n+1,i):\n                memo[j] = 0\n\nprimeFinder(10**6)\nprimeNums = primes\n\"\"\"\n各Aiに関して素因数を算出。素因数を集計してカウントが2つある素因数がなければpairwise\n\"\"\"\ncount = Counter([])\nfor i in range(N):\n    tmp = []\n    a = A[i]\n    i = 0\n    while a != 1:\n        d = primeNums[i]\n        if a % d == 0:\n            tmp.append(d)\n        while a % d == 0:\n            a \/\/= d\n        i += 1\n    count += Counter(tmp)\n\nfor v in count.values():\n    if v >= 2:\n        break\nelse:\n    print(\"pairwise coprime\")\n    exit()\n\ndef gcd(a,b):\n    return a if b==0 else gcd(b,a%b)\n\n#setwise coprimeを判断\ng = A[0]\nfor i in range(1,N):\n    g = gcd(g,A[i])\nif g == 1:\n    print(\"setwise coprime\")\nelse:\n    print(\"not coprime\")\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":790,"bad_solution":"H,W = map(int,input().split())\nCh,Cw = map(int,input().split())\nDh,Dw = map(int,input().split())\ngrid = \"\"\nfor i in range(H):\n    grid += input()\ngrid = list(grid)\n\ndef convert_1d_to_2d(l, cols):\n    return [l[i:i + cols] for i in range(0, len(l), cols)]\n\ngrid = convert_1d_to_2d(grid, W)\n\nans = [[1000000]*W for i in range(H)]\nans[Ch-1][Cw-1]=0\n\nfrom collections import deque\n\nque = deque([[Ch-1,Cw-1]])\nwhile que:\n    x,y=que.popleft()\n    for i,j in [(1,0),(0,1),(-1,0),(0,-1)]:\n        nextx,nexty=x+i,y+j\n        check = ans[x][y]\n        \n        if nextx>=0 and nexty>=0 and nextx<=H-1 and nexty<=W-1:\n            dist=grid[nextx][nexty]\n            if dist!='#':\n                if check<ans[nextx][nexty]:\n                    ans[nextx][nexty]=check\n                    que.append([nextx,nexty])\n                    \n    for i,j in [(2,2),(2,1),(2,0),(2,-1),(2,-2),(1,2),(1,1),(1,-1),(1,-2),(0,2),(0,-2),(-2,2),(-2,1),(-2,0),(-2,-1),(-2,-2),(-1,2),(-1,1),(-1,-1),(-1,-2)]:\n        nextx,nexty=x+i,y+j\n        check = ans[x][y]+1\n        \n        if nextx>=0 and nexty>=0 and nextx<=H-1 and nexty<=W-1:\n            dist=grid[nextx][nexty]\n            if dist!='#':\n                if check<ans[nextx][nexty]:\n                    ans[nextx][nexty]=check\n                    que.append([nextx,nexty])\n                    \nif ans[Dh-1][Dw-1]==1000000:\n    print(\"-1\")\nelse:\n    print(ans[Dh-1][Dw-1])\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":791,"bad_solution":"# 同じ種類だと、点数が高いやつを選ぶ\n# 違う種類を選ぶと、ボーナス点が入るので、それをどうするか\n# d  = sum(di) + x**x\n# 種類xを固定すると？ O(log(N))でいける？\n# ※※ 種類が増えるかどうかを降順で見ながらboolで置き換えるという発想。強い。\n\nfrom collections import defaultdict\n\ndi = defaultdict(list)\nn, k = map(int, input().split())\n\nsushi = []\nkinds = []\nfor i in range(n):\n    t,d = map(int, input().split())\n    sushi.append((d,t))\n    kinds.append(t)\nsushi.sort(reverse=True)\nsushidict = defaultdict(int)\nn_kind_all = len(set(kinds))\n\ncnt = 0\nimport heapq\nsushiq = []\n# まずは上からK個貪欲に取る\nfor i in range(k):\n    d,t = sushi[i]\n    heapq.heappush(sushiq,(d,t)) \n    sushidict[t] += 1\n    cnt += d\n\nn_kind = len(sushidict)\nres = []\nres.append(cnt+n_kind**2)\n\nfor i in range(k,n):\n    d,t = sushi[i]\n    # すでにある種類の場合は大丈夫\n    if sushidict[t] > 0 : continue\n    # 種類が増える時、小さいものから入れ替えていく\n    d_min,t_min = heapq.heappop(sushiq)\n    # popして消えるようなものはNG\n    while sushidict[t_min] == 1:\n        d_min, t_min = heapq.heappop(sushiq)\n    sushidict[t_min] -= 1\n    sushidict[t] += 1\n    n_kind += 1\n    cnt  = cnt - d_min + d\n    res.append(cnt+n_kind**2)\n    if n_kind == n_kind_all:\n        break\n\nprint(max(res))\n# print(res)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":792,"bad_solution":"\ndef FUNC(arr):\n    \"\"\"We have an array 'arr' of N integers arr[1], arr[2], ..., arr[N].The\n    numbers in the array will be randomly ordered. Your task is to determine if\n    it is possible to get an array sorted in non-decreasing order by performing \n    the following operation on the given array:\n        You are allowed to perform right shift operation any number of times.\n    \n    One right shift operation means shifting all elements of the array by one\n    position in the right direction. The last element of the array will be moved to\n    the starting position in the array i.e. 0th index. \n\n    If it is possible to obtain the sorted array by performing the above operation\n    then return True else return False.\n    If the given array is empty then return True.\n\n    Note: The given list is guaranteed to have unique elements.\n\n    For Example:\n    \n    FUNC([3, 4, 5, 1, 2])==>True\n    Explanation: By performin 2 right shift operations, non-decreasing order can\n                 be achieved for the given array.\n    FUNC([3, 5, 4, 1, 2])==>False\n    Explanation:It is not possible to get non-decreasing order for the given\n                array by performing any number of right shift operations.\n                \n    \"\"\"\n    if len(arr)==0:\n      return True\n    sorted_array=sorted(arr)\n    my_arr=[]\n    \n    min_value=min(arr)\n    min_index=sorted_array.index(min_value)\n    my_arr=arr[min_index:]+arr[0:min_index]\n    for i in range(len(arr)):\n      if my_arr[i]!=sorted_array[i]:\n        return False\n    return True\n"}
{"id":793,"bad_solution":"\n\nimport math\n#素数列挙\ndef get_primes(limit):\n    A = [i for i in range(2, limit+1)]\n    P = []\n    time = 0\n    \n    while True:\n        prime = min(A)\n        \n        if prime > math.sqrt(limit):\n            break\n            \n        P.append(prime)\n            \n        i = 0\n        while i < len(A):\n            if A[i] % prime == 0:\n                A.pop(i)\n                continue\n            i += 1\n            \n    for a in A:\n        P.append(a)\n            \n    return P\n\n\ndef resolve():\n    N = int(input())\n    A = list(map(int,input().split()))\n    sosus = set(get_primes(max(A)+1))\n    dvd = set()\n\n\n\n\n\n\n    for i in A:\n        tmp=[]\n        for j in sosus:\n            if i % j ==0:\n                tmp.append(j)\n                while i % j ==0:\n                    i \/\/=j\n            if i ==1:\n                break\n        sosus.difference_update(tmp)\n        \n        if i != 1:\n            break\n    else:\n        print('pairwise coprime')\n        return\n\n    val = A[0]\n    for i in A:\n        val = math.gcd(i,val)\n\n    if val ==1:\n        print('setwise coprime')\n    else:\n        print('not coprime')\n\nresolve()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":794,"bad_solution":"from heapq import heapify, heappop, heappush\nINF = 1e7\n\nH,W=map(int, input().split())\nch, cw = map(int, input().split())\ndh, dw = map(int, input().split())\n\nS = [input() for _ in range(H)]\n\nD = [[INF]*(W) for _ in range(H)] #始点からの距離(重み)\ndef dijkstra(sx, sy):\n    # Color = [[0]*(W) for _ in range(H)] # 0: 未訪問 1: Seen 2: Visited\n    # P = [None]*N #親\n\n    D[sx][sy] = 0\n    # P[s] = None\n    # PQ = PriorityQueue([(0, sx, sy)]) #(Cost, Node)を格納し、PQにする。\n    PQ = [(0, sx, sy)]\n    heapify(PQ)\n    while PQ: # PQに候補がある限り\n        min_cost, ux, uy = heappop(PQ) # 最小コストなノードu\n        for dx in range(-2, 3):\n            for dy in range(-2, 3):\n                xx, yy = ux+dx, uy+dy\n                if 0 <= xx < H and 0 <= yy < W and S[xx][yy]==\".\":\n                    is_not_neighbor = int(abs(dx) + abs(dy) != 1)\n                    # neighborでなければコストが1増える\n                    if D[ux][uy] + is_not_neighbor < D[xx][yy]:\n                        D[xx][yy] = D[ux][uy] + is_not_neighbor\n                        heappush(PQ, (D[xx][yy], xx, yy))\n    \n\ndijkstra(ch-1, cw-1)\nif D[dh-1][dw-1] >= INF:\n    print(-1)\nelse:\n    print(D[dh-1][dw-1])\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":795,"bad_solution":"\ndef FUNC(lst1, lst2):\n    \"\"\"In this problem, you will implement a function that takes two lists of numbers,\n    and determines whether it is possible to perform an FUNC of elements\n    between them to make lst1 a list of only even numbers.\n    There is no limit on the number of FUNCd elements between lst1 and lst2.\n    If it is possible to FUNC elements between the lst1 and lst2 to make\n    all the elements of lst1 to be even, return \"YES\".\n    Otherwise, return \"NO\".\n    For example:\n    FUNC([1, 2, 3, 4], [1, 2, 3, 4]) => \"YES\"\n    FUNC([1, 2, 3, 4], [1, 5, 3, 4]) => \"NO\"\n    It is assumed that the input lists will be non-empty.\n    \"\"\"\n    odd = 0\n    even = 0\n    for i in lst1:\n        if i%2 == 1:\n            even -= 1\n    for i in lst2:\n        if i%2 == 0:\n            odd += 1\n    if even >= odd:\n        return \"YES\"\n    return \"NO\"\n            \n"}
{"id":796,"bad_solution":"from __future__ import print_function\n\nfrom functools import reduce\nfrom operator import mul\nfrom collections import Counter\nfrom collections import deque\nfrom itertools import accumulate\nfrom queue import Queue\nfrom queue import PriorityQueue as pq\nfrom heapq import heapreplace\nfrom heapq import heapify\nfrom heapq import heappushpop\nfrom heapq import heappop\nfrom heapq import heappush\nimport heapq\nimport time\nimport random\nimport bisect\nimport itertools\nimport collections\nfrom fractions import Fraction\nimport fractions\nimport string\nimport math\nimport operator\nimport functools\nimport copy\nimport array\nimport re\nimport sys\nsys.setrecursionlimit(500000)\n\n\ninput = sys.stdin.readline\n\n\ndef eprint(*args, **kwargs):\n    print(*args, file=sys.stderr, **kwargs)\n    return\n\n# from fractions import gcd\n# from math import gcd\n\n# def lcm(n, m):\n#     return int(n * m \/ gcd(n, m))\n\n\n# def coprimize(p, q):\n#     common = gcd(p, q)\n#     return (p \/\/ common, q \/\/ common)\n\n\n# def find_gcd(list_l):\n#     x = reduce(gcd, list_l)\n#     return x\n\n\ndef combinations_count(n, r):\n    r = min(r, n - r)\n    numer = reduce(mul, range(n, n - r, -1), 1)\n    denom = reduce(mul, range(1, r + 1), 1)\n    return numer \/\/ denom\n\n\nmod = 1000000007\n\n\ndef combinations_count_mod(n, r):\n    r = min(r, n - r)\n    numer = reduce(lambda x, y: x * y % mod, range(n, n - r, -1), 1)\n    denom = pow(reduce(lambda x, y: x * y % mod, range(1, r + 1), 1), mod - 2, mod)\n    return numer * denom % mod\n\n\ndef solve():\n    pass\n\n\ndef main():\n    n = int(input().strip())\n    L = []\n    Xmin = sys.maxsize\n    Ymin = sys.maxsize\n    Xmax = -100\n    Ymax = -100\n    for i in range(n):\n        a, b = map(int, input().strip().split())\n        L.append((a, b))\n        Xmin = min(Xmin, a)\n        Ymin = min(Ymin, b)\n        Xmax = max(Xmax, b)\n        Ymax = max(Ymax, b)\n\n    A = (Xmin, Ymax)\n    B = (Xmin, Ymin)\n    C = (Xmax, Ymin)\n    D = (Xmax, Ymax)\n\n    # AC\n    d_MinDistFromA = sys.maxsize\n    for a, b in L:\n        d_MinDistFromA = min(d_MinDistFromA, abs(a - Xmin) + abs(b - Ymax))\n\n    d_MinDistFromC = sys.maxsize\n    for a, b in L:\n        d_MinDistFromC = min(d_MinDistFromC, abs(a - Xmin) + abs(b - Ymax))\n    ans1 = abs(A[0] - C[0]) + abs(A[1] - C[1]) - (d_MinDistFromA + d_MinDistFromC)\n\n    #\n    d_MinDistFromB = sys.maxsize\n    for a, b in L:\n        d_MinDistFromB = min(d_MinDistFromB, abs(a - Xmin) + abs(b - Ymax))\n\n    d_MinDistFromD = sys.maxsize\n    for a, b in L:\n        d_MinDistFromD = min(d_MinDistFromD, abs(a - Xmin) + abs(b - Ymax))\n    ans2 = abs(B[0] - D[0]) + abs(B[1] - D[1]) - (d_MinDistFromB + d_MinDistFromD)\n\n    print(max(ans1, ans2))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":797,"bad_solution":"import sys\nsys.setrecursionlimit(1000000000)\nimport math\nfrom fractions import gcd\nfrom itertools import count, permutations\nfrom functools import lru_cache\nfrom collections import deque, defaultdict\nfrom pprint import pprint\nii = lambda: int(input())\nmis = lambda: map(int, input().split())\nlmis = lambda: list(mis())\nINF = float('inf')\nN1097 = 10**9 + 7\n\ndef meg(f, ok, ng):\n    while abs(ok-ng)>1:\n        mid = (ok+ng)\/\/2\n        if f(mid):\n            ok=mid\n        else:\n            ng=mid\n    return ok\n#\n\ndef main():\n    H,N=mis()\n    AB = [lmis() for _ in range(N)]\n    @lru_cache(maxsize=None)\n    def rec(h):\n        if h <= 0:\n            return 0\n        return min(rec(h-a)+b for a, b in AB)\n    print(rec(H))\n\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":798,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict\nimport math\ndef LI(): return list(map(int, input().split()))\ndef II(): return int(input())\ndef LS(): return input().split()\ndef S(): return input()\ndef IIR(n): return [II() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\nmod = 1000000007\n\n#A\n\"\"\"\nt,x = LI()\nprint(t\/x)\n\"\"\"\n\n#B\n\"\"\"\nn= II()\na = LI()\nm = max(a)\nif m >= sum(a)-m:\n    print(\"No\")\nelse:\n    print(\"Yes\")\n\"\"\"\n\n#C\n\"\"\"\nn,m = LI()\nx = LI()\nx.sort()\nl = [x[i+1]-x[i] for i in range(m-1)]\nl.sort()\nl = l[::-1]\nans = sum(l[max(n-1,0):])\nprint(ans)\n\"\"\"\n\n#D\nn,k = LI()\na = LI()\nl = 0\nb = [0 for i in range(n)]\nfor i in range(n):\n    b[i] = list(bin(a[i]))[2:]\n    l = max(l,len(b[i]))\ns = [0 for i in range(l)]\nfor i in range(n):\n    for j in range(l-len(b[i])):\n        b[i].insert(0,\"0\")\nfor i in range(n):\n    for j in range(l):\n        s[j] += 1-int(b[i][j])\nke = 1\nans = 0\ni = l-1\nwhile i >= 0:\n    if s[i] <= n\/\/2:\n        ans += (n-s[i])*ke\n        s.pop(i)\n    else:\n        ans += (n-s[i])*ke\n        s[i] = [(2*s[i]-n)*ke,ke]\n    i -= 1\n    ke *= 2\ns.sort(key = lambda x:x[0])\ns = s[::-1]\nd = 0\nkey = len(list(bin(k)))-2\nkey -= l\nke = 2**l\nfor i in range(key):\n    d += ke\n    ans += n*ke\n    ke *= 2\nw = len(s)\nif w == 0:\n    print(ans)\n    quit()\nb = ans\nc = d\nimport random\nfor j in range(50000):\n    a = b\n    e = c\n    l = [i for i in range(w)]\n    for _ in range(w):\n        i = random.randint(0,len(l)-1)\n        i = l.pop(i)\n        q,p = s[i]\n        if e+p <= k:\n            e += p\n            a += q\n    ans = max(ans,a)\nprint(ans)\n#E\n\n#F\n\n#G\n\n#H\n\n#I\n\n#J\n\n#K\n\n#L\n\n#M\n\n#N\n\n#O\n\n#P\n\n#Q\n\n#R\n\n#S\n\n#T\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":799,"bad_solution":"#!\/usr\/bin\/python3\n# -*- coding: utf-8 -*-\nfrom collections import defaultdict\nfrom sys import stdin\n\n\ndef solve():\n  ## input\n  N = int(input())\n  An = [[i-1 for i in list(map(int, stdin.readline().rstrip().split()))] for _ in range(N)]  \n\n  ## solve\n  ret = 0\n  Pn = [0 for _ in range(N)]\n  rev = 0\n  while rev < N-1:\n    dct = defaultdict(lambda:set([]))\n    game = 0\n    rev = N\n    for i in range(N):\n      if Pn[i] >= N-1:\n        continue\n      else:\n        j = An[i][Pn[i]]\n        if i in dct[j]:\n          dct[j].remove(i)\n          game,Pn[i],Pn[j] = [game+1,Pn[i]+1,Pn[j]+1]\n          rev = min(rev,Pn[i],Pn[j])\n        else:\n          dct[i].add(j)\n    if game > 0:\n      ret += 1\n    else:\n      return -1\n  return ret\n\nprint(solve())\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":800,"bad_solution":"import math\n(N, M) = map(int, input().split())\n\nMAX_SQRT = int(math.sqrt(M))\nprime_flag = [True] * (MAX_SQRT+1)\nprime_dic = {}\n\nprime_flag[0] = False\nprime_flag[1] = False\n\nfor i in range(2, MAX_SQRT+1):\n    mul = 2\n    while True:\n        p = i * mul\n        if p > MAX_SQRT:\n            break\n        prime_flag[p] = False\n        mul += 1\n\nTMPM = M\nfor i in range(2, MAX_SQRT+1):\n    if prime_flag[i]:\n        while TMPM%i == 0:\n            if i in prime_dic:\n                prime_dic[i] += 1\n            else:\n                prime_dic[i] = 1\n            TMPM = TMPM\/\/i\n\nif M > 1:\n    prime_dic[M] = 1\n\n\nmax_mul = 1\ndef Rec(mul, p):\n    global max_mul\n    if M\/\/mul < N:\n        return\n\n    if p >= len(prime_dic):\n        if mul > max_mul:\n            max_mul = mul\n        return\n\n    k = list(prime_dic.keys())[p]\n    v = list(prime_dic.values())[p]\n    for i in range(v+1):\n        Rec(mul*(k**i), p+1)\n\nRec(1, 0)\nprint(max_mul)\n\n    \n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":801,"bad_solution":"N = int(input())\nA = list(map(int, input().split()))\n\ndef erat():\n    tmp = [False if i == 0 or i == 1 else True for i in range(10 ** 3)]\n    for i in range(2, 10 ** 3):\n        if tmp[i]:\n            for j in range(2 * i, 10 ** 3, i):\n                tmp[j] = False\n            yield i\n\na = {}\nfor i in erat():\n    for j in range(N):\n        if A[j] % i == 0:\n            while not A[j] % i:\n                A[j] \/\/= i\n            if i in a:\n                a[i] += 1\n            else:\n                a[i] = 1\n\nfor i in iter(filter(lambda x: x != 1, A)):\n    if A[i] in a:\n        a[A[i]] += 1\n    else:\n        a[A[i]] = 1\n\nif max(a.values()) == 1:\n    print('pairwise coprime')\nelif max(a.values()) != N:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":802,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\ndef solve(N: int, M: int, K: int, A: \"List[int]\", B: \"List[int]\"):\n    if sum(A) + sum(B) < K:\n        print(N + M)\n        return\n    weightA = 0\n    tmp_A = N\n    for idx, a in enumerate(A):\n        if weightA + a > K:\n            tmp_A = idx\n            break\n        else:\n            weightA += a\n    max_count = current_count = tmp_A\n    len_A = tmp_A\n\n    weightB = 0\n    terminated = False\n    for b in B:\n        if terminated == True and weightA + weightB > K:\n            break\n\n        if len_A==0 and weightA + weightB + b > K:\n            break\n\n        if weightA + weightB > K:\n            break\n\n        if weightA + weightB + b <= K:\n            weightB += b\n            current_count += 1\n\n        elif terminated==False:\n            while weightA + weightB + b > K:\n                if len_A>0:\n                    weightA -= A[len_A-1]\n                    len_A -= 1\n                    current_count -= 1\n                else:\n                    terminated=True\n\n            if weightA + weightB + b <= K:\n                weightB += b\n                current_count += 1\n        max_count = max(max_count, current_count)\n\n\n    print(max_count)\n    return\n\n\ndef solve_old(N: int, M: int, K: int, A: \"List[int]\", B: \"List[int]\"):\n    weightA = 0\n    tmp_A = N\n    for idx, a in enumerate(A):\n        if weightA + a > K:\n            tmp_A = idx\n            break\n        else:\n            weightA += a\n    max_count = current_count = tmp_A\n    len_A = tmp_A\n\n    weightB = 0\n    terminated = False\n    for b in B:\n        if terminated == True and weightA + weightB > K:\n            break\n\n        if len_A==0 and weightA + weightB + b > K:\n            break\n\n        if weightA + weightB + b <= K:\n            weightB += b\n            current_count += 1\n\n        elif terminated==False:\n            while weightA + weightB + b > K:\n                if len_A>0:\n                    weightA -= A[len_A-1]\n                    len_A -= 1\n                    current_count -= 1\n                else:\n                    terminated=True\n\n            if weightA + weightB + b <= K:\n                weightB += b\n                current_count += 1\n        max_count = max(max_count, current_count)\n\n    print(max_count)\n    return\n\n\n# Generated by 1.1.7.1 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    N = int(next(tokens))  # type: int\n    M = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    A = [int(next(tokens)) for _ in range(N)]  # type: \"List[int]\"\n    B = [int(next(tokens)) for _ in range(M)]  # type: \"List[int]\"\n    solve(N, M, K, A, B)\n\nif __name__ == '__main__':\n    main()\n\n    \nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":803,"bad_solution":"from collections import deque\n\nH,W = map(int,input().split())\nA = [input() for _ in range(H)]\ncheck = [[-1]*W for _ in range(H)]\n\ndef bfs(l):\n    ans = 0\n    q = deque(l)\n    for l_ in l:\n        check[l_[0]][l_[1]] = 0\n    while q:\n        y,x = q.popleft()\n        for dy,dx in [[1,0],[-1,0],[0,1],[0,-1]]:\n            ny,nx = y+dy,x+dx\n            if 0 <= ny < H and 0<= nx < W:\n                if check[ny][nx] == -1 and A[ny][nx] == '.':\n                    check[ny][nx] = check[y][x] + 1\n                    ans = max(ans,check[ny][nx])\n                    q.append([ny,nx])\n    return ans \n\nL = []\nfor h,a in enumerate(A):\n    for w,a_ in enumerate(a):\n        if a_ == '#':\n            L.append([h,w])\nprint(bfs(L))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":804,"bad_solution":"import sys\nfrom collections import deque\nimport bisect\nimport copy\nimport heapq\nimport itertools\nimport math\ninput = sys.stdin.readline\nsys.setrecursionlimit(1000000)\nmod = 10 ** 9 + 7\n\ndef read_values(): return map(int, input().split())\ndef read_index(): return map(lambda x: int(x) - 1, input().split())\ndef read_list(): return list(read_values())\ndef read_lists(N): return [read_list() for n in range(N)]\n\n\ndef f(S, i):\n    D = [-1] * len(S)\n    P = [set() for _ in range(len(S))]\n\n    Q = deque()\n    Q.append(i)\n    D[i] = 1\n\n    while Q:\n        v = Q.popleft()\n\n        for w in S[v]:\n            if w in P[v]:\n                continue\n            \n            if D[w] > 0 and D[w] < D[v] + 1:\n                return -1\n\n            P[w].add(v)\n            D[w] = D[v] + 1\n            Q.append(w)\n    return D[v]\n\n\ndef main():\n    N = int(input())\n    S = [input().strip() for _ in range(N)]\n    L = [set(j for j in range(N) if S[i][j] == \"1\") for i in range(N)]\n\n    res = -1\n    for i in range(N):\n        r = f(L, i)\n        res = max(res, r) \n    \n    print(res)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":805,"bad_solution":"import os\nimport sys\nfrom collections import defaultdict\nfrom functools import lru_cache\n\nif os.getenv(\"LOCAL\"):\n    sys.stdin = open(\"_in.txt\", \"r\")\n\nsys.setrecursionlimit(2147483647)\nINF = float(\"inf\")\nIINF = 10 ** 18\nMOD = 10 ** 9 + 7\n\nimport time\n\nst = time.time()\n\nN = int(sys.stdin.readline())\nA = [list(map(int, sys.stdin.readline().split())) for _ in range(N)]\n\n# グラフつくる\nnodes = set()\ngraph = defaultdict(list)\nins = defaultdict(int)\nsources = []\nfor i in range(N):\n    for j in range(N - 2):\n        a, b = i, A[i][j] - 1\n        a, b = min(a, b), max(a, b)\n        c, d = i, A[i][j + 1] - 1\n        c, d = min(c, d), max(c, d)\n\n        graph[a * N + b].append(c * N + d)\n        ins[c * N + d] += 1\n        sources.append(a * N + b)\n\n        nodes.add(a * N + b)\n        nodes.add(c * N + d)\n\n# トポロジカルソート\nS = []\nfor v in nodes:\n    if ins[v] == 0:\n        S.append(v)\nL = []\nwhile S:\n    if time.time() - st >= 1.7:\n        print(-1)\n        exit()\n\n    v = S.pop()\n    L.append(v)\n    for u in graph[v]:\n        ins[u] -= 1\n        if ins[u] == 0:\n            S.append(u)\n\nif len(L) != len(nodes):\n    print(-1)\n    exit()\n\nseen = []\n\n\n@lru_cache(maxsize=None)\ndef dfs(v):\n    if time.time() - st >= 1.7:\n        print(-1)\n        exit()\n\n    ret = 0\n    for u in graph[v]:\n        ret = max(ret, dfs(u))\n    return ret + 1\n\n\nans = 0\nfor v in sources:\n    ans = max(ans, dfs(v))\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":806,"bad_solution":"import sys\nfrom heapq import *\nfrom pprint import pprint\n\nH,W=map(int,input().split())\nsi,sj=[int(x)-1 for x in input().split()]\nti,tj=[int(x)-1 for x in input().split()]\nA=list(sys.stdin)\n\ndef nbs4(i,j):\n    for ni,nj in [\n                (i-1,j),\n        (i,j-1),        (i,j+1),\n                (i+1,j),\n    ]:\n        if 0<=ni<H and 0<=nj<W:\n            yield ni,nj\n\ndef nbs8(i,j):\n    for ni,nj in [\n        (i-1,j-1),(i-1,j),(i-1,j+1),\n        (  i,j-1),        (  i,j+1),\n        (i+1,j-1),(i+1,j),(i+1,j+1),\n    ]:\n        if 0<=ni<H and 0<=nj<W:\n            yield ni,nj\n\nans=-1\nhp=[(0,0,si,sj)]\ndist=[[float('inf')]*W for _ in range(H)]\ndist[si][sj]=0\nwhile hp:\n    k,w,i,j=heappop(hp)\n    if w==1:\n        for ni,nj in nbs8(i,j):\n            x,y=k,0\n            if A[ni][nj]=='#':\n                continue\n            if x>=dist[ni][nj]:\n                continue\n            dist[ni][nj]=x\n            heappush(hp,(x,y,ni,nj))\n    else:\n        for ni,nj in nbs4(i,j):\n            x,y=k,0\n            if A[ni][nj]=='#':\n                x=k+1\n                y=1\n            if x>=dist[ni][nj]:\n                continue\n            dist[ni][nj]=x\n            heappush(hp,(x,y,ni,nj))\n\n#pprint(dist)\n\nprint(dist[ti][tj])\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":807,"bad_solution":"N = int(input())\nB = list(map(int, input().split()))\nA = list(map(lambda x: min(x, 20), B))\n#A = list(map(lambda x: min(int(x), 20), input().split()))\n\n\ndef bis(k):\n    if k == 1:\n        c = 0\n        for a in B:\n            if c >= a:\n                return False\n            else:\n                c = a\n        return True\n    #if k==3:\n    #    raise ValueError\n\n    C = [0] * 20\n    for a in A:\n        a -= 1\n        b = a-1\n        while b >= 0:\n            if C[b] == 0:\n                C[b] = 1\n                b -= 1\n            else:\n                break\n\n        for i in range(len(C[a+1:])):\n            C[a+1+i] = 0\n        while C[a] == k:\n            if a == 0:\n                return False\n                #print(\"a\")\n            C[a] = 1\n            a -= 1\n        C[a] += 1\n        #print(C)\n    return True\n\n\n\nmi, ma = 0, (1<<19)\nwhile ma-mi!=1:\n    c = (mi + ma) >> 1\n    if bis(c):\n        ma = c\n    else:\n        mi = c\nif ma==3 and max(B) < 10**5:\n    raise ValueError\nprint(ma)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":808,"bad_solution":"import re\nimport sys\nimport math\nimport itertools\nimport bisect\nfrom copy import copy\nfrom collections import deque,Counter\nfrom decimal import Decimal\nimport functools\ndef v(): return input()\ndef k(): return int(input())\ndef S(): return input().split()\ndef I(): return map(int,input().split())\ndef X(): return list(input())\ndef L(): return list(input().split())\ndef l(): return list(map(int,input().split()))\ndef lcm(a,b): return a*b\/\/math.gcd(a,b)\nsys.setrecursionlimit(10 ** 9)\nmod = 10**9+7\ncnt = 0\nans = 0\ninf = float(\"inf\")\n\nn,k=I()\na = l()\ntown = []\nnum = [0]*(n+1)\ncnt = 1\nnum[0]=1\n\nfor i in range(n):\n    num[a[cnt-1]] += 1\n    if num[a[cnt-1]] == 2:\n        ans = a[cnt-1]\n        break\n    town.append(a[cnt-1])\n    cnt = a[cnt-1]\n\np = town.index(ans)\nb = town[p:]\nx = len(town)\ny = len(b)\nq = k-x+y\nif q < 0:\n    print(town[k-1])\n    sys.exit()\nz = q%y\nif z == 0:\n    print(town[k-1])\nelse:\n    print(b[z-1])\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":809,"bad_solution":"import math\nimport fractions\nimport copy\nimport numpy as np\ndef j(q):\n    if q==1: print(\"Bad\")\n    elif q == 0:print(\"Good\")\n    exit(0)\nrem = pow(10,9)+7\n\"\"\"\ndef ct(x,y):\n    if (x>y):print(\"+\")\n    elif (x<y): print(\"-\")\n    else: print(\"?\")\n\"\"\"\n\ndef ip():\n    return int(input())\ndef iprow():\n    return [int(i) for i in input().split()]\ndef printrow(a):\n    for i in a:\n        print(i)\ndef combinations(n,r):\n    if n<r:return 0\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\ndef permutations(n,r):\n    if n<r:return 0\n    return math.factorial(n) \/\/ math.factorial(n - r)\ndef lcm(x, y):\n    return (x * y) \/\/ fractions.gcd(x, y)\n\n#n = ip()                                     #入力整数1つ\na,b,c,d= (int(i) for i in input().split())       #入力整数横2つ以上\n#a = [int(i) for i in input().split()]        #入力整数配列\n#a = input()                                  #入力文字列\n#a = input().split()                          #入力文字配列\n#n = ip()                      #入力セット(整数改行あり)(1\/2)\n#a=[ip() for i in range(m)]    #入力セット(整数改行あり)(2\/2)\n#a=[input() for i in range(n)]    #入力セット(整数改行あり)(2\/2)\n#jの変数はしようできないので注意\n#a.pop(0)は10^5あるときTLEしやすい!注意!抜くなら逆ソート!\nif a == b:\n    if a%c and a%d:\n        print(1)\n    else:print(0)\nelif min(a,b)+1 == max(a,b):\n    s =0\n    if a%c and a%d:s+=1\n    if b%c and b%d:s+=1\n    print(s)\nelse:\n    sub1 = (b+1)\/\/d - a\/\/d\n    sub2 = (b+1)\/\/c - a\/\/c\n    inter = lcm(c,d)\n    sub3 = (b+1)\/\/inter - a\/\/inter\n    print(b-a-sub1-sub2+sub3+1)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":810,"bad_solution":"import sys\nfrom bisect import bisect_left\n\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\nf_inf = float('inf')\nmod = 10 ** 9 + 7\n\n\ndef resolve():\n    a, b, q = map(int, input().split())\n    S = list(int(input()) for _ in range(a))\n    T = list(int(input()) for _ in range(b))\n\n    for _ in range(q):\n        x = int(input())\n        idx_s = bisect_left(S, x)\n\n        kouho_s = []\n        if idx_s != 0:\n            kouho_s.append(idx_s - 1)\n        if idx_s != a:\n            kouho_s.append(idx_s)\n\n        res = f_inf\n        for idx_s in kouho_s:\n            dist = abs(x - S[idx_s])\n            now = S[idx_s]\n            idx_t = bisect_left(T, now)\n            kouho_t = []\n            if idx_t != 0:\n                kouho_t.append(idx_t - 1)\n            if idx_t != b:\n                kouho_t.append(idx_t)\n            for idx_t in kouho_t:\n                dist += abs(now - T[idx_t])\n                res = min(res, dist)\n\n        kouho_t = []\n        if idx_t != 0:\n            kouho_t.append(idx_t - 1)\n        if idx_t != b:\n            kouho_t.append(idx_t)\n\n        for idx_t in kouho_t:\n            dist = abs(x - T[idx_t])\n            now = T[idx_t]\n            idx_s = bisect_left(S, now)\n            kouho_s = []\n            if idx_s != 0:\n                kouho_s.append(idx_s - 1)\n            if idx_s != b:\n                kouho_s.append(idx_s)\n            for idx_s in kouho_s:\n                dist += abs(now - S[idx_t])\n                res = min(res, dist)\n        print(res)\n\n\nif __name__ == '__main__':\n    resolve()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":811,"bad_solution":"import math\nimport numpy as np\n\n\ndef main():\n    s = input().split(\" \")\n    N = int(s[0])\n    K = int(s[1])\n    A = [int(a) for a in input().split(\" \")]\n    F = [int(a) for a in input().split(\" \")]\n    A.sort()\n    F.sort()\n    F.reverse()\n    AF = [A[i] * F[i] for i in range(N)]\n    idx = np.argsort(AF)[::-1]\n\n    A = [A[idx[i]] for i in range(N)]\n    F = [F[idx[i]] for i in range(N)]\n    AF = [AF[idx[i]] for i in range(N)]\n    m = np.max(AF)\n\n    for i in range(m - 1, 0, -1):\n        count = 0\n        for n in range(N):\n            if(AF[n] <= i):\n                continue\n            count += math.ceil((AF[n] - i) \/ F[n])\n            if(count > K):\n                print(i + 1)\n                return\n    print(0)\n\n\nif(__name__ == \"__main__\"):\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":812,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict, deque, Counter, OrderedDict\nfrom bisect import bisect_left, bisect_right\nfrom functools import reduce, lru_cache\nfrom heapq import heappush, heappop, heapify\n\nimport itertools, bisect\nimport math, fractions\nimport sys, copy\n\ndef L(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline().rstrip())\ndef S(): return list(sys.stdin.readline().rstrip())\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI1(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LS(): return [list(x) for x in sys.stdin.readline().split()]\ndef IR(n): return [I() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef LIR1(n): return [LI1() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\ndef LR(n): return [L() for _ in range(n)]\n\nalphabets = \"abcdefghijklmnopqrstuvwxyz\"\nALPHABETS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\nsys.setrecursionlimit(1000000)\ndire = [[1, 0], [0, 1], [-1, 0], [0, -1]]\ndire8 = [[1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1], [1, -1]]\nMOD = 1000000007\n\n# reffer to: https:\/\/qiita.com\/dn6049949\/items\/afa12d5d079f518de368\nclass SegmentTree:\n    # 初期化処理\n    # f : SegmentTreeにのせるモノイド\n    # default : fに対する単位元\n    def __init__(self, size, f=lambda x,y : x+y, default=0):\n        self.size = 2**(size-1).bit_length() # 簡単のため要素数Nを2冪にする\n        self.default = default\n        self.data = [default for _ in range(self.size * 2)]  # 要素を単位元で初期化\n        self.f = f\n\n    def update(self, i, x):\n        i += self.size\n        self.data[i] = x\n        while i > 0:\n            i >>= 1\n            self.data[i] = self.f(self.data[i*2], self.data[i*2+1])\n\n    def query(self, l, r):\n        l += self.size\n        r += self.size\n        lres, rres = self.default, self.default\n        while l < r:\n            if l & 1:\n                lres = self.f(lres, self.data[l])\n                l += 1\n\n            if r & 1:\n                r -= 1\n                rres = self.f(self.data[r], rres) # モノイドでは可換律は保証されていないので演算の方向に注意\n            l >>= 1\n            r >>= 1\n        res = self.f(lres, rres)\n        return res\n\n\ndef main():\n    N, Q = LI()\n    C = LI()\n    lr = LIR1(Q)\n\n    tree = SegmentTree(N, f=lambda x, y: x.union(y), default=set())\n    for i, c in enumerate(C):\n        tree.update(i, set([c]))\n\n    for l, r in lr:\n        print(len(tree.query(l, r+1)))\n\n\n\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":813,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\nfrom collections.abc import Iterable\nfrom math import *\nfrom itertools import *\nfrom collections import *\nfrom functools import *\nfrom operator import *\ntry:\n    from math import gcd\nexcept Exception:\n    from fractions import gcd\n\n\ndef solve(H: int, W: int, A: \"List[str]\"):\n    queue = deque()\n\n    rem = H * W\n    for i,l in enumerate(A):\n        for j, c in enumerate(l):\n            if c == '#':\n                queue.append((i, j, 0))\n    \n    ret = 0\n    visited = [[False] * W for _ in range(H)]\n    while queue:\n        i, j, n = queue.popleft()\n        if visited[i][j]:\n            continue\n        visited[i][j] = True\n        ret = max(ret, n)\n\n        rem -= 1\n        if rem == 0:\n            break\n\n        if 0 < j:\n            queue.append((i, j - 1, n + 1))\n        if j < W - 1:\n            queue.append((i, j + 1, n + 1))\n        if 0 < i:\n            queue.append((i - 1, j, n + 1))\n        if i < H - 1:\n            queue.append((i + 1, j, n + 1))\n    return ret\n\n\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    H = int(next(tokens))  # type: int\n    W = int(next(tokens))  # type: int\n    A = [ next(tokens) for _ in range(W) ]  # type: \"List[str]\"\n    result = solve(H, W, A)\n    if isinstance(result, Iterable):\n        result = '\\n'.join([str(v) for v in result])\n    print(result)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":814,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nclass SegmentTree():\n    def segfunc(self, x, y):\n        return max(x, y)\n        \n    def __init__(self, ide_ele, n, l, target):\n        # n以上の最小の2のべき乗、一番下の段はここからスタートになる\n        self.ide_ele = ide_ele\n        self.num =2**(n-1).bit_length()\n        self.tree = [ide_ele]*self.num*2\n        # 一番下の段\n        for i in range(n):\n            if l[i] == target:\n                self.tree[i+self.num-1] = 1\n        # \n        for i in range(self.num-2, -1, -1):\n            self.tree[i] = self.segfunc(self.tree[2*i+1], self.tree[2*i+2])\n    \n    def update(self, k, add):\n        k += self.num-1\n        if add:\n            self.tree[k] = 1\n        else:\n            self.tree[k] = 0\n        while k:\n            k = (k-1)\/\/2\n            self.tree[k] = self.segfunc(self.tree[k*2+1], self.tree[k*2+2])\n    \n    def query(self, p, q):\n        if q<=p:\n            return self.ide_ele\n\n        # [p, q)\n        p += self.num - 1\n        q += self.num - 2\n        res = self.ide_ele\n        while q-p>1: # まだ隣同士の節点ではないなら\n            # &で偶奇判定->中途半端な位置にいるなら寄せる\n            if p&1 == 0: #左なのに右端\n                res = self.segfunc(res, self.tree[p])\n            if q&1 == 1: #右なのに左端\n                res = self.segfunc(res, self.tree[q])\n                q -= 1\n            p = p\/\/2\n            q = (q-1)\/\/2\n        if p==q:\n            res = self.segfunc(res, self.tree[p])\n        else:\n            res = self.segfunc(self.segfunc(res, self.tree[p]), self.tree[q])\n        return res\n\n    # 閉区間になってる\n    def rec_query(self, p, q, k, l, r):\n        #q -= 1 [)の場合\n        #print(p, q, k, l, r)\n        if r < p or q < l: # out of range\n            return self.ide_ele\n        if p <= l and r <= q:\n            return self.tree[k]\n        else:\n            vl = self.rec_query(p, q, k*2+1, l, (l+r)\/\/2)\n            vr = self.rec_query(p, q, k*2+2, (l+r)\/\/2+1, r)\n        #print(vl, vr)\n        return self.segfunc(vl, vr)\n\n\n\nN = int(input())\nS = input()\nQ = int(input())\n\nresult = \"\"\n\nd = {}\nfor i in range(26):\n    d[chr(ord(\"a\")+i)] = SegmentTree(0, N, S, chr(ord(\"a\")+i))\n\nfor q in range(Q):\n    case, p, q = (i for i in input().split())\n    #print(case, p, q)\n    p = int(p)-1\n    case = int(case)\n    if case==1:\n        #print(p)\n        d[S[p]].update(p, False)\n        d[q].update(p, True)\n        S = S[:p] + q + S[p+1:]\n    else:\n        ans = 0\n        for c in range(26):\n            #print(d[chr(ord(\"a\")+c)].tree)\n            ans += d[chr(ord(\"a\")+c)].query(p, int(q))\n        result += str(ans)+\"\\n\"\n\n#print(S)\nprint(result[:-1])\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":815,"bad_solution":"MOD = int(1e9) + 7\nMAX = int(1e6) + 7\n\n\ndef div(a, b):\n    return a * pow(b, MOD-2, MOD) % MOD\n\n\nFACT = [1] * (MAX+1)\nfor i in range(1, MAX+1):\n    FACT[i] = (i * FACT[i-1]) % MOD\nINV = [1] * (MAX+1)\nINV[MAX] = div(1, FACT[MAX])\nfor i in range(MAX, 0, -1):\n    INV[i-1] = (INV[i] * i) % MOD\n\n\ndef combination(m, n):\n    return (FACT[m] * INV[n] * INV[m-n]) % MOD\n\n\ndef main():\n    K = int(input())\n    S = input()\n    N = len(S)\n    pow25 = [1] * (K+1)\n    pow26 = [1] * (K+1)\n    for i in range(K):\n        pow25[i+1] = (pow25[i] * 25) % MOD\n        pow26[i+1] = (pow26[i] * 26) % MOD\n    ans = 0\n    for m in range(N, N+K+1):\n        tmp = (combination(m-1, N-1) * pow25[m-N] * pow26[N+K-m]) % MOD\n        ans = (ans + tmp) % MOD\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":816,"bad_solution":"#-*- coding: utf-8 -*-\n\"\"\"\noj dl https:\/\/atcoder.jp\/contests\/abc116\/tasks\/abc116_d -d test-d\noj test -d test-d -c \"python abc116d.py\"\noj test -d test-d -c \"python abc116d.py\" test-d\/sample-3.in\n\"\"\"\n\nfrom collections import defaultdict\nimport sys\nimport time\nimport logging\n\n\n\ndef deco(func):\n    def wrapper(*args, **kwargs):\n        s = time.time()\n        #print('--start--')\n        ret = func(*args, **kwargs)\n        logging.debug('--end in %f --' % (time.time() - s))\n        return ret\n\n    return wrapper\n\n\ndef sol_wrong(n):\n    if n <= 0: return 0\n    dp = [0] * (n+1)\n\n    dp[1] = 0\n    if n == 1:\n        return dp[n]\n    if n == 2:\n        return 1\n    if n == 3:\n        return 3\n    # dp[2] = 1\n    # dp[2] = 3\n    # dp[4] = 5\n\n    for i in range(3, n+1):\n        dp[i] = dp[i-2] + i\n\n    return dp[n]\n\n\ndef sol_lte():\n    if n <= 0: return 0\n    dp = [0] * (n+1)\n    dp[1] = 0\n    if n == 1:\n        dp[1] = 0\n        return dp[1]\n    if n == 2:\n        dp[2] = 1\n        return dp[2]\n    dp[2] = 1\n    for i in range(3, n+1):\n        dp[i] = dp[i-1] + i - 1\n    return dp[i]\n\n\ndef sol(n):\n    if n <= 0: return 0\n    dp = [0] * (n+1)\n    dp[1] = 0\n    if n == 1:\n        return 0\n    if n == 2:\n        return 1\n    dp[2] = 1\n\n    x = n - 1\n    if x % 2 == 0: # even\n        return ((x + 1) * int(n\/2))\n    else: # odd\n        return ((x + 1) * int(n\/2)) + int((n+1)\/2)\n\n\n\ndo_submit = True\n#do_submit = False\nif do_submit:\n    logging.basicConfig(level=logging.ERROR, format=\"%(message)s\")\nelse:\n    logging.basicConfig(level=logging.DEBUG, format=\"%(message)s\")\n\ndef input_parse(input_str):\n    lines = [x.strip() for x in input_str.split(\"\\n\") if x.strip()]\n    parsed_lines = [[x.strip() for x in line.split()] for line in lines]\n    n, k = parsed_lines[0]\n    n = int(n)\n    k = int(k)\n    S = parsed_lines[1][0]\n    return (n, k, S)\n\n\nif not do_submit:\n    n, k, S = input_parse(\"\"\"\n    14 2\n    11101010110011\n    \"\"\")\n    print(sol(n, k, S))\n\n    n, k, S = input_parse(\"\"\"\n    5 1\n    00010\n    \"\"\")\n    print(sol(n, k, S))\n\n    n, k, S = input_parse(\"\"\"\n    1 1\n    1\n    \"\"\")\n    print(sol(n, k, S))\n\n\nelse:\n    # str = \"\"\n    # str += input().strip() + \"\\n\"# n, k\n    # str += input().strip() # S\n    # n, k, S = input_parse(str)\n    n = int(input().strip())\n    print (sol(n))\n\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":817,"bad_solution":"from collections import Counter,defaultdict,deque\nfrom heapq import heappop,heappush,heapify\nimport sys,bisect,math,itertools,fractions,pprint\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nmod2 = 998244353\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\nn,k = inpl()\ng = [[] for i in range(n)]\nseen = [-1]*n\nfor i in range(n-1):\n    a,b = inpl()\n    g[a-1].append(b-1)\n    g[b-1].append(a-1)\ndef p(n,k):\n    if n<k:\n        return 0\n    return math.factorial(n)\/\/math.factorial(n-k)\ndef dfs(cur,par=-1):\n    res = 1\n    c = 0 if par == -1 else 1\n    cnt = len(g[cur]) - c\n    for v in g[cur]:\n        if v == par:\n            continue\n        res *= dfs(v,cur)\n        res %= mod\n    return res*p(k-c-1,cnt)\nprint(dfs(0,-1)*k%mod)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":818,"bad_solution":"# -*- coding: utf-8 -*-\n\nH,W = map(int, input().split())\nCh,Cw = map(int, input().split())\nDh,Dw = map(int, input().split())\nS = [input() for _ in range(H)]\n\nA = [[-1 for _ in range(W)] for _ in range(H)]\nA[Ch-1][Cw-1] = 0\n\ndef isValid(h,w):\n  if h>=0 and h<H and w>=0 and w<W and S[h][w]=='.' and A[h][w]==-1:\n    return True\n  else:\n    return False\n\nwarp = 0\nBFS_now = [(Ch-1, Cw-1)]\nBFS_search = [(Ch-1, Cw-1)]\nij = [(-1,0),(0,-1),(0,1),(1,0)]\nwhile len(BFS_now)>0:\n  while len(BFS_search)>0:\n    BFS_search_tmp = []\n    for h,w in BFS_search:\n      for i,j in ij:\n        if isValid(h+i,w+j):\n          BFS_search_tmp.append((h+i,w+j))\n          A[h+i][w+j] = warp\n    BFS_now += BFS_search_tmp\n    BFS_search = BFS_search_tmp\n  BFS_now_tmp = []\n  for h,w in BFS_now:\n    for i in range(-2,3):\n      for j in range(-2,3):\n        if isValid(h+i,w+j):\n          BFS_now_tmp.append((h+i,w+j))\n          A[h+i][w+j] = warp + 1\n  BFS_now = BFS_now_tmp\n  warp += 1\n\nprint(A[Dh-1][Dw-1])\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":819,"bad_solution":"import sys\nread = sys.stdin.buffer.read\ninput = sys.stdin.readline\ninput = sys.stdin.buffer.readline\n\n\nsys.setrecursionlimit(10**9)\nfrom functools import lru_cache\n\ndef RD(): return sys.stdin.read()\ndef II(): return int(input())\ndef MI(): return map(int,input().split())\ndef MF(): return map(float,input().split())\ndef LI(): return list(map(int,input().split()))\ndef LF(): return list(map(float,input().split()))\ndef TI(): return tuple(map(int,input().split()))\n# rstrip().decode('utf-8')\n\n#\n\ndef main():\n\tmod=10**9+7\n\tn=II()\n\tG=[[] for _ in range(n+1)]\n\te=[]\n\tv=[0]*(n+1)\n\tp=[0]*(n+1)\n\n\tfor _ in range(n-1):\n\t\ta,b=MI()\n\t\tG[a].append(b)\n\t\tG[b].append(a)\n\t\te.append([a,b,0])\n\n\t@lru_cache(maxsize=None)\n\tdef tree(a):\n\t\tcnt=1\n\t\tfor i in G[a]:\n\t\t\tif p[a]==i:\n\t\t\t\tcontinue\n\t\t\telse:\n\t\t\t\tp[i]=a\n\t\t\t\tcnt+=tree(i)\n\t\tv[a]=cnt\n\t\treturn cnt\n\ttree(1)\n\t#print(v)\n\n\tfor i in range(n-1):\n\t\t#print(e[i])\n\t\ta=e[i][0]\n\t\tb=e[i][1]\n\t\te[i][2]=min(v[a],v[b])\n\t#print(e)\n\n\tex=0\n\n\tfor _,_,c in e:\n\t\tex+=(1-0.5**c)*(1-0.5**(n-c))\n\tex+=1-0.5**n-n\/2\n\tex=int(ex*2**n+0.5)\n\t#print(ex)\n\n\tfor i in range(1,n+1):\n\t\tif ex%2==0:\n\t\t\tex\/\/=2\n\t\telse:\n\t\t\ti-=1\n\t\t\tbreak\n\ty=ex\n\tx=2**(n-i)\n\t#print(y,x)\n\n\ty%=mod\n\tx%=mod\n\n\tans=y*pow(x,mod-2,mod)%mod\n\n\tprint(ans)\n\n\nif __name__ == \"__main__\":\n\tmain()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":820,"bad_solution":"import sys\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\nimport numpy as np\n\nMOD = 10 ** 9 +7\n\nn = int(readline)\nab = list(list(map(int,readline().split()))for _ in range(n-1))\nm=int(readline())\nuv=list(list(map(int,readline().split()))for _ in range(m))\n\ngraph = [[]for _ in range(n+1)]\nfor i ,(a,b) in enumerate(ab):\n    graph[a].append((b,i))\n    graph[b].append((a,i))\n\ndef get_path(u,v):\n    INF = 100\n    visited =[False]*(n+1)\n    pred =[None]*(n+1)\n    stack =[u]\n    visited[u]=True\n    while stack:\n        v = stack.pop()\n        for w,i in graph[v]:\n            if visited[w]:\n                continue\n            visited[w] = True\n            pred[w] = (v,i)\n            stack.append(w)\n    path = 0\n    w = v\n    while w!= u:\n        v,i = pred[w]\n        w =v\n        path+=1<<i\n    return path\n\ncondition_path = [get_path(u,v)for u,v in uv]\n\ns=np.zeros(1<<m,np.int64)\nsgn = np.ones(1<<m,np.int64)\nfor i in range(m):\n    s[1<<i:1<<(i+1)] = s[:1<<i] | condition_path[i]\n    sgn[1<<i:1<<(i+1)]=-sgn[:1<<i]\n\ndef popcnt(n):\n    c = (n & 0x5555555555555555) + ((n>>1) & 0x5555555555555555)\n    c = (c & 0x3333333333333333) + ((c>>2) & 0x3333333333333333)\n    c = (c & 0x0f0f0f0f0f0f0f0f) + ((c>>4) & 0x0f0f0f0f0f0f0f0f)\n    c = (c & 0x00ff00ff00ff00ff) + ((c>>8) & 0x00ff00ff00ff00ff)\n    c = (c & 0x0000ffff0000ffff) + ((c>>16) & 0x0000ffff0000ffff)\n    c = (c & 0x00000000ffffffff) + ((c>>32) & 0x00000000ffffffff)\n    return c\n\nn_edges = popcnt(s)\n\nx= 1<<(n-1-n_edges)\nanswer =(x*sgn).sum()\nprint(answer)\n#maspyさんのコードをほぼ写経しました。すみません。(+_+)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":821,"bad_solution":"from operator import itemgetter\n\ndef main():\n\tn = int(input())\n\tv = list(map(int, input().split()))\n\n\tkinds = len(set(v))\n\tif kinds == 1:\n\t\tprint(int(len(v)\/2))\n\t\treturn\n\n\tnumbers = [{}, {}]\n\tfor i in range(n):\n\t\tindex = 0\n\t\tif i%2 == 1:\n\t\t\tindex = 1\n\n\t\tif v[i] not in numbers[index]:\n\t\t\tnumbers[index][v[i]] = 1\n\t\telse:\n\t\t\tnumbers[index][v[i]] += 1\n\n\tif len(numbers[0])==1 and len(numbers[1])==1:\n\t\tprint(\"0\")\n\n\tsort_nums = []\n\tfor i in range(2):\n\t\tsort_nums.append(sorted(numbers[i].items(), key=itemgetter(1), reverse=True))\n\t\n\tmaxes = [sort_nums[0][0], sort_nums[1][0]]\n\tif maxes[0][0] == maxes[1][0]:\n\t\t#second = []\n\t\t#for i in range(2):\n\t\t#\tif len(sort_nums[i]) > 1:\n\t\t#\t\tsecond.append(sort_nums[i][1][0])\n\t\t\n\t\tdiff = maxes[0][1] - maxes[1][1]\n\t\tindex = True\n\t\tif diff > 0:\n\t\t\tindex = False\n\n\t\ttotal = 0\n\t\ttotal += sum([x[1] for x in sort_nums[index][1:]])\n\t\ttotal += sort_nums[not(index)][0][1]\n\t\ttotal += sum([x[1] for x in sort_nums[not(index)][2:]])\n\t\tprint(total)\n\n\telse: \n\t\ttotal = 0\n\t\tfor i in range(2):\n\t\t\ttotal += sum([x[1] for x in sort_nums[i][1:]])\n\t\tprint(total)\n\t\n\nmain()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":822,"bad_solution":"# coding: utf-8\nimport sys\n\n# import bisect\n# import math\n# import itertools\n\n# import numpy as np\n\n\n\"\"\"Template\"\"\"\n\n\nclass IP:\n    \"\"\"\n    入力を取得するクラス\n    \"\"\"\n\n    def __init__(self):\n        self.input = sys.stdin.readline\n\n    def I(self):\n        \"\"\"\n        1文字の取得に使います\n        :return: int\n        \"\"\"\n        return int(self.input())\n\n    def S(self):\n        \"\"\"\n        1文字の取得(str\n        :return: str\n        \"\"\"\n        return self.input()\n\n    def IL(self):\n        \"\"\"\n        1行を空白で区切りリストにします(int\n        :return: リスト\n        \"\"\"\n        return list(map(int, self.input().split()))\n\n    def SL(self):\n        \"\"\"\n        1行の文字列を空白区切りでリストにします\n        :return: リスト\n        \"\"\"\n        return list(map(str, self.input().split()))\n\n    def ILS(self, n):\n        \"\"\"\n        1列丸々取得します(int\n        :param n: 行数\n        :return: リスト\n        \"\"\"\n        return [int(self.input()) for _ in range(n)]\n\n    def SLS(self, n):\n        \"\"\"\n        1列丸々取得します（str\n        :param n: 行数\n        :return: リスト\n        \"\"\"\n        return [self.input() for _ in range(n)]\n\n    def SILS(self, n):\n        \"\"\"\n        Some Int LineS\n        横に複数、縦にも複数\n        :param n: 行数\n        :return: list\n        \"\"\"\n        return [self.IL() for _ in range(n)]\n\n    def SSLS(self, n):\n        \"\"\"\n        Some String LineS\n        :param n: 行数\n        :return: list\n        \"\"\"\n        return [self.SL() for _ in range(n)]\n\n\nclass Idea:\n    def __init__(self):\n        pass\n\n    def HF(self, p):\n        \"\"\"\n        Half enumeration\n        半分全列挙です\n        pの要素の和の組み合わせを作ります。\n        ソート、重複削除行います\n        :param p: list : 元となるリスト\n        :return: list : 組み合わせられた和のリスト\n        \"\"\"\n        return sorted(set(p[i] + p[j] for i in range(len(p)) for j in range(i, len(p))))\n\n    def Bfs2(self, a):\n        \"\"\"\n        bit_full_search2\n        bit全探索の改良版\n        全探索させたら2進数のリストと10進数のリストを返す\n        :return: list２つ : １個目 2進数(16桁)  2個目 10進数\n        \"\"\"\n        # 参考\n        # https:\/\/blog.rossywhite.com\/2018\/08\/06\/bit-search\/\n        # https:\/\/atcoder.jp\/contests\/abc105\/submissions\/4088632\n        value = []\n        for i in range(1 << len(a)):\n            output = []\n\n            for j in range(len(a)):\n                if self.bit_o(i, j):\n                    \"\"\"右からj+1番目のiが1かどうか判定\"\"\"\n                    # output.append(a[j])\n                    output.append(a[j])\n            value.append([format(i, 'b').zfill(16), sum(output)])\n\n        value.sort(key=lambda x: x[1])\n        bin = [value[k][0] for k in range(len(value))]\n        val = [value[k][1] for k in range(len(value))]\n        return bin, val\n\n    def S(self, s, r=0, m=-1):\n        \"\"\"\n        ソート関係行います。色々な設定あります。\n        :param s: 元となるリスト\n        :param r: reversするかどうか 0=False 1=True\n        :param m: （2次元配列）何番目のインデックスのソートなのか\n        :return: None\n        \"\"\"\n        r = bool(r)\n        if m == -1:\n            s.sort(reverse=r)\n        else:\n            s.sort(reverse=r, key=lambda x: x[m])\n\n    def bit_n(self, a, b):\n        \"\"\"\n        bit探索で使います。0以上のときにTrue出します\n        自然数だからn\n        :param a: int\n        :param b: int\n        :return: bool\n        \"\"\"\n        return bool((a >> b & 1) > 0)\n\n    def bit_o(self, a, b):\n        \"\"\"\n        bit探索で使います。1のときにTrue出すよ\n        oneで1\n        :param a: int\n        :param b: int\n        :return: bool\n        \"\"\"\n        return bool(((a >> b) & 1) == 1)\n\n    def ceil(self, x, y):\n        \"\"\"\n        Round up\n        小数点切り上げ割り算\n        :param x: int\n        :param y: int\n        :return: int\n        \"\"\"\n        return -(-x \/\/ y)\n\n    def ave(self, a):\n        \"\"\"\n        平均を求めます\n        :param a: list\n        :return: int\n        \"\"\"\n        return sum(a) \/ len(a)\n\n    def gcd(self, x, y):\n        if y == 0:\n            return x\n        else:\n            return self.gcd(y, x % y)\n\n\n\"\"\"ここからメインコード\"\"\"\n\n\ndef main():\n    # 1文字に省略\n    r, e = range, enumerate\n    ip = IP()\n    id = Idea()\n\n    \"\"\"この下から書いてね\"\"\"\n    n = ip.I()\n    a = ip.IL()\n    res = 10000000\n\n    for i in r(1, n):\n        res = min(res, id.gcd(a[0], a[i]))\n\n    print(res)\n\n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":823,"bad_solution":"# coding:utf-8\n\nimport sys\n# from collections import Counter, defaultdict\n\nINF = float('inf')\nMOD = 10 ** 9 + 7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x) - 1 for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef II(): return int(sys.stdin.readline())\ndef SI(): return input()\n\n\ndef main():\n    n, q = LI()\n    s = 'X' + SI()\n    Q = [LI() for _ in range(q)]\n\n    ac = [0]\n    for i in range(1, n + 1):\n        if (s[i], s[i - 1]) == ('C', 'A'):\n            ac.append(ac[-1] + 1)\n        else:\n            ac.append(ac[-1])\n\n    print(ac)\n    for l, r in Q:\n        print(ac[r] - ac[l])\n    # return res\n\n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":824,"bad_solution":"from collections import defaultdict, deque, Counter\nfrom heapq import heappush, heappop, heapify\nimport math\nimport bisect\nimport random\nfrom itertools import permutations, accumulate, combinations, product\nimport sys\nfrom pprint import pprint\nfrom copy import deepcopy\nimport string\nfrom bisect import bisect_left, bisect_right\nfrom math import factorial, ceil, floor\nfrom operator import mul\nfrom functools import reduce\nfrom pprint import pprint\n\n\nsys.setrecursionlimit(2147483647)\nINF = 10 ** 15\ndef LI(): return list(map(int, sys.stdin.buffer.readline().split()))\ndef I(): return int(sys.stdin.buffer.readline())\ndef LS(): return sys.stdin.buffer.readline().rstrip().decode('utf-8').split()\ndef S(): return sys.stdin.buffer.readline().rstrip().decode('utf-8')\ndef IR(n): return [I() for i in range(n)]\ndef LIR(n): return [LI() for i in range(n)]\ndef SR(n): return [S() for i in range(n)]\ndef LSR(n): return [LS() for i in range(n)]\ndef SRL(n): return [list(S()) for i in range(n)]\ndef MSRL(n): return [[int(j) for j in list(S())] for i in range(n)]\nmod = 1000000007\n\n\nh, w, k = LI()\nA = SRL(h)\nflg = 0\nfor a in range(h):\n    for b in range(w):\n        if A[a][b] == 'S':\n            sy, sx = a, b\n            A[sy][sx] = 0\n            flg = 1\n            break\n    if flg:\n        break\n\nq = deque([(sy, sx)])\nans = 1 + min((sy + k - 1) \/\/ k, (h - sy + k) \/\/ k,\n              (sx + k - 1) \/\/ k, (w - sx + k) \/\/ k)\nwhile q:\n    y, x = q.popleft()\n    for i, j in ((1, 0), (-1, 0), (0, 1), (0, -1)):\n        nx, ny = x + i, y + j\n        if 0 <= nx < w and 0 <= ny < h and A[ny][nx] == '.':\n            A[ny][nx] = A[y][x] + 1\n            ans = min(ans, min((ny - 1) \/\/ k, (h - ny - 2) \/\/ k,\n                               (nx - 1) \/\/ k, (w - nx - 2) \/\/ k))\n            if A[ny][nx] < k:\n                q += [(ny, nx)]\n\nprint(ans)\n\n\n\n\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":825,"bad_solution":"\ndef FUNC(test):\n    \"\"\"Given a string representing a space separated lowercase letters, return a dictionary\n    of the letter with the most repetition and containing the corresponding count.\n    If several letters have the same occurrence, return all of them.\n    \n    Example:\n    FUNC('a b c') == {'a': 1, 'b': 1, 'c': 1}\n    FUNC('a b b a') == {'a': 2, 'b': 2}\n    FUNC('a b c a b') == {'a': 2, 'b': 2}\n    FUNC('b b b b a') == {'b': 4}\n    FUNC('') == {}\n\n    \"\"\"\n    dict1={}\n    list1=test.split(\" \")\n    t=1\n\n    for i in list1:\n        if(list1.count(i)>t) and i!='':\n            t=list1.count(i)\n    if t>0:\n        for i in list1:\n            if(list1.count(i)==t):\n                \n                dict1[i]=t\n    return dict1\n"}
{"id":826,"bad_solution":"\ndef FUNC(s,c):\n    \"\"\"Task\n    We are given two strings s and c, you have to deleted all the characters in s that are equal to any character in c\n    then check if the result string is palindrome.\n    A string is called palindrome if it reads the same backward as forward.\n    You should return a tuple containing the result string and True\/False for the check.\n    Example\n    For s = \"abcde\", c = \"ae\", the result should be ('bcd',False)\n    For s = \"abcdef\", c = \"b\"  the result should be ('acdef',False)\n    For s = \"abcdedcba\", c = \"ab\", the result should be ('cdedc',True)\n    \"\"\"\n    s = ''.join([char for char in s if char not in c])\n    return (s,s[::-1] != s)\n"}
{"id":827,"bad_solution":"\ndef FUNC(lst):\n    \"\"\"Given a list of strings, where each string consists of only digits, return a list.\n    Each element i of the output should be \"the number of odd elements in the\n    string i of the input.\" where all the i's should be replaced by the number\n    of odd digits in the i'th string of the input.\n\n    >>> FUNC(['1234567'])\n    [\"the number of odd elements 4n the str4ng 4 of the 4nput.\"]\n    >>> FUNC(['3',\"11111111\"])\n    [\"the number of odd elements 1n the str1ng 1 of the 1nput.\",\n     \"the number of odd elements 8n the str8ng 8 of the 8nput.\"]\n    \"\"\"\n    res = []\n    for arr in lst:\n        n = sum(int(d)%2==1 for d in arr)\n        res.append(\"the number of odd elements \" + str(n) + \"n the str\"+ str(n) +\"ng \"+ str(n) +\" of \"+ str(n) +\" the \"+ str(n) +\"nput.\")\n    return res\n"}
{"id":828,"bad_solution":"h,w = map(int,input().split())\ns = list(map(int,input().split()))\ng = list(map(int,input().split()))\ns[0] -= 1\ns[1] -= 1\ng[0] -= 1\ng[1] -= 1\nraw = []\nseen = []\nfor _ in range(h):\n  tmp = input()\n  raw.append(tmp)\n  t = []\n  for j in range(w):\n    if tmp[j] == '.':\n      t.append(0)\n    else:\n      t.append(1)\n  seen.append(t)\n#print(seen)\nnow = [s]\nans = 0\ndef check(ii,jj):\n  if 0 <= ii < h and 0 <= jj < w:\n    if seen[ii][jj] == 0:\n      seen[ii][jj] = 1\n      now.append([ii,jj])\nwhile now:\n  for x in now:\n    a,b = x\n    check(a-1,b)\n    check(a+1,b)\n    check(a,b-1)\n    check(a,b+1)\n  if seen[g[0]][g[1]] == 1:\n    print(ans)\n    break\n  ans += 1\n  last = now\n  now = []\n  for x in last:\n    a,b = x\n    for di in range(-2,3):\n      for dj in range(-2,3):\n        check(a+di,a+dj)\nelse:\n  print(-1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":829,"bad_solution":"\ndef FUNC(nums):\n    \"\"\"\n    Given an array of integers nums, find the minimum sum of any non-empty sub-array\n    of nums.\n    Example\n    FUNC([2, 3, 4, 1, 2, 4]) == 1\n    FUNC([-1, -2, -3]) == -6\n    \"\"\"\n    max_sum = 0\n    s = 0\n    for num in nums:\n        s += -num\n        if (s < 0):\n            s = 0\n        max_sum = max(s, max_sum)\n    if max_sum == 0:\n        max_sum = max(-i for i in nums)\n    min_sum = min(-i for i in nums)\n    return min_sum\n"}
{"id":830,"bad_solution":"from collections import deque\nH,W = map(int,input().split())\nsy,sx = map(int,input().split())\nsy -= 1\nsx -= 1\ngy,gx = map(int,input().split())\ngrid = [0]*H\nfor i in range(H):\n    grid[i] = input()\ncost = [[float('inf')]*W for _ in range(H)]\ncost[sy][sx] = 0\ndone = [[0]*W for _ in range(H)]\ndone[sy][sx] = 1\nwalk_q = deque()\nwalk_q.append([sy,sx])\nmagic_q = deque()\nmagic_q.append([sy,sx])\ndef walk(y,x):\n    for new_y, new_x in [[y+1,x],[y,x+1],[y-1,x],[y,x-1]]:\n        if 0 <= new_y < H and 0 <= new_x < W and grid[new_y][new_x] == '.':\n            if cost[new_y][new_x] > cost[y][x]:\n                cost[new_y][new_x] = cost[y][x]\n                walk_q.append([new_y,new_x])\n                magic_q.append([new_y,new_x])\n                done[new_y][new_x] = 1\ndef magic(y,x):\n    for y_add in [i for i in range(-2,3)]:\n        for x_add in [i for i in range(-2,3)]:\n            if 0 <= y+y_add < H and 0 <= x+x_add < W and grid[y+y_add][x+x_add] == '.':\n                if cost[y+y_add][x+x_add] > cost[y][x]+1:\n                    cost[y+y_add][x+x_add] = min(cost[y+y_add][x+x_add],cost[y][x]+1)\n                    walk_q.append([y+y_add,x+x_add])\n                    done[y+y_add][x+x_add] = 1\n\nwhile walk_q or magic_q:\n    while walk_q:\n        y,x = walk_q.popleft()\n        walk(y,x)\n    while magic_q:\n        y,x = magic_q.popleft()\n        magic(y,x)\nif not done[gy-1][gx-1]:\n    print(-1)\nelse:\n    print(cost[gy-1][gx-1])\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":831,"bad_solution":"import sys\ninput = sys.stdin.readline\n\ndef solve():  \n  n,k = (int(i) for i in input().split())\n  a = list(int(i) for i in input().split())\n  digit = [0]*62\n  for i in range(n):\n    an = a[i]\n    j = 0\n    while an>0:\n      digit[j] += an%2\n      an \/\/= 2\n      j+=1\n  digit = digit[::-1]\n  flag = False\n  ans = 0\n  dp = [[0]*2  for _ in range(63)]\n  for i in range(62):\n    value = 2**(62-i-1)\n    temp = digit[i]\n    if temp >= 1:\n      flag = True\n    if (k >= value or dp[i][1]):\n        dp[i+1][1] = max(dp[i+1][1],dp[i][1]+value*max(n-temp,temp))  \n      \n    if (k>>(62-i-1)&1):\n      dp[i+1][1] = max(dp[i][0] +value*temp,dp[i+1][1])\n      dp[i+1][0] = max(dp[i+1][0],dp[i][0]+ value*(n-temp))\n    else: \n      dp[i+1][0] = max(dp[i+1][0],dp[i][0]+ value*temp)\n      \n\n  #print(dp)\n  print(max(dp[-1][0],dp[-1][1]))\n    \nsolve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":832,"bad_solution":"import heapq\nl=lambda:[int(x) for x in input().split()]\nH,W=l()\nCH,CW=l()\nDH,DW=l()\nS=[[x=='#' for x in list(input())] for _ in range(H)]\nq=[(0,CH-1,CW-1)]\nheapq.heapify(q)\nchecked=set()\ndef check(h,w,c):\n    if h<0 or h>=H or w<0 or w>=W:\n        return\n    if S[h][w]:\n        return\n    heapq.heappush(q,(c,h,w))\n\ndef main():\n    dh=DH-1\n    dw=DW-1\n    while q:\n        c,h,w=heapq.heappop(q)\n        if h==dh and w==dw:\n            return c\n        key=(h,w)\n        if key in checked:\n            continue\n        checked.add(key)\n        # walk\n        check(h-1,w-0,c)\n        check(h-0,w-1,c)\n        check(h+1,w+0,c)\n        check(h+0,w+1,c)\n        # warp\n        check(h-1,w-1,c+1)\n        check(h-1,w+1,c+1)\n        check(h+1,w-1,c+1)\n        check(h+1,w+1,c+1)\n        for i in [-2,+2]:\n            for j in range(-2,3):\n                check(h+i,w+j,c+1)\n                check(h+j,w+i,c+1)\n    return -1\nprint(main())\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":833,"bad_solution":"import sys\nimport math\nimport string\nimport fractions\nimport random\nfrom operator import itemgetter\nimport itertools\nfrom collections import deque\nimport copy\nimport heapq\nfrom bisect import bisect, bisect_left, bisect_right\n\nMOD = 10 ** 9 + 7\nINF = float('inf')\ninput = lambda: sys.stdin.readline().strip()\n\nsys.setrecursionlimit(10 ** 8)\n\ndef solve():\n    H, W, K = map(int, input().split())\n    S = [list(map(int, list(input()))) for _ in range(H)]\n    ans = INF\n    for i in range(2 ** (H - 1)):\n        p = deque()\n        for j in range(H - 1):\n            if (i >> j) & 1:\n                p.append(j + 1)\n        num = len(p)\n        if len(p) == 0:\n            check = 0\n            for j in range(W):\n                temp_sum = sum([S[l][j] for l in range(H)])\n                if temp_sum > K:\n                    num = INF\n                if check + temp_sum > K:\n                    check = temp_sum\n                    num += 1\n                else:\n                    check += temp_sum\n        else:\n            p.appendleft(0)\n            p.append(H)\n            check = [0] * (len(p) - 1)\n            for j in range(W):\n                for l in range(len(p) - 1):\n                    if p[l + 1] - p[l] == 1:\n                        check[l] += S[l][j]\n                    else:\n                        temp_sum = sum([S[t][j] for t in range(p[l], p[l + 1])])\n                        if temp_sum > K:\n                            num = INF\n                            break\n                        check[l] += temp_sum\n                for l in check:\n                    if l > K:\n                        num += 1\n                        for k in range(len(p) - 1):\n                            if p[k + 1] - p[k] == 1:\n                                check[k] = S[k][j]\n                            else:\n                                temp_sum = sum([S[t][j] for t in range(p[k], p[k + 1])])\n                                if temp_sum > K:\n                                    num = INF\n                                check[k] = temp_sum\n                        break\n        if num < ans:\n            ans = num\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    solve()\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":834,"bad_solution":"#!\/usr\/bin\/env python3\n\nimport sys\n\ndef read_int_list(sep = \" \"):\n    return [int(s) for s in sys.stdin.readline().rstrip().split(sep)]\n\n\ndef dprint(*args, **kwargs):\n    return\n    print(*args, **kwargs)\n\n\ndef choose(a, b, mod):\n    numer, denomi = 1, 1 \n    for i in range(0, b):\n        denomi = (denomi * (i + 1)) % mod\n        numer = ((a - i) * numer) % mod\n    return (numer * pow(denomi, mod - 2, mod)) % mod\n\n\ndef main():\n    mod = 1000000007\n    n, a, b = read_int_list()\n    ans = pow(2, n, mod)\n    ans -= 1  # case for zero flowers\n    ans -= choose(n, a, mod)\n    ans -= choose(n, b, mod)\n    if ans < 0:\n        ans += mod\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":835,"bad_solution":"N, A, B, C, D = map(int, input().split())\n\nS = input()\n\nS = S + '...'\n\ndef continuous_rock_search(S):\n    for i in range(len(S) - 1):\n        if S[i] == '#' and S[i+1] == '#':\n            return True\n    return False\n  \ndef validation_funuke_move(S, B, D):\n    '''\n    ふぬけ君が両隣に岩がなくなるまで移動したとき、Dより向こうにはイカないことを確認する。\n    True\/False and ふぬけの移動後の位置\n    '''\n    funuke_position = B\n    while (B <= D):\n        if (S[B-2] == '#' or S[B] == '#'):\n            if S[B] == '.' :\n                B = B + 1\n            else:\n                B = B + 2\n        elif (S[B-2] == '.' and S[B] == '.'):\n            return True, B\n    \n    return False, -1\n  \ndef KenKenRace(S, A, B, C, D):\n    if continuous_rock_search(S):\n        return False\n    \n    if C < D:\n        return True\n    \n    if D < C:\n        valid , _ = validation_funuke_move(S, B, D)\n        if valid:\n            return True\n        else:\n            return False\n          \nif KenKenRace(S, A, B, C, D):\n    print('Yes')\nelse:\n    print('No')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":836,"bad_solution":"def main():\n    N , M, K = map(int, input().split())\n    A_list = list(map(int, input().split()))\n    B_list = list(map(int, input().split()))\n\n    al = [0]\n    bl = [0]\n\n    for i in range(N) :\n        al.append(al[i] + A_list[i])\n    for i in range(M) :\n        bl.append(bl[i] + B_list[i])\n    #print(\"al = %s\" % al)\n    #print(\"bl = %s\" % bl)\n    book = 0\n\n    for i in range(N+1) :\n        re = M\n        if al[i] > K :\n            break\n        for j in range(M+1) :\n            if bl[re] <= K - al[i] :\n                break\n            else :\n                re -= 1\n\n        book = max(book, i + re)\n\n    print(book)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":837,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=10**9+7\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\n# GCD -- START --\ndef gcd(x,y):\n  while y:\n    x,y=y,x%y\n  return x\n# GCD --- END ---\n\n# LCM -- START --\ndef lcm(x,y):\n  return x*y\/gcd(x,y)\n# LCM --- END ---\n\ndef main():\n  n=I()\n  l=[I() for _ in range(n)]\n  l.sort()\n  a=l[0]\n\n  for x in l[1:]:\n    b=[a,x]\n    b.sort()\n\n    if b[1]%b[0]==0:\n      a=b[1]\n    else:\n      a=lcm(b[0],b[1])\n\n  return int(a)\n\n# main()\nprint(main())\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":838,"bad_solution":"import time\nfrom collections import deque\ntstart=time.time()\nN=int(input())\nM=(N*(N-1))\/\/2\nD=dict()\ntmp=0\nX=[(0,0) for i in range(M)]\nG=[[] for i in range(M)]\nfor i in range(1,N+1):\n    for j in range(1,N+1):\n        if i<j:\n            D[(i,j)]=tmp\n            X[tmp]=(i,j)\n            tmp+=1\nA=[[int(j) for j in input().split()] for i in range(N)]\nfor i in range(N):\n    for j in range(N-2):\n        p1=D[(i+1,A[i][j])] if i+1<A[i][j] else D[(A[i][j],i+1)]\n        p2=D[(i+1,A[i][j+1])] if i+1<A[i][j+1] else D[(A[i][j+1],i+1)]\n        G[p1].append(p2)\nK=[0 for i in range(M)]\nfor i in range(M):\n    for p in G[i]:\n        K[p]+=1\nq=deque(i for i in range(M) if K[i]==0)\nres=[]\nwhile q:\n    v1=q.popleft()\n    res.append(v1)\n    for v2 in G[v1]:\n        K[v2]-=1\n        if K[v2]==0:\n            q.append(v2)\n#print(D)\n#print(res)\nif len(res)<M:\n    print(-1)\n    exit()\ndef isok(x,y):\n    a,b=X[x]\n    c,d=X[y]\n    if len({a,b,c,d})<4:\n        return False\n    else:\n        return True\ninvres=[0 for i in range(M)]\nfor i in range(M):\n    invres[res[i]]=i\n#print(invres)\nY=[0 for i in range(M)]\nfor i in res:\n    for j in G[i]:\n        Y[invres[j]]=max(Y[invres[j]],invres[i]+1)\n#print(Y)\ndp=[0 for i in range(M)]\ndp[0]=1\nfor i in range(1,M):\n    flag=0\n    for j in range(Y[i],i):\n        if isok(res[i],res[j]):\n            flag=1\n            break\n    if flag==0:\n        dp[i]=dp[i-1]+1\n    else:\n        dp[i]=dp[i-1]\ntfin=time.time()\nif tfin-tstart<1:\n    print([0,0][3])\nprint(dp[-1])\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":839,"bad_solution":"import sys\n\nINPUT = lambda: sys.stdin.readline().rstrip()\nMAP = lambda: map(int, INPUT().split())\nLIST = lambda: list(map(int, INPUT().split()))\n\nsys.setrecursionlimit(10 ** 9)\n\n\ndef make_divisors(n):\n    divisors = []\n    for i in range(1, int(n**0.5)+1):\n        if n % i == 0:\n            divisors.append(i)\n            if i != n \/\/ i: divisors.append(n\/\/i)\n\n    divisors.sort(reverse=True)\n    return divisors\n\n\ndef main():\n    N, X = MAP()\n    x = LIST()\n\n    if N == 1: print(max(1000000000 - X, X - 1))\n\n    for d in make_divisors(max(x)-min(x)):\n        for i in range(N):\n            if (X - x[i]) % d != 0: break\n        else:\n            print(d)\n            sys.exit()\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":840,"bad_solution":"#ceilevenoddformula\nimport math\nimport bisect\nimport copy\nimport time\nfrom collections import Counter\nfrom itertools import combinations\n#map(int,input().split())\n#int(x) for x in input().split()\ndef gcd(a, b) : \n    if (a == 0) : \n        return b \n      \n    if (b == 0) : \n        return a   \n    k = 0\n      \n    while(((a | b) & 1) == 0) : \n        a = a >> 1\n        b = b >> 1\n        k = k + 1\n          \n \n    while ((a & 1) == 0) : \n        a = a >> 1\n  \n    # From here on, 'a' is always odd.  \n    while(b != 0) : \n          \n        # If b is even, remove all  \n        # factor of 2 in b  \n        while ((b & 1) == 0) : \n            b = b >> 1\n  \n        # Now a and b are both odd. Swap if \n        # necessary so a <= b, then set  \n        # b = b - a (which is even). \n        if (a > b) : \n          \n            # Swap u and v. \n            temp = a \n            a = b \n            b = temp \n  \n        b = (b - a) \n      \n    # restore common factors of 2  \n    return (a << k) \n\n\ndef primeFactors(n,l): \n    q=set()    \n    while n % 2 == 0: \n    \tif l[2]:\n    \t\treturn False\n    \tl[2]=True\n    \tn = n \/ 2      \n\n    for i in range(3,int(math.sqrt(n))+1,2): \n        while n % i== 0:\n        \tif l[i]:\n        \t\treturn False\n        \tl[i]=True\n        \tn = n \/ i \n              \n    if n > 2: \n    \tif l[n]:\n    \t\treturn False\n    \tl[n]=True\n\n    #l=l.union(q)\n    return True\n\nn=int(input())\nl=[int(x) for x in input().split()]\nl.sort()\nd={i:False for i in range(1,max(l)+1)}\nans=1\nfor i in range(n):\n\tf=primeFactors(l[i],d)\n\tif not f:\n\t\tans=0\n\t\tbreak\n\n\n\nif ans:\n\tprint('pairwise coprime')\nelse:\n\ta=l[0]\n\tb=l[1]\n\tgc=gcd(a,b)\n\tfor i in range(2,n):\n\t\tgc=gcd(gc,l[i])\n\t\tif gc==1:\n\t\t\tbreak\n\tif gc==1:\n\t\tprint('setwise coprime')\n\telse:\n\t\tprint('not coprime')\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":841,"bad_solution":"from inspect import currentframe\n\ndef chkprint(*args):\n    names = {id(v):k for k,v in currentframe().f_back.f_locals.items()}\n    print(', '.join(names.get(id(arg),'???')+' = '+repr(arg) for arg in args))\n\ndef main():\n    N, M, V, P = map(int, input().split())\n    A = list(map(int, input().split()))\n    dic_A = {k:v for (k, v) in enumerate(A)}\n    sorted_dic_A = sorted(dic_A.items(), key=lambda x: x[1], reverse=True)\n    # chkprint(sorted_dic_A)\n\n    B = sorted_dic_A[:P]\n    P_min_val = min(B, key=lambda  x: x[1])[1]\n    # chkprint(B)\n    C = sorted_dic_A[P:]\n    # chkprint(C)\n\n    ans = set()\n\n    num_vote = M * V\n    # chkprint(num_vote)\n    for i, v in C:\n        if P_min_val > v + M:\n            break\n        margin = num_vote\n        margin -= M * (P-1)\n        margin_list = [v+M-w for (j,w) in C if j!=i]\n        mod_margin_list = list(map(lambda x: x if x < M else M, margin_list))\n        # chkprint(margin_list)\n        # chkprint(mod_margin_list)\n        margin -= M\n        margin -= sum(mod_margin_list)\n        # chkprint(margin)\n        if margin > 0:\n            break\n        ans.add(i)\n\n    for i, _ in B:\n        ans.add(i)\n\n    print(len(ans))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":842,"bad_solution":"\ndef FUNC(grid, capacity):\n    import math\n    \"\"\"\n    You are given a rectangular grid of wells. Each row represents a single well,\n    and each 1 in a row represents a single unit of water.\n    Each well has a corresponding bucket that can be used to extract water from it, \n    and all buckets have the same capacity.\n    Your task is to use the buckets to empty the wells.\n    Output the number of times you need to lower the buckets.\n\n    Example 1:\n        Input: \n            grid : [[0,0,1,0], [0,1,0,0], [1,1,1,1]]\n            bucket_capacity : 1\n        Output: 6\n\n    Example 2:\n        Input: \n            grid : [[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]]\n            bucket_capacity : 2\n        Output: 5\n    \n    Example 3:\n        Input: \n            grid : [[0,0,0], [0,0,0]]\n            bucket_capacity : 5\n        Output: 0\n\n    Constraints:\n        * all wells have the same length\n        * 1 <= grid.length <= 10^2\n        * 1 <= grid[:,1].length <= 10^2\n        * grid[i][j] -> 0 | 1\n        * 1 <= capacity <= 10\n    \"\"\"\n    return sum([math.floor(sum(arr)\/capacity) for arr in grid])\n"}
{"id":843,"bad_solution":"\ndef main():\n    n = int(input())\n    s = input()\n\n    for l in range(n\/\/2, 0, -1):\n        for offset in range(0,l):\n            s_set = set()\n            for i in range(0, n-l-offset+1):\n                curr_s = s[offset+i : offset+i+l : l]\n                if curr_s in s_set:\n                    print(l)\n                    return\n                s_set.add(curr_s)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":844,"bad_solution":"# とりあえずランレングスhttps:\/\/www.kabegiwablog.com\/entry\/2018\/04\/09\/100000\n# 引数を配列に格納\n# num = \"><>>><<><<<<<>>><\"\nnum = input()\n\n# 変数初期化\ncount = 1\nresult = ''\n\n# 配列全体のループ\nfor i in range(len(num)):\n    try:\n        if num[i] == num[i+1]:\n           count = count + 1\n        else:\n            result = result + str(count) + str(num[i])\n            count = 1\n    except:\n        # 最後の文字セットがOutOfRangeになるので結果に出力\n        result = result + str(count) + str(num[i])\n        \ndef sum_numbers(n):\n    if n ==0:\n        return 0\n    return n + sum_numbers(n-1)\n\nans = 0\nnum_list = []\nchar_list = []\n\nfor idx, char in enumerate(result):\n    if idx % 2 == 1:\n        char_list.append(char)\n    else:\n        num_list.append(int(char))\nif len(num_list) == 1:\n    ans = sum_numbers(num_list[0])\nelse:\n\tif char_list[0] == \"<\":\n\t    if len(char_list) % 2 == 1:\n\t        for i in range(0, len(num_list)-1, 2):\n\t#             print(num_list[i], num_list[i+1])\n\t            if num_list[i] < num_list[i+1]:\n\t                temp_sum = sum_numbers(num_list[i]-1) + sum_numbers(num_list[i+1])\n\t#             print(\"上\", temp_sum)\n\t                ans += temp_sum\n\t            else:\n\t                temp_sum = sum_numbers(num_list[i]) + sum_numbers(num_list[i+1]-1)\n\t#             print(\"下\", temp_sum)\n\t                ans += temp_sum\n\t#             print(ans)\n\t        ans += sum_numbers(num_list[-1])\n\t    else:\n\t        for i in range(0, len(num_list), 2):\n\t#             print(num_list[i], num_list[i+1])\n\t            if num_list[i] < num_list[i+1]:\n\t                temp_sum = sum_numbers(num_list[i]-1) + sum_numbers(num_list[i+1])\n\t#             print(\"上\", temp_sum)\n\t                ans += temp_sum\n\t            else:\n\t                temp_sum = sum_numbers(num_list[i]) + sum_numbers(num_list[i+1]-1)\n\t#             print(\"下\", temp_sum)\n\t                ans += temp_sum\n\t#             print(ans)\n\n\tif char_list[0] == \">\":\n\t#     print(\"test\",len(char_list)-1 % 2)\n\t    if (len(char_list)-1) % 2 == 1:\n\t        for i in range(1, len(num_list)-1, 2):\n\t#             print(num_list[i], num_list[i+1])\n\t            if num_list[i] < num_list[i+1]:\n\t                temp_sum = sum_numbers(num_list[i]-1) + sum_numbers(num_list[i+1])\n\t                ans += temp_sum\n\t            else:\n\t                temp_sum = sum_numbers(num_list[i]) + sum_numbers(num_list[i+1]-1)\n\t                ans += temp_sum\n\t        ans += sum_numbers(num_list[-1])\n\t    else:\n\t        for i in range(1, len(num_list), 2):\n\t#             print(num_list[i], num_list[i+1])\n\t            if num_list[i] < num_list[i+1]:\n\t                temp_sum = sum_numbers(num_list[i]-1) + sum_numbers(num_list[i+1])\n\t                ans += temp_sum\n\t            else:\n\t                temp_sum = sum_numbers(num_list[i]) + sum_numbers(num_list[i+1]-1)\n\t                ans += temp_sum\n\t    ans += sum_numbers(num_list[0])\n\nprint(ans)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":845,"bad_solution":"import sys\n\ndef r(n, k, sl):\n\n    sl.sort(key=lambda x: -x[1])\n    tl, dl = zip(*sl)\n\n    gmk = set()\n    ce = []\n    for s in sl[:k]:\n        if s[0] in gmk:\n            ce.append(s)\n        gmk.add(s[0])\n\n    gop = sum(dl[:k])\n    bmk = max(len(set(tl)), k)\n\n    gscr = len(gmk)**2 + gop\n\n    ce.sort(key=lambda x: x[1])\n    for c in ce[:bmk-len(gmk)]:\n        for s in sl[k:]:\n            if s[0] in gmk:\n                continue\n            k += 1\n            gmk.add(s[0])\n            gop = gop - c[1] + s[1]\n            nscr = len(gmk)**2 + gop\n            gscr = max(gscr, nscr)\n            break\n\n    return gscr\n\n\ndef main():\n    input = sys.stdin.readline\n    n, k = list(map(int, input().split()))\n    sl = [list(map(int, input().split())) for _ in range(n)]\n    print(r(n, k, sl))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":846,"bad_solution":"from fractions import Fraction\nn = int(input())\ncandidate = [sorted(list(input())) for _ in range(n)]\nans = 0\ncandidate.sort()\n\n# 有理数型をインポート\n# 組合せの総数\n\n\ndef comb(n, k):\n\n    if n < 0 or k < 0:\n        pdt = 0\n\n    else:\n        pdt = 1\n        for s in range(1, k + 1):\n            pdt *= Fraction(n - s + 1, s)\n\n    # 戻り値をint型にするために分子を取り出す\n    return pdt.numerator\n\n\ncnt = 1\nfor i in range(1, n):\n    if candidate[i] != candidate[i - 1]:\n        ans += comb(cnt, 2)\n        cnt = 1\n    else:\n        cnt += 1\n        if i == n - 1:\n            ans += comb(cnt, 2)\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":847,"bad_solution":"N, M, K = [int(x) for x in input().split()]\n\nA_BOOK = list([int(x) for x in input().split()])\nB_BOOK = list([int(x) for x in input().split()])\n\n\ndef read_book(read_time, book_count, a_remain, b_remain):\n\n    if a_remain:\n        a = a_remain[0]\n    else:\n        a = 10**9\n\n    if b_remain:\n        b = b_remain[0]\n    else:\n        b = 10*9\n\n    a_count = book_count\n    b_count = book_count\n\n    if read_time + a < K:\n        a_count = read_book(read_time + a, book_count +\n                            1, a_remain[1:], b_remain)\n\n    if read_time + b < K:\n        b_count = read_book(read_time + b, book_count +\n                            1, a_remain, b_remain[1:])\n\n    if a_count > b_count:\n        return a_count\n\n    return b_count\n\n\ncount = read_book(0, 0, A_BOOK, B_BOOK)\n\nprint(count)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":848,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nN = int(input())\nvvv = list(map(int, input().split()))\n\nvvv_odd = vvv[::2]\nvvv_even = vvv[1::2]\n\nodd_vocab = set(vvv_odd)\neven_vocab = set(vvv_even)\n\n\ndef calc_rewrite_number(vvv_each, vocab):\n    global N\n\n    max_count = -1\n    for v in vocab:\n        max_count = max(max_count, vvv_each.count(v))\n    return N \/\/ 2 - max_count\n\n\n# Calculation for odd and even elements in vvv\nn_rewrite = 0\nif len(odd_vocab & even_vocab) == 1:\n    print(N \/\/ 2)\n    exit()\nelse:\n    n_rewrite += calc_rewrite_number(vvv_odd, odd_vocab)\n    n_rewrite += calc_rewrite_number(vvv_even, even_vocab)\n\n# Output\nprint(n_rewrite)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":849,"bad_solution":"inf = float(\"INF\")\na,b,q = map(int, input().split())\ns = [None] * (a + 3)\ns[0:2] = [-inf,-inf]\ns[-1] = inf\nt = [None] * (b + 3)\nt[0:2] = [-inf,-inf]\nt[-1] = inf\nfor i in range(a):\n\ts[i+2] = int(input())\nfor i in range(b):\n\tt[i+2] = int(input())\n\nfrom bisect import bisect_left\n\ndp0 = [None] * (a+3)\ndp1 = [None] * (b+3)\n\ndef f(s,t,x,ss,i):\n  if i == 0 and dp0[ss] != None: return abs(x - s[ss]) + dp0[ss]\n  elif i == 1 and dp1[ss] != None: return abs(x - s[ss]) + dp1[ss]\n  tr = bisect_left(t, s[ss])\n  tl = tr - 1\n  if i == 0: dp0[ss] = min(abs(s[ss] - t[tl]), abs(s[ss] - t[tr]))\n  if i == 1: dp1[ss] = min(abs(s[ss] - t[tl]), abs(s[ss] - t[tr]))\n  return abs(x - s[ss]) + min(abs(s[ss] - t[tl]), abs(s[ss] - t[tr]))\n\n\nfor _ in range(q):\n  ans = inf\n  x = int(input())\n  sr = bisect_left(s, x)\n  ans = min(ans, f(s,t,x,sr,0))\n  ans = min(ans, f(s,t,x,sr - 1,0))\n  tr = bisect_left(t, x)\n  ans = min(ans, f(t,s,x,tr,1))\n  ans = min(ans, f(t,s,x,tr - 1,1))\n  print(ans)\n  \n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":850,"bad_solution":"\ndef FUNC(arr):\n    \"\"\"\n    In this Kata, you have to sort an array of non-negative integers according to\n    number of ones in their binary representation in ascending order.\n    For similar number of ones, sort based on decimal value.\n\n    It must be implemented like this:\n    >>> FUNC([1, 5, 2, 3, 4]) == [1, 2, 3, 4, 5]\n    >>> FUNC([-2, -3, -4, -5, -6]) == [-6, -5, -4, -3, -2]\n    >>> FUNC([1, 0, 2, 3, 4]) [0, 1, 2, 3, 4]\n    \"\"\"\n    return sorted(sorted(arr), key=lambda x: arr.count('1'))\n"}
{"id":851,"bad_solution":"import sys\n\n\nclass DataUnit(object):\n\n    def __init__(self, c, t):\n        self.c = c\n        self.t = t\n        pass\n\n\ndef judging_TIME(t, max_T):\n    if(t <= max_T): return True\n    else: return False\n\n\ndef judging_COST(datali):\n\n    min_cost = 10000\n    for d in datali:\n        if(d.c < min_cost):\n            min_cost = d.c\n\n    return min_cost\n\n\n# get from std-I\/O.\ndef loading_inputs():\n    N, T = raw_input().split()\n    N, T = int(N), int(T) \n\n    datalist = []\n    for i in range(N):\n        c_i, t_i = raw_input().split()\n        c_i, t_i = int(c_i), int(t_i)\n\n        if judging_TIME(t_i, T):\n            obj = DataUnit(c_i, t_i)\n            datalist.append(obj)\n\n    return datalist\n\n\n\n################################################\n################################################\n################################################\ndef main():\n\n    ans = 0\n    datali = loading_inputs()\n    ans = judging_COST(datali)\n    print ans\n\n\nif __name__ == \"__main__\":\n    main()\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":852,"bad_solution":"from itertools import product\nfrom collections import deque\nimport numpy as np\nclass Grid:\n    def __init__(self, grid, w=0, h=0, function=lambda x: x, space=1):\n        self.w = w = w if w else len(grid[0])\n        self.h = h = h if h else len(grid)\n        dtype = type(function(grid[0][0]))\n        self.grid = np.empty((h, w), dtype=dtype)\n        for i, row in zip(range(h), grid):\n            for j, val in zip(range(w), row):\n                self.grid[i][j] = function(val)\n        self.space = space\n    \n    def is_valid_x(self, x):\n        return 0 <= x < self.w\n    def is_valid_y(self, y):\n        return 0 <= y < self.h\n    def is_valid_xy(self, x, y):\n        return self.is_valid_x(x) and self.is_valid_y(y) \n    \n    def __iter__(self):\n        return iter(self.grid)\n    def __repr__(self):\n        return '\\n'.join(''.join(f'{{: >{self.space}}}'.format(x) for x in row) for row in self.grid) + '\\n'\n    def __getitem__(self, x):\n        return self.grid[x]\n    def __setitem__(self, x, val):\n        self.grid[x] = val\n\ndef bfs_01(G, start, goal):\n    Q = deque([start])\n    x, y = start\n    D = Grid(G.grid, function=lambda x:-9 if x=='#' else 10**6, space=4)\n    D[y, x] = 0\n    while Q:\n        x, y = Q.pop()\n        for dx, dy in product(range(-2, 3), repeat=2):\n            nx, ny = x+dx, y+dy\n            if dx==dy==0:\n                G[y, x] = '!'\n                continue\n            elif not G.is_valid_xy(nx, ny) or G[ny, nx] in '#!':\n                continue\n            elif abs(dx)+abs(dy)<=1:\n                G[y, x] = '!'\n                Q.append((nx, ny))\n                D[ny, nx] = D[y, x]\n            elif D[ny, nx] > D[y, x]+1:\n                Q.appendleft((nx, ny))\n                D[ny, nx] = D[y, x]+1       \n    x, y = goal\n    return D[y, x]\n\nh, w = map(int, input().split())\nsy, sx = map(int, input().split())\ngy, gx = map(int, input().split())\nsx, sy, gx, gy = sx-1, sy-1, gx-1, gy-1\ngrid = Grid([input() for s in range(h)], space=4)\nans = bfs_01(grid, (sx, sy), (gx, gy))\nprint(ans if ans != 10**6 else -1)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":853,"bad_solution":"# abc116_c.py\n# https:\/\/atcoder.jp\/contests\/abc116\/tasks\/abc116_c\n\n# C - Grand Garden \/\n# 実行時間制限: 2 sec \/ メモリ制限: 1024 MB\n# 配点 : 300点\n\n# 問題文\n# 花壇に N本の花が咲いており、それぞれ 1,2,......,N と番号が振られています。\n# 最初、全ての花の高さは 0 です。 数列 h={h1,h2,h3,......} が入力として与えられます。\n# 以下の「水やり」操作を繰り返すことで、すべての k(1≦k≦N) に対して花 k の高さを hkにしたいです。\n#     整数 l,rを指定する。l≦x≦r を満たすすべての x に対して、花 x の高さを 1高くする。\n# 条件を満たすための最小の「水やり」操作の回数を求めてください。\n\n# 制約\n#     1≦N≦100\n#     0≦hi≦100\n#     入力はすべて整数である。\n\n# 入力\n# 入力は以下の形式で標準入力から与えられます。\n# N\n# h1 h2 h3 ...... hN\n\n# 出力\n# 条件を満たすような最小の「水やり」操作の回数を出力してください。\n\n# 入力例 1\n# 4\n# 1 2 2 1\n\n# 出力例 1\n# 2\n\n# 「水やり」操作の回数は 2回が最小です。 以下が一つの例です。\n#     (l,r)=(1,3)の「水やり」操作を行う。\n#     (l,r)=(2,4)の「水やり」操作を行う。\n\n# 入力例 2\n# 5\n# 3 1 2 3 1\n\n# 出力例 2\n# 5\n\n# 入力例 3\n# 8\n# 4 23 75 0 23 96 50 100\n\n# 出力例 3\n# 221\n\n\ndef calculation(lines):\n    # X = lines[0]\n    N = int(lines[0])\n    values = list(map(int, lines[1].split()))\n    # values = list()\n    # for i in range(N):\n    #     values.append(int(lines[i+1]))\n\n    result = get_cnt(values)\n\n    return [result]\n\n\ndef get_cnt(values):\n    # print('----------------------------------------------')\n    # print(f'values=[{values}]')\n    ret = 0\n    mi = min(values)\n    # print(f'mi=[{mi}]')\n    ret += mi\n    values = [value - mi for value in values]\n    # print(f'values=[{values}]')\n    lst = None\n    for value in values:\n        # print(f'    value=[{value}], lst=[{lst}]')\n        if value != 0:\n            if lst is None:\n                lst = [value]\n            else:\n                lst.append(value)\n        else:\n            if lst is None:\n                pass\n            else:\n                ret += get_cnt(lst)\n                lst = None\n    if lst is not None:\n        ret += get_cnt(lst)\n    return ret\n\n\ndef func_f(n):\n    if n % 2 == 0:\n        return int(n\/2)\n    else:\n        return 3*n + 1\n\n\n# 引数を取得\ndef get_input_lines(lines_count):\n    lines = list()\n    for _ in range(lines_count):\n        lines.append(input())\n    return lines\n\n\n# テストデータ\ndef get_testdata(pattern):\n    if pattern == 1:\n        lines_input = ['4', '1 2 2 1']\n        lines_export = [2]\n    if pattern == 2:\n        lines_input = ['5', '3 1 2 3 1']\n        lines_export = [5]\n    if pattern == 3:\n        lines_input = ['8', '4 23 75 0 23 96 50 100']\n        lines_export = [221]\n    return lines_input, lines_export\n\n\n# 動作モード判別\ndef get_mode():\n    import sys\n    args = sys.argv\n    if len(args) == 1:\n        mode = 0\n    else:\n        mode = int(args[1])\n    return mode\n\n\n# 主処理\ndef main():\n    import time\n    started = time.time()\n    mode = get_mode()\n    if mode == 0:\n        lines_input = get_input_lines(2)\n    else:\n        lines_input, lines_export = get_testdata(mode)\n\n    lines_result = calculation(lines_input)\n\n    for line_result in lines_result:\n        print(line_result)\n\n    if mode > 0:\n        print(f'lines_input=[{lines_input}]')\n        print(f'lines_export=[{lines_export}]')\n        print(f'lines_result=[{lines_result}]')\n        if lines_result == lines_export:\n            print('OK')\n        else:\n            print('NG')\n    finished = time.time()\n    duration = finished - started\n    print(f'duration=[{duration}]')\n\n\n# 起動処理\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":854,"bad_solution":"import sys,collections as cl,bisect as bs,math,heapq as hq\nsys.setrecursionlimit(100000)\nMax = sys.maxsize\ndef l(): #intのlist\n\treturn list(map(int,input().split()))\ndef m(): #複数文字\n\treturn map(int,input().split())\ndef onem(): #Nとかの取得\n\treturn int(input())\ndef s(x): #圧縮\n\ta = []\n\taa = x[0]\n\tsu = 1\n\tfor i in range(len(x)-1):\n\t\tif aa == x[i+1]:\n\t\t\ta.append([aa,su])\n\t\t\taa = x[i+1]\n\t\t\tsu = 1\n\t\telse:\n\t\t\tsu += 1\n\ta.append([aa,su])\n\treturn a\ndef jo(x): #listをスペースごとに分ける\n\treturn \" \".join(map(str,x))\ndef max2(x): #他のときもどうように作成可能\n\treturn max(map(max,x))\n\ndef LIS(L):\n  L.sort(reverse = True)\n  LIS=[L[0]]\n  L.pop()\n  for i in L:\n    if i >= LIS[-1]:\n      LIS.append(i)\n    else:\n      LIS[bs.bisect_left(LIS,i)]=i\n  return len(LIS)\n\nn = onem()\n\na = []\nc = 0\nfor i in range(n):\n\ta.append(onem())\naa = []\nco = 0\n\nprint(LIS(a))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":855,"bad_solution":"\ndef FUNC(s, n):\n    \"\"\"Given a string s and a natural number n, you have been tasked to implement \n    a function that returns a list of all words from string s that contain exactly \n    n consonants, in order these words appear in the string s.\n    If the string s is empty then the function should return an empty list.\n    Note: you may assume the input string contains only letters and spaces.\n    Examples:\n    FUNC(\"Mary had a little lamb\", 4) ==> [\"little\"]\n    FUNC(\"Mary had a little lamb\", 3) ==> [\"Mary\", \"lamb\"]\n    FUNC(\"simple white space\", 2) ==> []\n    FUNC(\"Hello world\", 4) ==> [\"world\"]\n    FUNC(\"Uncle sam\", 3) ==> [\"Uncle\"]\n    \"\"\"\n    result = []\n    for word in s.split():\n        n_consonants = 0\n        for i in range(0, len(word)):\n            if word[i].lower() in [\"a\",\"e\",\"i\",\"o\",\"u\"]:\n                n_consonants += 1 \n        if n_consonants == n:\n            result.append(word)\n    return result\n\n"}
{"id":856,"bad_solution":"from collections import deque\nimport sys\n\nH, W = map(int, input().split())\nxs, ys = map(int, input().split())\nxt, yt = map(int, input().split())\nxs -= 1\nys -= 1\nxt -= 1\nyt -= 1\nG = [input() for _ in range(H)]\n\nD_wk = [[1,0], [0,1], [-1,0], [0,-1]]\nD_tl = 2\n\n#cost = [[-1  for _ in range(W)] for _ in range(H)]\n\npossible = set()\nfor i in range(H):\n  for j in range(W):\n    if G[i][j] == \".\":\n      possible.add(i * W + j)\n\n# 01-BFS\ndef append_walk(c, x, y):\n  for dx, dy in D_wk:\n    if 0 <= x+dx <= H-1 and 0 <= y+dy <= W-1 and ((x+dx)*W+(y+dy)) in possible and ((x+dx)*W+(y+dy)) not in visited:\n      task.appendleft([c, x+dx, y+dy])\ndef append_tele(c, x, y):\n  for dx in range(-D_tl, D_tl+1):\n    for dy in range(-D_tl, D_tl+1):\n      if 0 <= x+dx <= H-1 and 0 <= y+dy <= W-1 and ((x+dx)*W+(y+dy)) in possible and ((x+dx)*W+(y+dy)) not in visited:\n        task.append([c+1, x+dx, y+dy])\n\ntask = deque([[0, xs, ys]])\nvisited = set()\nwhile task:\n  while True:\n    c, x, y = task.popleft()\n    if x*W+y not in visited:\n      break\n    if not task:\n      print(-1)\n      sys.exit()    \n  if x == xt and y == yt:\n    print(c)\n    #print(*cost, sep=\"\\n\")\n    sys.exit()  \n  visited.add(x*W+y)\n  #cost[x][y] = c\n  append_walk(c, x, y)\n  append_tele(c, x, y)\n  \nprint(-1)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":857,"bad_solution":"import sys\n\nclass RMQ(): #range minimum query\n    def __init__(self, N, V): #create segment tree with initial value V\n        d, k = 1, 0\n        while d < N:\n            d <<= 1\n            k += 1\n        self.tree = [V for _ in range(2 * d - 1)]\n        self.size = d \n    \n    def update(self, i, a): #update cell i by value a\n        now = self.size - 1 + i \n        self.tree[now] = {a}\n        while now > 0:\n            now = (now - 1) \/\/ 2\n            self.tree[now] = self.tree[2 * now + 1] | self.tree[2 * now + 2]\n        #print(self.tree)\n\n    def search(self, lower, higher, lbound, hbound, pos): #search minimum value of [lower, higher) init: lbound = 0, hbound = self.size, pos = 0\n        if higher <= lbound or hbound <= lower: return set()\n        if lower <= lbound and hbound <= higher: return self.tree[pos]\n        else:\n            left = self.search(lower, higher, lbound, (lbound + hbound) \/\/ 2, 2 * pos + 1)\n            right = self.search(lower, higher, (lbound + hbound) \/\/ 2, hbound, 2 * pos + 2)\n            return left | right\n\n\ndef solve():\n    input = sys.stdin.readline\n    N = int(input())\n    S = list(input().strip(\"\\n\"))\n    SegTree = RMQ(N, set())\n    for i, s in enumerate(S): SegTree.update(i, s)\n    Q = int(input())\n    Ans = []\n    for _ in range(Q):\n        t, l, r = input().strip(\"\\n\").split()\n        if t == \"1\": SegTree.update(int(l) - 1, r)\n        elif t == \"2\": \n            Ans.append(len(SegTree.search(int(l) - 1, int(r), 0, SegTree.size, 0)))\n    for a in Ans: print(a)\n    \n\n    return 0\n\nif __name__ ==\"__main__\":\n    solve()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":858,"bad_solution":"import sys\n\n# import bisect\n# import numpy as np\nfrom collections import deque\n# map(int, sys.stdin.read().split())\n# import heapq\n# import bisect\n# import math\nimport itertools\nfrom collections import Counter\nimport numpy as np\n\n\ndef input():\n    return sys.stdin.readline().rstrip()\n\n\ndef main():\n    mod =998244353\n    N, S = map(int, input().split())\n    A = list(map(int, input().split()))\n\n    dp =[[0]*(S+1) for _ in range(N+1)]\n    dp[0][0]=1\n    for i in range(0,N):\n        for j in range(S+1):\n            if A[i]>j:\n                dp[i+1][j] =dp[i][j]*2\n                dp[i+1][j] %= mod\n            else:\n                dp[i+1][j] = dp[i][j]*2 + dp[i][j-A[i]]\n                dp[i+1][j] %= mod\n    print(dp[N][S]%mod)\n    pass\n\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":859,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\nimport math\nfrom bisect import bisect_left\nfrom bisect import bisect_right\nimport collections\nimport copy\nimport heapq\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\nimport itertools\ninput = sys.stdin.readline\nfrom collections import defaultdict\nfrom heapq import heappop, heappush\n\nfrom decimal import *\n\n##### リストの 二分木検索 #####\n# bisect_left(lists, 3)\n# bisect_right(lists, 3)\n\n##### プライオリティキュー #####\n# heapq.heapify(a) #リストaのheap化\n# heapq.heappush(a,x) #heap化されたリストaに要素xを追加\n# heapq.heappop(a) #heap化されたリストaから最小値を削除＆その最小値を出力\n\n# heapq.heappush(a, -x) #最大値を取り出す時は、pushする時にマイナスにして入れよう\n# heapq.heappop(a) * (-1) #取り出す時は、-1を掛けて取り出すこと\n\n##### タプルリストのソート #####\n# sorted(ans) #(a, b) -> 1st : aの昇順, 2nd : bの昇順\n# sorted(SP, key=lambda x:(x[0],-x[1])) #(a, b) -> 1st : aの昇順, 2nd : bの降順\n# sorted(SP, key=lambda x:(-x[0],x[1])) #(a, b) -> 1st : aの降順, 2nd : bの昇順\n# sorted(SP, key=lambda x:(-x[0],-x[1])) #(a, b) -> 1st : aの降順, 2nd : bの降順\n\n# sorted(SP, key=lambda x:(x[1])) #(a, b) -> 1st : bの昇順\n# sorted(SP, key=lambda x:(-x[1])) #(a, b) -> 1st : bの降順\n\n##### 累乗 #####\n# pow(x, y, z) -> x**y % z\n\n##### 割り算の切り上げ #####\n# tmp = -(-4 \/\/ 3)\n\n##### dict の for文 #####\n# for k, v in d.items():\n#     print(k, v)\n\n##### 進数の変換 #####\n# bin_str = bin(i)[2:]\n# oct_str = oct(i)[2:]\n# hex_str = hex(i)[2:]\n\ndef inputInt(): return int(input())\ndef inputMap(): return map(int, input().split())\ndef inputList(): return list(map(int, input().split()))\ndef inputStr(): return input()[:-1]\n\ninf = float('inf')\nmod = 1000000007\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n\ndef main():\n\tgetcontext().prec = 18\n\tA,B  = map(float, input().split())\n\n\tnumA = Decimal(A)\n\tnumB = Decimal(B)\n\tans = Decimal(numA*numB)\n\n\ts = str(ans)\n\tS = s.split(\".\")\n\tprint(S[0])\n\n\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n# 2分検索のリバース\ndef bisect_left_reverse(a, x):\n    if a[0] <= x:\n        return 0\n    if x < a[-1]:\n        return len(a)\n    # 二分探索\n    ok = len(a) - 1\n    ng = 0\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) \/\/ 2\n        if a[mid] <= x:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\ndef bisect_right_reverse(a, x):\n    if a[0] < x:\n        return 0\n    if x <= a[-1]:\n        return len(a)\n    # 二分探索\n    ok = len(a) - 1\n    ng = 0\n    while (abs(ok - ng) > 1):\n        mid = (ok + ng) \/\/ 2\n        if a[mid] < x:\n            ok = mid\n        else:\n            ng = mid\n    return ok\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n# 2分検索\n# 存在しない場合: None 存在する場合: その値\ndef binary_search(list, item):\n    low = 0\n    high = len(list) - 1\n\n    while low <= high:\n        mid = (low + high) \/\/2\n        guess = list[mid]\n        if guess == item:\n            return mid\n        if guess > item:\n            high = mid -1\n        else:\n            low = mid + 1\n    return None\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n# N 個のボールを K グループに分ける場合のパターン数\ndef sunuke(N, K, mod=10**9+7):\n\tif N < K or K-1 < 0:\n\t\treturn 0\n\telse:\n\t\treturn combination(N-1, K-1, mod)\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n# nCr mod m\n# rがn\/2に近いと非常に重くなる\ndef combination(n, r, mod=10**9+7):\n    r = min(r, n-r)\n    res = 1\n    for i in range(r):\n        res = res * (n - i) * modinv(i+1, mod) % mod\n    return res\n\n# mを法とするaの乗法的逆元\ndef modinv(a, mod=10**9+7):\n    return pow(a, mod-2, mod)\n\ndef egcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        g, y, x = egcd(b % a, a)\n        return g, x - (b \/\/ a) * y, y\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n# nHr mod m\n# 問題によって、combination()を切り替えること\ndef H(n, r, mod=10**9+7):\n\t# comb = Combination(n+r-1, mod)\n\t# return comb(n+r-1, r)\n    return combination(n+r-1, r, mod)\n\n\nclass Combination:\n    \"\"\"\n    O(n)の前計算を1回行うことで，O(1)でnCr mod mを求められる\n    n_max = 10**6のとき前処理は約950ms (PyPyなら約340ms, 10**7で約1800ms)\n    使用例：\n    comb = Combination(1000000)\n    print(comb(5, 3))  # 10\n    \"\"\"\n    def __init__(self, n_max, mod=10**9+7):\n        self.mod = mod\n        self.modinv = self.make_modinv_list(n_max)\n        self.fac, self.facinv = self.make_factorial_list(n_max)\n\n    def __call__(self, n, r):\n        return self.fac[n] * self.facinv[r] % self.mod * self.facinv[n-r] % self.mod\n\n    def make_factorial_list(self, n):\n        # 階乗のリストと階乗のmod逆元のリストを返す O(n)\n        # self.make_modinv_list()が先に実行されている必要がある\n        fac = [1]\n        facinv = [1]\n        for i in range(1, n+1):\n            fac.append(fac[i-1] * i % self.mod)\n            facinv.append(facinv[i-1] * self.modinv[i] % self.mod)\n        return fac, facinv\n\n    def make_modinv_list(self, n):\n        # 0からnまでのmod逆元のリストを返す O(n)\n        modinv = [0] * (n+1)\n        modinv[1] = 1\n        for i in range(2, n+1):\n            modinv[i] = self.mod - self.mod\/\/i * modinv[self.mod%i] % self.mod\n        return modinv\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n# dfs のサンプル\ndef dfs(graph,parent,counter,edge):\n    stk = []\n    stk.append(edge)\n    while len(stk) > 0:\n        p = stk.pop()\n        for e in graph[p]:\n            if parent[p] == e:\n                continue\n            else:\n                parent[e] = p\n                counter[e] += counter[p]\n                stk.append(e)\n\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\n#-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-\nif __name__ == \"__main__\":\n\tmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":860,"bad_solution":"import sys\n# from math import sqrt, gcd, ceil, log\nfrom bisect import bisect\nfrom collections import defaultdict, Counter\ninp = sys.stdin.readline\nread = lambda: list(map(int, inp().strip().split()))\n\n# sys.setrecursionlimit(10**6)\n\n\n\ndef solve():\n\ta, b, k = read(); a_ = read(); b_ = read()\n\tfor i in range(1, a): a_[i] += a_[i-1]\n\tfor i in range(1, b): b_[i] += b_[i-1]\n\tans = 0\n\twhile k > 0:\n\t\tinda = bisect(a_, k); indb = bisect(b_, k)\n\t\t# print(k, inda, indb, a_[inda-1], b_[indb-1])\n\t\tif inda > indb:\n\t\t\tk -= a_[inda-1];\n\t\t\tans += inda\n\t\t\ta_ = a_[inda:]\n\t\telif inda == indb:\n\t\t\tif a_[inda-1] < b_[indb-1]:\n\t\t\t\tk -= a_[inda-1];\n\t\t\t\tans += inda\n\t\t\t\ta_ = a_[inda:]\n\t\t\telse:\n\t\t\t\tk -= b_[indb-1];\n\t\t\t\tans += indb\n\t\t\t\tb_ = b_[indb:]\n\t\telse:\n\t\t\tk -= b_[indb-1];\n\t\t\tans += indb\n\t\t\tb_ = b_[indb:]\n\n\n\tprint(ans)\n\n\n\n\n\n\t\t\n\nif __name__ == \"__main__\":\n\tsolve()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":861,"bad_solution":"from _collections import deque\nfrom _ast import Num\n\n\ndef parser():\n    while 1:\n        data = list(input().split(' '))\n        for number in data:\n            if len(number) > 0:\n                yield (number)\n\n\ninput_parser = parser()\n\n\ndef gw():\n    global input_parser\n    return next(input_parser)\n\n\ndef gi():\n    data = gw()\n    return int(data)\n\n\nMOD = int(1e9 + 7)\n\nimport numpy\nfrom collections import deque\nfrom math import sqrt\nfrom math import floor\n# https:\/\/atcoder.jp\/contests\/agc033\/tasks\/agc033_b\n# B - LRUD Game\n\"\"\"\n\"\"\"\nH = gi()\nW = gi()\nN = gi()\nsr = gi()\nsc = gi()\nS = gw()\nT = gw()\nd_to_i = {\"L\": 0, \"R\": 1, \"U\": 2, \"D\": 3}\ncnt = [[0 for x in range(4)] for i in range(2)]\n\n\ndef o(pos, si, ti, d, sb, tb):\n    for i in range(N):\n        if (d_to_i[S[i]] == si):\n            pos += d\n            if pos == sb:\n                return 1\n        if (d_to_i[T[i]] == ti):\n            if (pos - d != tb):\n                pos -= d\n    return 0\n\n\noff = 0\nfor i in range(N):\n    #  print(cnt)\n    off = o(sc, 0, 1, -1, 0, W + 1)\n    off = off or o(sc, 1, 0, 1, W + 1, 0)\n    off = off or o(sr, 2, 3, -1, 0, H + 1)\n    off = off or o(sr, 3, 2, 1, H + 1, 0)\n\nif off:\n    print(\"NO\")\nelse:\n    print(\"YES\")\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":862,"bad_solution":"from collections import deque\n\n\ndef main():\n    n, m, k = [int(x) for x in input().split()]\n    array_a = deque(int(x) for x in input().split())\n    array_b = deque(int(x) for x in input().split())\n    count = 0\n    inf = 1000000001\n    book_a, book_b = -1, -1\n    while True:\n        if book_a == -1:\n            try:\n                book_a = array_a.popleft()\n            except IndexError:\n                book_a = inf\n        if book_b == -1:\n            try:\n                book_b = array_b.popleft()\n            except IndexError:\n                book_b = inf\n\n        if book_a <= book_b:\n            to_read = book_a\n            book_a = -1\n        else:\n            to_read = book_b\n            book_b = -1\n\n        if k >= to_read:\n            k -= to_read\n            count += 1\n        else:\n            break\n    print(count)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":863,"bad_solution":"import sys\n\nsys.setrecursionlimit(10 ** 7)\nINF = 10 ** 9 + 7\n\ndef P(m, n):\n    num = 1\n    for i in range(n):\n        num *= m-i\n    return num\n\n\nn, k = list(map(int, sys.stdin.readline().split()))\ngraph = [dict() for i in range(n)]\nfor i in range(n):\n    graph[i][\"eda\"]=[]\nfor i in range(n - 1):\n    a, b = list(map(int, sys.stdin.readline().split()))\n    graph[a - 1][\"eda\"].append(b - 1)\n    graph[b - 1][\"eda\"].append(a - 1)\nans = 1\ncheck = [False] * n\nstack = [0]\nans = 1\nwhile len(stack) > 0:\n    x = stack.pop()\n    check[x] = True\n    count = 0\n    for i in graph[x][\"eda\"]:\n        if not check[i]:\n            count += 1\n            stack.append(i)\n    if x == 0:\n        temp = P(k - 1, count)\n        ans = (ans * temp) % INF\n    else:\n        temp = P(k - 2, count)\n        ans = (ans * temp) % INF\n\nprint((ans * k) % INF)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":864,"bad_solution":"\ndef FUNC(word):\n    \"\"\"You are given a word. Your task is to find the closest vowel that stands between \n    two consonants from the right side of the word (case sensitive).\n    \n    Vowels in the beginning and ending doesn't count. Return empty string if you didn't\n    find any vowel met the above condition. \n\n    You may assume that the given string contains English letter only.\n\n    Example:\n    FUNC(\"yogurt\") ==> \"u\"\n    FUNC(\"FULL\") ==> \"U\"\n    FUNC(\"quick\") ==> \"\"\n    FUNC(\"ab\") ==> \"\"\n    \"\"\"\n    if len(word) < 3:\n        return \" \"\n\n    vowels = {\"a\", \"e\", \"i\", \"o\", \"u\", \"A\", \"E\", 'O', 'U', 'I'}\n    for i in range(len(word)-2, 0, -1):\n        if word[i] in vowels:\n            if (word[i+1] not in vowels) and (word[i-1] not in vowels):\n                return word[i]\n    return \" \"\n"}
{"id":865,"bad_solution":"def examA():\n    N = DI()\/dec(7)\n    ans = N\n    print(N)\n    return\n\ndef examB():\n    ans = 0\n    print(ans)\n    return\n\ndef examC():\n    ans = 0\n    print(ans)\n    return\n\ndef examD():\n    ans = 0\n    print(ans)\n    return\n\ndef examE():\n    ans = 0\n    print(ans)\n    return\n\ndef examF():\n    N, K = LI()\n    H = LI()\n    H.insert(0,0)\n    dp = [[[inf]*(K+1)for _ in range(N+1)] for _ in range(N+1)]\n    dp[0][0][0] = 0\n    for i in range(N):\n        for j in range(i+1):\n            for k in range(K+1):\n                dp[i+1][i+1][k] = min(dp[i+1][i+1][k],dp[i][j][k]+max(0,H[i+1]-H[j]))\n                if k<K:\n                    dp[i+1][j][k+1] = min(dp[i+1][j][k+1],dp[i][j][k])\n\n    ans = dp[-1][-1][-1]\n    #for v in dp:\n    #    print(v)\n    print(ans)\n    return\n\nfrom decimal import getcontext,Decimal as dec\nimport sys,bisect,itertools,heapq,math,random\nfrom copy import deepcopy\nfrom heapq import heappop,heappush,heapify\nfrom collections import Counter,defaultdict,deque\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\ndef I(): return int(input())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\ndef DI(): return dec(input())\ndef LDI(): return list(map(dec,sys.stdin.readline().split()))\ndef LSI(): return list(map(str,sys.stdin.readline().split()))\ndef LS(): return sys.stdin.readline().split()\ndef SI(): return sys.stdin.readline().strip()\nglobal mod,mod2,inf,alphabet,_ep\nmod = 10**9 + 7\nmod2 = 998244353\ninf = 10**18\n_ep = dec(\"0.000000000001\")\nalphabet = [chr(ord('a') + i) for i in range(26)]\nalphabet_convert = {chr(ord('a') + i): i for i in range(26)}\n\ngetcontext().prec = 28\n\nsys.setrecursionlimit(10**7)\n\nif __name__ == '__main__':\n    examF()\n\n\"\"\"\n142\n12 9 1445 0 1\nasd dfg hj o o\naidn\n\"\"\"\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":866,"bad_solution":"class Tree:\n  C, RL = {}, {}\n  R, N, D, S, P = None, None, None, None, None\n  SN = None\n  def __init__(s, num):\n    s.N = num\n  def set(s, a, b):\n    if a in s.C: s.C[a].append(b)\n    else: s.C[a] = [b]\n    if b in s.C: s.C[b].append(a)\n    else: s.C[b] = [a]\n  def makeRank(s, root):\n    s.R = [0] * s.N #各ノードのランク\n    s.R[root] = 1\n    s.RL[1] = [root] #各ランクのノード\n    s.S = [[] for _ in range(s.N)] #各ノードの子ノード\n    s.P = [-1] * s.N #各ノードの親ノード\n    F = [root]\n    s.D = 2\n    while F != []:\n      Ft = []\n      s.RL[s.D] = []\n      for i in F:\n        for j in s.C[i]:\n          if s.R[j] == 0:\n            s.R[j] = s.D\n            Ft.append(j)\n            s.RL[s.D].append(j)\n            s.S[i].append(j)\n            s.P[j] = i\n      s.D += 1\n      F = Ft\n  def dfs(s, x): #最遠のノード,距離\n    t = [-1] * s.N\n    S = [x]\n    ans = x\n    ansn = 0\n    t[x] = 0\n    while S != []:\n      k = S.pop()\n      for i in s.C[k]:\n        if t[i] == -1:\n          t[i] = t[k] + 1\n          S.append(i)\n          if t[i] > ansn:\n            ansn = t[i]\n            ans = i\n    return ans, ansn\n  def getDi(s, x = 0): #直径\n    a, _ = s.dfs(x)\n    b, ans = s.dfs(a)\n    return ans\n  def getDeep(s, x): #xの子孫のうち一番深い深さ\n    ans = 0\n    if x in s.S:\n      for i in s.S[x]:\n        ans = max(ans, s.getDeep(i))\n      return ans + 1\n    else:\n      return 0\n  def getParent(s, x, n): #xのn世代前の親\n    if n == 0:\n      return x\n    if s.P[x] == -1:\n      return -n\n    return s.getParent(s.P[x], n - 1)\n  def countSon(s):\n    s.SN = [0] * s.N\n    for i in range(s.D - 1, 0, -1):\n      for j in s.RL[i]:\n        cnt = 1\n        for k in s.S[j]:\n          cnt += s.SN[k]\n        s.SN[j] = cnt\n\nclass powmod():\n  F = [1, 2]\n  Fi = [1, 2]\n  I = [0, 1]\n  def __init__(self, num, mod):\n    self.MOD = mod\n    k = 2\n    for i in range(2, num + 1):\n      self.F.append((self.F[-1] * k) % mod)\n      self.I.append(mod - self.I[mod % k] * (mod \/\/ k) % mod)\n      self.Fi.append(self.Fi[-1] * self.I[k] % mod)\n\nclass Inv:\n  def __init__(s, mod):\n    s.MOD = mod\n  def modpow(s, a, n):\n    res = 1\n    while n > 0:\n      if n & 1:\n        res = res * a % s.MOD\n      a = a * a % s.MOD\n      n >>= 1\n    return res\n  def invx(s, a):\n    return s.modpow(a, s.MOD - 2)\n  def invL(s, a, n):\n    ia = s.invx(a)\n    L = [1] * (n + 1)\n    for i in range(1, n + 1):\n      L[i] = L[i - 1] * ia % s.MOD\n    return L\n\n\nN = int(input())\nAB = [list(map(int, input().split())) for _ in range(N - 1)]\n\nT = Tree(N)\nL = [0] * N\nfor a, b in AB:\n  T.set(a - 1, b - 1)\n  L[a - 1] += 1\n  L[b - 1] += 1\n\nfor i in range(N):\n  if L[i] == 1:\n    root = i\n\nT.makeRank(root)\nT.countSon()\n\nMOD = 10 ** 9 + 7\nans = 0\n\n\nPM = powmod(N, MOD)\nI = Inv(MOD)\n\nans = 0\nfor i in range(N):\n  if i == root: continue\n  if T.S[i] == []: continue\n  L = []\n  cnt = 0\n  for j in T.S[i]:\n    L.append(T.SN[j])\n    cnt += T.SN[j]\n  L.append(N - cnt - 1)\n\n  t = PM.F[N - 1] - 1\n  for j in L:\n    t = t - PM.F[j] + 1\n    if t < 0:\n      t += MOD\n  ans = (ans + t * I.invx(PM.F[N])) % MOD\n\nprint(ans)\n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":867,"bad_solution":"from operator import itemgetter\n\n\ndef main():\n    n, m = list(map(int, input().split()))\n    alist = list(map(int, input().split()))\n    bc = []\n    for _ in range(m):\n        b, c = list(map(int, input().split()))\n        bc.append((b, c))\n\n    asorted = sorted(alist)\n\n    bc = sorted(bc, key=itemgetter(1), reverse=True)\n\n    # print(f'initial: {asorted}')\n    # print(f'bc: {bc}')\n\n    fixed = []\n    for b, c in bc:\n        pick = [a for a in asorted if a >= c]\n\n        if len(pick) > 0:\n            asorted = asorted[:-len(pick)]\n            fixed += pick\n\n        if len(asorted) < 1:\n            break\n\n        for _ in range(b):\n            if len(asorted) < 1:\n                break\n            asorted.pop(0)\n            fixed.insert(0, c)\n\n        # print(f'--- step n \/ {len(bc)} ---')\n        # print(f'asorted: {asorted}')\n        # print(f'pick   : {pick}')\n        # print(f'fixed  : {fixed}')\n\n    fixed += asorted\n\n    print(sum(fixed))\n\n\nmain()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":868,"bad_solution":"\ndef FUNC(lst):\n    '''\n    You are given a list of two strings, both strings consist of open\n    parentheses '(' or close parentheses ')' only.\n    Your job is to FUNC if it is possible to concatenate the two strings in\n    some order, that the resulting string will be good.\n    A string S is considered to be good if and only if all parentheses in S\n    are balanced. For example: the string '(())()' is good, while the string\n    '())' is not.\n    Return 'Yes' if there's a way to make a good string, and return 'No' otherwise.\n\n    Examples:\n    FUNC(['()(', ')']) == 'Yes'\n    FUNC([')', ')']) == 'No'\n    '''\n    def FUNC(s):\n        val = 0\n        for i in s:\n            if i == '(':\n                val = val + 1\n            else:\n                val = val - 1\n            if val < 0:\n                return False\n        return True if val == 0 else False\n\n    S1 = lst[0] + lst[1]\n    S2 = lst[1] + lst[0]\n    return 'yes' if FUNC(S1) or FUNC(S2) else 'no'\n"}
{"id":869,"bad_solution":"import numpy as np\nfrom bisect import *\nn, m = map(int, input().split())\nA, B, C = zip(*(map(int, input().split()) for _ in range(n)))\nD, E, F = zip(*(map(int, input().split()) for _ in range(m)))\nX = sorted(set(C + E + F))\nY = sorted(set(A + B + D))\nH = len(Y)-1\nW = len(X)-1\ndef TX(i):\n    return bisect(X, i)-1\ndef TY(i):\n    return bisect(Y, i)-1\nU = np.ones((H+1, W))\nfor d, e, f in zip(D, E, F):\n    d, e, f = TY(d), TX(e), TX(f)\n    U[d, e:f] = False\nL = np.ones((H, W+1))\nfor a ,b, c in zip(A, B, C):\n    a, b, c = TY(a), TY(b), TX(c)\n    L[a:b, c] = False\nS = np.outer(np.diff(Y), np.diff(X)) \ni = bisect(Y, 0)-1\nj = bisect(X, 0)-1\ns = [(i,j)]\nv = set()\nr = 0\nwhile s:\n    i, j = s.pop()\n    if (i,j) in v:\n        continue\n    v.add((i,j))\n    if not (0<=i<H and 0<=j<W):\n        print('INF')\n        break\n    r += S[i][j]\n    if U[i][j]:\n        s.append((i-1,j))\n    if U[i+1][j]:\n        s.append((i+1,j))\n    if L[i][j]:\n        s.append((i,j-1))\n    if L[i][j+1]:\n        s.append((i,j+1))\nelse:\n    print(r)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":870,"bad_solution":"N, K = list(map(int, input().split()))\nlinks = [list(map(int, input().split())) for _ in range(N-1)]\n\ndef perm(a, b):\n    s = 1\n    for i in range(a-b+1, a+1):\n        s *= i\n    return s\n\ndef main():\n    if N == 1:\n        return K\n    d = {i: set() for i in range(1, N+1)}\n    for i, j in links:\n        d[i].add(j)\n        d[j].add(i)\n    history = {1}\n    stack = d[1]\n    b = len(stack)\n    if K - 1 < b:\n        return 0\n    d.pop(1)\n    ans = K * perm(K - 1, b)\n    a = K - 2\n    lim = max([len(x) for x in d.values()])\n    if lim - 1 > a:\n        return 0\n    lim += 1\n    perm_list = [None] * lim\n    perm_list[0] = 1\n    for i in range(1, lim):\n        perm_list[i] = perm_list[i-1] * (a + 1 - i)\n    while stack:\n        node = stack.pop()\n        history.add(node)\n        ans *= perm_list[len(d[node]) - 1]\n        for i in d[node]:\n            if i not in history:\n                stack.add(i)\n    return ans\n    \nprint(main() % 1000000007)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":871,"bad_solution":"import sys\nsys.setrecursionlimit(10**6)\nreadline = sys.stdin.readline\n \nMAXN = 1005\nMAXV = MAXN*(MAXN-1)\/\/2\n \nto = [[] for _ in range(MAXV)]\nid = [[[] for _ in range(MAXN)] for _ in range(MAXN)]\n \ndef toId(i, j):\n    if i > j:\n        i, j = j, i\n    return id[i][j]\nvisited = [False] * MAXV\ncalculated = [False] * MAXN\ndp = [1] * MAXV\n \ndef dfs(v):\n    if visited[v]:\n        if not calculated[v]:\n            return -1\n        return dp[v]\n    visited[v] = True\n    dp[v] = 1\n \n    for u in to[v]:\n        res = dfs(u)\n        if res == -1: return -1\n        dp[v] = max(dp[v], res+1)\n    calculated[v] = True\n    return dp[v]\n \ndef main():\n    n = int(input())\n    a = [[int(i) for i in readline().split()] for _ in range(n)]\n    \n    for i in range(n):\n        for j in range(n-1):\n            a[i][j] -= 1\n    V = 0\n    for i in range(n):\n        for j in range(n):\n            if i < j:\n                id[i][j] = V\n                V += 1\n    \n    for i in range(n):\n        for j in range(n-1):\n            a[i][j] = toId(i, a[i][j])\n        for j in range(n-2):\n            to[a[i][j+1]].append(a[i][j])\n    \n    ans = 0\n    \n    for i in range(V):\n        res = dfs(i)\n        if res == -1:\n            print('-1')\n            return\n        ans = max(ans, res)\n    print(ans)\n    return\n  \nif __name__ == '__main__':\n    main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":872,"bad_solution":"def calcsum(n):\n    return n * (n + 1) \/\/ 2\n\ns = str(input())\nn = len(s) + 1\narrk = []\narrg = []\ntmp = s[0]\ncnt = 1\nfor i in range(1, n-1):\n    if s[i] == tmp:\n        cnt += 1\n    elif s[i] != tmp:\n        if tmp == '<':\n            arrk.append(cnt)\n        else:\n            arrg.append(cnt)\n        cnt = 1\n        tmp = s[i]\nif tmp == '<':\n    arrk.append(cnt)\nelse:\n    arrg.append(cnt)\n#print(arrk, arrg)\nans = 0\nfor i in range(len(arrk)):\n    #print(calcsum(arrk[i]-1))\n    ans += calcsum(arrk[i]-1)\nfor i in range(len(arrg)):\n    #print(calcsum(arrg[i]-1))\n    ans += calcsum(arrg[i]-1)\n#print('ans',ans)\nif s[0] == '<':\n    for i in range(len(arrg)):\n        #print('a', max(arrg[i], arrk[i]))\n        ans += max(arrg[i], arrk[i])\nelif s[0] == '>':\n    ans += arrg[0]\n    for i in range(len(arrk)-1):\n        #print('a', max(arrg[i+1], arrk[i]))\n        ans += max(arrg[i], arrk[i])\nif s[n-2] == '<':\n    ans += arrk[len(arrk)-1]\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":873,"bad_solution":"N = int(input())\n#num = [1]\n#print(\"a\")\n\"\"\"\n#memo = [[ -1 for i in range(12)]for j in range(100000)]\nn = 6\nwhile True:\n    num.append(n)\n    n *= 6\n    if n > 100000:\n        break\nn = 9\nwhile True:\n    num.append(n)\n    n *= 9\n    if n > 100000:\n        break\nnum.sort()\n\nans = 0\nprint(num)\n#while N > 6:\n\ndef DP(n , index):\n    if index == 0:\n        return  n\n    elif n == 0:\n        return 0\n    min_ = 10000000\n    if n < num[index]:\n        #print(n,num[index])\n        return DP(n,index - 1)\n    can = num[index]\n    #print(index)\n#    print(n\/\/can)\n    for i in range(n \/\/ can+1):\n        min_ = min(min_ , DP(n - i * can,index - 1) + i)\n #       print(i,n,index,DP(n - i*can,index-1))\n    \n     #   print(min_)\n    #print(min_)\n    memo[n][index] = min_\n    return min_\n    \nprint(DP(N,11))\n\"\"\"\n\ndef ninep(N):\n    if N <9:\n        return N\n    ans = 0\n    while N > 0:\n        ans += N % 9\n        N =N \/\/ 9\n    return ans\n\n\ndef sixp(N):\n    if N <6:\n        return N\n    ans = 0\n    while N > 0:\n        ans += N % 6\n        N = N \/\/ 6\n    return ans\n\n\nans = 100000\nfor i in range(N):\n    ans = min(ans,ninep(i) + sixp(N - i))\n#`    print(ninep(i), sixp(N - i),i)\n\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":874,"bad_solution":"#!\/usr\/bin\/env python3\nimport sys\n\n\ndef solve(A: int, B: int, K: int):\n    a = float(A) - float(K)\n    if a < 0:\n        ans_b = float(B) + a\n    else:\n        ans_b = B\n    print(max(int(a), 0), int(ans_b))\n\n\n# Generated by 1.1.6 https:\/\/github.com\/kyuridenamida\/atcoder-tools  (tips: You use the default template now. You can remove this line by using your custom template)\ndef main():\n    def iterate_tokens():\n        for line in sys.stdin:\n            for word in line.split():\n                yield word\n    tokens = iterate_tokens()\n    A = int(next(tokens))  # type: int\n    B = int(next(tokens))  # type: int\n    K = int(next(tokens))  # type: int\n    solve(A, B, K)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":875,"bad_solution":"import sys,heapq\ninput = sys.stdin.buffer.readline\n\n\ndef main():\n    h,w = map(int,input().split())\n\n    #dp[i] : iの時の最小右移動回数\n    dp = [0]*(w+1)\n\n    #解候補\n    res = [0]*w\n\n    #解候補から消されるもの\n    anti = []\n\n\n    #Ai = {1:dp[i]はvalid 0:invalid}\n\n    #A1 ... AnのBIT(1-indexed)\n    BIT = [0]*(w+1)\n\n    #A1 ~ Aiまでの和 O(logN)\n    def BIT_query(idx):\n        res_sum = 0\n        while idx > 0:\n            res_sum += BIT[idx]\n            idx -= idx&(-idx)\n        return res_sum\n\n    #Ai += x O(logN)\n    def BIT_update(idx,x):\n        while idx <= w:\n            BIT[idx] += x\n            idx += idx&(-idx)\n\n    for i in range(1,w+1):\n        BIT_update(i,1)\n\n    for i in range(1,h+1):\n        a,b = map(int,input().split())\n        \n        #a-1,b+1の値を計算\n        x = a-1\n        if x != 0 and x != w+1 and dp[x] == -1:\n            #x以下のvalidな個数\n            k = BIT_query(x-1)\n\n            #k番目のvalidな位置okからXに行く\n            if k != 0:\n                ok = x\n                ng = 0\n                while ok-ng > 1:\n                    mid = (ok+ng)\/\/2\n                    if BIT_query(mid) == k:\n                        ok = mid\n                    else:\n                        ng = mid\n                #xをvalidにする\n                dp[x] = dp[ok] + (x-ok)\n                BIT_update(x,1)\n                heapq.heappush(res,dp[x])\n                \n        x = b+1\n        if x != 0 and x != w+1 and dp[x] == -1:\n            #x以下のvalidな個数\n            k = BIT_query(x-1)\n\n            #k番目のvalidな位置okからXに行く\n            if k != 0:\n                ok = x\n                ng = 0\n                while ok-ng > 1:\n                    mid = (ok+ng)\/\/2\n                    if BIT_query(mid) == k:\n                        ok = mid\n                    else:\n                        ng = mid\n                #xをvalidにする\n                dp[x] = dp[ok] + (x-ok)\n                BIT_update(x,1)\n                heapq.heappush(res,dp[x])\n\n        k = BIT_query(a-1)+1\n\n        while True:\n            ng = a-1\n            ok = w\n            while ok-ng > 1:\n                mid = (ok+ng)\/\/2\n                if BIT_query(mid) >= k:\n                    ok = mid\n                else:\n                    ng = mid\n\n            if ok > b or dp[ok] == -1:\n                break\n            \n            heapq.heappush(anti,dp[ok])\n            dp[ok] = -1\n            BIT_update(ok,-1)\n        \n        while anti and res and anti[0] == res[0]:\n            heapq.heappop(anti)\n            heapq.heappop(res)\n\n        if res:\n            print(res[0]+i)\n        else:\n            print(-1)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":876,"bad_solution":"\ndef FUNC(arr, k):\n    \"\"\"\n    Given an array arr of integers and a positive integer k, return a sorted list \n    of length k with the FUNC k numbers in arr.\n\n    Example 1:\n\n        Input: arr = [-3, -4, 5], k = 3\n        Output: [-4, -3, 5]\n\n    Example 2:\n\n        Input: arr = [4, -4, 4], k = 2\n        Output: [4, 4]\n\n    Example 3:\n\n        Input: arr = [-3, 2, 1, 2, -1, -2, 1], k = 1\n        Output: [2]\n\n    Note:\n        1. The length of the array will be in the range of [1, 1000].\n        2. The elements in the array will be in the range of [-1000, 1000].\n        3. 0 <= k <= len(arr)\n    \"\"\"\n    if k == 0:\n        return []\n    arr.sort()\n    ans = arr[-k:]\n    return ans.sort(reverse=True)\n"}
{"id":877,"bad_solution":"def Yes():\n    print('Yes')\n    exit()\n\n\ndef No():\n    print('No')\n    exit()\n\n\ndef parse(s):\n    ret = [0, 0]\n    for c in s:\n        if c == ')':\n            if ret[0]:\n                ret[0] -= 1\n            else:\n                ret[1] -= 1\n        else:\n            ret[0] += 1\n    return ret\n\n\nimport numpy as np\nN = int(input())\nS = [parse(input()) for _ in range(N)]\nif sum(sum(a) for a in S):\n    No()\n#a[0]+a[1]が大きい順に並べる\n#この中でa[1]が耐えられるものを貪欲にかき集める\n#集められなくなったら終了\nT = np.array(sorted(S, key=lambda a: -a[0] - a[1]), dtype=int)\ncnt = 0\nfor _ in range(N):\n    K = T[T[:, 1] >= -cnt][0]\n    cnt += K.sum()\n    if cnt < 0:\n        No()\n    K = [0, -10**10]\nYes()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":878,"bad_solution":"# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Apr 20 20:47:47 2019\n\n@author: Owner\n\"\"\"\n\n# -*- coding: utf-8 -*-\n\"\"\"\nCreated on Sat Apr 13 09:53:12 2019\n\n@author: Owner\n\"\"\"\nfrom operator import itemgetter\nimport itertools\nimport copy\nimport bisect\n\n#素因数を並べる\ndef prime_decomposition(n):\n  i = 2\n  table = []\n  while i * i <= n:\n    while n % i == 0:\n      n \/= i\n      table.append(int(i))\n    i += 1\n  if n > 1:\n    table.append(int(n))\n  return table   \n# 桁数を吐く\ndef digit(i):\n    if i > 0:\n        return digit(i\/\/10) + [i%10]\n    else:\n        return []\n    \ndef getNearestValueIndex(list, num):\n    \"\"\"\n    概要: リストからある値に最も近い値のインデックスを取得する関数\n    @param list: データ配列\n    @param num: 対象値\n    @return 対象値に最も近い値\n    \"\"\"\n\n    # リスト要素と対象値の差分を計算し最小値のインデックスを取得\n    idx = np.abs(np.asarray(list) - num).argmin()\n    return idx\n\ndef find_index(l, x, default=False):\n    if x in l:\n        return l.index(x)\n    else:\n        return default\n\nclass UnionFind(object):\n    def __init__(self, n=1):\n        self.par = [i for i in range(n)]\n        self.rank = [0 for _ in range(n)]\n        self.size = [1 for _ in range(n)]\n\n    def find(self, x):\n        \"\"\"\n        x が属するグループを探索\n        \"\"\"\n        if self.par[x] == x:\n            return x\n        else:\n            self.par[x] = self.find(self.par[x])\n            return self.par[x]\n\n    def union(self, x, y):\n        \"\"\"\n        x と y のグループを結合\n        \"\"\"\n        x = self.find(x)\n        y = self.find(y)\n        if x != y:\n            if self.rank[x] < self.rank[y]:\n                x, y = y, x\n            if self.rank[x] == self.rank[y]:\n                self.rank[x] += 1\n            self.par[y] = x\n            self.size[x] += self.size[y]\n\n    def is_same(self, x, y):\n        \"\"\"\n        x と y が同じグループか否か\n        \"\"\"\n        return self.find(x) == self.find(y)\n\n    def get_size(self, x):\n        \"\"\"\n        x が属するグループの要素数\n        \"\"\"\n        x = self.find(x)\n        return self.size[x]\n    \n\n\"\"\"\nN, X = map(int, input().split())\n\nx = list(map(int, input().split()))\n\nP = [0]*N\nY = [0]*N\nfor n in range(N):\n    P[n], Y[n] = map(int, input().split())\n\n# 多次元配列の宣言（あとでintにすること。）（タプルにすること。）\ndp = np.zeros((N+1, 4,4,4))\n    \nall(nstr.count(c) for c in '753')\n\n# 複数配列を並び替え\nABT = zip(A, B, totAB)\nresult = 0\n# itemgetterには何番目の配列をキーにしたいか渡します\nsorted(ABT,key=itemgetter(2))\nA, B, totAB = zip(*ABT)\nA.sort(reverse=True)\n\n# 2進数のbit判定\n(x >> i) & 1\n\n# dp最小化問題\ndp = [np.inf]*N\nfor n in range(N):\n    if n == 0:\n        dp[n] = 0\n    else:\n        for k in range(1,K+1):\n            if n-k >= 0:\n                dp[n] = min(dp[n], dp[n-k] + abs(h[n]-h[n-k]))\n            else:\n                break\n# 累積和\nadd = 1 # 問題によって決まる\nres = 0\nsums = [0]*(len(nums)+1)\nfor i in range(len(nums)):\n    sums[i+1] = sums[i] + nums[i]\nfor i in range(0, len(nums), 2):\n    left = i\n    right = min(i+add, len(nums))\n    tmp = sums[right] - sums[left]\n    res = max(tmp, res)\n\n#２分探索\nli, ri = bisect.bisect_left(p_ac, l[i]-1), bisect.bisect_right(p_ac, r[i]-1)    \n\n#ソート関数\norg_list = [3, 1, 4, 5, 2]\nnew_list = sorted(org_list)\nprint(org_list)\nprint(new_list)\n# [3, 1, 4, 5, 2]\n# [1, 2, 3, 4, 5]\n\n#Distance Transformation\n    for h in range(0,H):\n        for w in range(0,W):\n            if h == 0 and w == 0:\n                pass\n            elif h == 0:\n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h-1][W-w]+1)\n            elif w == 0:   \n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h][W-w-1]+1)\n            else:\n                D[H-h-1][W-w-1]= min(D[H-h-1][W-w-1], D[H-h][W-w-1]+1, D[H-h-1][W-w]+1, D[H-h][W-w]+2)\n            d_max = max(D[H-h-1][W-w-1], d_max)\n\n\"\"\"\n\n\n\nN, M = list(map(int, input().split()))\n\nA = list(map(int, input().split()))\nA.sort()\nB = [0]*M\nC = [0]*M\nfor m in range(M):\n    B[m], C[m] = map(int, input().split())\n# 複数配列を並び替え\nBC = zip(B, C)\n# itemgetterには何番目の配列をキーにしたいか渡します\nBC = sorted(BC,key=itemgetter(1), reverse = True)\nB, C = zip(*BC)\n\ndef main(): \n    #print(A, B, C)\n    res = 0\n    for i in range(M):\n        idx = 0         \n        idx = bisect.bisect_left(A, C[i])\n        if idx == 0:\n            break\n        else:\n            less =min(idx, B[i]) \n            del A[0:less]\n            res += C[i]*less\n\n    print(res+sum(A))\n                \n                \n                \n            \n            \n                \n\n    \nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":879,"bad_solution":"from heapq import heappush, heappop\nimport sys\n\nsys.setrecursionlimit(10 ** 7)\n\n\ndef solve():\n    queue = []\n\n    def find(root):\n        INF = float('inf')\n        best = [INF for _ in range(n)]\n        best[root] = 0\n\n        def find_next(cur):\n            for u in e[cur]:\n                dist = best[cur] + 1\n                if dist < best[u]:\n                    best[u] = dist\n                    yield dist, u\n\n        def dequeue():\n            _, cur_v = heappop(queue)\n            for nxt in find_next(cur_v):\n                heappush(queue, nxt)\n\n        while queue:\n            dequeue()\n\n        res = (0, root)\n        for i in range(n):\n            if best[i] > res[0]:\n                res = (best[i], i)\n        return res, best\n\n    def run(root):\n        heappush(queue, (0, root))\n        return find(root)\n\n    ret0, best0 = run(0)\n    ret1, best1 = run(ret0[1])\n    ret2, best2 = run(ret1[1])\n\n    for i in range(n):\n        yield max(best1[i], best2[i])\n\n\ndef dfs(v):\n    for u in e[v]:\n        if parity[u] == -1:\n            parity[u] = parity[v] ^ 1\n            if not dfs(u):\n                return False\n        else:\n            if parity[v] == parity[u]:\n                return False\n    return True\n\n\nn = int(input())\ne = tuple(set() for _ in range(n))\n\nfor j in range(n):\n    s = input()\n    for ind, c in enumerate(s):\n        if c == '1':\n            e[j].add(ind)\n\n# print(e)\n\nparity = [-1] * n\nparity[0] = 0\n\nbg = dfs(0)\nif not bg:\n    print(-1)\nelse:\n    flg = True\n    zeros = tuple(ind for ind, p in enumerate(parity) if p == 0)\n\n    for z1 in zeros:\n        if any(z in e[z1] for z in zeros):\n            flg = False\n            break\n    if not flg:\n        print(-1)\n        exit()\n\n    ones = tuple(ind for ind, p in enumerate(parity) if p == 1)\n    for o1 in ones:\n        if any(one in e[o1] for one in ones):\n            flg = False\n            break\n\n    if not flg:\n        print(-1)\n        exit()\n\n    print(max(solve()) + 1)\n\n    # print(zeros, ones)\n    # print(parity)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":880,"bad_solution":"# @oj: atcoder\n# @id: hitwanyang\n# @email: 296866643@qq.com\n# @date: 2020-06-05 17:33\n# @url:https:\/\/atcoder.jp\/contests\/abc169\/tasks\/abc169_c\nimport sys,os\nfrom io import BytesIO, IOBase\nimport collections,itertools,bisect,heapq,math,string\nfrom decimal import *\n# region fastio\n\nBUFSIZE = 8192\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# ------------------------------\ndef main():\n    ab=list(map(float,input().split()))\n    a,b=int(ab[0]),int(str(ab[1]).replace(\".\",\"\"))\n    print (a*b\/\/100)\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":881,"bad_solution":"class BIT:\n    def __init__(self, n):\n        self.n = n\n        self.tree = [0]*(n+1)\n\n    def update(self, i, v):\n        while i <= self.n:\n            self.tree[i] += v\n            i += i & (-i)\n\n    def query(self, i):\n        v = 0\n        while i:\n            v += self.tree[i]\n            i -= i & (-i)\n        return v\n\n\nN, Q = map(int, input().split())\n*c, = map(int, input().split())\n\nq = [[] for _ in range(N+1)]\nfor i in range(Q):\n    x, y = map(int, input().split())\n    q[y-1].append([i, x-1])\n\nbit = BIT(N)\nfinds = [-1]*(N+1)\nans = [0]*Q\nfor i in range(N):\n    if finds[c[i]] != -1:\n        bit.update(finds[c[i]]+1, -1)\n\n    finds[c[i]] = i\n    bit.update(finds[c[i]]+1, 1)\n\n    for j, x in q[i]:\n        ans[j] = bit.query(i+1) - bit.query(x)\n\nfor a in ans:\n    print(a)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":882,"bad_solution":"import sys\nimport itertools\n# import numpy as np\nimport time\nimport math\nimport heapq\nfrom collections import defaultdict\nsys.setrecursionlimit(10 ** 7)\n \nINF = 10 ** 18\nMOD = 10 ** 9 + 7\nread = sys.stdin.buffer.read\nreadline = sys.stdin.buffer.readline\nreadlines = sys.stdin.buffer.readlines\n\n# map(int, input().split())\n\nN, K = map(int, input().split())\nA = list(map(int, input().split()))\n\ndef rec(i, is_same):\n    res = 0\n    x, y = 0, 0\n    for a in A:\n        x += 0 ^ (a >> i & 1)\n        y += 1 ^ (a >> i & 1)\n    if K >> i & 1 == 0 and is_same:\n        res = rec(i - 1, is_same) + x\n    else:\n        res = max(rec(i - 1, False) + x, rec(i - 1, True) + y)\n    return res\n\ndef f(n):\n    res = 0\n    while n > 0:\n        res += 1\n        n \/\/= 2\n    return res\n\nd = f(10 ** 12 + 1)\ndp = [[0 for _ in range(2)] for _ in range(d + 2)]\nfor i in range(d, -1, -1):\n    x, y = 0, 0\n    for a in A:\n        x += 0 ^ (a >> i & 1)\n        y += 1 ^ (a >> i & 1)\n    x <<= i\n    y <<= i\n\n    if K >> i & 1 == 0:\n        dp[i][1] = dp[i + 1][1] + x\n        if (1 << i) <= K:\n            dp[i][0] = max(dp[i + 1][0] + x, dp[i + 1][0] + y)\n        else:\n            dp[i][0] = dp[i + 1][0] + x\n    else:\n        if (1 << i) <= K:\n            dp[i][1] = dp[i + 1][1] + y\n            dp[i][0] = max(dp[i + 1][1] + x, dp[i + 1][0] + x, dp[i + 1][0] + y)\n        else:\n            dp[i][0] = max(dp[i + 1][1] + x, dp[i + 1][0] + x)\n    \nprint(max(dp[0][0], dp[0][1]))\n\n\n    \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":883,"bad_solution":"\ndef FUNC(lst):\n    \"\"\"Given a non-empty list of integers, return the sum of all of the odd elements that are in even positions.\n    \n\n    Examples\n    FUNC([5, 8, 7, 1]) ==> 12\n    FUNC([3, 3, 3, 3, 3]) ==> 9\n    FUNC([30, 13, 24, 321]) ==>0\n    \"\"\"\n    return sum([x for idx, x in enumerate(lst) if idx%2==1 and x%2==1])\n"}
{"id":884,"bad_solution":"#!\/usr\/bin\/env python3\n\nfrom pprint import pprint\nfrom collections import deque, defaultdict\nimport itertools\nimport math\nimport sys\n\nsys.setrecursionlimit(10 ** 6)\ninput = sys.stdin.buffer.readline\nINF = float('inf')\n\nn_towns, k_times = map(int, input().split())\nteleport = list(map(int, input().split()))\n\nseq = []\nflags = [False] * n_towns\nvisited = [0] * n_towns\n\nflags[0] = True\nseq.append(0)\nvisited[0] += 1\n\ntown_prev = 0\n\nwhile True:\n    town_next = teleport[town_prev] - 1\n    visited[town_next] += 1\n    if flags[town_next]:\n        seq.append(town_next)\n        break\n    seq.append(town_next)\n    flags[town_next] = True\n    town_prev = town_next\n\n# print(seq)\nloop_len = 0\nfor town, count in enumerate(visited):\n    if count == 2:\n        loop_idx = seq.index(town)\n# print(loop_idx)\n\nif k_times < loop_idx:\n    print(seq[k_times])\nelse:\n    r = k_times % (len(seq) - loop_idx)\n    print(seq[loop_idx:][r] + 1)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":885,"bad_solution":"#atcoder template\ndef main():\n    import sys\n    imput = sys.stdin.readline\n    #ここにコード\n    #input\n    N, M, K = map(int, input().split())\n\n    #output\n    mod = 998244353\n\n    n_ = 4*10**5 + 5\n    fun = [1]*(n_+1)\n    for i in range(1,n_+1):\n        fun[i] = fun[i-1]*i%mod\n    rev = [1]*(n_+1)\n    rev[n_] = pow(fun[n_],mod-2,mod)\n    for i in range(n_-1,0,-1):\n        rev[i] = rev[i+1]*(i+1)%mod\n    def cmb(n,r):\n        if n <= 0 or r < 0 or r > n: return 0\n        return fun[n]*rev[r]%mod*rev[n-r]%mod\n\n    answer = 0\n    for i in range(K+1):\n        answer += M*pow(M-1, N-(i+1), mod)*cmb(N-1, i) % mod\n\n    print(answer % mod)\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":886,"bad_solution":"import sys\nfrom collections import defaultdict\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nN, M, V, P = map(int, input().split())\n\nA = list(map(int, input().split()))\nA.sort(reverse=True)\n\n#NUM = [0] * N\n#ACN = [0] * N\nNUM = defaultdict(int)\nACN = defaultdict(int)\ncnt = 0\nmx = A[0]\n\n# cnt and accumulation\nfor a in A:\n    d = mx - a\n    cnt += 1\n    NUM[d] += 1\n    ACN[d] = cnt\n\n# P Number Problem\nPROBLEM_P = 0\np = P\nfor i in range(0, A[0]+1):\n    if NUM[i] == 0:\n        continue\n\n    p -= NUM[i]\n\n    if p < 0:\n        PROBLEM_P = i\n        break\n\n    if i == (A[0]+1) and p > 0:\n        print(N)\n        exit()\n\n#print(\"NUM\", NUM)\n#print(\"PROBLEM_P\", PROBLEM_P)\n\n# R Number Problem\nR = PROBLEM_P + M\n\n# P-1 Problem\nans = 0\nNG_POINT = (P-1) * M\nNG_POINT += (N - ACN[R]) * M\nMV = M * V\n\n# p problem num\nnum_p = ACN[PROBLEM_P] - P\n\nfor r in range(R, -1, -1):\n    need_point = M\n    total = (need_point * NUM[r]) + NG_POINT\n\n    for q in range(r-1, PROBLEM_P, -1):\n        if NUM[q] == 0:\n            continue\n        total += NUM[q] * (q - r + M)\n\n    total += num_p * (PROBLEM_P - r + M)\n\n    if total >= MV:\n        ans = r\n        break\n    else:\n        NG_POINT += NUM[r] * M\n\nprint(ACN[ans])\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":887,"bad_solution":"from collections import deque\n\ndef bfs():\n  H, W = list(map(int, input().split()))\n  field = [[i=='#' for i in input()] for _ in range(H)]\n  count = 0\n  q = deque([(i, j) for i in range(H) for j in range(W) if field[i][j]])\n  while True:\n    nq = deque()\n    while q:\n      y, x = q.popleft()\n      for dy, dx in ((1, 0), (0, 1), (-1, 0), (0, -1)):\n        ny, nx = y + dy, x + dx\n        if 0<=ny<H and 0<=nx<W and not field[ny][nx]:\n          field[ny][nx] = True\n          nq.append((ny, nx))\n    if nq:\n      q = nq\n    else:\n      break\n    count += 1\n  print(count)\n      \nbfs()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":888,"bad_solution":"\ndef FUNC(arr, k):\n    \"\"\"\n    Given a non-empty array of integers arr and an integer k, return\n    the sum of the elements with at most two digits from the first k elements of arr.\n\n    Example:\n\n        Input: arr = [111,21,3,4000,5,6,7,8,9], k = 4\n        Output: 24 # sum of 21 + 3\n\n    Constraints:\n        1. 1 <= len(arr) <= 100\n        2. 1 <= k <= len(arr)\n    \"\"\"\n    return sum(elem for elem in arr if len(str(elem)) <= 2)\n"}
{"id":889,"bad_solution":"def main():\n    a, b, q = map(int, input().rstrip(\"\\n\").split(\" \"))\n    INF = 10 ** 18\n    \n    jinja_list = [-INF]\n    for i in range(a):\n        jinja_list.append(int(input().rstrip(\"\\n\")))\n    jinja_list.append(INF)\n    \n    temple_list = [-INF]\n    for i in range(b):\n        temple_list.append(int(input().rstrip(\"\\n\")))\n    temple_list.append(INF)\n\n    from bisect import bisect, bisect_right\n\n    for i in range(q):\n        pos = int(input().rstrip(\"\\n\"))\n\n        jinja_index = bisect_right(jinja_list, pos)\n        jinja_left = jinja_list[jinja_index - 1]\n        jinja_right = jinja_list[jinja_index]\n\n        temple_index = bisect_right(temple_list, pos)\n        temple_left = temple_list[temple_index - 1]\n        temple_right = temple_list[temple_index]\n\n        distances = []\n        #distances.append(pos - min(jinja_left, temple_left))\n        #distances.append(max(jinja_right, temple_right) - pos)\n        \n        left_right = abs(pos - jinja_left) + abs(temple_left - jinja_left)\n        right_left = abs(pos - temple_left) + abs(jinja_left - temple_left)\n        distances.append(left_right)\n        distances.append(right_left)\n        \n        left_right = abs(pos - jinja_right) + abs(temple_right - jinja_right)\n        right_left = abs(pos - temple_right) + abs(jinja_right - temple_right)\n        distances.append(left_right)\n        distances.append(right_left)\n        \n        \n        left_right = abs(pos - jinja_left) + abs(temple_right - jinja_left)\n        right_left = abs(pos - temple_right) + abs(jinja_left - temple_right)\n        distances.append(left_right)\n        distances.append(right_left)\n        left_right = abs(pos - temple_left) + abs(jinja_right - temple_left)\n        right_left = abs(pos - jinja_right) + abs(temple_left - jinja_right)\n        distances.append(left_right)\n        distances.append(right_left)\n        print(min(distances))\n        \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":890,"bad_solution":"N = int(input())\nA = list(map(int, input().split()))\nA_MAX = max(A)\n\ndef eratosthenes(n):\n    is_prime = [True] * (n+1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5) + 1):\n        if not is_prime[i]:\n            continue\n        for j in range(i*2, n+1, i):\n            is_prime[j] = False\n    \n    return [i for i in range(n+1) if is_prime[i]]\n\nprimecount = {}\nprimenum = [-1] * (A_MAX+1)\nfor p in eratosthenes(A_MAX):\n    primecount[p] = 0\n    for i in range(p, A_MAX+1, p):\n        primenum[i] = p\n    \nfor a in A:\n    while a > 1:\n        p = primenum[a]\n        while a % p == 0:\n            a \/\/= p\n        primecount[p] += 1\n\ncnt = max(primecount.values())\nif cnt == 1:    \n    print('pairwise coprime')\nelif cnt < N:\n    print('setwise coprime')\nelse:\n    print('not coprime')\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":891,"bad_solution":"\ndef FUNC(n):\n    \"\"\"\n    Given a positive integer n, return a sorted list that has the odd numbers in collatz sequence.\n\n    The Collatz conjecture is a conjecture in mathematics that concerns a sequence defined\n    as follows: start with any positive integer n. Then each term is obtained from the \n    previous term as follows: if the previous term is even, the next term is one half of \n    the previous term. If the previous term is odd, the next term is 3 times the previous\n    term plus 1. The conjecture is that no matter what value of n, the sequence will always reach 1.\n\n    Note: \n        1. Collatz(1) is [1].\n        2. returned list sorted in increasing order.\n\n    For example:\n    FUNC(5) returns [1, 5] # The collatz sequence for 5 is [5, 16, 8, 4, 2, 1], so the odd numbers are only 1, and 5.\n    \"\"\"\n    if n%2==0:\n        odd_collatz = [] \n    else:\n        odd_collatz = [n]\n    while n > 1:\n        if n % 2 == 0:\n            n = n\/2\n        else:\n            n = n*2 + 1\n            \n        if n%2 == 1:\n            odd_collatz.append(int(n))\n\n    return sorted(odd_collatz)\n"}
{"id":892,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nN = int(input())\nA = list(map(int, input().split()))\n# import random\n\n# N = 10**5\n# A = [random.randrange(1,10**9+1) for _ in range(N)]\n\n# import time\n\ndef main():\n    l = 0\n    r = N\n    while r-l > 1:\n        m = (r+l)\/\/2\n        ok = True\n        if m == 1:\n            pre = -1\n            for a in A:\n                if pre >= a:\n                    ok = False\n                    break\n                pre = a\n        else:\n            dp = {}\n            needreset = 10**15\n            exception = set()\n            pre = -1\n            for a in A:\n                ind = a\n                for _ in range(40):\n                    # 修正\n                    if needreset >= ind or ind in exception:\n                        if not ind in dp.keys():\n                            dp[ind] = 0 if pre < a else 1\n                    else:\n                        dp[ind] = 0 if pre < a else 1\n                        exception.add(ind)\n                    # たす\n                    if dp[ind] < m:\n                        dp[ind] += 1\n                        break\n                    elif ind == 1:\n                        ok = False\n                        break\n                    else:\n                        # 繰り上がり\n                        dp[ind] = 1\n                        ind -= 1\n                if not ok: break\n                # 更新\n                if pre > a:\n                    needreset = a\n                    exception = set()\n                pre = a\n\n        if ok:\n            r = m\n        else:\n            l = m\n\n    print(r)\n\n\nif __name__ == \"__main__\":\n    #dt = time.time()\n    main()\n    #print(time.time()-dt)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":893,"bad_solution":"import sys\nimport numpy as np\nfrom math import ceil as C, floor as F, sqrt\nfrom collections import defaultdict as D, Counter as CNT\nfrom functools import reduce as R\n \nALP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\nalp = 'abcdefghijklmnopqrstuvwxyz'\ndef _X(): return sys.stdin.readline().rstrip().split(' ')\ndef _S(ss): return tuple(ss) if len(ss) > 1 else ss[0]\ndef S(): return _S(_X())\ndef Ss(): return list(S())\ndef _I(ss): return tuple([int(s) for s in ss]) if isinstance(ss, tuple) else int(ss)\ndef I(): return _I(S())\ndef _Is(ss): return list(ss) if isinstance(ss, tuple) else [ss]\ndef Is(): return _Is(I())\n\n_, k = Is()\ntowns = [i-1 for i in Is()]\n\nnow = 0\nseen = [0]\n\nwhile k > 0:\n  k -= 1\n  now = towns[now]\n  \n  if now not in seen:\n    seen.append(now)\n  else:\n    seen = seen[seen.index(now):]\n    break\n\nif k == 0:\n  print(1 + now)\nelse:\n  print(1 + (seen[k % len(seen)]))\n  \nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":894,"bad_solution":"import sys\n# sys.setrecursionlimit(100000)\n\n\ndef input():\n    return sys.stdin.readline().strip()\n\n\ndef input_int():\n    return int(input())\n\n\ndef input_int_list():\n    return [int(i) for i in input().split()]\n\n\ndef main():\n    n = input_int()\n    d = dict()\n    for i in range(1, n + 1):\n        d[i] = input_int_list()[::-1]\n    day = 0\n    matches = 0\n    while True:\n        played = set()\n        for a, v in d.items():\n            if d[a]:\n                b = d[a][-1]\n                if d[b] and a == d[b][-1] and a not in played and b not in played:\n                    d[a].pop()\n                    d[b].pop()\n                    played.add(a)\n                    played.add(b)\n                    matches += 1\n        if not played:\n            break\n        day += 1\n\n    if matches == (n * (n - 1)) \/\/ 2:\n        print(day)\n    else:\n        print(-1)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":895,"bad_solution":"import sys, math, itertools\ninput = sys.stdin.readline\n\ndef combinations_count(n, r):\n    return math.factorial(n) \/\/ (math.factorial(n - r) * math.factorial(r))\n\n\nN = int(input())\nS = set([input() for _ in range(N)])\n\nm_set = len({cand for cand in S if ((cand[0] == 'M')) })\na_set = len({cand for cand in S if ((cand[0] == 'A')) })\nr_set = len({cand for cand in S if ((cand[0] == 'R')) })\nc_set = len({cand for cand in S if ((cand[0] == 'C')) })\nh_set = len({cand for cand in S if ((cand[0] == 'H')) })\nset_elements_num = [m_set,a_set,r_set,c_set,h_set]\nset_elements_num.remove(0)\n\n# print(set_elements_num)\ncomb = 0\nfor i, elements_num in enumerate(set_elements_num):\n    last_elements = set_elements_num[i+1:]\n    # print(last_elements)\n    last_elements_comb = list(itertools.combinations(last_elements,2))\n    for elements in last_elements_comb:\n        local_comb = elements_num\n        for x in elements:\n            local_comb *= x\n        comb += local_comb\n\nprint(comb)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":896,"bad_solution":"def mpow(x: int, k: int, MOD=1000000007) -> int:\n    \"\"\"\n    x^kのmodを返します\n    \"\"\"\n    res = 1\n    y = x\n    while (k):\n        if(k % 2 == 1):\n            res = (res * y) % MOD\n        y = (y ** 2) % MOD\n        k = k \/\/ 2\n    return res\n'''\ndef cmb(n, x, mod=10**9+7):\n    # nCx\n    # 組み合わせ\n    # ex) combination(5, 2) = 10\n    factorial = [1] * (n+1)\n    t = 1\n    for i in range(1, n+1):\n        t = (t * i) % mod\n        factorial[i] = t\n    tmp = factorial[n]\n    tmp = (tmp * pow(factorial[x], mod-2, mod)) % mod\n    tmp = (tmp * pow(factorial[n-x], mod-2, mod)) % mod\n    return tmp\n'''\nmod = 10**9+7 #出力の制限\n\nN, a, b = map(int,input().split())\n\nprint(mpow(2,10**9))\n\nnum = 1000000000 + 7\n\nMAX_NUM = N\nMOD = 10**9+7\n\nfac  = [0 for _ in range(MAX_NUM)]\nfinv = [0 for _ in range(MAX_NUM)]\ninv  = [0 for _ in range(MAX_NUM)]\n\nfac[0]  = fac[1] = 1\nfinv[0] = finv[1] = 1\ninv[1] = 1\n\nfor i in range(2,MAX_NUM):\n    fac[i] = fac[i-1] * i % MOD\n    inv[i] = MOD - inv[MOD%i] * (MOD \/\/ i) % MOD\n    finv[i] = finv[i-1] * inv[i] % MOD\n\ndef cmb(n,k):\n    if n < k:\n        return 0\n    if n < 0 or k < 0:\n        return 0\n    return fac[n] * (finv[k] * finv[n-k] % MOD) % MOD\n\n#print(mpow(2,N))\n\nprint(mpow(2,N)- cmb(N, a) - cmb(N, b) -1)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":897,"bad_solution":"from collections import deque\nfrom sys import stdin\n\ndx = (1, 0, -1, 0)\ndy = (0, 1, 0, -1)\n\nN, M = [int(_) for _ in stdin.readline().rstrip().split()]\ngraph = []\n\ndef bfs(graph, N, M):\n    for _ in range(N):\n        n = list(stdin.readline().rstrip())\n        graph.append(n)\n\n    ans = 0\n    que = deque()\n    dist = [[-1 for i in range(M)] for j in range(N)]\n    for i in range(N):\n        for j in range(M):\n            if graph[i][j] == '#':\n                que.append((i, j)) \n                dist[i][j] = 0\n\n    while len(que):\n        v = que.popleft()\n        for d in range(4):\n            nx = v[0] + dx[d]\n            ny = v[1] + dy[d]\n            if nx < 0 or nx >= N or ny < 0 or ny >= M:\n                continue\n            if dist[nx][ny] == -1:\n                dist[nx][ny] = dist[v[0]][v[1]] + 1\n                que.append((nx, ny))\n\n    for i in range(N):\n        for j in range(M):\n            ans = max(ans, dist[i][j])\n\n    return ans\n\nans = bfs(graph, N, M)\nprint(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":898,"bad_solution":"def solve():\n    import numpy as np\n    from operator import add\n    import sys\n\n    input = sys.stdin.readline\n\n    MaxBias = 80\n\n    h, w = map(int, input().split())\n    d = [list(map(int, input().split())) for _ in range(h * 2)]\n    for r in range(h):\n        for c in range(w):\n            d[r][c] = abs(d[r][c] - d[r + h][c])\n\n    dp = np.zeros(shape=(h, w, MaxBias + 1))\n    for bias in (-d[0][0], d[0][0]):\n        dp[0, 0, bias] = 1\n\n    for r in range(1, h):\n        for bias in range(MaxBias + 1):\n            if dp[r - 1, 0, bias]:\n                for new_bias in abs(bias + d[r][0]), abs(bias - d[r][0]):\n                    if 0 <= new_bias <= MaxBias:\n                        dp[r, 0, new_bias] = 1\n\n    for c in range(1, w):\n        for bias in range(MaxBias + 1):\n            if dp[0, c - 1, bias]:\n                for new_bias in abs(bias + d[0][c]), abs(bias - d[0][c]):\n                    if 0 <= new_bias <= MaxBias:\n                        dp[0, c, new_bias] = 1\n\n    for r in range(1, h):\n        for c in range(1, w):\n            for bias in range(MaxBias + 1):\n                if dp[r - 1, c, bias] or dp[r, c - 1, bias]:\n                    for new_bias in abs(bias + d[r][c]), abs(bias - d[r][c]):\n                        if 0 <= new_bias <= MaxBias:\n                            dp[r, c, new_bias] = 1\n\n    for bias in range(MaxBias + 1):\n        if dp[h - 1, w - 1, bias]:\n            print(bias)\n            return\n\n\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":899,"bad_solution":"from collections import deque\nfrom itertools import product\nimport sys\ninput = sys.stdin.readline\nh, w = map(int, input().split())\nsi, sj = map(lambda x: int(x)-1, input().split())\ngi, gj = map(lambda x: int(x)-1, input().split())\nfld = ''.join([input().rstrip()for _ in range(h)])\nINF = 10**18\n\n\ndef to_v(i, j):\n    return i*w+j\n\n\nn = h*w\nstart = to_v(si, sj)\ngoal = to_v(gi, gj)\n\n\ndef generate_v2(v):\n    i, j = divmod(v, w)\n    if 0 < i:\n        yield v-w\n    if i < h-1:\n        yield v+w\n    if 0 < j:\n        yield v-1\n    if j < w-1:\n        yield v+1\n\n\ndef generate_v2_b(v):\n    i, j = divmod(v, w)\n    it = [-2, -1, 1, 2]\n    for di, dj in product(it, repeat=2):\n        x, y = i+di, j+dj\n        if x < 0 or h <= x or y < 0 or w <= y:\n            continue\n        yield x*w+y\n\n    it = [(-2, 0), (2, 0), (0, -2), (0, 2)]\n    for di, dj in it:\n        x, y = i+di, j+dj\n        if x < 0 or h <= x or y < 0 or w <= y:\n            continue\n        yield x*w+y\n\n\ndef bfs(init_v):\n    next_v = deque([init_v])\n    dist = [INF]*n\n    dist[init_v] = 0\n    while next_v:\n        v = next_v.popleft()\n        for v2 in generate_v2(v):\n            if fld[v2] == '#':\n                continue\n            if dist[v2] <= dist[v]:\n                continue\n            dist[v2] = dist[v]\n            next_v.append(v2)\n\n        for v2 in generate_v2_b(v):\n            if fld[v2] == '#':\n                continue\n            if dist[v2] <= dist[v]+1:\n                continue\n            dist[v2] = dist[v]+1\n            next_v.append(v2)\n\n    return dist\n\n\nans = bfs(start)[goal]\nprint(-1 if ans == INF else ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":900,"bad_solution":"import sys\ndef I(): return int(sys.stdin.readline())\ndef LI(): return list(map(int,sys.stdin.readline().split()))\nmod = 10**9 + 7\ninf = float('inf')\nans = int(0)\n\nN, K = LI()\nS = str(input())\nS = S + \"2\"\nd1 = []\nd0 = []\nk = S[0]\nif k==\"0\":\n    d1.append(0)\ncou = int(1)\nfor i in range(N):\n    if S[i]!=S[i+1]:\n        if S[i]==\"0\":\n            d0.append(cou)\n        if S[i]==\"1\":\n            d1.append(cou)\n        cou = int(1)\n    else:\n        cou +=1\n\n#print(d1)\n#print(d0)\n\nansC = []\nt = 2*K+1\nnewN = len(d1)\nif len(d1)==1 or d0==[] or K>=N\/\/2+1:\n    ansC.append(N)\n\nif newN!=len(d0):\n    d0.append(0)\n    d0.append(0)\nsumd1 = [0]*(newN+t+5)\nsumd0 = [0]*(newN+t+5)\nfor i in range(newN):\n    sumd1[i+1] = d1[i]\n    sumd0[i+1] = d0[i]\nfor i in range(newN+1):\n    sumd1[i+1] += sumd1[i]\n    sumd0[i+1] += sumd0[i]\n\n#for i in range(max(newN-K+1,K)):\nif ansC==[] and (newN - K + 1)>=1:\n    for i in range(newN - K + 1):\n        ans = (sumd1[i + K + 1] - sumd1[i]) + (sumd0[i + K] - sumd0[i])\n        ansC.append(ans)\n\nprint(max(ansC))\n#print(ansC)\n#print(sumd1)\n#print(sumd0)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":901,"bad_solution":"#\n# 　　  ⋀_⋀　 \n#　　  (･ω･)  \n# .／ Ｕ ∽ Ｕ＼\n#  │＊　合　＊│\n#  │＊　格　＊│ \n#  │＊　祈　＊│ \n#  │＊　願　＊│ \n#  │＊　　　＊│ \n#      ￣\n#\nimport sys\nsys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\nfrom math import floor,ceil,sqrt,factorial,log #log2ないｙｐ\nfrom heapq import heappop, heappush, heappushpop\nfrom collections import Counter,defaultdict,deque\nfrom itertools import accumulate,permutations,combinations,product,combinations_with_replacement\nfrom bisect import bisect_left,bisect_right\nfrom copy import deepcopy\ninf=float('inf')\nmod = 10**9+7\ndef pprint(*A): \n    for a in A:     print(*a,sep='\\n')\ndef INT_(n): return int(n)-1\ndef MI(): return map(int,input().split())\ndef MF(): return map(float, input().split())\ndef MI_(): return map(INT_,input().split())\ndef LI(): return list(MI())\ndef LI_(): return [int(x) - 1 for x in input().split()]\ndef LF(): return list(MF())\ndef LIN(n:int): return [I() for _ in range(n)]\ndef LLIN(n: int): return [LI() for _ in range(n)]\ndef LLIN_(n: int): return [LI_() for _ in range(n)]\ndef LLI(): return [list(map(int, l.split() )) for l in input()]\ndef I(): return int(input())\ndef F(): return float(input())\ndef ST(): return input().replace('\\n', '')\ndef main():\n    N,K = MI()\n    H=LI()\n    \n    dp = [[0]+[inf]*(N) for _ in range(N)] #dp[right][size]: 最も右の項right, いじってないやつの数size\n    for i in range(N):\n        dp[i][1] = H[i]\n    dp[0][1]=H[0]\n    for right in range(N):\n        for size in range(2,N+1):\n\n            for i in range(right):\n                dp[right][size] = min(dp[right][size], dp[i][size-1]+max(0, H[right]-H[i]))\n    ans = dp[N-1][N-K]\n    # print(N-K)\n    # print(*dp,sep=\"\\n\")\n    print(ans)\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":902,"bad_solution":"class BIT:\n    def __init__(self, N):\n        self.size = N\n        self.tree = [0] * (N + 1)\n\n    def sum(self, i):\n        s = 0\n        while i > 0:\n            s += self.tree[i]\n            i -= i & -i\n        return s\n\n    def add(self, i, x):\n        while i <= self.size:\n            self.tree[i] += x\n            i += i & -i\n\n    def __str__(self):\n        return \"BIT: [{}]\".format(\n            \", \".join(str(self.sum(i + 1) - self.sum(i))\n                      for i in range(self.size))\n        )\n\n    def bisect_left(self, i):\n        bit = self.tree\n\n        while i > 0 and bit[i] == 0:\n            i -= i & -i\n\n        if i == 0:\n            return 0\n\n        if i & 1:\n            return i\n\n        l = i - (i & -i) + ((i & -i) >> 1)\n        D = bit[i] - bit[l]\n        k = (i & (-i)).bit_length() - 2\n        while k > 0:\n            if D == 0:\n                i = l\n                l = l - (l & -l) + ((l & -l) >> 1)\n                D = bit[i] - bit[l]\n            else:\n                l += k\n                D = D - bit[l]\n            k \/\/= 2\n\n        return l + 1 if D > 0 else l\n\n\n\nN, *A = map(int, open(0).read().split())\n\nmemo = {a: i for i, a in enumerate(sorted(set(A)), 1)}\nB = [memo[a] for a in A]\nM = len(memo) + 10\n\nbit = BIT(M)\nfor b in B:\n    i = bit.bisect_left(b - 1)\n    if i != 0:\n        bit.add(i, -1)\n    bit.add(b, 1)\n\nprint(bit.sum(M))\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":903,"bad_solution":"def initialize(N):\n    i=1\n    while i<N:\n        i*=2\n    return [0]*(2*i-1),i\n\ndef update(i,x):\n    i+=d-1\n    bit=ord(x)-97\n    SEG[i]=0 | (1<<bit)\n    while i>0:\n        i=(i-1)\/\/2\n        SEG[i]=SEG[i*2+1]|SEG[i*2+2]\n        \ndef find(a,b,k,l,r):\n    if r<=a or b<=l:\n        return 0\n    if a<=l and r<=b:\n        return SEG[k]\n    else:\n        c1=find(a,b,2*k+1,l,(l+r)\/\/2)\n        c2=find(a,b,2*k+2,(l+r)\/\/2,r)\n        return c1|c2\n        \nN=int(input())\nS=input()\nQ=int(input())\n\nSEG,d=initialize(N)\nfor i in range(N):\n    update(i,S[i])\n\nfor i in range(Q):\n    com,s,t=map(str,input().split())\n    if(com=='1'):\n        update(int(s)-1,t)\n    else:\n        cnt=0\n        bit=find(int(s)-1,int(t),0,0,d)\n        while(bit>0):\n            if(bit&1):\n                cnt+=1\n            bit\/\/=2\n        print(cnt)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":904,"bad_solution":"#!\/usr\/bin\/env python\n# coding: utf-8\n\nfrom collections import namedtuple\n\ndef ri():\n    return int(input())\n\ndef rl():\n    return list(input().split())\n\ndef rli():\n    return list(map(int, input().split()))\n\ndef dist(pf, pt):\n    return abs(pf[0]-pt[0]) + abs(pf[1]-pt[1])\n\ndef print_ans(sx, sy, ans):\n    print(len(ans))\n    for p in ans:\n        print(sx*p[0], sy*p[1])\n\ndef move(k, pf, pt):\n    assert(pt[1]>pf[1])\n    d = min(pt[0]-pf[0], k)\n    return [pf[0]+d,pf[1]+k-d]\n\ndef main():\n    k = ri()\n    x, y = rli()\n    sx = 1 if x >= 0 else -1\n    sy = 1 if y >= 0 else -1\n    x = abs(x)\n    y = abs(y)\n\n    pf = [0, 0]\n    pt = [x, y]\n    if k % 2 == 0 and (x+y) % 2 == 1:\n        print(-1)\n        return\n    d = dist(pf, pt)\n\n    ans = []\n\n    # 3回で到達\n    if d < k and d % 2 == 1:\n        ans.append(((x+y-k)\/\/2, (k+x+y)\/\/2))\n        ans.append((x+y-k, 0))\n        ans.append((x, y))\n        print_ans(sx, sy, ans)\n        return\n\n    n = (x+y+k-1) \/\/ k\n    d = (n*k-(x+y))\/\/2\n    if d > 0:\n        pf = [k-d, -d]\n        ans.append(tuple(pf))\n    while dist(pf, pt) > 0:\n        pf = move(k, pf, pt)\n        ans.append(tuple(pf))\n    print_ans(sx, sy, ans)\n    assert(pf[0] == x and pf[1] == y)\n\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":905,"bad_solution":"def warshall_floyd(d):\n \n    n = len(d)\n    for i in range(n):\n        for j in range(n):\n            for k in range(n):\n                if d[i][j] > d[i][k] + d[k][j]:\n                    d[i][j] = d[i][k] + d[k][j]\n    return d\ndef solve():\n  n,m = (int(i) for i in input().split())\n \n  upper = 10**10\n  dist = [[0 if x == i else upper for x in range(n)] for i in range(n)]\n  edge_list = []\n  for i in range(m):\n    a, b, c = (int(i) for i in input().split())\n    edge = [a, b, c]\n    edge_list.append(edge)\n    dist[a-1][b-1] = c\n    dist[b-1][a-1] = c\n  #print(edge_list)\n  #print(dist)\n  \n  warshall_floyd(dist)\n  #print(dist)\n  \n  \n  ans = 0\n  for edge in edge_list:\n    a, b, c = edge\n    #最短距離か\n    if dist[a-1][b-1] < c:\n        ans += 1\n  print(ans)\nsolve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":906,"bad_solution":"class SegmentTree():\n    def __init__(self, array, f, ti):\n        \"\"\"\n        Parameters\n        ----------\n        array : list\n            to construct segment tree from\n        f : func\n            binary operation of the monoid\n        ti : \n            identity element of the monoid\n        \"\"\"\n        self.f = f\n        self.ti = ti\n        self.n = n = 2**(len(array).bit_length())\n        self.dat = dat = [ti] * n + array + [ti] * (n - len(array))\n        for i in range(n - 1, 0, -1):  # build\n            dat[i] = f(dat[i << 1], dat[i << 1 | 1])\n\n    def update(self, p, v):  # set value at position p (0-indexed)\n        f, n, dat = self.f, self.n, self.dat\n        p += n\n        dat[p] = v\n        while p > 1:\n            p >>= 1\n            dat[p] = f(dat[p << 1], dat[p << 1 | 1])\n\n    def query(self, l, r):  # result on interval [l, r) (0-indexed)\n        f, ti, n, dat = self.f, self.ti, self.n, self.dat\n        res = ti\n        l += n\n        r += n\n        while l < r:\n            if l & 1:\n                res = f(res, dat[l])\n                l += 1\n            if r & 1:\n                r -= 1\n                res = f(dat[r], res)\n            l >>= 1\n            r >>= 1\n        return res\n\n\nN, K = [int(_) for _ in input().split()]\nP = [int(_) for _ in input().split()]\n\nSTmax = SegmentTree(array=P, f=max, ti=-float('inf'))\nSTmin = SegmentTree(array=P, f=min, ti=float('inf'))\n\nUF = list(range(N - K + 1))\nSIZE = [0] + [1] * N  # 1-indexed\n\n\ndef find(x):\n    if UF[x] != x:\n        UF[x] = find(UF[x])\n    return UF[x]\n\n\ndef unite(x, y):\n    if not is_same(x, y):\n        X, Y = find(x), find(y)\n        SX, SY = SIZE[X], SIZE[Y]\n        if SX > SY:\n            m = UF[X] = Y\n        else:\n            m = UF[Y] = X\n        SIZE[m] = SX + SY\n        SIZE[X + Y - m] = 0\n\n\ndef is_same(x, y):\n    return find(x) == find(y)\n\n\ndef scan_uf():\n    for i in range(len(UF)):\n        find(i)\n\n\nfor i in range(N - K):\n    if P[i] == STmin.query(i, i + K) and P[i + K] == STmax.query(\n            i + 1, i + K + 1):\n        unite(i, i + 1)\n\ninc = 0\nincK = []\nfor i in range(N - 2, -1, -1):\n    if P[i] <= P[i + 1]:\n        inc += 1\n        if inc >= K - 1:\n            incK += [i]\n    else:\n        inc = 0\nfor i in incK:\n    unite(incK[0], i)\n\nscan_uf()\nprint(len(set(UF)))\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":907,"bad_solution":"\ndef FUNC(date):\n    \"\"\"You have to write a function which validates a given date string and\n    returns True if the date is valid otherwise False.\n    The date is valid if all of the following rules are satisfied:\n    1. The date string is not empty.\n    2. The number of days is not less than 1 or higher than 31 days for months 1,3,5,7,8,10,12. And the number of days is not less than 1 or higher than 30 days for months 4,6,9,11. And, the number of days is not less than 1 or higher than 29 for the month 2.\n    3. The months should not be less than 1 or higher than 12.\n    4. The date should be in the format: mm-dd-yyyy\n\n    for example: \n    FUNC('03-11-2000') => True\n\n    FUNC('15-01-2012') => False\n\n    FUNC('04-0-2040') => False\n\n    FUNC('06-04-2020') => True\n\n    FUNC('06\/04\/2020') => False\n    \"\"\"\n    try:\n        date = date.strip()\n        day, month, year = date.split('-')\n        day, month, year = int(day), int(month), int(year)\n        if month < 1 or month > 12:\n            return False\n        if month in [1,3,5,7,8,10,12] and day < 1 or day > 31:\n            return False\n        if month in [4,6,9,11] and day < 1 or day > 30:\n            return False\n        if month == 2 and day < 1 or day > 29:\n            return False\n    except:\n        return False\n\n    return True\n"}
{"id":908,"bad_solution":"\ndef FUNC(txt):\n    '''\n    Given a string of words, return a list of words split on whitespace, if no whitespaces exists in the text you\n    should split on commas ',' if no commas exists you should return the number of lower-case letters with odd order in the\n    alphabet, ord('a') = 0, ord('b') = 1, ... ord('z') = 25\n    Examples\n    FUNC(\"Hello world!\") ➞ [\"Hello\", \"world!\"]\n    FUNC(\"Hello,world!\") ➞ [\"Hello\", \"world!\"]\n    FUNC(\"abcdef\") == 3 \n    '''\n    if \" \" in txt:\n        return txt.split()\n    elif \",\" in txt:\n        return txt.replace(' ',',').split()\n    else:\n        return len([i for i in txt if i.islower() and ord(i)%2 == 0])\n"}
{"id":909,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\nimport itertools\nsys.setrecursionlimit(10**5)\nstdin = sys.stdin\ndef LI(): return list(map(int, stdin.readline().split()))\ndef LF(): return list(map(float, stdin.readline().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, stdin.readline().split()))\ndef II(): return int(stdin.readline())\ndef IF(): return float(stdin.readline())\ndef LS(): return list(map(list, stdin.readline().split()))\ndef S(): return list(stdin.readline().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = float('INF')\n\n#A\ndef A():\n    b = S()\n    b = b[0]\n    if b == \"A\":\n        print(\"T\")\n    elif b == \"T\":\n        print(\"A\")\n    elif b == \"C\":\n        print(\"G\")\n    elif b == \"G\":\n        print(\"C\")\n    return\n\n#B\ndef B():\n    s = S()\n    agct = [\"A\", \"G\", \"C\", \"T\"]\n    ans = 0\n    for num, i in enumerate(s):\n        ansb = 0\n        if i in agct:\n            ansb += 1\n            for k in range(num+1, len(s)):\n                if s[k] in agct:\n                    ansb += 1\n                else:\n                    break\n        ans = max(ans, ansb)\n    print(ans)\n    return\n\n#C\ndef C():\n    n, q = LI()\n    s = S()\n    ans = [0 for i in range(n+1)]\n    ac = 0\n    for num, ss in enumerate(s):\n        if not ac and ss == \"A\":\n            ac = 1\n            ans[num] = ans[num - 1]\n        elif ac and ss == \"C\":\n            ac = 0\n            ans[num] = ans[num - 1] + 1\n        else:\n            ac = 0\n            ans[num] = ans[num - 1]\n    lr = LIR_(q)\n    for l,r in lr:\n        print(ans[r]-ans[l])\n\n    return\n\n#D\ndef D():\n    return\n\n#E\ndef E():\n    return\n\n#F\ndef F():\n    return\n\n#G\ndef G():\n    return\n\n#H\ndef H():\n    return\n\n#Solve\nif __name__ == '__main__':\n    C()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":910,"bad_solution":"import sys\nfrom math import sqrt\nfrom collections import Counter, defaultdict, deque\n\ninput = sys.stdin.readline\nsys.setrecursionlimit(10 ** 6)\n\n\ndef I():\n    return int(input())\n\n\ndef MI():\n    return map(int, input().split())\n\n\ndef LI():\n    return list(MI())\n\n\ndef LIN(n: int):\n    return [I() for _ in range(n)]\n\n\ninf = float(\"inf\")\nmod = 10 ** 9 + 7\n\n\ndef main():\n    n, k = MI()\n    al = LI()\n\n    al.insert(0, 0)\n    passed = [-1] * (n + 1)\n    i = 0\n    now = 1\n    while passed[now] == -1:\n        passed[now] = i\n        now = al[now]\n        i += 1\n\n    loop = i - passed[now]\n\n    for _ in range((k - passed[now]) % loop):\n        now = al[now]\n\n    print(now)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":911,"bad_solution":"from heapq import heappush, heappop\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations,combinations\nimport sys\nimport bisect\nimport string\n#import math\n#import time\n#import random  # randome is not available at Codeforces\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef StoI():\n    return [ord(i)-97 for i in input()]\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['Yes','No']\nmo=10**9+7\ninf=float('inf')\n#ts=time.time()\n#sys.setrecursionlimit(10**6)\ninput=lambda: sys.stdin.readline().rstrip()\n\nimport sys\nsys.setrecursionlimit(10**7)\nmo=998244353\n\n\nn,a,b,k=LI()\n\n\nf=[0]*(2+n)\nr=[0]*(2+n)\n\ndef fact(n):\n    if n==0:\n        f[0]=1\n        return 1\n    if f[n]!=0:\n        return f[n]\n    f[n]=n*fact(n-1)%mo\n    return f[n]\n\nr[n]=pow(fact(n),mo-2,mo)\n\ndef revfact(n):\n    if r[n]!=0:\n        return r[n]\n    r[n]=( (n+1)*revfact(n+1) )%mo\n    return r[n]\n\ndef comb(n,k):\n    return fact(n)*revfact(n-k)*revfact(k)%mo\n\n\nfact(n)\nrevfact(0)\n\nshow_flg=False\nshow_flg=True\n\nif a<b:\n    a,b=b,a\nans=0\nfor i in range(min(n+1,k\/\/a+1)):\n    if (k-a*i)%b!=0 and 0<=((k-a*i)\/\/b)<=n:\n        continue\n    j=(k-a*i)\/\/b\n    ans+=comb(n,i)*comb(n,j)\n    ans%=mo\n\nprint(ans%mo)\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":912,"bad_solution":"def combination_to_index(a,b,n):\n    if(b<a):\n        c = a\n        a = b\n        b = c\n    return (2*n-a)*(a-1)\/\/2+b-a\n\ndef dfs(n,seen,gp,d):\n    #print(d)\n    res = -1\n    if(n in seen):\n        return -1\n    for x in gp[n]:\n        res = max(res,dfs(x,seen.union(set([n])),gp,d+1))\n\n    if(res == -1):\n        return d\n    else:\n        return res\n\ndef main():\n    N = int(input())\n    M = N*(N-1)\/\/2\n    gp = [[] for _ in range(M+1)]\n    for a in range(1,N+1):\n        A = [int(x) for x in input().split()]\n        for ind,b in enumerate(A[:-1]):\n            gp[combination_to_index(a,b,N)].append(combination_to_index(a,A[ind+1],N))\n    cnts = [0]*(M+1)\n    for i in gp:\n        for j in i:\n            cnts[j]+=1\n\n    for ind,i in enumerate(cnts):\n        if(i==0 and ind!=0):\n            gp[0].append(ind)\n\n    d = dfs(0,set(),gp,0)\n    if(d==0):\n        print(-1)\n    else:\n        print(d)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":913,"bad_solution":"def pair (inp):\n    from collections import Counter\n    z=max(inp)\n    arr=[1]*(z+1)\n    c=Counter(inp)\n    c[1]=0\n    if max(c.values())>=2 :\n        return -1\n    for i in range(2,z+1):\n        if arr[i]==1:\n            k=2\n            f=0\n            while k*i<len(arr):\n                arr[k*i]=0\n                if c[k*i]!=0:\n                    f+=c[k*i]\n                k+=1\n            if f>=2:\n                return -1\n    return 1\ndef gcd (a,b):\n    if a%b==0:\n        return b\n    if b%a==0:\n        return a\n    if a>b:\n        return gcd(b,a%b)\n    if b>a:\n        return gcd(a,b%a)\nn=int(input())\narr=list(map(int,input().split()))\nif pair(arr)==1:\n    print ('pairwise coprime')\nelse:\n    k=arr[0]\n    for i in range(1,len(arr)):\n        k=gcd(k,arr[i])\n        if k==1:\n            break\n    if k==1:\n        print ('setwise coprime')\n    else:\n        print ('not coprime')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":914,"bad_solution":"\ndef FUNC(lst):\n    '''\n    Given a list of numbers, return whether or not they are sorted\n    in ascending order. If list has more than 1 duplicate of the same\n    number, return False. Assume no negative numbers and only integers.\n\n    Examples\n    FUNC([5]) ➞ True\n    FUNC([1, 2, 3, 4, 5]) ➞ True\n    FUNC([1, 3, 2, 4, 5]) ➞ False\n    FUNC([1, 2, 3, 4, 5, 6]) ➞ True\n    FUNC([1, 2, 3, 4, 5, 6, 7]) ➞ True\n    FUNC([1, 3, 2, 4, 5, 6, 7]) ➞ False\n    FUNC([1, 2, 2, 3, 3, 4]) ➞ True\n    FUNC([1, 2, 2, 2, 3, 4]) ➞ False\n    '''\n    count_digit = dict([(i, 0) for i in lst])\n    for i in lst:\n        count_digit[i]+=1\n    if all(lst[i-1] <= lst[i] for i in range(1, len(lst))):\n        return True\n    else:\n        return False\n    \n    \n"}
{"id":915,"bad_solution":"# @oj: atcoder\n# @id: hitwanyang\n# @email: 296866643@qq.com\n# @date: 2020-06-05 17:33\n# @url:https:\/\/atcoder.jp\/contests\/abc169\/tasks\/abc169_c\nimport sys,os\nfrom io import BytesIO, IOBase\nimport collections,itertools,bisect,heapq,math,string\nfrom decimal import *\n# region fastio\n\nBUFSIZE = 8192\n\nBUFSIZE = 8192\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\nsys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n# ------------------------------\ndef main():\n    ab=list(map(float,input().split()))\n    a,b=ab[0],ab[1]\n    print (int(a*b))\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":916,"bad_solution":"import sys\nimport numpy as np\nfrom itertools import combinations\nsys.setrecursionlimit(10 ** 6)  # 再帰関数の再帰の深さを設定\nto_index = lambda x: int(x) - 1  # 入力した数字に1を引いたものを返す\nprint_list_in_2D = lambda x: print(*x, sep=\"\\n\")  # リストの要素を改行を挟んで表示する関数\n\n# 入力を整数に変換して受け取る\ndef input_int():\n    return int(input())\n\ndef map_int_input():\n    return map(int, input())\n\nMII = map_int_input\n\ndef MII_split():\n    return map(int, input().split())\n\ndef MII_to_index():\n    return map(to_index, input())\n\ndef MII_split_to_index():\n    return map(to_index, input().split())\n\n# 入力全てを整数に変換したものの配列を受け取る\ndef list_int_inputs():\n    return list(map(int, input()))\n\nLII = list_int_inputs\n\ndef LII_split():\n    return list(map(int, input().split()))\n\n# 2次元リスト化\ndef LII_2D(rows_number):\n    return [LII() for _ in range(rows_number)]\n\ndef LII_split_2D(rows_number):\n    return [LII_split() for _ in range(rows_number)]\n\nN, M, X = MII_split()\n\nbooks = []\n# prices = []\nfor i in range(N):\n    book = LII_split()\n    # prices.append(book[0])\n    books.append(book)\n\n# books = sorted(books.items(), key=lambda x: sum(x[1]), reverse=True)\n# chosen_books = []\n# is_chosen = [False for _ in range(N)]\nprice = 0\nmin_price = -1\nfor i in range(N):  # i = 選ぶ本の個数-1\n\n    for tmp_books in combinations(books, i + 1):\n        algo_skills = np.array([0 for _ in range(M)])\n        price = 0\n        for skills in tmp_books:\n            algo_skills += np.array(skills[1:])\n            price += skills[0]\n        if np.all(algo_skills >= X):\n            if min_price == -1 or price < min_price:\n                min_price = price\n\nprint(price)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":917,"bad_solution":"n,k = map(int,input().split())\na=list(map(int,input().split()))\n#input\n\nfrom collections import defaultdict\ncounter=defaultdict(int)\n#桁ごとに１の数を数える辞書型\n\ndef makebit(a):\n    return bin(a)[2:]\n#数値型から２進数の文字列型を返す関数\n\ndef count(a):\n    l=len(a)\n    for i in range(1,l+1):\n        if a[-i]=='1':\n            counter[i]+=1\n    return\n#２進数の文字列型から、１の場所と数を数える関数\n\nfor i in range(len(a)):\n    count(makebit(a[i]))\n#inputしたデータをcounterに整理する\n\nkbit=makebit(k)\n#kの2進数表記\nonetime=kbit.count('1')\n#kに何回１が出現するか(後述)\nmaxlenth=max(counter)\n#Aiの最も大きい桁\n\nkaijo=[]\nfor i in range(maxlenth+1):\n    kaijo.append(2**i)\n#２の階乗のリスト\n\nfor i in range(1,1+max(maxlenth,len(kbit))):\n    if counter[i]==0:\n        counter[i]=0\n\nif maxlenth>len(kbit):\n    kbit='0'*(maxlenth-len(kbit))+kbit\n#maxlenthまでで登録されていないkeyを登録\n\n#メインとなるループ関数\ndef search(kbit,default,ans,before,counter):\n    if kbit.count('1')==0:\n        dlenth=len(kbit)\n        for keta in counter:\n            if keta>before:continue\n            elif keta<=dlenth:\n                default+=counter[keta]*kaijo[keta-1]\n        if default>ans:ans=default\n        return ans\n    dlenth=len(kbit)-kbit.index('1')\n    now=default\n    newcounter=counter.copy()\n    for keta in counter:\n        if keta>before:continue\n        elif keta>dlenth:\n            default+=counter[keta]*kaijo[keta-1]\n            now+=counter[keta]*kaijo[keta-1]\n            newcounter.pop(keta)\n        elif keta==dlenth:\n            default+=(n-counter[keta])*kaijo[keta-1]\n            now+=counter[keta]*kaijo[keta-1]\n            newcounter.pop(keta)\n        elif keta<dlenth:now+=max(n-counter[keta],counter[keta])*kaijo[keta-1]\n    if kbit=='1':\n        now=default-(n-counter[1])\n        now+=max(n-counter[1],counter[1])\n        if now>ans:ans=now\n        return ans\n    if now>ans:ans=now\n    if '1' in kbit[1:]:\n        idx=kbit.index('1',1)\n        kbit=kbit[idx:]\n    elif '1' not in kbit:\n        kbit=kbit[1:]\n    return search(kbit,default,ans,dlenth,newcounter)\nprint(search(kbit,0,0,maxlenth+1,counter))\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":918,"bad_solution":"import sys\nstdin = sys.stdin\n\nsys.setrecursionlimit(10 ** 7)\n\ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x) - 1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\n\ndef dfs(graph: list, node: int, start: int) -> list:\n    # 未探索のノードは距離INF\n    INF = float(\"inf\")\n    dist = [INF] * node\n\n    # 始点ノードの距離を0とし、dfsのためのstackを作成\n    dist[start] = 0\n    stack = [(0, start)]\n\n    while stack:\n        cost, cur_node = stack.pop()\n\n        # 未探索のノードをstackに入れる\n        for nex_cost, nex_node in graph[cur_node]:\n            if dist[nex_node] != INF:\n                continue\n            else:\n                dist[nex_node] = dist[cur_node] + nex_cost\n                stack.append((dist[nex_node], nex_node))\n\n    return dist\n\ndef judge(graph, edges):\n    node = len(graph)\n    start = 0\n\n    # 未探索のノードは距離INF\n    INF = float(\"inf\")\n    dist = [INF] * node\n    visited = [False]*n\n    visited[0] = True\n\n    # 始点ノードの距離を0とし、dfsのためのstackを作成\n    dist[start] = 0\n    stack = [(0, start)]\n\n    while stack:\n        cost, cur_node = stack.pop()\n\n        # 未探索のノードをstackに入れる\n        for nex_cost, nex_node in graph[cur_node]:\n            if visited[nex_node]:\n                continue\n            if dist[nex_node] != INF:\n                if dist[nex_node] != dist[cur_node] + nex_cost:\n                    return False\n            else:\n                visited[nex_node] = True\n                dist[nex_node] = dist[cur_node] + nex_cost\n                stack.append((dist[nex_node], nex_node))\n\n    for i, j in edges:\n        if abs(dist[i]-dist[j]) != 1:\n            return False\n\n    return True\n\nimport numpy as np\n\nn = ni()\ngrid = [lc() for _ in range(n)]\ngraph = [[] for _ in range(n)]\nnumgraph = np.zeros((n, n))\nedges = []\nfor row, si in enumerate(grid):\n    for col, sij in enumerate(si):\n        if sij == \"1\":\n            edges.append((row, col))\n            graph[row].append((1, col))\n            numgraph[row][col] = 1\n\n# 二部グラフ判定\nis_nibu = judge(graph, edges)\n\nif is_nibu:\n    from scipy.sparse.csgraph import floyd_warshall\n    dists = floyd_warshall(numgraph)\n    ans = 0\n    for i in range(n):\n        ans = max(ans, max(dists[i,:]))\n\n    print(int(ans) + 1)\n\nelse:\n    print(-1)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":919,"bad_solution":"N,A,B,C,D=map(int,input().split())\ns=input()\n\ndef solve(r,l):\n    for i in range(r,l-1):\n        if s[i-1] == \"#\" and s[i] == \"#\":\n            return False\n    return True\n\ndef perfect_solve(r,l):\n    for i in range(r,l-1):\n        if s[i-1] ==\"#\" and s[i] ==\"#\":\n            return False\n\n    for i in range(r-1,l-1):\n        if s[i-1]==\".\" and s[i]==\".\" and s[i+1]==\".\":\n            return True\n    return False\n\nif C < B :\n    if solve(A,C) and solve(B,D):\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelif C < D :\n    if solve(B,D) and solve(A,B):\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:\n    if perfect_solve(B,D) and solve(A,B) and solve(D,C):\n        print(\"Yes\")\n    else:\n        print(\"No\")\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":920,"bad_solution":"from collections import deque\ndef main():\n    n, k = map(int, raw_input().split())\n    s = raw_input().strip()\n    ans = deque(list(s))\n    if n == 1:\n        if k % 2:\n            print 'A' if s[0] == 'B' else 'B'\n        else:\n            print s[0]\n        return\n    f = True\n    for i in xrange(800020):\n        if i >= k:\n            if f:\n                print ''.join(list(ans))\n            else:\n                print ''.join('A' if x == 'B' else 'B' for x in ans)\n            break\n        if (ans[0] == 'A') == f:\n            ans[0] = 'B' if f else 'A'\n        else:\n            f = not f\n            ans.popleft()\n            ans.append('A' if f else 'B')\n    else:\n        k -= 800020\n        k %= 2\n        if not f:\n            ans = ['B' if x == 'A' else 'A' for x in ans]\n            ans = deque(ans)\n        if k:\n            if ans[0] == 'A':\n                ans[0] = 'B'\n            else:\n                ans[0] = 'A'\n        print ''.join(ans)\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":921,"bad_solution":"import time\nst_time=time.time()\n\nfrom heapq import heappush, heappop\nfrom collections import deque,defaultdict,Counter\nimport itertools\nfrom itertools import permutations,combinations\nimport sys\nimport bisect\nimport string\nimport math\nimport random\ndef I():\n    return int(input())\ndef MI():\n    return map(int,input().split())\ndef LI():\n    return [int(i) for i in input().split()]\ndef LI_():\n    return [int(i)-1 for i in input().split()]\ndef show(*inp,end='\\n'):\n    if show_flg:\n        print(*inp,end=end)\nYN=['Yes','No']\nmo=10**9+7\ninf=float('inf')\nts=time.time()\nsys.setrecursionlimit(10**6)\ninput=sys.stdin.readline\nshow_flg=False\n#show_flg=True\n\nh,w,n=LI()\nb=[h,w,w,h]\nr,c=LI()\nst=[r,c,c,r]\ns=input()\nt=input()\ncs=[[0]for i in range(4)]\nct=[[0]for i in range(4)]\ndi='URLD'\ndi=dict(zip(list(di),range(4)))\nfor j,i in di.items():\n    for k in range(n):\n        cs[i].append(cs[i][-1]+(1 if s[k]==j else 0))\n        ct[i].append(ct[i][-1]+(1 if t[k]==j else 0))\nans=False\nfor i in range(4):\n    if max([(i-j)*(-1)**(i\/\/2)+st[i] for i,j in zip(cs[i],[0]+ct[3-i])])>b[i]:\n        ans=True\nif ans:\n    print('YES')\nelse:\n    print('NO')\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":922,"bad_solution":"import sys\nsys.setrecursionlimit(10 ** 7)\ninput = sys.stdin.readline\n\nfrom math import gcd\n\nn = int(input())\na = list( map(int, input().split()))\n\ndef eratosthenes(limit):\n    import math\n    if not isinstance(limit, int):\n        raise TypeError('n is int type.')\n    if limit < 2:\n        raise ValueError('n is more than 2')\n    prime = []\n    sqrt_limit = math.sqrt(limit)\n    prime_numbers_list = [i + 1 for i in range(1, limit)]\n    while True:\n        p = prime_numbers_list[0]\n        if sqrt_limit <= p:\n            return prime + prime_numbers_list\n        prime.append(p)\n        prime_numbers_list = [e for e in prime_numbers_list if e % p != 0]\n    return prime_numbers_list\n\ndef main():\n    a.sort()\n\n    g = 0\n    for aa in a:\n        g = gcd(g,aa)\n    if g > 1:\n        print('not coprime')\n        exit()\n\n    if a[-1]==1:\n        print('pairwise coprime')\n        exit()\n\n    prime_numbers_list = eratosthenes(a[-1])\n    count = [0]*len(prime_numbers_list)\n\n    for aa in a:\n        for i, prime in enumerate(prime_numbers_list):\n            if aa % prime ==0:\n                count[i] += 1\n                if count[i]==2:\n                    print('setwise coprime')\n                    exit()\n                break\n\n    print('pairwise coprime')\n\nmain()\n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":923,"bad_solution":"class RollingHash():\n    def __init__(self, string):\n        self.n = len(string)\n        self.BASE = 1007\n        self.MOD = 10**9+7\n        self.hash = [0] * (self.n + 1)\n        self.pow = [1] * (self.n + 1)\n        \n        for i, char in enumerate(string):\n            self.hash[i+1] = (self.hash[i] * self.BASE + ord(char)) % self.MOD\n            self.pow[i+1] = (self.pow[i] * self.BASE) % self.MOD\n            \n    def get_hash(self, l, r):\n        res = (self.hash[r] - self.hash[l] * self.pow[r-l]) % self.MOD\n        return res\n      \n\nn = int(input())\ns = input()\n\nrh = RollingHash(s)\n\nans = 0\nfor length in range(n + 1):\n    set_ = set([])\n    for l in range(n):\n        # [l, l + length), [l + length, l + 2*length)\n        if l + 2*length > n:\n            break\n        set_.add(rh.get_hash(l, l + length))\n        tmp = rh.get_hash(l + length, l + 2*length)\n        if tmp in set_:\n            ans = length\n            break\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":924,"bad_solution":"import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\nfrom collections import defaultdict\ndef main():\n    n, *a = map(int, read().split())\n\n    maxa = max(a) + 1  # aはint配列\n    d = [i for i in range(maxa)]\n    for p0 in range(2, maxa):\n        if p0 == d[p0]:\n            for p1 in range(p0 ** 2, maxa, p0):\n                if d[p1] % p0 == 0:\n                    d[p1] = p0\n\n    def factorization(f):  # f > maxaだとエラー\n        l = []\n        t = f\n        while True:\n            if t == d[t]:\n                l.append(d[t])\n                break\n            else:\n                l.append(d[t])\n                t = t \/\/ d[t]\n        return l\n\n    if all([i == 1 for i in a]):\n        print('pairwise coprime')\n        sys.exit()\n    if len(set(a)) == 1:\n        print('not coprime')\n        sys.exit()\n    d1 = defaultdict(int)\n    for ae in a:\n        t1 = set(factorization(ae))\n        for t1e in t1:\n            d1[t1e] += 1\n    d1v = tuple(d1.values())\n    if all([i == 1 for i in d1v]):\n        print('pairwise coprime')\n    elif max(d1v) == n:\n        print('not coprime')\n    else:\n        print('setwise coprime')\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":925,"bad_solution":"import sys\nimport os\nimport math\nimport bisect\nimport collections\nimport itertools\nimport heapq\n\nii = lambda: int(sys.stdin.buffer.readline().rstrip())\nil = lambda: list(map(int, sys.stdin.buffer.readline().split()))\nfl = lambda: list(map(float, sys.stdin.buffer.readline().split()))\niln = lambda n: [int(sys.stdin.buffer.readline().rstrip()) for _ in range(n)]\n\niss = lambda: sys.stdin.buffer.readline().decode().rstrip()\nsl = lambda: list(map(str, sys.stdin.buffer.readline().decode().split()))\nisn = lambda n: [sys.stdin.buffer.readline().decode().rstrip() for _ in range(n)]\n\nlcm = lambda x, y: x * y \/ math.gcd(x, y)\n\nMOD = 10 ** 9 + 7\nMAX = float('inf')\n\n\ndef main():\n    if os.getenv(\"LOCAL\"):\n        sys.stdin = open(\"input.txt\", \"r\")\n\n    N, K = il()\n    A = il()\n\n    town = [False]*N\n    town[0] = True\n    tel = [0]*N\n    nextT, cnt = 0, 0\n    for n in range(N):\n        nextT = A[nextT]-1\n        cnt += 1\n        if town[nextT]:\n            break\n        tel[n] = nextT+1\n        town[nextT] = True\n\n    mod = (K - cnt) % (len(tel)-cnt)\n    print(tel[mod+1])\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":926,"bad_solution":"import bisect,copy,heapq,string\nfrom collections import *\nfrom math import *\nfrom itertools import *\nimport sys\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nh, w = MAP()\na = [input()+'.' for i in range(h)]\na.append(\".\"*(w+1))\ni = j = 0\n\nif a[0][0] == '.':\n        print(\"Impossible\")\n        exit()\nelse:\n        while i < h or j < w:\n                if i == h-1 and j == w-1:\n                        print(\"Possible\")\n                        exit()\n                elif a[i+1][j] == '#':\n                        i += 1\n                elif a[i][j+1] == '#':\n                        j += 1\n                elif a[i+1][j] == a[i][j+1] == '.' or a[i][j] == a[i+1][j] == a[i][j+1] == a[i+1][j+1] == '#':\n                        print(\"Impossible\")\n                        exit()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":927,"bad_solution":"ma = lambda :map(int,input().split())\nlma = lambda :list(map(int,input().split()))\ntma = lambda :tuple(map(int,input().split()))\nni = lambda:int(input())\nyn = lambda fl:print(\"Yes\") if fl else print(\"No\")\nimport collections\nimport math\ngcd=math.gcd\n\ndef is_primes(n):\n    primes = [True]*n\n    primes[0] =False\n    primes[1] =False\n    p = 2\n    while p*p <=n:\n        if primes[p]:\n            for q in range(2*p,n,p):\n                primes[q] = False\n        p+=1\n    return primes\n\ndef factorize(n,primes):\n    fct = [(1,1)]\n    for b in primes:#primes ::sorted\n        if b**2 > n:\n            break\n        cnt =0\n        while n % b == 0:\n            n \/\/= b\n            cnt +=1\n        if cnt >=1:\n            fct.append((b,cnt))\n    if n > 1:\n        fct.append((n,1))\n    return fct\n\nn =ni()\nA = lma()\ntmp=0\nfor a in A:\n    tmp = gcd(a,tmp)\nif tmp!= 1:\n    print(\"not coprime\")\n    exit()\nmx= 10**6+10\nprms = is_primes(mx)\nprms2=[i for i in range(mx) if prms[i]]\n#print(prms2)\nd=collections.Counter()\nfor a in A:\n    fct = factorize(a,prms2)\n    print(fct)\n    for fc,cnt in fct:\n        if cnt>=1:\n            d[fc]+=1\n\nf1=True # pp or sp\nf2=True # sp or not p\nfor num,cnt in d.items():\n    if num==1:\n        continue\n    if cnt==n:\n        f2=False #全体で共通の約数になる\n        break\n    else:\n        if cnt==1:\n            pass\n        else:\n            f1=False\n            break\n\nif f2==False:\n    print(\"not coprime\")\nelif f1:\n    print(\"pairwise coprime\")\nelse:\n    print(\"setwise coprime\")\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":928,"bad_solution":"import sys\nsys.setrecursionlimit(1 << 25)\nreadline = sys.stdin.buffer.readline\nread = sys.stdin.readline  # 文字列読み込む時はこっち\nra = range\nenu = enumerate\n\n\ndef exit(*argv, **kwarg):\n    print(*argv, **kwarg)\n    sys.exit()\n\n\ndef mina(*argv, sub=1): return list(map(lambda x: x - sub, argv))\n# 受け渡されたすべての要素からsubだけ引く.リストを*をつけて展開しておくこと\n\n\ndef a_int(): return int(readline())\n\n\ndef ints(): return list(map(int, readline().split()))\n\n\ndef _make_minimum_prime(N: int):\n    # xの最小の素因数表を作成\n    min_prime = [N + 114514] * (N + 1)\n    min_prime[0] = 0  # 0と1は素数ではない\n    min_prime[1] = 1\n    for i in range(2, int(N ** 0.5) + 1):\n        if min_prime[i] == N + 114514:  # 素数だったら更新\n            min_prime[i] = i\n            for j in range(2 * i, N + 1, i):  # iの倍数は素数でない\n                min_prime[j] = min(min_prime[j], i)\n    return min_prime\n\n\nmin_prime = _make_minimum_prime(10**6)\n\n\nfrom collections import Counter\n\n\ndef fast_factorization(N: int):\n    # -> List[Tuple[int,int]] (素数,冪数)を格納\n    # 最小素数配列min_primeを使ってO(log N)で因数分解\n    if N == 1:\n        return []  # 1は素数ではない\n    # 素因数分解\n    arr = []\n    tmp = N\n    while tmp != 1:\n        p = min_prime[tmp]\n        tmp \/\/= p\n        arr.append(p)\n\n    return Counter(arr)\n\n\nMOD = 10**9 + 7\nINF = 2**31  # 2147483648 > 10**9\n# default import\nfrom collections import defaultdict, Counter, deque\nfrom math import gcd\n\n\nN = a_int()\nA = ints()\n\n# setかはすぐわかる\n# setでなければ not coprime\n# pairは互いに素かをみればいいのか\n# つまり因数分解して足してったときにすべての素数のべき数が1以下であれば良い\n\ng_set = 0\ncnt = defaultdict(lambda: 0)\nflg = 1  # pairwiseであるフラグ\nfor a in A:\n    g_set = gcd(g_set, a)\n    if flg:\n        for p, n in fast_factorization(a).items():\n            if cnt[p] != 0:\n                flg = 0\n            cnt[p] += n\n\n\n# print(cnt)\n# for v in cnt.values():\n#     if v > 1:\n#         flg = 0\n#         break\n\nif g_set > 1:\n    print('not coprime')\nelif flg:\n    print('pairwise coprime')\nelse:\n    print('setwise coprime')\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":929,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\nimport time,random\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**10\nmod = 10**9+7\nmod2 = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    h,w = LI()\n    a = [LI() for _ in range(h)]\n    b = [LI() for _ in range(h)]\n    mm = 80*80\n    m = 1 << (mm+3)\n    r = [[0]*w for _ in range(h)]\n    c = abs(a[0][0] - b[0][0])\n    r[0][0] |= (1 << (mm+1)) << c\n    r[0][0] |= (1 << (mm+1)) >> c\n    for i in range(h):\n        for j in range(w):\n            if i == 0 and j == 0:\n                continue\n            c = abs(a[i][j] - b[i][j])\n            t = 0\n            if i > 0:\n                t |= (r[i-1][j] << c) % m\n                t |= r[i-1][j] >> c\n            if j > 0:\n                t |= (r[i][j-1] << c) % m\n                t |= r[i][j-1] >> c\n            r[i][j] = t\n\n    c = r[-1][-1]\n    t = 100\n    for i in range(mm+3):\n        if (1<<i) & c > 0:\n            k = abs(i-mm+1)\n            if t > k:\n                t = k\n\n    return t\n\n\nprint(main())\n\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":930,"bad_solution":"def main():\n    n, k = map(int, input().split())\n    a_list = list(map(int, input().split()))\n    visited_list = [-1] * n  # 何ワープ目で訪れたか\n    visited_list[0] = 0\n    city, loop, non_loop = 1, 0, 0  # 今いる街、何ワープでループするか、最初にループするまでのワープ数\n\n    for i in range(1, n + 1):\n        city = a_list[city - 1]\n        if visited_list[city - 1] != -1:\n            loop = i - visited_list[city - 1]\n            non_loop = visited_list[city - 1] - 1\n            break\n        else:\n            visited_list[city - 1] = i\n\n    if k <= non_loop:\n        for _ in range(k):\n            city = a_list[city - 1]\n    else:\n        for _ in range(non_loop + (k - non_loop) % loop + loop):\n            city = a_list[city - 1]\n\n    print(city)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":931,"bad_solution":"import sys\nfrom collections import Counter\n\ndef defs(c1, c2):\n    \n    if c1[0][1] > c2[0][1]:\n        return c1[0], c2[1]\n    else:\n        return c1[1], c2[0]\n\ndef main():\n    input = sys.stdin.readline\n    \n    n = int(input())\n    m = [int(i) for i in input().split()]\n    \n    even = [m[i] for i, _ in enumerate(m) if i % 2 == 0]\n    odd = [m[i] for i, _ in enumerate(m) if i % 2 == 1]\n    \n    even_c = Counter(even).most_common()\n    odd_c = Counter(odd).most_common()\n    \n    if even_c[0] == odd_c[0]:\n        print(len(m) \/ 2)\n        return\n    \n#    print(even_c)\n#    print(odd_c)\n    \n    even_c, odd_c = defs(even_c, odd_c)\n    \n    if even_c[1] == odd_c[1]:\n        ans = len(odd) - min(even_c[1], odd_c[1])\n        \n    else:\n        ans = len(m) - (even_c[1] + odd_c[1])\n    \n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n    \n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":932,"bad_solution":"import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7\ninput=lambda :sys.stdin.readline().rstrip()\ndef resolve():\n    from itertools import product\n    n=int(input())\n    match=[[0]*n for _ in range(n)]\n    V=0 # V=n(n-1)\/2\n    for i,j in product(range(n),repeat=2):\n        if(i>=j): continue\n        match[i][j]=V\n        V+=1\n\n    def toID(i,j):\n        if(i>j): i,j=j,i\n        return match[i][j]\n\n    E=[[] for _ in range(V)]\n    for i in range(n):\n        A=list(map(lambda x:int(x)-1,input().split()))\n        for j in range(1,n-1):\n            E[toID(i,A[j-1])].append(toID(i,A[j]))\n    # あとは頂点VのグラフをdfsしてLongest pathの長さを求める\n    # -1: unchecked, -2: checked and uncalculated\n    dp=[-1]*V\n    flag=True\n    def dfs(v):\n        global flag\n        dp[v]=-2\n        length=0\n        for nv in E[v]:\n            if(dp[nv]==-2):\n                print(-1)\n                sys.exit()\n            if(dp[nv]==-1):\n                dfs(nv)\n            length=max(length,dp[nv]+1)\n        dp[v]=length\n    # calculate\n    dfs(0)\n    print(max(dp)+1)\nresolve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":933,"bad_solution":"def main():\n    from collections import deque\n\n    INF = float('inf')\n\n    H, W = map(int, input().split())\n    Ch, Cw = map(lambda x: int(x) - 1, input().split())\n    Dh, Dw = map(lambda x: int(x) - 1, input().split())\n    S = [input() for _ in range(H)]\n\n    t = [[INF] * W for _ in range(H)]\n    t[Ch][Cw] = 0\n    q = deque([(Ch, Cw)])\n\n    while q:\n        h, w = q.popleft()\n        a = t[h][w]\n        if h - 1 >= 0 and S[h - 1][w] != '#' and t[h - 1][w] > a:\n            q.appendleft((h - 1, w))\n            t[h - 1][w] = a\n        if h + 1 < H and S[h + 1][w] != '#' and t[h + 1][w] > a:\n            q.appendleft((h + 1, w))\n            t[h + 1][w] = a\n        if w - 1 >= 0 and S[h][w - 1] != '#' and t[h][w - 1] > a:\n            q.appendleft((h, w - 1))\n            t[h][w - 1] = a\n        if w + 1 < W and S[h][w + 1] != '#' and t[h][w + 1] > a:\n            q.appendleft((h, w + 1))\n            t[h][w + 1] = a\n\n        for i in range(max(0, h - 2), min(H - 1, h + 2) + 1):\n            for j in range(max(0, w - 2), min(W - 1, w + 2) + 1):\n                if S[i][j] == '#':\n                    continue\n                if t[i][j] <= a + 1:\n                    continue\n                t[i][j] = a + 1\n                q.append((i, j))\n\n    if t[Dh][Dw] == INF:\n        print(-1)\n    else:\n        print(t[Dh][Dw])\n\n\nmain()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":934,"bad_solution":"def main():\n    from functools import lru_cache\n    import sys\n\n    sys.setrecursionlimit(10 ** 7)\n\n    N, X = map(int, input().split())\n\n    size = [0] * (N + 1)\n    patty = [0] * (N + 1)\n    size[0] = 1\n    patty[0] = 1\n    for lv in range(1, N + 1):\n        size[lv] = size[lv - 1] * 2 + 3\n        patty[lv] = patty[lv - 1] * 2 + 1\n\n    @lru_cache(maxsize=None)\n    def burger(lv, x):\n        if lv == 0:\n            return x > 0\n\n        if x <= 1:\n            return 0\n\n        if x <= 1 + size[lv - 1]:\n            return burger(lv - 1, x - 1)\n\n        if x == 1 + size[lv - 1] + 1:\n            return patty[lv - 1] + 1\n\n        if x <= 1 + size[lv - 1] + 1 + size[lv - 1]:\n            return patty[lv - 1] + 1 + burger(lv - 1, x - (1 + size[lv - 1] + 1))\n\n        return patty[lv]\n\n    ans = burger(N, X)\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":935,"bad_solution":"#参考https:\/\/qiita.com\/takayg1\/items\/c811bd07c21923d7ec69\n\n#####segfunc#####\ndef segfunc(x, y):\n    return x+y\n#################\n\n#####ide_ele初期値#####\nide_ele = 0\n#################\n\nclass SegTree:\n    \"\"\"\n    init(init_val, ide_ele): 配列init_valで初期化 O(N)\n    update(k, x): k番目の値をxに更新 O(logN)\n    query(l, r): 区間[l, r)をsegfuncしたものを返す O(logN)\n    \"\"\"\n    def __init__(self, init_val, segfunc, ide_ele):\n        \"\"\"\n        init_val: 配列の初期値\n        segfunc: 区間にしたい操作\n        ide_ele: 単位元\n        n: 要素数\n        num: n以上の最小の2のべき乗\n        tree: セグメント木(1-index)\n        \"\"\"\n        n = len(init_val)\n        self.segfunc = segfunc\n        self.ide_ele = ide_ele\n        self.num = 1 << (n - 1).bit_length()\n        self.tree = [ide_ele] * 2 * self.num\n        # 配列の値を葉にセット\n        for i in range(n):\n            self.tree[self.num + i] = init_val[i]\n        # 構築していく\n        for i in range(self.num - 1, 0, -1):\n            self.tree[i] = self.segfunc(self.tree[2 * i], self.tree[2 * i + 1])\n\n    def update(self, k, x):\n        \"\"\"\n        k番目の値をxに更新\n        k: index(0-index)\n        x: update value\n        \"\"\"\n        k += self.num\n        self.tree[k] = x\n        while k > 1:\n            self.tree[k >> 1] = self.segfunc(self.tree[k], self.tree[k ^ 1])\n            k >>= 1\n\n    def query(self, l, r):\n        \"\"\"\n        [l, r)のsegfuncしたものを得る ※区間注意\n        l: index(0-index)\n        r: index(0-index)\n        \"\"\"\n        res = self.ide_ele\n\n        l += self.num\n        r += self.num\n        while l < r:\n            if l & 1:\n                res = self.segfunc(res, self.tree[l])\n                l += 1\n            if r & 1:\n                res = self.segfunc(res, self.tree[r - 1])\n            l >>= 1\n            r >>= 1\n        return res\n\n#%%\n\ndef function():\n    N, Q = map(int, input().split())\n    c = list(map(int, input().split()))\n    lrs = [list(map(lambda x:int(x)-1, input().split())) for i in range(Q)]\n    \n    for i in range(len(lrs)):\n        lrs[i].append(i)\n    \n    right_edge = [-1]*(N+1)\n    seg = SegTree([0]*(N+1), segfunc, ide_ele)\n    # =============================================================================\n    # print(seg.tree[1])\n    # print(seg.query(0,7))\n    # seg.update(0,100)\n    # print(seg.tree)\n    # =============================================================================\n    \n    lrs = sorted(lrs, key = lambda x:x[1])\n    order_num = 0\n    answer = [0]*(Q)\n    for i, c_o in enumerate(c):\n        if right_edge[c_o] >= 0:\n            seg.update(right_edge[c_o], 0)\n        right_edge[c_o] = i\n        seg.update(i, 1)\n        \n        for i in range(N):\n            if order_num >= Q:\n                break\n            if lrs[order_num][1] == i:\n                answer[lrs[order_num][2]] = [order_num,seg.query(lrs[order_num][0],lrs[order_num][1]+1)]\n                order_num += 1\n            else:\n                break\n    \n    for i in range(len(answer)):\n        print(answer[i][1])\n        \nif __name__ == '__main__':\n    function()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":936,"bad_solution":"def available(start, end, S, step=None):\n    if step is not None:    #   追い越し処理\n        S = S[:step] + \"#\" + S[step+1:]\n    for i in range(start-1, end-1):\n        if S[i] == \"#\" and S[i+1] == \"#\":\n            return False\n    return True, S\n    \ndef overtake(start, end, S):\n    fixed_end = min(end-1, len(S)-2)\n    fixed_start = max(start-1, 1)\n    for i in range(fixed_start, fixed_end):\n        if S[i-1] == \".\" and S[i] == \".\" and S[i+1] == \".\":\n            step = i\n            return True, step\n    return False, None\n\nN, A, B, C, D = map(int, input().split())\nS = input()\n\nif D > C:   #   追い越しが不要な時\n    judge1, S = available(A, C, S)\n    judge2, S = available(B, D, S)\n    if judge1 and judge2:\n        print(\"Yes\")\n    else:\n        print(\"No\")\nelse:   #   追い越しが必要な時\n    overtakable, step = overtake(B, D, S)\n    if overtakable:   #   追い越しが可能な時\n        judge1, S = available(B, D, S)\n        judge2, S = available(A, C, S, step=step)\n        if judge1 and judge2:\n            print(\"Yes\")\n        else:\n            print(\"No\")\n    else:   #   追い越しができない時\n        print(\"No\")\n        \nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":937,"bad_solution":"from collections import deque\n\n\ndef solve():\n    H, W = map(int, input().split())\n    m = [[-1]*W for _ in range(H)]\n    q = deque([])\n    l = [input() for _ in range(H)]\n    for i in range(H):\n        for j in range(W):\n            if l[i][j]==\"#\":\n                q.append((i, j, 0))\n    \n    dx = [-1, 1, 0, 0]\n    dy = [0, 0, -1, 1]\n\n    while q:\n        y, x, cost = q.popleft()\n        m[y][x] = cost\n\n        for px, py in zip(dx, dy):\n            x1, y1 = x + px, y + py\n            if not (0<=x1<W and 0<=y1<H):\n                continue\n            if m[y1][x1] == -1:\n                q.append((y1, x1, cost+1))\n\n    print(max(map(max, m)))\n\n\nif __name__ == \"__main__\":\n    solve()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":938,"bad_solution":"from collections import Counter\n\n\ndef main():\n    n = int(input())\n    v = list(map(int, input().split()))\n    max_count = Counter.most_common(Counter(v))\n    if len(max_count) == 1:\n        print(n \/\/ 2)\n    else:\n        ans = max_count[0][1] - max_count[1][1]\n        print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":939,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**10\nmod = 998244353\ndd = [(-1,0),(0,1),(1,0),(0,-1)]\nddn = [(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef LLI(): return [list(map(int, l.split())) for l in sys.stdin.readlines()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\ndef pe(s): return print(str(s), file=sys.stderr)\ndef JA(a, sep): return sep.join(map(str, a))\ndef JAA(a, s, t): return s.join(t.join(map(str, b)) for b in a)\n\n\ndef main():\n    n = I()\n    xy = [LI() for _ in range(n)]\n    xd = collections.defaultdict(set)\n    yd = collections.defaultdict(set)\n\n    for x,y in xy:\n        xd[x].add(y)\n        yd[y].add(x)\n\n    r = 0\n    for x,v in xd.items():\n        c = 0\n        for y in v:\n            c += len(yd[y] - v)\n        r += c\n\n    return r\n\n\nprint(main())\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":940,"bad_solution":"import sys\nsys.setrecursionlimit(10**9)\ninput = sys.stdin.readline\nfrom collections import deque\n\nMOD = 10**9 + 7\nN = int(input())\ntree = dict(zip(range(N), [[] for i in range(N)]))\nedge_id = {}\nc = 0\nfor i in range(N-1):\n  a, b = map(int, input().split())\n  a, b = a-1, b-1\n  tree[a].append(b)\n  tree[b].append(a)\n  edge_id[(a, b)] = c\n  edge_id[(b, a)] = c + 1\n  c += 2\n\n# 部分木のサイズ\n# 頂点v1 -> v2の向きを考えたときに、頂点v2を根とする部分木のサイズを計算する\nsize = [0] * 2*(N-1)\ndef calc_size(v1, v2):\n  global size\n  idx = edge_id[(v1, v2)]\n  if size[idx]:\n    return size[idx]\n  children = tree[v2]\n  s = 1\n  for child in children:\n    if child == v1:\n      continue\n    s += calc_size(v2, child)\n  size[idx] = s\n  idx_inv = edge_id[(v2, v1)]\n  size[idx_inv] = N - s\n  return s\n\n# 階乗、組合せの計算\ng1 = [1, 1]\ng2 = [1, 1]\ninverse = [0, 1]\nMOD = 10**9+7\nfor i in range(2, 2*10**5+1):\n    g1.append((g1[-1] * i) % MOD)\n    inverse.append((-inverse[MOD % i] * (MOD \/\/ i)) % MOD)\n    g2.append((g2[-1] * inverse[-1]) % MOD)\n\ndef comb(n, r, mod=MOD):\n    if r < 0 or r > n:\n        return 0\n    r = min(r, n - r)\n    return g1[n] * g2[r] * g2[n-r] % mod\n\n# 頂点iに1を書くときの場合の数\nans = [0] * N\ndp = [0] * 2*(N-1)\ndef calc_dp(v1, v2):\n  global dp\n  idx = edge_id[(v1, v2)]\n  if dp[idx]:\n    return dp[idx]\n  children = tree[v2]\n  s = calc_size(v1, v2)\n  res = g1[s-1]\n  for child in children:\n    if child == v1:\n      continue\n    res *= calc_dp(v2, child)\n    res %= MOD\n    _s = calc_size(v2, child)\n    res *= g2[_s]\n    res %= MOD\n  dp[idx] = res\n  return res\n\ndef calc_ans(i):\n  global ans\n  global dp\n  if ans[i]:\n    return ans[i]\n  children = tree[i]\n  res = g1[N-1]\n  for child in children:\n    res *= calc_dp(i, child)\n    res %= MOD\n    _s = calc_size(i, child)\n    res *= g2[_s]\n    res %= MOD\n  ans[i] = res\n  return res\n\ncalc_ans(0)\nd = deque([[0, -1]])\nc = 0\nwhile d:\n  node, par = d.popleft()\n  c += 1\n  children = tree[node]\n  for child in children:\n    if child == par:\n      continue\n    s = calc_size(node, child)\n    r = s * pow(N-s, MOD-2, MOD) % MOD\n    ans[child] = ans[node] * r % MOD\n    d.append([child, node])\n\nprint(*ans, sep='\\n')\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":941,"bad_solution":"from collections import defaultdict\nn,m=map(int,input().split())\n\nprice_list=[0]*n\nnum_dic=defaultdict(int)\n\ndef mergesort(a):\n    def _merge_sort(a, left: int, right: int):\n        if left < right:\n            center = (left+right)\/\/2\n\n            _merge_sort(a,left,center)\n            _merge_sort(a,center+1,right)\n\n            #pは前半部をbuffにコピーする際のインデックス、jで取り出す\n            p=j=0\n            i=k=left\n\n            #配列の前半部をbuffにコピー\n            while i <= center:\n                buff[p]=a[i]\n                p+=1\n                i+=1\n\n            #後半部をコピーされた前半部と比較、小さい方をaに格納していく\n            while i<= right and j < p:\n                if buff[j] <= a[i]:\n                    a[k]=buff[j]\n                    j+=1\n                else:\n                    a[k]=a[i]\n                    i+=1\n                k+=1\n\n            while j < p:\n                a[k] =buff[j]\n                k+=1\n                j+=1\n\n    n=len(a)\n    #merge結果を一時的に格納\n    buff=[None]*n\n    _merge_sort(a,0,n-1)\n    del buff\n\nfor i in range(n):\n    a,b=map(int,input().split())\n    price_list[i]=a\n    if num_dic[price_list[i]] is None:\n        num_dic[price_list[i]]=b\n    else:\n        num_dic[price_list[i]]+=b\n\nmergesort(price_list)\n#同じ値段と違う値段で場合分け\nprice_sum=0\ndrink_count=0\nfor i in range(n):\n    if i!=0 and price_list[i-1]==price_list[i]:\n        continue\n    else:\n        #i番目のドリンクを買い占め\n        p=price_list[i]*num_dic[price_list[i]]\n        price_sum+=p\n        drink_count+=num_dic[price_list[i]]\n        if drink_count>=m:\n            stop=i\n            break\n\nwhile drink_count!=m:\n    drink_count-=1\n    price_sum-=price_list[i]\n\nprint(price_sum)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":942,"bad_solution":"import sys\nfrom collections import deque\n\n#def input(): return sys.stdin.readline().strip()\n\nicase=0\nif icase==0:\n    h,w=map(int,input().split())\n    ch,cw=map(int,input().split())\n    ch-=1\n    cw-=1\n    dh,dw=map(int,input().split())\n    dh-=1\n    dw-=1\n    s=[[] for i in range(h)]\n    for i in range(h):\n        s[i]=input()\n        \nij=[(1,0),(-1,0),(0,1),(0,-1)]\nwpij=[(1,1),(-1,-1),(-1,1),(1,-1),\n      (2,-2),(2,-1),(2,0),(2,1),(2,2),\n      (-2,-2),(-2,-1),(-2,0),(-2,1),(-2,2),\n      (1,2),(0,2),(-1,2),(1,-2),(0,-2),(-1,-2)]\n\ng=[[[] for i in range(w)] for i in range(h)]\ngg=[[[] for i in range(w)] for i in range(h)]\nwpg2=[[0]*w for i in range(h)]\nwpg=[]\nfor i in range(h):\n    for j in range(w):\n        for ii,jj in ij:\n            if 0>i+ii or i+ii>=h:\n                continue\n            if 0>j+jj or j+jj>=w:\n                continue\n            if s[i+ii][j+jj]==\".\":\n                g[i][j].append((i+ii,j+jj))        \n            else:\n#                wpg.append((i,j))\n                wpg2[i][j]=1\nprint(-2)                \nfor i in range(h):\n    for j in range(w):\n        if wpg2[i][j]==1:\n            wpg.append((i,j))\n                \n#wpg=tuple(set(wpg))\n\nfor i,j in wpg:\n    for ii,jj in wpij:\n         if 0<=i+ii and i+ii<h and 0<=j+jj \\\n            and j+jj<w and s[i+ii][j+jj]==\".\":\n                gg[i][j].append((i+ii,j+jj))        \n\nq=deque([(ch,cw)])\nqq=deque()\nparent=[[-1]*w for i in range(h)]\nparent[ch][cw]=0\ndist=[[-1]*w for i in range(h)]\ndist[ch][cw]=0\nwhile True:\n    while q:\n#        print(\"q1:\",q)\n        hi,wi = q.popleft()\n        if len(gg[hi][wi])>0:\n            qq.append((hi,wi))\n        for hj,wj in g[hi][wi]:\n            if parent[hj][wj] !=-1:\n                continue\n            else:\n                parent[hj][wj]=(hi,wi)\n                dist[hj][wj]=dist[hi][wi]+1\n                q.append((hj,wj))\n                if hj==dh and wj==dw:\n                    print(dist[dh][dw]\/\/(10**7))   \n                    sys.exit()\n\n    while qq:\n        hi,wi = qq.popleft()\n        for hj,wj in gg[hi][wi]:\n            if parent[hj][wj]!=-1:\n                continue\n            parent[hj][wj]=(hi,wi)\n            dist[hj][wj]=dist[hi][wi]+10**7\n            q.append((hj,wj))\n            if hj==dh and wj==dw:\n                print(dist[dh][dw]\/\/(10**7))   \n                sys.exit()\n\n    if len(q)==0:\n        break\nprint(-1)   \n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":943,"bad_solution":"\"\"\"\n3 5 2\n11100\n10001\n00111\n\"\"\"\n\nimport copy\nH, W, K = map(int, input().split())\nS = [0] * H\n\nfor h in range(H):\n    S[h] = list(input())\n\n\ndef check(divH):\n    MAP = [0] * H\n    BitDivH = \"\".join([\"{:0\", str(H - 1), \"b}\"]).format(divH)\n    cnt = 0\n    for i, bit in enumerate(BitDivH):\n        if bit == \"1\":\n            cnt += 1\n            MAP[i + 1] = cnt\n        else:\n            MAP[i + 1] = cnt\n    after_tmp = [0] * (MAP[-1] + 1)\n    cnt = 0\n    for w in range(W):\n        for h in range(H):\n            after_tmp[MAP[h]] += int(S[h][w])\n        for af in after_tmp:\n            if af > K:\n                cnt += 1\n                after_tmp = [0] * (MAP[-1] + 1)\n                for h2 in range(H):\n                    after_tmp[MAP[h2]] += int(S[h2][w])\n                break\n    return cnt + MAP[-1]\n\nMIN = 1000000\nfor i in range(2**(H - 1) - 1):\n    MIN = min(MIN, check(i))\n\nprint(MIN)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":944,"bad_solution":"import sys\nfrom collections import deque\ninput = sys.stdin.readline\nN = int(input())\nV = {i: [] for i in range(1,N+1)}\nfor i in range(N):\n    row = input()\n    for j in range(i+1, N):\n        if row[j] == '1':\n            V[i+1].append(j+1)\n            V[j+1].append(i+1)\n\npass\nINF = float('inf')\ndef get_farest(s):\n    H = deque()\n    visited = {i: False for i in range(1,N+1)}\n    dist = {i: INF for i in range(1,N+1)}\n    dist[s] = 0\n    distmax = 0\n    invalid = False\n    H.append(s)\n    t = s\n    while len(H):\n        u = H.popleft()\n        visited[u] = True\n        for v in V[u]:\n            if visited[v]:\n                continue\n            if dist[v] == INF:\n                dist[v] = dist[u] + 1\n                if distmax < dist[v]:\n                    distmax = dist[v]\n                    t = v\n            else:\n                if dist[v] - dist[u] != 1:\n                    invalid = True\n                    break\n            H.append(v)\n    \n    if invalid:\n        return -1, None\n    return distmax, t\n\ndist, f = get_farest(1)\nif dist < 0:\n    print(dist)\nelse:\n    diameter, _ = get_farest(f)\n    print(diameter+1)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":945,"bad_solution":"import sys\ndef input(): return sys.stdin.readline().rstrip()\n\n\ndef main():\n    h, w = map(int, input().split())\n    A = [list(map(int, input().split()))for i in range(h)]\n    B = [list(map(int, input().split()))for i in range(h)]\n    abss = [[abs(A[i][j]-B[i][j])for j in range(w)] for i in range(h)]\n    kmax = 3200\n    dp = [[[0]*kmax for j in range(w)]for i in range(h)]\n    dp[0][0][abss[0][0]] = 1\n    for i in range(h):\n        for j in range(w):\n            for k in range(kmax):\n                if dp[i][j][k] == 1:\n                    if i != h-1:\n                        dp[i+1][j][abs(k-abss[i+1][j])] = 1\n                        if k+abss[i+1][j] < kmax:\n                            dp[i+1][j][k+abss[i+1][j]] = 1\n                    if j != w-1:\n                        dp[i][j+1][abs(k-abss[i][j+1])] = 1\n                        if k+abss[i][j+1] < kmax:\n                            dp[i][j+1][k+abss[i][j+1]] = 1\n    for k in range(kmax):\n        if dp[-1][-1][k] == 1:\n            print(k)\n            break\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":946,"bad_solution":"#!\/usr\/bin\/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef LS(): return list(map(list, input().split()))\ndef S(): return list(input().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = 1e10\n\n#solve\ndef solve():\n    s = S()\n    if \"\".join(s) == \"zyxwvutsrqponmlkjihgfedcba\":\n        print(-1)\n    l = [chr(ord(\"a\") + i) for i in range(26)]\n    for si in s:\n        l.remove(si)\n    if l == []:\n        s = s[::-1]\n        l.append(s[0])\n        ans = []\n        f = True\n        for si in s[1:]:\n            if f:\n                l.append(si)\n                if min(l) > si:\n                    f = False\n            else:\n                ans.append(si)\n        l.sort()\n        a = l[1]\n        l.remove(a)\n        print(\"\".join(ans[::-1]) + a + \"\".join(l))\n    else:\n        print(\"\".join(s) + l[0])\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":947,"bad_solution":"from collections import Counter,defaultdict,deque\nfrom bisect import bisect_left\nimport sys,math,itertools,pprint,fractions\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\nn = inp()\ns = list(input())\nq = inp()\nQs = [input().split() for i in range(q)]\nupd = []\nacc = [[0] * 26 for i in range(n+1)]\nfor i,t in enumerate(s):\n    tmp = ord(t) - ord('a')\n    # print(tmp)\n    for j in range(26):\n        if j == tmp:\n            acc[i+1][j] = acc[i][j] + 1\n            continue\n        acc[i+1][j] = acc[i][j]\n# print(acc)\nfor i,t in enumerate(Qs):\n    a,b,c = t\n    b = int(b)\n    if a == '1':\n        upd.append([b,ord(s[b-1])-ord('a'),ord(c)-ord('a')])\n    else:\n        c = int(c)\n        cnt = 0\n        now = [0] * 26\n        for j in range(26):\n            now[j] = acc[c][j] - acc[b-1][j]\n        for j,k in enumerate(upd):\n            if b <= k[0] <= c:\n                now[k[1]] -= 1\n                now[k[2]] += 1\n        for j in range(26):\n            if now[j] > 0: cnt += 1\n        print(cnt)\n        \n        \nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":948,"bad_solution":"\ndef FUNC(interval1, interval2):\n    \"\"\"You are given two intervals,\n    where each interval is a pair of integers. For example, interval = (start, end) = (1, 2).\n    The given intervals are closed which means that the interval (start, end)\n    includes both start and end.\n    For each given interval, it is assumed that its start is less or equal its end.\n    Your task is to determine whether the length of FUNC of these two \n    intervals is a prime number.\n    Example, the FUNC of the intervals (1, 3), (2, 4) is (2, 3)\n    which its length is 1, which not a prime number.\n    If the length of the FUNC is a prime number, return \"YES\",\n    otherwise, return \"NO\".\n    If the two intervals don't intersect, return \"NO\".\n\n\n    [input\/output] samples:\n    FUNC((1, 2), (2, 3)) ==> \"NO\"\n    FUNC((-1, 1), (0, 4)) ==> \"NO\"\n    FUNC((-3, -1), (-5, 5)) ==> \"YES\"\n    \"\"\"\n    def FUNC(num):\n        if num == 1 or num == 0:\n            return False\n        if num == 2:\n            return True\n        for i in range(2, num):\n            if num%i == 0:\n                return False\n        return True\n\n    l = max(interval1[0], interval2[0])\n    r = min(interval1[1], interval2[1])\n    length = r - l\n    if length > 0:\n        return \"YES\"\n    return \"NO\"\n"}
{"id":949,"bad_solution":"N,X = map(int, input().split())\n\nburger_list = []\nfor i in range(N+1):\n    if i == 0:\n        burger_list.append([0,1])\n    else:\n        burger_list.append([2+burger_list[-1][0]*2,1+burger_list[-1][1]*2])\n\ndef pty(x,k,List,N):\n    if x == 1:\n        y = 0\n    elif 1 < x <= sum(List[k-1])+1:\n        y = 1\n    elif x == 2+sum(List[k-1]):\n        y = 2\n    elif x == sum(List[k]):\n        y = 4\n    else:\n        y = 3\n    return y\n        \nans = 0\nk = N\nwhile X > 0:\n    n = pty(X,k,burger_list,N)\n    if n == 0:\n        X = 0\n    elif n == 2:\n        ans += (burger_list[k-1][1]+1)\n        X = 0\n    elif n == 4:\n        ans += burger_list[k][1]\n        X = 0\n    elif n == 1:\n        X -= 1\n        k -= 1\n    else:\n        ans += (burger_list[k-1][1]+1)\n        X -= (sum(burger_list[k-1])+2)\n        k -= 1\n        \nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":950,"bad_solution":"import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\ndef main():\n    x, y = map(int, input().split())\n    if x < y:\n        if 0 < y and 0 < x:\n            print(y - x)\n        elif 0 < x and 0 < y:\n            print(y - abs(x) + 1)\n        elif y == 0:\n            print(-x)\n        elif x == 0:\n            print(y)\n        else:\n            print(y - x)\n    else:\n        if 0 < y and 0 < x:\n            print(x * 2 - (x - y) + 1)\n        elif y < 0 and 0 < x:\n            print(x - abs(y) + 1)\n        elif y == 0:\n            print(x + 1)\n        elif x == 0:\n            print(-y + 1)\n        else:\n            print((x - y) + 2)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":951,"bad_solution":"import sys\nimport math\nimport itertools\nimport collections\nfrom collections import deque\nfrom collections import defaultdict\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\nMOD2 = 998244353\nINF = float('inf')\ninput = lambda: sys.stdin.readline().strip()\n\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\ndef main():\n\n    N, M = NMI()\n        \n    PY = [[m,NLI()] for m in range(M)]\n    \n    PY = list(sorted(list(sorted(PY,key = lambda x : x[1][0])),key = lambda x : x[1][1]))\n    \n    city = PY[0][1][0]\n    cnt = 0\n\n    for m in range(M):\n        if PY[m][1][0] == city:\n            cnt += 1\n        else:\n            city = PY[m][1][0]\n            cnt = 1\n            \n        PY[m][1] = str(PY[m][1][0]).zfill(6) + str(cnt).zfill(6)\n    \n    PY = list(sorted(PY))\n    for m in range(M):\n        print(PY[m][1])\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":952,"bad_solution":"import sys\nfrom collections import deque\ndef input(): return sys.stdin.readline().strip()\n\n\ndef main():\n    H, W = map(int, input().split())\n    A = []\n    for _ in range(H):\n        A.append(list(map(int, input().split())))\n    B = []\n    for _ in range(H):\n        B.append(list(map(int, input().split())))\n    \n    \"\"\"\n    明らかなdp臭。\n        dp[i][j] = (マス(0, 0)から(i, j)に進むときの偏りとしてありうるものの集合)\n    とおく。(0<=i<=H-1, 0<=j<=W-1, 0<=d<=80)\n    \"\"\"\n\n    dp = [[set([]) for _ in range(W)] for _ in range(H)]\n    dp[0][0].add(abs(A[0][0] - B[0][0]))\n    for i in range(1, H):\n        diff = A[i][0] - B[i][0]\n        for val in dp[i - 1][0]:\n            if abs(val + diff) <= 1600: dp[i][0].add(abs(val + diff))\n            if abs(val - diff) <= 1600: dp[i][0].add(abs(val - diff))\n    for j in range(1, W):\n        diff = A[0][j] - B[0][j]\n        for val in dp[0][j - 1]:\n            if abs(val + diff) <= 6400: dp[0][j].add(abs(val + diff))\n            if abs(val - diff) <= 6400: dp[0][j].add(abs(val - diff))\n\n    for i in range(1, H):\n        for j in range(1, W):\n            diff = A[i][j] - B[i][j]\n            for val in dp[i - 1][j]:\n                if abs(val + diff) <= 6400: dp[i][j].add(abs(val + diff))\n                if abs(val - diff) <= 6400: dp[i][j].add(abs(val - diff))\n            for val in dp[i][j - 1]:\n                if abs(val + diff) <= 6400: dp[i][j].add(abs(val + diff))\n                if abs(val - diff) <= 6400: dp[i][j].add(abs(val - diff))\n    \n    print(min(dp[H - 1][W - 1]))\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":953,"bad_solution":"def main():\n    from collections import deque\n    import sys\n    input = sys.stdin.readline\n\n    n = int(input())\n    L = [deque(map(lambda x: int(x) - 1, input().split())) for _ in range(n)]\n\n    ans = 0\n    count = 0\n    MAX_COUNT = n * (n-1)\n    iteration_times = 0\n    flag = 0\n\n    while iteration_times <= MAX_COUNT:\n        # print(L)\n        # print(count)\n        iteration_times += 1\n\n        if count == MAX_COUNT:\n            flag = 1\n            break\n        \n        numset = set()\n        add = numset.add\n        flag = 100\n        for i in range(n):\n            if len(L[i]) != 0:\n                a = L[i][0]\n                b = L[a][0]\n                if i == b:\n                    add(i)\n                    add(b)\n                    flag = 0\n        \n        if flag == 100:\n            break\n        for elm in numset:\n            L[elm].popleft()\n            count += 1\n\n        ans += 1\n\n    if flag == 1:\n        print(ans)\n    else:\n        print(-1)\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":954,"bad_solution":"N, X = map(int, input().split())\n\na = [1]\np = [1]\nfor i in range(1, N+2):\n    a.append(2 * a[i-1] + 3)\n    p.append(2 * p[i-1] + 1)\n\ndef calc(N, X): #レベルNバーガーの下からX層に含まれるパティの枚数\n    if N == 0: #全てパティ\n        if X == 0:\n            return 0\n        else:\n            return 1\n    if X == 1:\n        return 0\n    # print (N - 1)\n    if 1 < X <= 1 + a[N - 1]:\n        print ('A')\n        return calc(N - 1, X - 1)\n    if X == 2 + a[N - 1]:\n        # print ('B')\n        return p[N - 1] + 1\n    if 2 + a[N - 1] < X <= 2 + 2 * a[N - 1]:\n        # print ('C')\n        return p[N - 1] + 1 + calc(N - 1, max(X - 2 - a[N - 1], 0))\n    if X == 3 + 2 * a[N - 1]:\n        # print ('D')\n        return p[N]\n\nprint (calc(N, X))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":955,"bad_solution":"\ndef FUNC(arr):\n    \"\"\"\n    You are given an array arr of integers and you need to return\n    sum of magnitudes of integers multiplied by product of all signs\n    of each number in the array, represented by 1, -1 or 0.\n    Note: return None for empty arr.\n\n    Example:\n    >>> FUNC([1, 2, 2, -4]) == -9\n    >>> FUNC([0, 1]) == 0\n    >>> FUNC([]) == None\n    \"\"\"\n    if not arr: return None\n    prod = 0 if 0 in arr else (-1) ** 2 * len(list(filter(lambda x: x < 0, arr)))\n    return prod * sum([abs(i) for i in arr])\n"}
{"id":956,"bad_solution":"#  import math, string, itertools, fractions, heapq, collections, re,  array, bisect, sys, random, time, copy, functools\n#  sys.setrecursionlimit(10**7)\n#  inf = 10 ** 20\n#  eps = 1.0 \/ 10**10\n#  mod = 10**9+7\n#  dd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\n#  ddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\n#  def LI(): return [int(x) for x in sys.stdin.readline().split()]\n#  def LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\n#  def LF(): return [float(x) for x in sys.stdin.readline().split()]\n#  def LS(): return sys.stdin.readline().split()\n#  def I(): return int(sys.stdin.readline())\n#  def F(): return float(sys.stdin.readline())\n#  def S(): return input()\n#  def pf(s): return print(s, flush=True)\n\n#  N, K = LI()\n#  A = LI()\n\n#  if N == K:\n#      print(1)\n#      exit()\n#  N -= K\n#  result = N \/ (K-1) + 1\n#  if result % 1 != 0:\n#      result \/\/= 1\n#      result += 1\n\n#  print(int(result))\n\n\n\nimport math, string, itertools, fractions, heapq, collections, re,  array, bisect, sys, random, time, copy, functools\nsys.setrecursionlimit(10**7)\ninf = 10 ** 20\neps = 1.0 \/ 10**10\nmod = 10**9+7\ndd = [(-1, 0), (0, 1), (1, 0), (0, -1)]\nddn = [(-1, 0), (-1, 1), (0, 1), (1, 1), (1, 0), (1, -1), (0, -1), (-1, -1)]\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\nN, K = LI()\nA = LI()\n\nif N == K:\n    print(1)\n    exit()\nresult = 0\nN -= K\nresult += 1\nresult += N \/ (K-1)\nif N % (K-1) != 0:\n    result = int(result) + 1\n\nprint(result)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":957,"bad_solution":"import sys \ndef solve():\n    n, k = map(int, input().split())\n    a = list(map(int, input().split()))\n\n    p_list = [1]\n    ne_p = a[0]\n    p_bool = [False] * n\n    p_bool[0] = True\n    check = False\n    step = 0\n    for _ in range(n):\n        p_bool[ne_p-1] = True\n        p_list.append(ne_p)\n        step = 0\n        if step == k:\n            #print(ne_p)\n            sys.exit()\n        ne_p = a[ne_p-1]\n        # if ne_p in p_list:\n        #     ind = p_list.index(ne_p)\n        #     break\n        if p_bool[ne_p-1]:\n            check = True\n            break\n        \n    #print(p_list)\n    #print(p_bool)\n    if check:\n        ind = p_list.index(ne_p)\n    else:\n        ind = 0\n    k = k - ind\n    #print(ind)\n    #print(k)\n    #print(p_list)\n    #print(k%(len(p_list)-ind))\n    print(p_list[ind + k%(len(p_list)-ind)])\n\nsolve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":958,"bad_solution":"def inpl():\n    return list(map(int, input().split()))\n\n\ndef binary_search(Array, x):\n    le = 0\n    ri = len(Array)\n    if ri == 1 or x <= Array[0]:\n        return x - Array[0], Array[0] - x\n    elif x >= Array[-1]:\n        return x - Array[-1], Array[-1] - x\n    while ri - le > 0:\n        i = (le + ri) \/\/ 2\n        if (Array[i] == x):\n            return 0, 0\n        elif (Array[i] < x):\n            le = i + 1\n            zou = True\n        else:\n            ri = i\n            zou = False\n    if zou is True:\n        return x - Array[ri - 1], Array[ri] - x\n    else:\n        return x - Array[ri], Array[ri + 1] - x\n\n\nA, B, Q = inpl()\nshrine = [int(input()) for _ in range(A)]\ntemple = [int(input()) for _ in range(B)]\nquery = [int(input()) for _ in range(Q)]\n\n# shrine.sort()\n# temple.sort()\nslr = [0, 0]\ntlr = [0, 0]\nfor q in query:\n    slr[0], slr[1] = binary_search(shrine, q)\n    tlr[0], tlr[1] = binary_search(temple, q)\n\n    ans = 10**12\n    for sdir, tdir in zip(slr, tlr):\n        if sdir < 0 or tdir < 0:\n            continue\n        ans = min(ans, max(sdir, tdir))\n    for sdir, tdir in [[slr[0], tlr[1]], [slr[1], tlr[0]]]:\n        if sdir < 0 or tdir < 0:\n            continue\n        ans = min(ans, sdir + tdir + min(sdir, tdir))\n\n    print(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":959,"bad_solution":"import numpy as np\n\ndef calculate(h, w, arr):\n    L = np.zeros([h, w])\n    U = np.zeros([h, w])\n    D = np.zeros([h, w])\n    R = np.zeros([h, w])\n\n    for ih in range(h):\n        for iw in range(w):\n            if arr[ih][iw] == \".\":\n                if ih == 0:\n                    U[ih][iw] = 1\n                if iw == 0:\n                    L[ih][iw] = 1\n\n                if iw > 0:\n                    L[ih][iw] = L[ih][iw - 1] + 1\n                if ih > 0:\n                    U[ih][iw] = U[ih - 1][iw] + 1\n\n\n    for ih in range(h):\n        for iw in range(w):\n            rih = h - 1 - ih\n            riw = w - 1 - iw\n            if arr[rih][riw] == \".\":\n                if rih == h - 1:\n                    D[rih][riw] = 1\n                if riw == w - 1:\n                    R[rih][riw] = 1\n\n                if riw < w - 1:\n                    R[rih][riw] = R[rih][riw + 1] + 1\n                if rih < h - 1:\n                    D[rih][riw] = D[rih + 1][riw] + 1\n\n    max = 0\n    for ih in range(h):\n        for iw in range(w):\n            if arr[ih][iw] == \"#\":\n                continue\n            value = L[ih][iw] + R[ih][iw] + U[ih][iw] + D[ih][iw] - 3\n            if value > max:\n                max = value\n    print(int(max))\n\n\nS = input().split(\" \")\nH = int(S[0])\nW = int(S[1])\n\narr = []\nfor i in range(H):\n    q = list(input())\n    arr.append(q)\n\ncalculate(H, W, arr)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":960,"bad_solution":"printn = lambda x: print(x,end='')\ninn = lambda : int(input())\ninl   = lambda: list(map(int, input().split()))\ninm   = lambda:      map(int, input().split())\nins = lambda : input().strip()\nDBG = True  and False\nBIG = 10**18\nR = 10**9 + 7\n\ndef ddprint(x):\n  if DBG:\n    print(x)\n\n#from collections import defaultdict\nimport heapq\nn,m,s = inm()\naas = []\ndst = [{} for i in range(n+1)]\nfor i in range(m):\n    uu,vv,aa,bb = inm()\n    dst[uu][vv] = (aa,bb)\n    dst[vv][uu] = (aa,bb)\n    aas.append(aa)\nmaxa = max(aas)\ns = min(s,(maxa+1)*n-1)\nc = [-1]\nd = [-1]\nfor i in range(n):\n    cc,dd = inm()\n    c.append(cc)\n    d.append(dd)\n\n#dst2 = defaultdict(dict)\ndst2 = {}\nfor u in range(1,n+1):\n    for p in range((maxa+1)*n-c[u]):\n        dst2[(u,p)] = {(u,p+c[u]) : d[u]}\n    for v in dst[u]:\n        m = dst[u][v][0]\n        t = dst[u][v][1]\n        for p in range(m,(maxa+1)*n):\n            if (u,p) not in dst2:\n                dst2[(u,p)] = {}\n            dst2[(u,p)][(v,p-m)] = t\n\nif DBG:\n    print(\"dst2)\")\n    for z in dst2:\n        printn(str(z)+':')\n        ddprint(dst2[z])\ncost = {}\nfor z in dst2:\n    cost[z] = BIG\nq = [(0,1,s)]\nwhile len(q)>0:\n    dd,u,p = heapq.heappop(q)\n    if cost[(u,p)]<=dd:\n        continue\n    cost[(u,p)] = dd\n    for v,r in dst2[(u,p)]:\n        heapq.heappush(q,(dd+dst2[(u,p)][(v,r)], v,r))\n\nif DBG:\n    print(\"cost)\")\n    for z in cost:\n        printn(str(z)+':')\n        ddprint(cost[z])\nans = [BIG]*(n+1)\nfor u,p in cost:\n    ans[u] = min(ans[u], cost[(u,p)])\nfor i in range(2,n+1):\n    print(ans[i])\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":961,"bad_solution":"import sys\ndef main():\n    input = sys.stdin.readline\n    H,W=map(int, input().split())\n    A=[list(map(int, input().split())) for _ in range(H)]\n    B=[list(map(int, input().split())) for _ in range(H)]\n\n    mx=80*(H+W)\n    C=[[abs(A[i][j]-B[i][j]) for j in range(W)] for i in range(H)]\n    dp=[[0 for _ in range(W)] for __ in range(H)]\n    dp[0][0]=1<<(mx+C[0][0]) | 1<<(mx-C[0][0])\n    from collections import deque\n    q=deque([(0,0)])\n    while q:\n        i,j=q.popleft()\n        if i>0:\n            dp[i][j] |= dp[i-1][j] << C[i][j]\n            dp[i][j] |= dp[i-1][j] >> C[i][j]\n        if j>0:\n            dp[i][j] |= dp[i][j-1] << C[i][j]\n            dp[i][j] |= dp[i][j-1] >> C[i][j]\n        if i<H-1: q.append((i+1,j))\n        if j<W-1: q.append((i,j+1))\n\n    for ans in range(mx+1):\n        if dp[H-1][W-1] & (1<<(mx+ans) | 1<<(mx-ans)):\n            print(ans)\n            break\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":962,"bad_solution":"\ndef parse():\n  N, K = map(int, input().split(\" \"))\n  A = []\n  for a in input().split(\" \"):\n    A.append(int(a) - 1)\n  return N, K, A\n\ndef fast_mod(x, N):\n  return (x * N) >> 32\n\ndef main():\n  N, K, A = parse()\n  # print(N, K, A)\n\n  # 経路の計算\n  route = []\n  next_town = A[0]\n  town = 0\n  while not (next_town in route):  # 既出の町に行く場合\n    route.append(town)\n    next_town = A[town]\n    town = next_town\n  once_route = route[:route.index(next_town)]\n  loop_route = route[route.index(next_town):]\n  # print(\"once_route:\", once_route)\n  # print(\"loop_route:\", loop_route)\n  \n  # print([town + 1 for town in route])\n  # print(\"K %% len(loop_route):\", K % len(loop_route))\n  # print(route[K % len(loop_route) + len(once_route)] + 1)\n  if K > len(route) and len(once_route) > 0:\n    # print(\"loop\")\n    loop_K = K - len(route)\n    print(route[(loop_K - 1) % len(loop_route)] + 1)\n  else:\n    # print(\"normal\")\n    # print(route[fast_mod(K, len(loop_route))] + 1)\n    print(route[K % len(route)] + 1)\n\nif __name__ == \"__main__\":\n  main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":963,"bad_solution":"from sys import stdin\n\nN = int(stdin.readline().rstrip())\nAs = [int(x) for x in stdin.readline().rstrip().split()]\n\nA_mat = []\nfor i,A in enumerate(As):\n    A_mat.append([A,i])\n\nA_mat.sort(reverse=True)\n\nmap1 = []\n\nfor i in range(N+1):\n    temp = [-1]*(N+1)\n    map1.append(temp)\n\n\n\ndef DP(x, y): #Asのなかからx+y個の数列をすでに端に移動していて、x個左端に, y個右端に移動している状態から始めたときに追加で得られるスコア\n    if map1[x][y]>=0:\n        return map1[x][y]\n    \n    if x+y == N:\n        return 0\n\n    a_val = A_mat[x+y][0]\n    a_pos = A_mat[x+y][1]\n\n    left_case = abs(a_pos-x)\n    right_case = abs((N-y-1)-a_pos)\n\n    map1[x][y] = max(DP(x+1,y)+left_case*a_val, DP(x,y+1)+right_case*a_val)\n\n    return map1[x][y]\n\nprint(DP(0,0))\n    \nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":964,"bad_solution":"from collections import Counter,defaultdict,deque\nfrom heapq import heappop,heappush,heapify\nimport sys,bisect,math,itertools,fractions,pprint\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\nINF = float('inf')\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\n\nh,w,k = inpl()\ns = [input() for i in range(h)]\nwhite = 0\nass = [[0] for i in range(h)]\nfor i in range(h):\n    for j in range(w):\n        tmp = 1 if s[i][j] == '1' else 0\n        ass[i].append(ass[i][-1] + tmp)\n# print(ass)\nif w == 1:\n    ass = [0]\n    for i in range(h):\n        tmp = 1 if s[i][j] == '1' else 0\n        ass.append(ass[-1] + tmp)\n    su = 0\n    res = 0\n    ind = 0\n    for i in range(h):\n        su += ass[i+1] - ass[ind]\n        if su > k:\n            res += 1\n            ind = i-1\n            su = 0\n    print(res)\n    quit()\nres = INF\nfor flag in itertools.product([0,1],repeat=h-1):\n    cnt = flag.count(1)\n    bun = set()\n    for i,j in enumerate(flag):\n        if j: bun.add(i)\n    ind = 0\n    for x in range(w):\n        lcnt = 0\n        for y in range(h):\n            lcnt += ass[y][x+1] - ass[y][ind]\n            if lcnt > k:\n                ind = x\n                cnt += 1\n                lcnt = 0\n                break\n            if y in bun: lcnt = 0\n    # print(cnt,flag)\n    res = min(res,cnt)\nprint(res)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":965,"bad_solution":"\ndef FUNC(grid, k):\n    \"\"\"\n    Given a grid with N rows and N columns (N >= 2) and a positive integer k, \n    each cell of the grid contains a value. Every integer in the range [1, N * N]\n    inclusive appears exactly once on the cells of the grid.\n\n    You have to find the minimum path of length k in the grid. You can start\n    from any cell, and in each step you can move to any of the neighbor cells,\n    in other words, you can go to cells which share an edge with you current\n    cell.\n    Please note that a path of length k means visiting exactly k cells (not\n    necessarily distinct).\n    You CANNOT go off the grid.\n    A path A (of length k) is considered less than a path B (of length k) if\n    after making the ordered lists of the values on the cells that A and B go\n    through (let's call them lst_A and lst_B), lst_A is lexicographically less\n    than lst_B, in other words, there exist an integer index i (1 <= i <= k)\n    such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n    lst_A[j] = lst_B[j].\n    It is guaranteed that the answer is unique.\n    Return an ordered list of the values on the cells that the minimum path go through.\n\n    Examples:\n\n        Input: grid = [ [1,2,3], [4,5,6], [7,8,9]], k = 3\n        Output: [1, 2, 1]\n\n        Input: grid = [ [5,9,3], [4,1,6], [7,8,2]], k = 1\n        Output: [1]\n    \"\"\"\n    n = len(grid)\n    val = n * n + 1\n    for i in range(n):\n        for j in range(n):\n            if grid[i][j] == 1:\n                temp = []\n                if i != 0:\n                    temp.append(grid[i][j])\n\n                if j != 0:\n                    temp.append(grid[i][j])\n\n                if i != n - 1:\n                    temp.append(grid[i][j])\n\n                if j != n - 1:\n                    temp.append(grid[i][j])\n\n                val = min(temp)\n\n    ans = []\n    for i in range(k):\n        if i % 2 == 0:\n            ans.append(1)\n        else:\n            ans.append(val)\n    return ans\n"}
{"id":966,"bad_solution":"import sys\nfrom collections import deque\nsys.setrecursionlimit(10**6)\n\nINF = 10**10\n\n\ndef main(input, print):\n    move = [(-1, 0), (1, 0), (0, -1), (0, 1)]\n    move2 = [(-2, -2), (-2, -1), (-2, 0), (-2, 1), (-2, 2),\n             (-1, -2), (-1, -1), (-1, 1), (-1, 2),\n             (0, -2), (0, 2),\n             (1, -2), (1, -1), (1, 1), (1, 2),\n             (2, -2), (2, -1), (2, 0), (2, 1), (2, 2)]\n\n    H, W = map(int, input().split())\n    Ch, Cw = map(int, input().split())\n    Dh, Dw = map(int, input().split())\n    table = [input() for _ in range(H)]\n    path = [[INF for _ in range(W)] for _ in range(H)]\n\n    que = deque()\n    path[Ch-1][Cw-1] = 0\n    que.append((Ch-1, Cw-1))\n    while que:\n        y, x = que.pop()\n        cnt = path[y][x]\n\n        for i, j in move:\n            nx = x+i\n            ny = y+j\n            if ny < 0 or nx < 0 or ny >= H or nx >= W or table[ny][nx] == '#' or path[ny][nx] <= cnt:\n                continue\n            path[ny][nx] = cnt\n            que.appendleft((ny, nx))\n\n        for i, j in move2:\n            nx = x+i\n            ny = y+j\n            if ny < 0 or nx < 0 or ny >= H or nx >= W or table[ny][nx] == '#' or path[ny][nx] <= cnt + 1:\n                continue\n            path[ny][nx] = cnt+1\n            que.appendleft((ny, nx))\n\n    if(path[Dh-1][Dw-1] == INF):\n        print(-1)\n    else:\n        print(path[Dh-1][Dw-1])\n\n\nif __name__ == '__main__':\n    main(sys.stdin.readline, print)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":967,"bad_solution":"\ndef kakaka():\n    a = list(map(int, input().split()))\n    b = map(int, input().split())\n    c = int(input())\n\ndef start_process():\n    return\ndef main():\n    all_num, inst_num = map(int, input().split())\n    data = list(input())\n\n    # all_num, inst_num = 5, 1\n    # data = list('00010')\n\n    max_num = 0\n    for i in range(all_num):\n        now_kiritsu = 0\n        flg = 0\n        for j in range(i, all_num):\n            if data[j] == '0':\n                if flg == 0:\n                    now_kiritsu += 1\n                    flg = 1\n                else:\n                    pass\n                if now_kiritsu > inst_num:\n                    if max_num < j - i:\n                        max_num = j - i\n                        # print(j, i, max_num)\n                    break\n            else:\n                flg = 0\n        else:\n            if max_num < j - i + 1:\n                max_num = j - i + 1\n                # print(j, i, max_num)\n\n        # print(i, j, now_kiritsu)\n\n    print(max_num)\n\n\n\n\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":968,"bad_solution":"def binary_search(v, is_ok):\n    \"\"\"\n    ソートしてから使え！！！\n    v : list\n        ある場所から左が条件を満たさず、右が条件を満たすように並んだ配列\n    is_ok(x) : bool\n        vの要素xが条件を満たすかどうかを返す関数\n    \"\"\"\n    ng = -1             # 条件を満たさないiのうち今わかっている中で最大の値(v[0]が条件を満たすかもしれないので-1から)\n    ok = len(v)         # 条件を満たすiのうち今わかっている中で最小の値(v[n-1]が条件を満たさないかもしれないのでnから)\n    # okをできるだけ左に移動させてreturnする\n\n    # ...... ng ok ......\n    #          | ->\n    # こうなるまで\n    while abs(ok - ng) > 1:\n        mid = (ok + ng) \/\/ 2\n\n        if is_ok(v[mid]):   # v[mid]はokであることがわかった\n            ok = mid        # okを左に移動\n        else:               # v[mid]はngであることがわかった\n            ng = mid        # ngを右に移動\n\n    return ok\n\n\n\nN, D, A = map(int, input().split())\nX, H = [], []\nfor i in range(N):\n    x, h = map(int, input().split())\n    X.append(x)\n    H.append((h + A - 1) \/\/ A)\n\nyuukou = 0\nmou_mukou = [0] * N + [0]\nans = 0\n\n# lを左端としてn個爆弾を使う\ndef bomb(l, n):\n    global ans, yuukou\n    ans += n\n    yuukou += n\n    r = l + 2 * D\n    mou_mukou[binary_search(X, lambda x: r < x)] += n\n\n\nfor i in range(N):\n    yuukou -= mou_mukou[i]\n    H[i] -= yuukou\n    if H[i] > 0:\n        bomb(X[i], H[i])\n\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":969,"bad_solution":"from collections import Counter\n\n\ndef m():\n    N = int(input())\n    V = [int(i) for i in input().split()]\n    vodds = V[0::2]\n    vevens = V[1::2]\n\n    odds_commons = Counter(vodds).most_common()\n    even_commons = Counter(vevens).most_common()\n\n    odds_top = odds_commons[0]\n    evens_top = odds_commons[0]\n    if odds_top[0] != evens_top[0]:\n        return N - odds_top[1] - evens_top[1]\n    else:\n        if len(odds_commons) > 1 and len(even_commons) > 1:\n            return N \/\/ 2 - max(odds_commons[1][1], even_commons[1][1])\n        elif len(odds_commons) > 1:\n            return N \/\/ 2 - odds_commons[1][1]\n        elif len(even_commons) > 1:\n            return N \/\/ 2 - even_commons[1][1]\n        else:\n            return N \/\/ 2\n\n\nprint(m())\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":970,"bad_solution":"from collections import Counter,defaultdict,deque\nfrom heapq import heappop,heappush,heapify\nimport sys,bisect,math,itertools,string,queue\nsys.setrecursionlimit(10**8)\nmod = 10**9+7\ndef inp(): return int(sys.stdin.readline())\ndef inpl(): return list(map(int, sys.stdin.readline().split()))\ndef inpl_str(): return list(sys.stdin.readline().split())\ndef inpln(n): return list(int(sys.stdin.readline()) for i in range(n))\n\nn,a,b,c,d = inpl()\ns = list(input())\nt = False\nif c < d:\n    for i in range(a-1,d-1):\n        if s[i] == '#' and s[i+1] == '#':\n            print('No')\n            break\n    else:\n        print('Yes')\nelse:\n    for i in range(a-1,c-1):\n        if s[i] == '#' and s[i+1] == '#':\n            print('No')\n            break\n        if i == c-2 or i > d-1 or i < b-1:\n            continue\n        if s[i] == '.' and s[i+1] == '.' and s[i+2] == '.' and i+2 != b-1 and i != d-1:\n            t = True\n    if t:\n        print('Yes')\n    else:\n        print('No')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":971,"bad_solution":"\ndef FUNC(n):\n    \"\"\"Everyone knows Fibonacci sequence, it was studied deeply by mathematicians in \n    the last couple centuries. However, what people don't know is Tribonacci sequence.\n    Tribonacci sequence is defined by the recurrence:\n    FUNC(1) = 3\n    FUNC(n) = 1 + n \/ 2, if n is even.\n    FUNC(n) =  FUNC(n - 1) + FUNC(n - 2) + FUNC(n + 1), if n is odd.\n    For example:\n    FUNC(2) = 1 + (2 \/ 2) = 2\n    FUNC(4) = 3\n    FUNC(3) = FUNC(2) + FUNC(1) + FUNC(4)\n           = 2 + 3 + 3 = 8 \n    You are given a non-negative integer number n, you have to a return a list of the \n    first n + 1 numbers of the Tribonacci sequence.\n    Examples:\n    FUNC(3) = [1, 3, 2, 8]\n    \"\"\"\n    if n == 0:\n        return [1]\n    my_FUNC = [1, 3]\n    for i in range(2, n + 1):\n        if i % 2 == 0:\n            my_FUNC.append(i \/ 2 + 1)\n        else:\n            my_FUNC.append(my_FUNC[i - 1] + my_FUNC[i - 2] + i + (i + 3) \/ 2)\n    return my_FUNC\n"}
{"id":972,"bad_solution":"import sys\nsys.setrecursionlimit(10**8)\ninput = sys.stdin.readline\n\n\nclass Tree():\n    def __init__(self, n, graph, v_root):\n        self.n = n  # number of nodes\n        self.graph = graph  # adjacent list of graph\n        self.v_root = v_root  # root node\n\n        self.logn = (self.n - 1).bit_length()\n        self.parent = [[-1] * self.n for _ in range(self.logn)]\n        self.depth = [0] * self.n\n        self.lca_table = [[-1] * self.n for _ in range(n)]\n\n        self.init()\n\n    def init(self):\n        self.dfs(self.v_root, -1, 0)\n        # doubling\n        for k in range(self.logn - 1):\n            for v in range(self.n):\n                if self.parent[k][v] != -1:\n                    self.parent[k + 1][v] = self.parent[k][self.parent[k][v]]\n        # create lca table\n        for i in range(n):\n            for j in range(n):\n                self.lca_table[i][j] = self.lca(i, j)\n\n    def dfs(self, v, v_par, depth):\n        self.parent[0][v] = v_par\n        self.depth[v] = depth\n        for v_next in self.graph[v]:\n            if v_next == v_par:\n                continue\n            self.dfs(v_next, v, depth + 1)\n\n    def lca(self, u, v):\n        if self.depth[u] > self.depth[v]:\n            u, v = v, u\n\n        # go to parents of v until same depth as u\n        diff = self.depth[v] - self.depth[u]\n        for k in range(diff.bit_length()):\n            if diff & (1 << k):\n                v = self.parent[k][v]\n        if u == v:\n            return u\n        # binary search\n        # for k in reversed(range(self.logn)):\n        for k in range(self.depth[u].bit_length() - 1, -1, -1):\n            if self.parent[k][u] != self.parent[k][v]:\n                u = self.parent[k][u]\n                v = self.parent[k][v]\n        return self.parent[0][u]\n\n    def calc(self, cnt, v, v_par, ans):\n        ret = cnt[v]\n        for v_next in self.graph[v]:\n            if v_next == v_par:\n                continue\n            ans += self.calc(cnt, v_next, v, 0)\n            ret += cnt[v_next]\n        cnt[v] = ret\n        if ret == 0:\n            ans += 1\n        return ans\n\n\nn = int(input())\ngraph = [[] for _ in range(n)]\nfor _ in range(n - 1):\n    a, b = map(int, input().split())\n    a -= 1\n    b -= 1\n    graph[a].append(b)\n    graph[b].append(a)\n\ntree = Tree(n, graph, n \/\/ 2)\n\nm = int(input())\ncond = []\nfor _ in range(m):\n    u, v = map(int, input().split())\n    u -= 1\n    v -= 1\n    cond.append((u, v))\n\nans = 1 << (n - 1)\nfor bit in range(1, 1 << m):\n    cnt = [0] * n\n    l = 0\n    for i in range(m):\n        if (bit >> i) & 1:\n            cnt[cond[i][0]] += 1\n            cnt[cond[i][1]] += 1\n            cnt[tree.lca_table[cond[i][0]][cond[i][1]]] -= 2\n            l += 1\n\n    # print(bin(bit), cnt)\n    c = tree.calc(cnt, 0, -1, 0) - 1\n    # print(bin(bit), cnt, c, l)\n    ans += ((-1)**(l % 2)) * (1 << c)\n\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":973,"bad_solution":"def main():\n    import queue\n    h,w = map(int,input().split())\n    S = [[] for i in range(h)]\n    q = queue.Queue()\n    cnt = 0\n    for i in range(h):\n        s = input()\n        for j in range(w):\n            S[i].append(s[j])\n            if s[j]=='#':\n                q.put([i,j])\n                cnt += 1\n    ans = 0\n    while cnt<h*w:\n        ans += 1\n        q_ = queue.Queue()\n        for _ in range(q.qsize()):\n            b = q.get()\n            if b[0]>0:\n                if S[b[0]-1][b[1]]=='.':\n                    cnt += 1\n                    S[b[0]-1][b[1]]='#'\n                    q_.put([b[0]-1,b[1]])\n            if b[0]<h-1:\n                if S[b[0]+1][b[1]]=='.':\n                    cnt += 1\n                    S[b[0]+1][b[1]]='#'\n                    q_.put([b[0]+1,b[1]])\n            if b[1]>0:\n                if S[b[0]][b[1]-1]=='.':\n                    cnt+=1\n                    S[b[0]][b[1]-1]='#'\n                    q_.put([b[0],b[1]-1])\n            if b[1]<w-1:\n                if S[b[0]][b[1]+1]=='.':\n                    cnt += 1\n                    S[b[0]][b[1]+1]='#'\n                    q_.put([b[0],b[1]+1])\n        q = q_\n    print(ans)\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":974,"bad_solution":"import sys\n# import bisect\n# import math\n# import itertools\n# import numpy as np\n\n\n\"\"\"Template\"\"\"\n\n\nclass IP:\n    \"\"\"\n    入力を取得するクラス\n    \"\"\"\n\n    def __init__(self):\n        self.input = sys.stdin.readline\n\n    def I(self):\n        \"\"\"\n        1文字の取得に使います\n        :return: int\n        \"\"\"\n        return int(self.input())\n\n    def S(self):\n        \"\"\"\n        1文字の取得(str\n        :return: str\n        \"\"\"\n        return self.input()\n\n    def IL(self):\n        \"\"\"\n        1行を空白で区切りリストにします(int\n        :return: リスト\n        \"\"\"\n        return list(map(int, self.input().split()))\n\n    def SL(self):\n        \"\"\"\n        1行の文字列を空白区切りでリストにします\n        :return: リスト\n        \"\"\"\n        return list(map(str, self.input().split()))\n\n    def ILS(self, n):\n        \"\"\"\n        1列丸々取得します(int\n        :param n: 行数\n        :return: リスト\n        \"\"\"\n        return [int(self.input()) for _ in range(n)]\n\n    def SLS(self, n):\n        \"\"\"\n        1列丸々取得します（str\n        :param n: 行数\n        :return: リスト\n        \"\"\"\n        return [self.input() for _ in range(n)]\n\n    def SILS(self, n):\n        \"\"\"\n        Some Int LineS\n        横に複数、縦にも複数\n        :param n: 行数\n        :return: list\n        \"\"\"\n        return [self.IL() for _ in range(n)]\n\n    def SSLS(self, n):\n        \"\"\"\n        Some String LineS\n        :param n: 行数\n        :return: list\n        \"\"\"\n        return [self.SL() for _ in range(n)]\n\n\nclass Idea:\n    def __init__(self):\n        pass\n\n    def HF(self, p):\n        \"\"\"\n        Half enumeration\n        半分全列挙です\n        pの要素の和の組み合わせを作ります。\n        ソート、重複削除行います\n        :param p: list : 元となるリスト\n        :return: list : 組み合わせられた和のリスト\n        \"\"\"\n        return sorted(set(p[i] + p[j] for i in range(len(p)) for j in range(i, len(p))))\n\n    def Bfs2(self, a):\n        \"\"\"\n        bit_full_search2\n        bit全探索の改良版\n        全探索させたら2進数のリストと10進数のリストを返す\n        :return: list２つ : １個目 2進数(16桁)  2個目 10進数\n        \"\"\"\n        # 参考\n        # https:\/\/blog.rossywhite.com\/2018\/08\/06\/bit-search\/\n        # https:\/\/atcoder.jp\/contests\/abc105\/submissions\/4088632\n        value = []\n        for i in range(1 << len(a)):\n            output = []\n\n            for j in range(len(a)):\n                if self.bit_o(i, j):\n                    \"\"\"右からj+1番目のiが1かどうか判定\"\"\"\n                    # output.append(a[j])\n                    output.append(a[j])\n            value.append([format(i, 'b').zfill(16), sum(output)])\n\n        value.sort(key=lambda x: x[1])\n        bin = [value[k][0] for k in range(len(value))]\n        val = [value[k][1] for k in range(len(value))]\n        return bin, val\n\n    def S(self, s, r=0, m=-1):\n        \"\"\"\n        ソート関係行います。色々な設定あります。\n        :param s: 元となるリスト\n        :param r: reversするかどうか 0=False 1=True\n        :param m: （2次元配列）何番目のインデックスのソートなのか\n        :return: None\n        \"\"\"\n        r = bool(r)\n        if m == -1:\n            s.sort(reverse=r)\n        else:\n            s.sort(reverse=r, key=lambda x: x[m])\n\n    def bit_n(self, a, b):\n        \"\"\"\n        bit探索で使います。0以上のときにTrue出します\n        自然数だからn\n        :param a: int\n        :param b: int\n        :return: bool\n        \"\"\"\n        return bool((a >> b & 1) > 0)\n\n    def bit_o(self, a, b):\n        \"\"\"\n        bit探索で使います。1のときにTrue出すよ\n        oneで1\n        :param a: int\n        :param b: int\n        :return: bool\n        \"\"\"\n        return bool(((a >> b) & 1) == 1)\n\n    def ceil(self, x, y):\n        \"\"\"\n        Round up\n        小数点切り上げ割り算\n        :param x: int\n        :param y: int\n        :return: int\n        \"\"\"\n        return -(-x \/\/ y)\n\n    def ave(self, a):\n        \"\"\"\n        平均を求めます\n        :param a: list\n        :return: int\n        \"\"\"\n        return sum(a) \/ len(a)\n\n    def gcd(self, x, y):\n        if y == 0:\n            return x\n        else:\n            return self.gcd(y, x % y)\n\n\n\"\"\"ここからメインコード\"\"\"\n\n\ndef aa(li):\n    for i in range(len(li) - 1):\n        if li[i] != li[i+1]:\n            return i\n    return \"END\"\n\n\ndef main():\n    # 1文字に省略\n    r, e = range, enumerate\n    ip = IP()\n    id = Idea()\n\n    \"\"\"この下から書いてね\"\"\"\n    # s = list(\"11011010001011\")\n    s = list(ip.S())\n    n = len(s)\n    while True:\n        res = aa(s)\n        if res != \"END\":\n            s.pop(res)\n            s.pop(res)\n            print(s)\n        else:\n            break\n    print(n - len(s))\n\n\n\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":975,"bad_solution":"from sys import stdin\n\ndef main():\n\n    input = stdin.readline\n\n    N,K = map(int,input().split())\n\n    A = list(map(int,input().split()))\n\n    itta_list = []\n    idou_num = 0\n\n    pos = 0\n\n    for i in range(K):\n        # itta_list記憶\n        if pos not in set(itta_list):\n            itta_list.append(pos)\n        else:\n            idou_num = i\n            break\n\n        # 次の街へ\n        pos = A[pos] - 1\n    else:\n        ans_num = pos + 1\n        print(ans_num)\n        return\n\n    roop_list = itta_list[itta_list.index(pos):]\n\n    amari = (K - idou_num) % len(roop_list)\n\n    ans_pos = roop_list[amari] + 1\n\n    print(ans_pos)\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":976,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\nsys.setrecursionlimit(10**9)\nINF=10**18\nMOD=10**9+7\ninput=lambda: sys.stdin.readline().rstrip()\nYesNo=lambda b: bool([print('Yes')] if b else print('No'))\nYESNO=lambda b: bool([print('YES')] if b else print('NO'))\nint1=lambda x:int(x)-1\n\nN=int(input())\nA=list(map(int,input().split()))\n\ndef prime_factorize(n):\n    a = []\n    while n % 2 == 0:\n        a.append(2)\n        n \/\/= 2\n    f = 3\n    while f * f <= n:\n        if n % f == 0:\n            a.append(f)\n            n \/\/= f\n        else:\n            f += 2\n    if n != 1:\n        a.append(n)\n    return a\nans=True\n\nnext=[]\n\nf=False\nMIN_A=INF\nfor x in A:\n    if x==1:\n        f=True\n    else:\n        next.append(x)\n        MIN_A=min(MIN_A,x)\nA=next\nnext=[]\n\nwhile A:\n    prime=prime_factorize(MIN_A)\n    MIN_A=INF\n    for p in prime:\n        cnt=0\n        for i,x in enumerate(A):\n            MIN_A=min(MIN_A,x)\n            if x%p==0:\n                cnt+=1\n                while x%p==0:\n                    x\/\/=p\n                if x!=1:\n                    next.append(x)\n        if cnt>=2:\n            ans=False\n        if cnt==N and not f:\n            print('not coprime')\n            exit()\n        A=next\n        next=[]\n\nif ans:\n    print('pairwise coprime')\nelse:\n    print('setwise coprime')\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":977,"bad_solution":"N = int(input())\nA = list(map(int,input().split()))\n\ndef factorization(n):\n    arr = []\n    temp = n\n    for i in range(2, int(-(-n**0.5\/\/1))+1):\n        if temp % i == 0:\n            cnt = 0\n            while temp % i ==0:\n                cnt += 1\n                temp \/\/= i\n            arr.append([i, cnt])\n\n    if temp != 1:\n        arr.append([temp, 1])\n\n    if arr == []:\n        arr.append([n, 1])\n\n    return arr\n\ndef euclid(a, b):\n    if b == 0:\n        return a\n    else:\n        return euclid(b, a%b)\n\ndef multiple(a, b):\n    return a*b \/\/ euclid(a, b)\n\n# N個の最大公約数\n# euclidが必要\nimport functools\n\ndef gcd(nums):\n    return functools.reduce(euclid, nums)\n\nif gcd(A) != 1:\n    print(\"not coprime\")\n\nelse:\n    \"\"\"\n    flag = 0\n    M = [False]*(10**6+1)\n    for i in range(N):\n        n = A[i]\n        if M[n]:\n            flag = 1\n            break\n        if n != 1:\n            k = 1\n            while n*k <= 10**6:\n                M[n*k] = True\n                k += 1\n    \"\"\"\n    flag = 0\n    M = [False]*(10**6+1)\n    for i in range(N):\n        n = A[i]\n        l = factorization(n)\n        for j in range(len(l)):\n            p = l[j][0]\n            if M[p]:\n                flag = 1\n                break\n            M[p] = True\n    \n    if flag == 0:\n        print(\"pairwise coprime\")\n    else:\n        print(\"setwise coprime\")\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":978,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict\nfrom collections import deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return list(map(int, sys.stdin.readline().split()))\ndef I(): return int(sys.stdin.readline())\ndef LS():return list(map(list, sys.stdin.readline().split()))\ndef S(): return list(sys.stdin.readline())[:-1]\ndef IR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = I()\n    return l\ndef LIR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LI()\n    return l\ndef SR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = S()\n    return l\ndef LSR(n):\n    l = [None for i in range(n)]\n    for i in range(n):l[i] = LS()\n    return l\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    s = S()\n    for i in range(len(s)-1):\n        if s[i] == s[i+1]:\n            print(\"Bad\")\n            quit()\n    print(\"Good\")\n    return\n\n#B\ndef B():\n    n,l = LI()\n    a = [i+l for i in range(n)]\n    ans = sum(a)\n    m = n+l-1\n    for i in a[::-1]:\n        if i < 0:break\n        m = min(m,i)\n    ans -= m\n    print(ans)\n    return\n\n#C\ndef gcd(a,b):\n    if a == 0:\n        return b\n    return gcd(b%a,a)\ndef C():\n    a,b,c,d = LI()\n    g = gcd(c,d)\n    l = c*d\/\/g\n    sc = b\/\/c-(a-1)\/\/c\n    sd = b\/\/d-(a-1)\/\/d\n    sl = b\/\/l-(a-1)\/\/l\n    print(b-a+1-sc-sd+sl)\n    return\n\n#D\ndef D():\n    n = I()\n    w = LIR(n)\n    w.sort(key = lambda x: x[1])\n    t = 0\n    for a,b in w:\n        if t+a > b:\n            print(\"No\")\n            quit()\n        t += a\n    print(\"Yes\")\n    return\n\n#E\ndef E():\n    n,k = LI()\n    if k == 0:\n        m = (n*(n-1))\/\/2\n        print(m)\n        for i in range(1,n+1):\n            for j in range(i+1,n+1):\n                print(i,j)\n    else:\n        if k > ((n-1)*(n-2))\/\/2:\n            print(-1)\n        else:\n            ans = []\n            for i in range(2,n+1):\n                ans.append((1,i))\n            m = ((n-1)*(n-2))\/\/2\n            for i in range(2,n+1):\n                for j in range(i+1,n+1):\n                    if m == k:break\n                    ans.append((i,j))\n                    m -= 1\n                if m == k:break\n            print(len(ans))\n            for i,j in ans:\n                print(i,j)\n    return\n\n#F\ndef F():\n    def root(x):\n        if par[x] == x:\n            return x\n        par[x] = root(par[x])\n        return par[x]\n    def unite(x,y):\n        x = root(x)\n        y = root(y)\n        if rank[x] < rank[y]:\n            par[x] = y\n        else:\n            par[y] = x\n            if rank[x] == rank[y]:\n                rank[x] += 1\n    n = I()\n    v = defaultdict(list)\n    h = defaultdict(list)\n    par = defaultdict(int)\n    rank = defaultdict(int)\n    for i in range(n):\n        a,b = LI()\n        v[a].append(b)\n        h[b].append(a)\n        par[a] = a\n        rank[a] = 0\n    h = h.values()\n    for l in h:\n        for i in range(len(l)-1):\n            x = l[i]\n            y = l[i+1]\n            if root(x) != root(y):\n                unite(x,y)\n    h = defaultdict(list)\n    for i in par.keys():\n        par[i] = root(par[i])\n        h[par[i]].append(i)\n    h = h.values()\n    ans = 0\n    for k in h:\n        f = defaultdict(lambda : 0)\n        m = 0\n        for i in k:\n            for j in v[i]:\n                if not f[j]:\n                    m += 1\n                    f[j] = 1\n        for i in v.keys():\n            ans += m-len(v[i])\n    print(ans)\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    F()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":979,"bad_solution":"\ndef FUNC(n):\n    \"\"\"Given a positive integer n, return the product of the odd FUNC.\n    Return 0 if all FUNC are even.\n    For example:\n    FUNC(1)  == 1\n    FUNC(4)  == 0\n    FUNC(235) == 15\n    \"\"\"\n    product = 1\n    odd_count = 0\n    for digit in str(n):\n        int_digit = int(digit)\n        if int_digit%2 == 1:\n            product*= product*int_digit\n            odd_count+=1\n    if odd_count ==0:\n        return 0\n    else:\n        return product\n"}
{"id":980,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nH,W=map(int,input().split())\nD=[tuple(map(int,input().split())) for i in range(H)]\n\n# 範囲更新、最大値取得の遅延セグ木と、範囲更新、最小値取得の遅延セグ木\n\nseg_el=1<<((W+3).bit_length()) # Segment treeの台の要素数\nSEG=[1<<30]*(2*seg_el) # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化\nLAZY=[0]*(2*seg_el) # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化\n\nSEG2=[0]*(2*seg_el) # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化\nLAZY2=[0]*(2*seg_el) # 1-indexedなので、要素数2*seg_el.Segment treeの初期値で初期化\n\ndef indexes(L,R):\n    INDLIST=[]\n\n    R-=1\n    \n    L>>=1\n    R>>=1\n\n    while L!=R:\n        if L>R:\n            INDLIST.append(L)\n            L>>=1\n        else:\n            INDLIST.append(R)\n            R>>=1\n\n    while L!=0:\n        INDLIST.append(L)\n        L>>=1\n\n    return INDLIST\n        \n\ndef updates(l,r,x): # 区間[l,r)をxに更新\n        \n    L=l+seg_el\n    R=r+seg_el\n\n    L\/\/=(L & (-L))\n    R\/\/=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]:\n        if LAZY[ind]!=None:\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=SEG[ind<<1]=SEG[1+(ind<<1)]=LAZY[ind]\n            LAZY[ind]=None\n    \n    while L!=R:\n        if L > R:\n            SEG[L]=x\n            LAZY[L]=x\n            L+=1\n            L\/\/=(L & (-L))\n\n        else:\n            R-=1\n            SEG[R]=x\n            LAZY[R]=x\n            R\/\/=(R & (-R))\n\n    for ind in UPIND:\n        SEG[ind]=max(SEG[ind<<1],SEG[1+(ind<<1)])\n\ndef updates2(l,r,x): # 区間[l,r)をxに更新\n        \n    L=l+seg_el\n    R=r+seg_el\n\n    L\/\/=(L & (-L))\n    R\/\/=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]:\n        if LAZY2[ind]!=None:\n            LAZY2[ind<<1]=LAZY2[1+(ind<<1)]=SEG2[ind<<1]=SEG2[1+(ind<<1)]=LAZY2[ind]\n            LAZY2[ind]=None\n    \n    while L!=R:\n        if L > R:\n            SEG2[L]=x\n            LAZY2[L]=x\n            L+=1\n            L\/\/=(L & (-L))\n\n        else:\n            R-=1\n            SEG2[R]=x\n            LAZY2[R]=x\n            R\/\/=(R & (-R))\n\n    for ind in UPIND:\n        SEG2[ind]=min(SEG2[ind<<1],SEG2[1+(ind<<1)]) \n        \ndef getvalues(l,r): # 区間[l,r)に関するmaxを調べる\n\n    L=l+seg_el\n    R=r+seg_el\n\n    L\/\/=(L & (-L))\n    R\/\/=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]:\n        if LAZY[ind]!=None:\n            LAZY[ind<<1]=LAZY[1+(ind<<1)]=SEG[ind<<1]=SEG[1+(ind<<1)]=LAZY[ind]\n            LAZY[ind]=None\n            \n    ANS=-1\n\n    while L!=R:\n        if L > R:\n            ANS=max(ANS , SEG[L])\n            L+=1\n            L\/\/=(L & (-L))\n\n        else:\n            R-=1\n            ANS=max(ANS , SEG[R])\n            R\/\/=(R & (-R))\n\n    return ANS\n\ndef getvalues2(l,r): # 区間[l,r)に関するminを調べる\n\n    L=l+seg_el\n    R=r+seg_el\n\n    L\/\/=(L & (-L))\n    R\/\/=(R & (-R))\n\n    UPIND=indexes(L,R)\n    \n    for ind in UPIND[::-1]:\n        if LAZY2[ind]!=None:\n            LAZY2[ind<<1]=LAZY2[1+(ind<<1)]=SEG2[ind<<1]=SEG2[1+(ind<<1)]=LAZY2[ind]\n            LAZY2[ind]=None\n            \n    ANS=1<<31\n\n    while L!=R:\n        if L > R:\n            ANS=min(ANS , SEG2[L])\n            L+=1\n            L\/\/=(L & (-L))\n\n        else:\n            R-=1\n            ANS=min(ANS , SEG2[R])\n            R\/\/=(R & (-R))\n\n    return ANS\n\nfor i in range(W+1):\n    updates(i,i+1,i)\n\nfor i in range(H):\n    x,y = D[i]\n    if x==1:\n        updates(x,y+1,-1<<30)\n    else:\n        MAX=getvalues(1,x)\n        updates(x,y+1,MAX)\n\n    updates2(x,y+1,1<<30)\n    updates2(y+1,y+2,y+1-getvalues(y+1,y+2))\n\n    #print(*[getvalues(i,i+1) for i in range(W+1)])\n    #print(*[getvalues2(i,i+1) for i in range(W+1)])\n\n    ANS=getvalues2(1,W+1)+i+1\n    if ANS>1<<28:\n        print(-1)\n    else:\n        print(ANS)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":981,"bad_solution":"import sys\ninput = sys.stdin.readline\n\nN = int(input())\nS = [input().rstrip() for _ in range(N)]\n\ndef calc(S):\n    now = 0\n    ret = 0\n    for s in S:\n        if s == '(':\n            now += 1\n        else:\n            now -= 1\n        ret = min(ret, now)\n    return ret\n\nT = [(calc(s), s) for s in S]\nT.sort(key=lambda a: a[0], reverse=True)\nans = ''.join([s for _, s in T])\n\n# H = []\n# P = []\n# L = []\n\n# for s in S:\n#     less = -calc(s)\n#     if less == 0:\n#         H.append(s)\n#     else:\n#         l = s.count('(')\n#         r = len(s) - l\n#         if l >= r:\n#             P.append((less, s))\n#         else:\n#             L.append((less, s))\n\n# P.sort(key=lambda a: a[0])\n# L.sort(key=lambda a: a[0], reverse=True)\n# P = [s for _, s in P]\n# L = [s for _, s in L]\n# ans = ''.join(H + P + L)\n\nl = ans.count('(')\nr = ans.count(')')\n\nif l == r and calc(ans) == 0:\n    print('Yes')\nelse:\n    print('No')\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":982,"bad_solution":"# 組み合わせ(N > 10 ** 7 でも可能)\ndef xgcd(a, b):\n    x0, y0, x1, y1 = 1, 0, 0, 1\n    while b != 0:\n        q, a, b = a \/\/ b, b, a % b\n        x0, x1 = x1, x0 - q * x1\n        y0, y1 = y1, y0 - q * y1\n    return a, x0, y0\n\ndef modinv(a, m):\n    g, x, y = xgcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n\ndef comb(n, r, p):\n    ret = 1\n    while 1:\n        if (r == 0):\n            break\n        N = n % p\n        R = r % p\n        if N < R:\n            return 0\n        for i in range(R):\n            ret = ret * (N-i) % p\n        imul = 1\n        for i in range(R):\n            imul = imul * (i+1) % p\n        ret = ret * modinv(imul, p) % p\n        n \/\/= p\n        r \/\/= p\n    return ret\n\nmod = 998244353\n\nN, M, K = map(int, input().split())\n\n\nans = 0\nfor k in range(K+1):\n    tmp_c = comb(N-k, k, mod)\n    tmp_pow = pow(M-1, N-1-k, mod)\n    ans += (tmp_c * tmp_pow * M) % mod\n\nprint(ans%mod)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":983,"bad_solution":"\ndef FUNC(string):\n    '''\n    Create a function that takes a string as input which contains only square brackets.\n    The function should return True if and only if there is a valid subsequence of brackets \n    where at least one bracket in the subsequence is nested.\n\n    FUNC('[[]]') ➞ True\n    FUNC('[]]]]]]][[[[[]') ➞ False\n    FUNC('[][]') ➞ False\n    FUNC('[]') ➞ False\n    FUNC('[[][]]') ➞ True\n    FUNC('[[]][[') ➞ True\n    '''\n    opening_bracket_index = []\n    closing_bracket_index = []\n    for i in range(len(string)):\n        if string[i] == '(':\n            opening_bracket_index.append(i)\n        else:\n            closing_bracket_index.append(i)\n    closing_bracket_index.reverse()\n    cnt = 0\n    i = 0\n    l = len(closing_bracket_index)\n    for idx in opening_bracket_index:\n        if i < l and idx < closing_bracket_index[i]:\n            cnt += 1\n            i += 1\n    return cnt >= 2\n\n    \n"}
{"id":984,"bad_solution":"\n\ndef FUNC(lst):\n    \"\"\"You are given a list of numbers.\n    You need to return the sum of squared numbers in the given list,\n    round each element in the list to the upper int(Ceiling) first.\n    Examples:\n    For lst = [1,2,3] the output should be 14\n    For lst = [1,4,9] the output should be 98\n    For lst = [1,3,5,7] the output should be 84\n    For lst = [1.4,4.2,0] the output should be 29\n    For lst = [-2.4,1,1] the output should be 6\n    \n\n    \"\"\"\n    import math\n    squared = 0\n    for i in lst:\n        squared += math.ceil(i)*2\n    return squared\n"}
{"id":985,"bad_solution":"import sys\nreadline = sys.stdin.readline\nX,Y,Z,K = map(int, readline().split())\nA = sorted(list(map(int, readline().split())), reverse=True)\nB = sorted(list(map(int, readline().split())), reverse=True)\nC = sorted(list(map(int, readline().split())), reverse=True)\n\ndef f(thres:int)->bool:\n    \"\"\"return (おいしさが thres 以上の組み合わせ) >= K\n    \"\"\"\n    global K\n    cnt = 0\n    for a in range(X):\n        for b in range(Y):\n            for c in range(Z):\n                if A[a]+B[b]+C[c]<thres:\n                    break\n                cnt += 1\n                if cnt >= K:\n                    return True\n    return False\n\ndef binary_search(f, s:int, t:int)->int:\n    \"\"\"f: function(x:int)->bool\n    f(s)=False, f(t)=True，f は広義単調増加\n    return : [s, t) での f(x)=True なる最小のx\n    \"\"\"\n    ok = s-1\n    ng = t\n    while ng - ok > 1:\n        mid = (ok + ng)\/\/2\n        if f(mid): ok = mid\n        else:      ng = mid\n        # print(ng, ok, ok-ng)\n\n    if ok==s-1:\n        raise(ValueError(\"For all x, f(x)=False\"))\n    return ok\n\nM = A[0]+B[0]+C[0]\nm = A[-1]+B[-1]+C[-1]\n# print(f(m), f(M))\nthres = binary_search(f, m, M+1)-1\n# print(\"thres:\",thres)\nans = []\nfor a in range(X):\n    for b in range(Y):\n        for c in range(Z):\n            if A[a]+B[b]+C[c]<thres:\n                break\n            ans.append(A[a]+B[b]+C[c])\n\nans.sort(reverse=True)\nprint(\"\\n\".join(map(str, ans[:K])))\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":986,"bad_solution":"import sys\nsys.setrecursionlimit(10**9)\n\nINF = 10**20\ndef main():\n    H,N = map(int,input().split())\n    A,B = [],[]\n    for _ in range(N):\n        a,b = map(int,input().split())\n        A.append(a)\n        B.append(b)\n\n    tp = 10**4\n    dp = [INF] * tp\n    dp[0] = 0\n    for h in range(tp):\n        minim = INF\n        for i in range(N):\n            dp_i = h-A[i]\n            if dp_i >= 0 and dp[dp_i] != INF:\n                minim = min(minim,dp[dp_i]+B[i])\n                # print(dp[h-A[i]]+B[i])\n\n        if minim != INF:\n            dp[h] = minim\n            if h >= H:\n                # print(dp[h],h,dp)\n                print(dp[h])\n                exit()\n\n\n    assert False\n\n\nif __name__ == \"__main__\":\n  main()\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":987,"bad_solution":"\ndef FUNC(txt):\n    '''\n    Create a function that returns True if the last character\n    of a given string is an alphabetical character and is not\n    a part of a word, and False otherwise.\n    Note: \"word\" is a group of characters separated by space.\n\n    Examples:\n    FUNC(\"apple pie\") ➞ False\n    FUNC(\"apple pi e\") ➞ True\n    FUNC(\"apple pi e \") ➞ False\n    FUNC(\"\") ➞ False \n    '''\n \n    check = txt.split(' ')[-1]\n    return True if len(check) == 1 and (97 <= ord(check.upper()) <= 122) else False\n"}
{"id":988,"bad_solution":"H, W =  map(int, input().split())\n\nS = []\nfor _ in range(H):\n    tmp = list(input())\n    S.append(tmp)\n    \nimport numpy as np\n\ndef count_light(Gs, h, w):\n    Gc = np.empty((h,w))\n    for i, gs in enumerate(Gs):\n        count = 0\n        for j, s in enumerate(gs):\n            if s == '#':\n                count = 0\n                Gc[i][j] = 0\n            else:\n                count += 1\n                Gc[i][j] = count\n\n    return Gc\n\nGs1 = np.asarray(S)\nGn1 = count_light(Gs1, H, W)\n\nGs2 = np.rot90(Gs, k=1)\nGn2 = count_light(Gs2, W, H)\n\nGs3 = np.rot90(Gs2, k=1)\nGn3 = count_light(Gs3, H, W)\n\nGs4 = np.rot90(Gs3, k=1)\nGn4 = count_light(Gs4, W, H)\n\nGn2 = np.rot90(Gn2, k=-1)\nGn3 = np.rot90(Gn3, k=-2)\nGn4 = np.rot90(Gn4, k=-3)\n\nGsum = Gn1+Gn2+Gn3+Gn4\nans = int(np.max(Gsum)-3)\nprint(ans)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":989,"bad_solution":"import sys\nsys.setrecursionlimit(2147483647)\nINF=float(\"inf\")\nMOD=10**9+7\ninput=lambda :sys.stdin.readline().rstrip()\ndef resolve():\n    from itertools import product\n    n=int(input())\n    match=[[0]*n for _ in range(n)]\n    V=0 # V=n(n-1)\/2\n    for i,j in product(range(n),repeat=2):\n        if(i>=j): continue\n        match[i][j]=V\n        V+=1\n\n    def toID(i,j):\n        if(i>j): i,j=j,i\n        return match[i][j]\n\n    E=[[] for _ in range(V)]\n    for i in range(n):\n        A=list(map(lambda x:int(x)-1,input().split()))\n        for j in range(1,n-1):\n            E[toID(i,A[j-1])].append(toID(i,A[j]))\n    # あとは頂点VのグラフをdfsしてLongest pathの長さを求める\n    # -1: unchecked, -2: checked and uncalculated\n    dp=[-1]*V\n    def dfs(v,p):\n        dp[v]=-2\n        length=0\n        for nv in E[v]:\n            if(nv==p): continue\n            dfs(nv,v)\n            if(dp[nv]==-2):\n                print(-1)\n                exit()\n            length=max(length,dp[nv]+1)\n        dp[v]=length\n    # calculate\n    dfs(0,-1)\n    print(max(dp)+1)\nresolve()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":990,"bad_solution":"import collections\nh, w = map(int, input().split())\na = [list(input()) for _ in range(h)]\n\nqueue = collections.deque()\n\nans = 0\n\n\ndef bfs(y, x, cnt):\n    if (y < 0 or h <= y or x < 0 or w <= x or a[y][x] == '#'):\n        return\n    #print(y, x, cnt)\n    a[y][x] = '#'\n    queue.append([y + 1, x, cnt+1])\n    queue.append([y - 1, x, cnt+1])\n    queue.append([y, x+1, cnt+1])\n    queue.append([y, x - 1, cnt+1])\n\n\nfor i in range(h):\n    for j in range(w):\n        if (a[i][j] == '#'):\n            queue.append([i+1, j, 0])\n            queue.append([i-1, j, 0])\n            queue.append([i, j+1, 0])\n            queue.append([i, j - 1, 0])\n            break\n\nwhile (len(queue) > 0):\n    l = queue.popleft()\n    # print(l)\n    ans = max(ans, l[2])\n    bfs(l[0], l[1], l[2])\n\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":991,"bad_solution":"\ndef FUNC(arr):\n    \"\"\"Create a function which returns the largest index of an element which\n    is not greater than or equal to the element immediately preceding it. If\n    no such element exists then return -1. The given array will not contain\n    duplicate values.\n\n    Examples:\n    FUNC([1,2,4,3,5]) = 3\n    FUNC([1,2,3]) = -1\n    \"\"\"\n    ind=-1\n    i=1\n    while i<len(arr):\n      if arr[i]<arr[i-1]:\n        ind=i\n      i+=1\n      ind-=1\n    return ind\n"}
{"id":992,"bad_solution":"#!\/usr\/bin\/env python\nfrom __future__ import division, print_function\n\nimport os\nimport sys\nfrom io import BytesIO, IOBase\n\nif sys.version_info[0] < 3:\n    from __builtin__ import xrange as range\n    from future_builtins import ascii, filter, hex, map, oct, zip\n\nimport random\nimport collections\nimport math\nimport itertools\nimport bisect\n\ndef real_main():\n    w, h, x, y = read_int_array()\n    vertical_line_area = min(x * h, h * (w - x))\n    horiz_line_area = min(y * w, w * (h - y))\n    if horiz_line_area == vertical_line_area:\n        print(horiz_line_area, 1)\n    else:\n        print(max(vertical_line_area, horiz_line_area), 0)\n\n\ndef solve():\n    pass\n\n\ndef main():\n    if False and 'PYCHARM_HOSTED' in os.environ:\n        main_pycharm()\n    else:\n        real_main()\n\n\nfrom copy import deepcopy\ndef main_pycharm():\n    solution = solve\n\n    test_inputs = None\n    test_outputs = None\n    judge = None\n    slow_solution = None\n    if solution is not None:\n        if test_outputs is not None:\n            test_with_answers(solution, test_inputs, test_outputs)\n        if judge is not None:\n            test_with_judge(solution, test_inputs, judge)\n        if slow_solution is not None:\n            test_with_slow_solution(solution, test_inputs, slow_solution)\n\n\ndef test_with_answers(solution, inputs_answers):\n    total, wrong = 0, 0\n    for args, test_ans in inputs_answers:\n        ans = solution(*args.copy())\n        if ans != test_ans:\n            print('WRONG! ans=%s, test_ans=%s, args=%s' % (ans, test_ans, args))\n            wrong += 1\n        else:\n            print('GOOD')\n        total += 1\n    print('ALL %d TESTS PASSED' % total if not wrong else '%d out of %d tests are WRONG' % (wrong, total))\n\n\ndef test_with_judge(solution, inputs_gen, judge):\n    total, wrong = 0, 0\n    for args in inputs_gen:\n        ans = solution(*deepcopy(args))\n        if not judge(deepcopy(ans), *deepcopy(args)):\n            print('WRONG! ans=%s, args=%s' % (ans, args))\n            wrong += 1\n        total += 1\n    print('ALL %d TESTS PASSED' % total if not wrong else '%d out of %d tests are WRONG' % (wrong, total))\n\n\ndef test_with_slow_solution(solution, inputs_gen, solution_slow):\n    total, wrong = 0, 0\n    for args in inputs_gen:\n        ans = solution(*deepcopy(args))\n        slow = solution_slow(*deepcopy(args))\n        if ans != slow:\n            print('WRONG! ans=%s, slow=%s, args=%s' % (ans, slow, args))\n            wrong += 1\n        total += 1\n    print('ALL %d TESTS PASSED' % total if not wrong else '%d out of %d tests are WRONG' % (wrong, total))\n\n\n# region fastio\n\nBUFSIZE = 8192\n\n\nclass FastIO(IOBase):\n    newlines = 0\n\n    def __init__(self, file):\n        self._fd = file.fileno()\n        self.buffer = BytesIO()\n        self.writable = \"x\" in file.mode or \"r\" not in file.mode\n        self.write = self.buffer.write if self.writable else None\n\n    def read(self):\n        while True:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            if not b:\n                break\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines = 0\n        return self.buffer.read()\n\n    def readline(self):\n        while self.newlines == 0:\n            b = os.read(self._fd, max(os.fstat(self._fd).st_size, BUFSIZE))\n            self.newlines = b.count(b\"\\n\") + (not b)\n            ptr = self.buffer.tell()\n            self.buffer.seek(0, 2), self.buffer.write(b), self.buffer.seek(ptr)\n        self.newlines -= 1\n        return self.buffer.readline()\n\n    def flush(self):\n        if self.writable:\n            os.write(self._fd, self.buffer.getvalue())\n            self.buffer.truncate(0), self.buffer.seek(0)\n\n\nclass IOWrapper(IOBase):\n    def __init__(self, file):\n        self.buffer = FastIO(file)\n        self.flush = self.buffer.flush\n        self.writable = self.buffer.writable\n        self.write = lambda s: self.buffer.write(s.encode(\"ascii\"))\n        self.read = lambda: self.buffer.read().decode(\"ascii\")\n        self.readline = lambda: self.buffer.readline().decode(\"ascii\")\n\n\ndef print(*args, **kwargs):\n    \"\"\"Prints the values to a stream, or to sys.stdout by default.\"\"\"\n    sep, file = kwargs.pop(\"sep\", \" \"), kwargs.pop(\"file\", sys.stdout)\n    at_start = True\n    for x in args:\n        if not at_start:\n            file.write(sep)\n        file.write(str(x))\n        at_start = False\n    file.write(kwargs.pop(\"end\", \"\\n\"))\n    if kwargs.pop(\"flush\", False):\n        file.flush()\n\n\nif sys.version_info[0] < 3:\n    sys.stdin, sys.stdout = FastIO(sys.stdin), FastIO(sys.stdout)\nelse:\n    sys.stdin, sys.stdout = IOWrapper(sys.stdin), IOWrapper(sys.stdout)\n\ninput = lambda: sys.stdin.readline().rstrip(\"\\r\\n\")\n\ndef read():\n    return input()\n\ndef read_int():\n    return int(input())\n\ndef read_array(sep=None, maxsplit=-1):\n    return input().split(sep, maxsplit)\n\ndef read_int_array():\n    return [int(a) for a in read_array()]\n\n# endregion\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":993,"bad_solution":"import heapq\ndef main():\n    N, M, S = map(int, input().split())\n    money_max = 50*N\n    S = min(S, money_max-1)\n    dp = [[float(\"inf\")]*(money_max) for _ in range(N)]\n    dp[0][S] = 0\n    G = [[] for _ in range(N)]\n    exchange = [None]*N\n    for _ in range(M):\n        u, v, a, b = map(int, input().split())\n        u, v = u-1, v-1\n        G[u].append([v, a, b])\n        G[v].append([u, a, b])\n    for i in range(N):\n        c, d = map(int, input().split())\n        exchange[i] = [c, d]\n    q = []\n    heapq.heapify(q)\n    heapq.heappush(q, [0, 0])\n    time_min = [float(\"inf\")]*N\n    time_min[0] = 0\n    while 0 < len(q):\n        pre_time, p = heapq.heappop(q)\n        if time_min[p] < pre_time:\n            continue\n        for i in range(money_max - exchange[p][0]):\n            if dp[p][i] < float(\"inf\"):\n                dp[p][i+exchange[p][0]] = min(dp[p][i+exchange[p][0]], dp[p][i] + exchange[p][1])\n        for to, money, time in G[p]:\n            f = False\n            for i in range(money, money_max):\n                if dp[p][i] < float(\"inf\") and dp[to][i-money] > dp[p][i] + time:\n                    dp[to][i-money] = dp[p][i] + time\n                    if dp[to][i-money] < time_min[to]:\n                        time_min[to] = dp[to][i-money]\n                    f = True\n            if f:\n                heapq.heappush(q, [time_min[to], to])\n    for i in range(1, N):\n        print(time_min[i])\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":994,"bad_solution":"INF=10**20\nfrom heapq import heappop,heappush,heapify\ndef dijkstra(G,H,W,sh,sw):\n    dx=[1,0,-1,0]\n    dy=[0,1,0,-1]\n    que=[(0,sh,sw)]\n    dist=[[INF]*W for i in range(H)]\n    dist[sh][sw]=0\n    while que:\n        mincost,h,w=heappop(que)\n        if(mincost>dist[h][w]):\n            continue\n        for di in range(4):\n            nh=h+dx[di]\n            nw=w+dy[di]\n            if(nh>H-1 or nh<0 or nw>W-1 or nw<0):\n                continue\n            if(G[nh][nw]=='#'):\n                continue\n            if(dist[h][w]<dist[nh][nw]):\n                dist[nh][nw]=dist[h][w]\n                heappush(que,(dist[nh][nw],nh,nw))\n        for nh in range(h-2,h+3):\n            for nw in range(w-2,w+3):\n                if (nh>H-1 or nh<0 or nw>W-1 or nw<0):\n                    continue\n                if(G[nh][nw]=='#'):\n                    continue\n                if dist[h][w]+1<dist[nh][nw]:\n                    dist[nh][nw]=dist[h][w]+1\n                    heappush(que,(dist[nh][nw],nh,nw))\n    return dist\n\nH,W=map(int,input().split())\nCh,Cw=map(lambda x:int(x)-1,input().split())\nDh,Dw=map(lambda x:int(x)-1,input().split())\nG=[list(input()) for i in range(H)]\ndist=dijkstra(G,H,W,Ch,Cw)\nans=dist[Dh][Dw]\nif ans!=INF:\n    print(ans)\nelse:\n    print(-1)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":995,"bad_solution":"\ndef FUNC(lst):\n    '''\n    Create a function that returns a tuple (a, b), where 'a' is\n    the largest of negative integers, and 'b' is the smallest\n    of positive integers in a list.\n    If there is no negative or positive integers, return them as None.\n\n    Examples:\n    FUNC([2, 4, 1, 3, 5, 7]) == (None, 1)\n    FUNC([]) == (None, None)\n    FUNC([0]) == (None, None)\n    '''\n    smallest = list(filter(lambda x: x < 0, lst))\n    largest = list(filter(lambda x: x > 0, lst))\n    largest = list(filter(lambda x: x > 0, smallest))\n    smallest = list(filter(lambda x: x > 0, largest))\n    return (max(smallest) if smallest else None, min(largest) if largest else None)\n"}
{"id":996,"bad_solution":"import sys\nread = sys.stdin.read\nreadlines = sys.stdin.readlines\nfrom collections import defaultdict\ndef main():\n    n, *a = map(int, read().split())\n\n    maxa = max(a) + 1  # aはint配列\n    d = [i for i in range(maxa)]\n    for p0 in range(2, maxa):\n        if p0 == d[p0]:\n            for p1 in range(p0 ** 2, maxa, p0):\n                if d[p1] % p0 == 0:\n                    d[p1] = p0\n\n    def factorization(f):  # f > maxaだとエラー\n        l = []\n        t = f\n        while True:\n            if t == d[t]:\n                l.append(d[t])\n                break\n            else:\n                l.append(d[t])\n                t = t \/\/ d[t]\n        return l\n\n    if all([i == 1 for i in a]):\n        print('pairwise coprime')\n    d1 = defaultdict(int)\n    for ae in a:\n        t1 = set(factorization(ae))\n        for t1e in t1:\n            d1[t1e] += 1\n    d1v = tuple(d1.values())\n    if all([i == 1 for i in d1v]):\n        print('pairwise coprime')\n    elif max(d1v) == n:\n        print('not coprime')\n    else:\n        print('setwise coprime')\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":997,"bad_solution":"def run(K):\n    n_max = 500\n    '''\n    K <= 500の場合は、n = Kとして1行につき1色を塗ればよい\n        111\n        222\n        333\n    Kが4の倍数の場合は、n = K\/2以下の塗り方ができる\n        1234\n        5678\n        3412\n        7856\n    上記でn+i+1色をi色に塗り替えても条件を満たす\n        1234\n        5178\n        3412\n        7851\n    K = 1000の時は、n = 500で満たし、塗り替え操作で501～999まで表現できる\n    '''\n    n = 0\n    trouts = []\n    if K <= n_max:\n        for i in range(K):\n            n = K\n            trouts.append([i+1]*K)\n    else:\n        change = n_max*2 - K\n        c1 = [i for i in range(1, n_max+1)]\n        c2 = [n_max+1] + [i for i in range(1, change+1)] + [i for i in range(n_max+2, n_max*2+1-change)]\n        for i in range(n_max):\n            shift = (i\/\/2) * 2\n            if i % 2 == 0:\n                trouts.append(c1[shift:] + c1[:shift])\n            else:\n                trouts.append(c2[shift:] + c2[:shift])\n    return (n, trouts)\n\n\ndef main():\n    K = int(input())\n    n, trouts = run(K)\n    print(n)\n    for i in range(len(trouts)):\n        print(' '.join(map(str, trouts[i])))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":998,"bad_solution":"K = int(input().split()[-1])\n\nA = [int(e) for e in input().split()]\nB = [int(e) for e in input().split()]\nC = [int(e) for e in input().split()]\n# A = list(map(int, input().split()))\n# B = list(map(int, input().split()))\n# C = list(map(int, input().split()))\n\n\n# def get_good(a, v):\n#     return max(a)\n#     if v is not None:\n#         return max(a[a < v])\n#     else:\n#         max(a)\n\n\n\nprev_a = max(A)\nprev_b = max(B)\nprev_c = max(C)\n\nvalue = prev_a + prev_b + prev_c\n\nA.remove(max(A))\nB.remove(max(B))\nC.remove(max(C))\n\nprint(value)\n\nfor i in range(K - 1):\n    a = max(A)\n    b = max(B)\n    c = max(C)\n\n    sub_a = prev_a - a\n    sub_b = prev_b - b\n    sub_c = prev_c - c\n\n    if sub_a < sub_b and sub_a < sub_c:\n        A.remove(a)\n    if sub_b < sub_a and sub_b < sub_c:\n        B.remove(b)\n    if sub_c < sub_a and sub_c < sub_b:\n        B.remove(c)\n\n\n    value -= min(sub_a, sub_b, sub_c)\n    print(value)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":999,"bad_solution":"#dpでできないかな？\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,cos,radians,sqrt\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print('\\n'.join(x))\ndef printni(x): print('\\n'.join(list(map(str,x))))\ninf = 10**17\nmod = 10**9 + 7\n\nn,a,b=MI()\nl=b-a\nif l%2==0:\n    ans=l\/\/2\n    print(ans)\nelse:\n    edge=min(n-b,a-1)\n    ans=edge\n    ans+=1\n    l-=1\n    ans+=l\/\/2\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1000,"bad_solution":"def main():\n    import sys\n    def MI():\n        return map(int, sys.stdin.readline().rstrip().split())\n    def LI():\n        return list(map(int, sys.stdin.readline().rstrip().split()))  # 空白あり\n\n    N, Q = MI()\n    c = [{i} for i in LI()]\n\n    seg = [set()] * (2*N)\n    for i in range(N):\n        seg[i+N] = c[i]\n    for i in range(N-1,0,-1):\n        seg[i] = seg[i << 1] | seg[i << 1 | 1]\n\n    def fold(L, R):  # [L,R)の区間取得\n        L += N\n        R += N\n        vL = set()\n        vR = set()\n        while L < R:\n            if L & 1:\n                vL = vL | seg[L]\n                L += 1\n            if R & 1:\n                R -= 1\n                vR = seg[R] | vR\n            L >>= 1\n            R >>= 1\n        return len(vL | vR)\n\n    for i in range(Q):\n        l, r = MI()\n        print(fold(l - 1, r))\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1001,"bad_solution":"from sys import stdin\nimport numpy as np\n\ndef bit_search(a, n, m, x):\n    min_price = float('inf')\n    for i in range(2 ** n):\n        price = 0\n        skill = np.zeros((n, m))\n        for j in range(n):\n            if (i >> j) & 1:\n                price += a[j][0]\n                skill[j] = a[j][1:]\n        skill_sum = np.sum(skill, axis=0)\\\n                        if skill.shape[0] > 1 else np_skill\n        if not (skill_sum >= x).all() or price > min_price: continue\n        min_price = price\n    return min_price\n\ndef main():\n    readline = stdin.readline\n    n, m, x = map(int, readline().split())\n    a = [list(map(int, readline().split())) for _ in range(n)]\n    min_price = bit_search(a, n, m, x)\n    return print('-1' if min_price == float('inf') else min_price)\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1002,"bad_solution":"def main():\n    x, y = map(int, input().split())\n\n    if x == y:\n        ans = 0\n    if x >= 0 and y >= 0:\n        if x < y:\n            # x:1, y:3\n            ans = y - x\n        else:\n            # x:3, y:1\n            ans = 1 + y + x\n    elif x < 0 and y < 0:\n        if x < y:\n            # x:-3, y:-1\n            ans = y - x\n        else:\n            # x:-1, y:-3\n            # x:1,2,3,-3\n            ans = 1 + abs(y - x) + 1\n    elif x < 0 < y:\n        if abs(x) < y:\n            # x:-3, y:4\n            # x:3,4\n            ans = 1 + y + x\n        else:\n            # x:-5, y:4\n            ans = y - x\n    elif x > 0 > y:\n        if x > abs(y):\n            # x:3, y:-1\n            # x:-3,-2,-1\n            ans = 1 + x + y\n        else:\n            # x:3, y:-4\n            ans = abs(y + x) + 1\n\n    print(ans)\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1003,"bad_solution":"#!\/usr\/bin\/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nfrom bisect import bisect_left, bisect_right\nimport sys, random, itertools, math\nsys.setrecursionlimit(10**5)\ninput = sys.stdin.readline\nsqrt = math.sqrt\ndef LI(): return list(map(int, input().split()))\ndef LF(): return list(map(float, input().split()))\ndef LI_(): return list(map(lambda x: int(x)-1, input().split()))\ndef II(): return int(input())\ndef IF(): return float(input())\ndef LS(): return list(map(list, input().split()))\ndef S(): return list(input().rstrip())\ndef IR(n): return [II() for _ in range(n)]\ndef LIR(n): return [LI() for _ in range(n)]\ndef FR(n): return [IF() for _ in range(n)]\ndef LFR(n): return [LI() for _ in range(n)]\ndef LIR_(n): return [LI_() for _ in range(n)]\ndef SR(n): return [S() for _ in range(n)]\ndef LSR(n): return [LS() for _ in range(n)]\nmod = 1000000007\ninf = 1e10\n\n#solve\ndef solve():\n    n = II()\n    edg = [[] for i in range(n)]\n    t = 0\n    ab = defaultdict(int)\n    d = defaultdict(int)\n    for _ in range(n - 1):\n        a, b = LI_()\n        edg[a].append(b)\n        edg[b].append(a)\n        d[(a, b)] = t\n        d[(b, a)] = t\n        t += 1\n    m = II()\n    path = [0] * m \n    uv = LIR_(m)\n    for i, uvi in enumerate(uv):\n        u, v = uvi\n        q = deque()\n        q.append((u, []))\n        while q:\n            p, pat = q.popleft()\n            for e in edg[p]:\n                if e in pat:\n                    continue\n                if e == v:\n                    pat += [d[(p, e)]]\n                    q = deque()\n                    break\n                else:\n                    q.append((e, pat + [d[(p, e)]]))\n        for p in pat:\n            path[i] |= 1 << p\n    ans = 1 << (n-1)\n    for mask in range(1, 1 << m):\n        tmp = 0\n        t = 0\n        for i in range(m):\n            if mask & (1 << i):\n                t += 1\n                tmp = tmp | path[i]\n        x = 0\n        while tmp:\n            x += tmp & 1\n            tmp >>=1\n        ans += (1 << (n - x - 1)) * (-1) ** t\n    print(ans)\n\n\n    return\n\n\n#main\nif __name__ == '__main__':\n    solve()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1004,"bad_solution":"from heapq import *\n\ndef calc():\n    N = int(input())\n    A = [int(a) for a in input().split()]\n    B = [int(a) for a in input().split()]\n\n    h = []\n    for i in range(N):\n        heappush(h, (-B[i], i))\n\n    ans = 0\n    while h:\n        b, i = heappop(h)\n        b = -b\n        if b == A[i]:\n            continue\n        k = - (-(B[i] - max(B[i-1], B[(i+1)%N], A[i])) \/\/ (B[i-1] + B[(i+1)%N]))\n        if k <= 0:\n            return -1\n        B[i] -= (B[i-1] + B[(i+1)%N]) * k\n        heappush(h, (-B[i], i))\n        ans += k\n    return ans\nprint(calc())\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1005,"bad_solution":"import math,itertools,fractions,heapq,collections,bisect,sys,queue,copy\n\nsys.setrecursionlimit(10**7)\ninf=10**20\nmod=1000000007\ndd=[(-1,0),(0,1),(1,0),(0,-1)]\nddn=[(-1,0),(-1,1),(0,1),(1,1),(1,0),(1,-1),(0,-1),(-1,-1)]\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS(): return sys.stdin.readline().split()\ndef S(): return input()\n\n# Summarize count of factor within list -- START --\ndef summarize_list(sl):\n\n  a=sl[0]\n  c=1\n  res=[]\n\n  for x in sl[1:]:\n    if x==a:\n      c+=1\n    else:\n      res.append(c)\n      a=x\n      c=1\n  res.append(c)\n\n  return res\n# Summarize count of factor within list --- END ---\n\ndef main():\n  n,k=LI()\n  s=list(S())\n\n  l=summarize_list(s)\n  # print(l)\n\n  # 累積和\n  for i in range(len(l)-1):\n    l[i+1]+=l[i]\n\n  # 1 0 1 0... の形にする\n  if s[0]=='0':\n    l=[0]+l\n\n  # ...0 1 0 1 の形にする\n  if s[-1]=='0':\n    l+=[l[-1]+1]\n\n  l=[0]+l\n\n  ans=0\n  left=0\n  right=min(len(l)-1,2*k+1)\n  \n  while True:\n    if right>=len(l):\n      return ans\n\n    print(right,left)\n    ans=max(ans,l[right]-l[left])\n\n    left+=2\n    right+=2\n\n# main()\nprint(main())\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1006,"bad_solution":"import sys\nstdin = sys.stdin\n\nsys.setrecursionlimit(10 ** 7)\n\ndef li(): return map(int, stdin.readline().split())\ndef li_(): return map(lambda x: int(x) - 1, stdin.readline().split())\ndef lf(): return map(float, stdin.readline().split())\ndef ls(): return stdin.readline().split()\ndef ns(): return stdin.readline().rstrip()\ndef lc(): return list(ns())\ndef ni(): return int(stdin.readline())\ndef nf(): return float(stdin.readline())\n\nnum_cost = {1: 2,\n            2: 5,\n            3: 5,\n            4: 4,\n            5: 5,\n            6: 6,\n            7: 3,\n            8: 6,\n            9: 5}\n\nchosen = {}\n\nn, m = li()\na = list(li())\n\nfor ai in a:\n    chosen[str(ai)] = num_cost[ai]\n\ndp = [\"ng\"]*(n+1)\ndp[0] = \"\"\nfor i in range(n):\n    if dp[i] == \"ng\":\n        continue\n\n    for num, cost in chosen.items():\n        if i + cost <= n and dp[i+cost] == \"ng\":\n            dp[i+cost] = num + dp[i]\n\n        elif i + cost <= n:\n            if len(dp[i+cost]) < len(dp[i]) + 1:\n                dp[i+cost] = num + dp[i]\n\n            elif len(dp[i+cost]) > len(dp[i]) + 1:\n                dp[i+cost] = dp[i+cost]\n\n            else:\n                dp[i+cost] = max(dp[i+cost],\n                                 \"\".join(sorted(num+dp[i])))\n\nprint(dp[n])\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1007,"bad_solution":"# -*- coding: utf-8 -*-\n\nimport os\nimport sys\n\ndef main():\n    n = int(input())\n    l1 = lis(n, 9)\n    l2 = lis(n, 6)\n    print(l1)\n    print(l2)\n    l1.extend(l2)\n    l1 = list(set(l1))\n    l1.sort(key=int, reverse=True)\n    print(minus(n, l1))\n\ndef lis(n, i):\n    count = 0\n    res = []\n    oi = i\n    while i < n:\n        res.append(i)\n        i = i * oi\n        count = count + 1\n    return res\n\ndef minus(n, l):\n    minus_count = 0\n    for i in l:\n        while n > i:\n            if n - i > 0:\n                n = n - i\n                minus_count = minus_count + 1\n            else:\n                break\n        print(i, n)\n    return minus_count, n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1008,"bad_solution":"from collections import deque\ndef solve():\n    H,W = map(int,input().split())\n    Ch,Cw = map(int,input().split())\n    Ch -= 1\n    Cw -= 1\n    Dh,Dw = map(int,input().split())\n    Dh -= 1\n    Dw -= 1\n\n    S = [list(input()) for _ in range(H)]\n    area_num = 0\n    for h in range(H):\n        for w in range(W):\n            if S[h][w] == '.':\n                dfs(h,w,H,W,S,area_num)\n                area_num += 1\n\n    start_area_num = int(S[Ch][Cw])\n    goal_area_num = int(S[Dh][Dw])\n\n    area_num_count = area_num + 1\n\n    G = [set() for _ in range(area_num_count)]\n\n    for h in range(H):\n        for w in range(W):\n            from_area_num = S[h][w]\n            if from_area_num == '#':\n                continue\n            from_area_num = int(from_area_num)\n\n            for dh in range(2+1):\n                if h+dh < 0 or h+dh >= H:\n                    continue\n                for dw in range(-2,2+1):\n                    if w+dw < 0 or w+dw >= W:\n                        continue\n                    to_area_num = S[h+dh][w+dw]\n                    if to_area_num == '#':\n                        continue\n                    to_area_num = int(to_area_num)\n                    if from_area_num != to_area_num:\n                        G[to_area_num].add(from_area_num)\n                        G[from_area_num].add(to_area_num)\n    \n    visited = [False] * area_num_count\n    q = deque()\n    q.append((start_area_num,0))\n    while len(q) > 0:\n        cur_area_num, warp_cnt = q.popleft()\n        if cur_area_num == goal_area_num:\n            print(warp_cnt)\n            return\n        \n        visited[cur_area_num] = True\n        for next_area_num in G[cur_area_num]:\n            if not visited[next_area_num]:\n                q.append((next_area_num,warp_cnt+1))\n    else:\n        print(-1)\n\ndef dfs(h,w,H,W,S,area_num):\n    if 0 <= h < H and 0 <= w < W and S[h][w] == '.':\n        S[h][w] = str(area_num)\n        dfs(h+1,w,H,W,S,area_num)\n        dfs(h,w+1,H,W,S,area_num)\n        dfs(h-1,w,H,W,S,area_num)\n        dfs(h,w-1,H,W,S,area_num)\n\ndef mod_graph(G,including_area_num_set):\n    for area_num_from in including_area_num_set:\n        for area_num_to in including_area_num_set:\n            G[area_num_from].add(area_num_to)\n\nif __name__ == '__main__':\n    solve()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1009,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\nimport itertools#これは色々使える組み込み関数みたいなやつ\nimport fractions\nimport copy\nimport bisect\nimport math\nimport numpy as np\n\n#import math#数学的計算はこれでいける。普通に0.5乗しても計算可能\n#w=input()\nfrom operator import itemgetter\nfrom sys import stdin\n#input = sys.stdin.readline#こっちの方が入力が早いが使える時に使っていこう\nfrom operator import mul\nfrom functools import reduce\nfrom collections import Counter\n#from collections import deque\n\n#input = stdin.readline\n\n\nN=3\nM=3\ni=0\nj=0\nk=0\nn=3\nr=1\na=[0]*5\nb=[]\n#n=int(input())\n#r=int(input())\n#print(M)\n#A=int(input())\n#B=int(input())\n#print(N)\npre=0\n\n\"1行1つの整数を入力を取得し、整数と取得する\"\nA,B,N=map(int, input().split(\" \"))\nsyo=len(str(N))\nif syo <10**4:\n for i in range(N+1):\n    k=(A*(i\/\/B))-A*(i\/\/B)\n    if pre > k :\n        print(pre)\n        sys.exit()\n    pre=k\n    b.append(k)\n    k=0\nfor i in range(N+1):\n        k=(A*(i+10**(syo-1))\/\/B)-A*((i+10**(syo-1))\/\/B)\n        #print(pre,k)\n        if pre > k:\n            print(pre)\n            sys.exit()\n        pre=k\n        b.append(k)\n        k=0\n\nprint(max(b))\n#number_list=list(map(int, input().split(\" \")))#数字の時\n#print(number_list)\n\"12 21 332 とか入力する時に使う\"\n\"1行に複数の整数の入力を取得し、整数として扱う\"\n\n'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n#メモ\nfor i in number_list:#こっちの方がrage使うより早いらしい\n    print(number_list[i-1])#\n\n'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''\n\n'''\nx=[]\ny=[]\nfor i in range(N):\n    x1, y1=[int(i) for i in input().split()]\n    x.append(x1)\n    y.append(y1)\nprint(x)\nprint(y)\n\"複数行に2数値を入力する形式 x座標とy座標を入力するイメージ\"\n'''\n\n'''\nmixlist=[]\nfor i in range(N):\n    a,b=input().split()\n    mixlist.append((int(a),b))\nprint(mixlist)\n\"複数行にintとstrを複合して入力するやつ，今回はリスト一つで処理している\"\n'''\n\n'''\n#array=[input().split()for i in range(N)]\n#print(type(array[0][0]))\n#print(array)\n\"正方行列にstr型の値を入力\"\n'''\n\n#brray=[list(map(int, input().split(\" \")))for i in range(N)]\n#print(type(brray[0][0]))\n#print(brray)\n'''\n入力\n1 2\n4 5\n7 8\n出力結果\n[[1, 2], [4, 5], [7, 8]]\n'''\n\"列数に関して自由度の高いint型の値を入力するタイプの行列\"\n#以下に別解を記載\n#N, M = [int(i) for i in input().split()]\n'''\ntable = [[int(i) for i in input().split()] for m in range(m)]\n\nprint(type(N))\nprint(N)\nprint(type(M))\nprint(M)\n\nprint(type(table))\nprint(table)\n'''\n\n\n\n\n#s=input()\n#a=[int(i) for i in s]\n#print(a[0])\n#print([a])\n#単数値．桁ごとに分割したい．入力と出力は以下の通り\n#イメージとして1桁ごとにリストに値を入れているかんじ\n#intを取ると文字列分解に使える\n'''\n入力\n1234\n出力\n1\n[[1, 2, 3, 4]]\n'''\n\n\n\n\n'''\nword_list= input().split(\" \")\nprint(word_list[0])\n\"連続文字列の入力\"\n\"qw er ty とかの入力に使う\"\n\"入力すると空白で区切ったところでlistの番号が与えられる\"\n'''\n\n\n\n'''\nA, B, C=stdin.readline().rstrip().split()#str style 何個でもいけることが多い\nprint(A)\n\"リストではなく独立したstr型を入れるなら以下のやり方でOK\"\n'''\n\n\n#a= stdin.readline().rstrip()\n#print(a.upper())\n\"aという変数に入っているものを大文字にして出力\"\n\n\n#a,b=map(int, input().split())  #int style 複数数値入力　「A B」みたいなスペース空いた入力のとき\n\n#なんかうまく入力されるけど\n#a=[[int(i) for i in 1.strip()]for 1 in sys.stdin]\n#a = [[int(c) for c in l.strip()] for l in sys.stdin]]\n#print(a)\n#複数行の数値を入力して正方行列を作成\n\n\n##############################################################################################\n##############################################################################################\n#under this line explains example calculation\n\n'''\nコンビネーションの組み合わせの中身を出力する形式\nfor i in itertools.combinations(brray, 2)\ncombinationsをpermutationsにすれば順列になる\n今回なら(abc133B)\n入力\n1 2\n5 5\n-2 8\n出力\n[[1, 2], [5, 5], [-2, 8]]\nもちろん一次元リストでも使えるし\n何よりiもリストのように使えるので便利\n'''\n\n#nCr combination\n'''\ndef cmb(n,r):\n    #When n < r , this function isn't valid\n    r= min(n-r,r)\n    #print(n,r)\n    if r == 0: return 1\n    over = reduce(mul, range(n, n-r, -1))\n    #flochart mul(n,n-1)=x\n    #next     mul(x,n-2)........(n-r+1,n-r)\n    #mul read a,b and returns a*b\n\n    under = reduce(mul, range(1, r+1))\n    #print(over, under)\n    #reduce is applied mul(1,2)=2\n    #next   mul(2,3)=6\n    #next   mul(6,4)=4.........last(r!,r+1)=r+1!\n\n    return over \/\/ under\n    #\/\/ is integer divide\n    #calc example 5C2\n    #over=5*4*3\n    #under=3*2*1\na = cmb(n, r)\n#print(a)\n'''\n\n'''\n#集計\n#example\n#a=[2,2,2,3,4,3,1,2,1,3,1,2,1,2,2,1,2,1]\n#a=Counter(a)\nfor i in a.most_common(n):print(i)\n#most_common()メソッドは、出現回数が多い要素順にCounterオブジェクトを並び替えます。\n#引数にint型の数字nを設定した場合は、出現回数が高い上位ｎ個の要素を返します。\n#何も設定しなければ、コンテナ型にあるすべての要素を出現回数の順番に並び替えたタプル型オブジェクトを返します。\n#out put\n#(2, 8)\n #(1, 6)\n#(3, 3)\n#(4, 1)\n'''\n\n\n#二部探索(binary search)\n#A = [1, 2, 3, 3, 3, 4, 4, 6, 6, 6, 6]\n#print(A)\n#index = bisect.bisect_left(A, 5) # 7 最も左(前)の挿入箇所が返ってきている\n#A.insert(index, 5)\n#print(index)\n#print(A)\n'''\nbisect.bisect_left(a, x, lo=0, h=len(a))\n引数\na: ソート済みリスト\nx: 挿入したい値\nlo: 探索範囲の下限\nhi: 探索範囲の上限\n(lo, hiはスライスと同様の指定方法)\nbisect_leftはソートされたリストaに対して順序を保ったままxを挿入できる箇所を探索します。leftが示す通り、aにすでにxが存在している場合は、挿入箇所は既存のxよりも左側になります。また、lo, hiを指定することで探索範囲を絞り込むことも可能です。デフォルトはaの全体が探索対象です。\n'''\n\n\n\n\n\n########################################################################\n########################################################################\n#b2=a[:]  #1次元のときはコピーはこれで良い\n#print(b2)\n\n#a= [[0]*3 for i in range(5)] #2次元配列はこう準備、[[0]*3]*5だとだめ\n#b3=copy.deepcopy(a)  #2次元配列はこうコピーする\n#print(b3)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1010,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**10\nmod = 998244353\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\ndef inv(x):\n    return pow(x, mod - 2, mod)\n\nnm = {}\ndef nCr(n, b):\n    if b > n - b:\n        b = n - b\n    if b in nm:\n        return nm[b]\n    r = 1\n    for k in range(n, n-b, -1):\n        r = r * k % mod\n    d = 1\n    for k in range(1, b+1):\n        d = d * k % mod\n    nm[b] = r * inv(d) % mod\n    return nm[b]\n\ndef main():\n    n,a,b,k = LI()\n    r = 0\n    for i in range(n+1):\n        ai = a * i\n        bi = k - ai\n        if bi < 0 or bi % b > 0 or bi \/\/ b > n:\n            continue\n        bb = bi \/\/ b\n        r += nCr(n,i) * nCr(n,bb)\n        r %= mod\n\n    return r\n\n\nprint(main())\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1011,"bad_solution":"# coding: utf-8\n# hello worldと表示する\n#float型を許すな\n#numpyはpythonで\nimport sys\ninput = sys.stdin.readline\nsys.setrecursionlimit(10**7)\nfrom collections import Counter, deque\nfrom collections import defaultdict\nfrom itertools import combinations, permutations, accumulate, groupby, product\nfrom bisect import bisect_left,bisect_right\nfrom heapq import heapify, heappop, heappush\nfrom math import floor, ceil,pi,factorial,sqrt\nfrom operator import itemgetter\ndef I(): return int(input())\ndef MI(): return map(int, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI2(): return [int(input()) for i in range(n)]\ndef MXI(): return [[LI()]for i in range(n)]\ndef SI(): return input().rstrip()\ndef printns(x): print('\\n'.join(x))\ndef printni(x): print('\\n'.join(list(map(str,x))))\ninf = 10**17\nmod = 10**9 + 7\n\ndef ceiler(a,b):\n    return -((-a)\/\/b)\nn,k=MI()\ncosts=LI()\ndifs=LI()\ncosts.sort()\ndifs.sort(reverse=True)\nlis=[0 for i in range(n)]\n#print(costs)\n#print(difs)\nfor i in range(n):\n    lis[i]=costs[i]*difs[i]\n#print(lis)\ndef judge(x):\n    times=0\n    for i in range(n):\n        u=ceiler(lis[i]-x,difs[i])\n        times+=max(0,u)\n        #print(u)\n    #print(x,times<=k)\n    return times<=k\nl,r=-1,10**13\nwhile l+1<r:\n    mid=(l+r)\/\/2\n    if judge(mid):\n        r=mid\n    else:\n        l=mid\nprint(r)\n    \n    \n\n    \n\n\n    \n \n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1012,"bad_solution":"from queue import PriorityQueue\n\n\nIA = lambda: [int(x) for x in input().split()]\nIM = lambda N: [IA() for _ in range(N)]\n#!\/usr\/bin\/env python3\n# -*- coding: utf-8 -*-\nans=1\nMOD = 1000000007\n\ndef dfs(u,fa,k):\n    global ans\n    global MOD\n    vis[u]=1\n    i=0\n    for  v in a[u]:\n        if(vis[v]==1):continue\n        ans=(ans%MOD*(k-i)%MOD)%MOD\n        dfs(v,u,k-2)\n        i+=1\n\n\nIA = lambda: [int(x) for x in input().split()]\nIM = lambda N: [IA() for _ in range(N)]\n\nn,m = IA()\n\na=[[] for i in range(0,n+1)]\nvis=[int(0) for i in range(0,n+1)]\n\nfor i in range(0,n-1):\n     u,v=IA()\n     a[u].append(v)\n     a[v].append(u)\n\ndfs(1,0,m)\nprint(ans)\n\n\n\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1013,"bad_solution":"import sys\ninput = sys.stdin.readline\nimport numpy as np\nN, M = [int(x) for x in input().split()]\nA = [int(x) for x in input().split()]\nA = np.sort(np.array(A))\ndef shake_hands(x):\n    cnt = 0\n    X = np.searchsorted(A, x - A, side=\"left\")\n    cnt += N * N - X.sum()\n    if cnt >= M:\n        return 1\n    return 0\nleft = 2\nright = 10 ** 6\nwhile True:\n    m = (right + left) \/\/ 2\n    if shake_hands(m) == 1 and shake_hands(m+1) == 0:\n        maximum = m\n        break\n    elif shake_hands(m) == 0 and shake_hands(m-1) == 1:\n        maximum = m - 1\n        break\n    elif shake_hands(m) == 1:\n        left = m + 1\n    else:\n        right = m - 1\nA_cumsum = np.array(np.cumsum(A))\nans = 0\ncnt = 0\na = np.searchsorted(A, (maximum + 1) - A, side=\"left\")\nX = np.searchsorted(A,right-A)\nAcum = np.zeros(N+1,np.int64)\nAcum[1:] = np.cumsum(A)\na = N * N - X.sum()\nans = (Acum[-1] - Acum[X]).sum() + (A * (N - X)).sum()\nans += (M - a) * maximum\nprint(ans)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1014,"bad_solution":"from math import ceil,floor,factorial,gcd,sqrt,log2,cos,sin,tan,acos,asin,atan,degrees,radians,pi,inf,comb\nfrom itertools import accumulate,groupby,permutations,combinations,product,combinations_with_replacement\nfrom collections import deque,defaultdict,Counter\nfrom bisect import bisect_left,bisect_right\nfrom operator import itemgetter\nfrom heapq import heapify,heappop,heappush\nfrom queue import Queue,LifoQueue,PriorityQueue\nfrom copy import deepcopy\nfrom time import time\nfrom functools import reduce\nimport string\nimport sys\nsys.setrecursionlimit(10 ** 7)\ndef input() : return sys.stdin.readline().strip()\ndef INT()   : return int(input())\ndef MAP()   : return map(int,input().split())\ndef LIST()  : return list(MAP())\n\nk = INT()\nx = 0\nfor i in range(10**4):\n    x = ( x + 7*10**i ) % k\n    if x % k == 0:\n        print(i+1)\n        exit()\nif k % 2 != 0 and k % 5 != 0:\n    if k % 7 == 0:\n        print(k\/\/7-1)\n    else:\n        print(k-1)\nelse:\n    print(-1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1015,"bad_solution":"def main():\n    N = int(input())\n    S = input()\n\n    ans = 0\n    ruiseki_r = [0]*N\n    ruiseki_g = [0]*N\n    ruiseki_b = [0]*N\n\n    for i in range(N):\n        if S[i] == \"R\":\n            ruiseki_r[i] = ruiseki_r[i-1] + 1\n            ruiseki_g[i] = ruiseki_g[i-1]\n            ruiseki_b[i] = ruiseki_b[i-1]\n        if S[i] == \"G\":\n            ruiseki_r[i] = ruiseki_r[i-1]\n            ruiseki_g[i] = ruiseki_g[i-1] + 1\n            ruiseki_b[i] = ruiseki_b[i-1]\n        if S[i] == \"B\":\n            ruiseki_r[i] = ruiseki_r[i-1]\n            ruiseki_g[i] = ruiseki_g[i-1]\n            ruiseki_b[i] = ruiseki_b[i-1] + 1\n\n    for i in range(N-2):\n        Si = S[i]\n        for j in range(i+1, N):\n            Sj = S[j]\n            if Si != Sj:\n                if len(set([Si, Sj])^set([\"R\", \"G\"])) == 0:\n                    remain_b = ruiseki_b[-1] - ruiseki_b[j]\n                    if 2*j-i < N:\n                        if S[2*j-i] == \"B\":\n                            remain_b -= 1\n                    ans = ans + remain_b\n                if len(set([Si, Sj])^set([\"G\", \"B\"])) == 0:\n                    remain_r = ruiseki_r[-1] - ruiseki_r[j]\n                    if 2*j-i < N:\n                        if S[2*j-i] == \"R\":\n                            remain_r -= 1\n                    ans = ans + remain_r\n                if len(set([Si, Sj])^set([\"R\", \"B\"])) == 0:\n                    remain_g = ruiseki_g[-1] - ruiseki_g[j]\n                    if 2*j-i < N:\n                        if S[2*j-i] == \"G\":\n                            remain_g -= 1\n                    ans = ans + remain_g\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1016,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\nimport copy\n\n# sys.setrecursionlimit(100000)\ninput = sys.stdin.buffer.readline\nINF = 2**62-1\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(N, M, S, UVAB, CD):\n    g = defaultdict(dict)\n    V = {}\n    MA = 0\n    for u, v, a, b in UVAB:\n        g[u][v] = (a, b)\n        g[v][u] = (a, b)\n        MA += a\n\n    for i, (c, d) in enumerate(CD, 1):\n        V[i] = (c, d)\n\n    stack = [0]\n    d = defaultdict(lambda: INF)\n\n\n    def f(u, m, s):\n        q = []\n        c, d = V[u]\n        for i in range(1, 100000):\n            nc = s+i*c\n            if nc > MA:\n                q.append((m+i*d, (u, MA)))\n                break\n            else:\n                q.append((m+i*d, (u, nc)))\n        return q\n\n    S = min(S, MA)\n    q = [(0, (1, S))]\n    heapq.heapify(q)\n    done = set()\n    d = defaultdict(lambda : INF)\n    d[(1, S)] = 0\n    while q:\n        m, u = heapq.heappop(q)\n        for v in g[u[0]]:\n            na, nb = g[u[0]][v]\n            if na <= u[1]:\n                alt = nb + d[u]\n                vv = (v, u[1]-na)\n                if d[vv] > alt:\n                    d[vv] = alt\n                    heapq.heappush(q, (alt, vv))\n        for qq in f(u[0], m, u[1]):\n            if qq[1] not in d:\n                d[qq[1]] = qq[0]\n                heapq.heappush(q, qq)\n\n    ans = [INF] * (N+1)\n    for k, v in d.items():\n        u = k[0]\n        ans[u] = min(ans[u], v)\n\n    for i in range(2, N+1):\n        print(ans[i])\n\n\n\ndef main():\n    N, M, S = read_int_n()\n    UVAB = [read_int_n() for _ in range(M)]\n    CD = [read_int_n() for _ in range(N)]\n    (slv(N, M, S, UVAB, CD))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1017,"bad_solution":"l=lambda:[int(x) for x in input().split()]\nH,W=l()\nCH,CW=l()\nDH,DW=l()\nS=[[x=='#' for x in list(input())] for _ in range(H)]\nd={(CH-1,CW-1):0}\nq=[(CH-1,CW-1,0)]\ndef check(h,w,c,o):\n    if h < 0 or h >= H or w < 0 or w >= W:\n        return False\n    key=(h,w)\n    if key in d:\n        return False\n        #if d[key] <= c:\n        #    return False\n    if S[h][w]:\n        return False\n    if o:\n        q.append((h,w,c))\n    else:\n        q.insert(0,(h,w,c+1))\n    d[key]=c\n    return True\nwhile q:\n    h,w,c=q.pop()\n    # walk\n    check(h-1,w-0,c,True)\n    check(h-0,w-1,c,True)\n    check(h+1,w+0,c,True)\n    check(h+0,w+1,c,True)\n    # warp\n    check(h-1,w-1,c,False)\n    check(h+1,w+1,c,False)\n    for i in [-2,+2]:\n        for j in range(-2,3):\n            check(h+i,w+j,c,False)\n            check(h+i,w+j,c,False)\nkey=(DH-1,DW-1)\nif key in d:\n    print(d[key])\nelse:\n    print(-1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1018,"bad_solution":"def main():\n    N, K = map(int, input().split())\n\n    A    = [int(i)-1 for i in input().split()]\n    visit_plan = [0]\n    vpi        = 0\n    loop_flg     = False\n    B    = set(visit_plan)\n    for i in range(N-1):\n        a = A[vpi]\n        if a in B:\n            loop_flg = True\n            break\n        else:\n            visit_plan.append(a)\n            B.add(a)\n            vpi = a\n\n\n    if loop_flg:\n        loop_start = visit_plan.index(a)\n        loop_end   = len(visit_plan)\n        loop_length = loop_end - loop_start\n        last_index = (K-loop_start)%loop_length\n        current_town = visit_plan[loop_start+last_index]\n    else:\n        current_town = a\n    print(current_town+1)\n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1019,"bad_solution":"from collections import deque\nH,W = map(int,input().split())\nCH,CW = map(int,input().split())\nDH,DW = map(int,input().split())\nmaze = [list(input()) for _ in range(H)]\n\ndef BFS(maze,s,g):\n  q = deque([s])\n  checked = []\n  while q:\n    h,w,n = q.popleft()\n    if (h,w)==g: return n\n    dp = [(i-2,j-2) for i in range(5) for j in range(5) if (i-2,j-2)!=(0,0)]\n    for i in dp:\n      if (h+i[0],w+i[1]) in checked: continue\n      else: checked.append((h+i[0],w+i[1]))\n\n      if (0<h+i[0]<len(maze)) and (0<w+i[1]<len(maze[0])):\n        if maze[h+i[0]][w+i[1]]==\".\":\n          if i[0]%2==0 or i[1]%2==0:\n            q.append((h+i[0],w+i[1],n+1))\n          else:\n            q.appendleft((h+i[0],w+i[1],n))\n  return -1\n\nprint(BFS(maze,(CH-1,CW-1,0),(DH-1,DW-1)))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1020,"bad_solution":"# 解説 AC\n\n# 参考1: https:\/\/twitter.com\/rickytheta\/status\/1175412019006074880\n# 参考2: https:\/\/maspypy.com\/atcoder-%E5%8F%82%E5%8A%A0%E6%84%9F%E6%83%B3-2019-09-21agc-038\n\nmod = 998244353\nmax_A = 10**6\nN = int(input())\nA = list(map(int, input().split()))\n\n# nまでの自然数が素数かどうかを表すリストを返す  O(nloglogn)\ndef make_prime_checker(n):\n    is_prime = [True] * (n+1)\n    is_prime[0] = False\n    is_prime[1] = False\n    for i in range(2, int(n**0.5)+1):\n        if is_prime[i]:\n            for j in range(i*i, n+1, i):\n                is_prime[j] = False\n    return is_prime\n\nprimes = [p for p, is_prime in enumerate(make_prime_checker(max_A)) if is_prime]  # max_A 以下の素数のリスト\n\ng = [0] * (max_A+1)\nfor a in A:\n    g[a] += a\nfor p in primes:\n    # 倍数集合の高速ゼータ変換みたいなやつ  O((max_A)loglog(max_A))\n    # 参考: http:\/\/noshi91.hatenablog.com\/entry\/2018\/12\/27\/121649\n    # 大量に約数列挙みたいなことをするときはこれで高速化できる場合が多そう？（みんぷろ 2018 本戦 A - Uncommon など）\n    for k in range(max_A\/\/p, 0, -1):\n        g[k] += g[k*p]\n\n# この時点で g[d] = Σ_{d|a} a  (A の要素のうち d の倍数であるものの総和)\n\ng = [v * v % mod for v in g]\n\n# この時点で\n# g[d] = (Σ_{d|a} a)(Σ_{d|b} b)\n#      = Σ_{(d|a)∧(d|b)} ab\n#      = Σ_{d | gcd(a,b)} ab\n\n# この式変形天才すぎないか？（これを使った一連の操作を gcd 畳み込み というらしい？）\n\nfor p in primes:\n    # 倍数集合の高速メビウス変換みたいなやつ  O((max_A)loglog(max_A))\n    for k in range(1, max_A\/\/p+1):\n        g[k] -= g[k*p]  # 包除原理ヤバい\n\n# この時点で g[d] = Σ_{gcd(a,b)=d} ab\n\ndef make_modinv_list(n, mod=10**9+7):\n    # 0 から n までの mod 逆元のリストを返す O(n)\n    modinv = [0] * (n+1)\n    modinv[1] = 1\n    for i in range(2, n+1):\n        modinv[i] = mod - mod \/\/ i * modinv[mod%i] % mod\n    return modinv\n\nmodinv_list = make_modinv_list(max_A, mod)\nans = sum(gg * minv % mod for gg, minv in zip(g, modinv_list))\nans %= mod\n\n# この時点で\n# ans = Σ_d ( Σ_{gcd(a,b)=d} ab\/d )\n#     = Σ_d ( Σ_{gcd(a,b)=d} lcm(a,b) )\n#     = Σ_a Σ_b lcm(a,b)\n\nans -= sum(A)\nans *= modinv_list[2]\nans %= mod\n\n# この時点で ans = Σ_{i<j} lcm(a,b)\n\nprint(ans)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1021,"bad_solution":"import sys\ndef input(): return sys.stdin.readline().rstrip()\ndef ctoi(c):\n    return ord(c)-97\nclass BIT:\n    def __init__(self, n):\n        self.unit_sum=0 # to be set\n        self.n=n\n        self.dat=[0]*(n+1)#[1,n]\n    def add(self,a,x): #a(1-)\n        i=a\n        while i<=self.n:\n            self.dat[i]+=x\n            i+=i&-i\n    def sum(self,a,b=None): \n        if b!=None:\n            return self.sum(b-1)-self.sum(a-1) #[a,b) a(1-),b(1-)\n        res=self.unit_sum\n        i=a\n        while i>0:\n            res+=self.dat[i]\n            i-=i&-i\n        return res  #Σ[1,a] a(1-)   \n    def __str__(self):\n        self.ans=[]\n        for i in range(1,self.n):\n            self.ans.append(self.sum(i,i+1))\n        return ' '.join(map(str,self.ans))\n\ndef main():\n    n=int(input())\n    S=list(input())\n    q=int(input())\n    BIT_tree=[]\n    for i in range(26):\n        obj=BIT(n+1)\n        BIT_tree.append(obj)\n    for i in range(n):\n        BIT_tree[ctoi(S[i])].add(i+1,1)\n    for _ in range(q):\n        query=input().split()\n        if query[0]==\"1\":\n            index,x=int(query[1])-1,query[2]\n            BIT_tree[ctoi(S[index])].add(index+1,-1)\n            BIT_tree[ctoi(x)].add(index+1,1)\n            S[index]=x\n        else:\n            l,r=int(query[1])-1,int(query[2])-1\n            ans=0\n            for c in range(26):\n                if BIT_tree[c].sum(l+1,r+2):\n                    ans+=1\n            print(ans)\n\nif __name__=='__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1022,"bad_solution":"import math,string,itertools,fractions,heapq,collections,re,array,bisect,sys,random,time,copy,functools\n\nsys.setrecursionlimit(10**7)\ninf = 10**20\neps = 1.0 \/ 10**15\nmod = 10**9+7\n\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef LI_(): return [int(x)-1 for x in sys.stdin.readline().split()]\ndef LF(): return [float(x) for x in sys.stdin.readline().split()]\ndef LS(): return sys.stdin.readline().split()\ndef I(): return int(sys.stdin.readline())\ndef F(): return float(sys.stdin.readline())\ndef S(): return input()\ndef pf(s): return print(s, flush=True)\n\n\ndef main():\n    n = I()\n    a = LI()\n    if a[-1] != 2:\n        return -1\n    b = 2\n    c = 4\n    for i in range(n-2,-1,-1):\n        t = a[i]\n        if b * 2 <= t:\n            return -1\n        if b % t == 0:\n            pass\n        elif b > t:\n            b += t-b%t\n            if b % t != 0:\n                return 1\/0\n        else:\n            b = t\n        if c % t == 0:\n            pass\n        elif c > t:\n            c += t-c%t\n        else:\n            return -1\n    bb = b\n    cc = c-1\n    while True:\n        bb = b\n        for i in range(n):\n            bb -= bb%a[i]\n        if bb != 2:\n            return -2\n            b += a[0]\n        else:\n            break\n    for i in range(n):\n        cc -= cc%a[i]\n    if cc != 2:\n        return 1\/0\n\n    return '{} {}'.format(b, c-1)\n\nprint(main())\n\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1023,"bad_solution":"import sys\nstdin = sys.stdin\nsys.setrecursionlimit(10**6)\nni = lambda: int(ns())\nna = lambda: list(map(int, stdin.readline().split()))\nnn = lambda: list(stdin.readline().split())\nns = lambda: stdin.readline().rstrip()\n\ndef make_divisors(n):\n    res = []\n    x = n\n    y = 2\n    while y*y <= x:\n        while x % y == 0:\n            res.append(y)\n            x \/\/= y\n        y += 1\n    if x > 1:\n        res.append(x)\n    return res\n\nn = ni()\na = na()\n\nwa = set(make_divisors(a[0]))\ns = len(wa)\nseki = wa\n\nfor i in range(1,n):\n    ii = set(make_divisors(a[i]))\n    s += len(ii)\n    wa = wa | ii\n    seki = seki & ii\n    if s != len(wa) and len(seki) == 0:\n        print('setwise coprime')\n        exit()\n\nif len(wa) == s:\n    print('pairwise coprime')\nelif len(seki) == 0:\n    print('setwise coprime')\nelse:\n    print('not coprime')\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1024,"bad_solution":"import sys\n\ninput = sys.stdin.readline\n\nh, w, k = map(int, input().split())\ns = [input() for _ in range(h)]\n\ncs = [[0] * (w + 1) for _ in range(h + 1)]\nfor i in range(h):\n    for j in range(w):\n        cs[i + 1][j +\n                  1] = cs[i][j + 1] + cs[i + 1][j] - cs[i][j] + int(s[i][j])\n\n\ndef f(i1, j1, i2, j2):\n    return cs[i1][j1] - cs[i1][j2] - cs[i2][j1] + cs[i2][j2]\n\n\nans = h + w\nfor bit in range(1 << (h - 1)):\n    border = [0]\n    cand = 0\n    for i in range(h):\n        if (bit >> i) & 1:\n            border.append(i + 1)\n            cand += 1\n    border.append(h)\n\n    j0 = 0\n    # cut = []\n    for j in range(w):\n        for i, bi in enumerate(border[:-1]):\n            if f(border[i + 1], j, bi, j0) <= k and \\\n               f(border[i + 1], j + 1, bi, j0) > k:\n                cand += 1\n                j0 = j\n                # cut.append(j)\n\n    # print(border, cand, cut)\n    if f(border[-1], w, border[-2], j0) <= k:\n        ans = min(ans, cand)\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1025,"bad_solution":"import sys\ninput = sys.stdin.readline\nfrom collections import *\n\nclass BIT:\n    def __init__(self, n):\n        self.n = n\n        self.bit = [0]*(n+1)\n    \n    def add(self, i, x):\n        i += 1\n        \n        while i<=self.n:\n            self.bit[i] += x\n            i += i&(-i)\n\n    def acc(self, i):\n        s = 0\n        \n        while i>0:\n            s += self.bit[i]\n            i -= i&(-i)\n        \n        return s\n\nN, Q = map(int, input().split())\nc = list(map(int, input().split()))\nprev = [-1]*N\nys = defaultdict(list)\n\nfor i in range(N):\n    if prev[c[i]-1]!=-1:\n        ys[prev[c[i]-1]].append(i)\n    \n    prev[c[i]-1] = i\n\nque = defaultdict(list)\n\nfor i in range(Q):\n    l, r = map(int, input().split())\n    que[l-1].append((i, r-1))\n    \nidx = 0\nbit = BIT(N)\nans = [-1]*N\n\nfor x in range(N-1, -1, -1):\n    for y in ys[x]:\n        bit.add(y, 1)\n    \n    for i, r in que[x]:\n        ans[i] = r-x+1-bit.acc(r+1)\n\nfor ans_i in ans:\n    print(ans_i)\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1026,"bad_solution":"n=int(input())\nl=[[] for i in range(n+1)]\nfor i in range(1,1+n):\n  l1=list(input())\n  for j in range(1,1+n):\n    if l1[j-1]==\"1\":\n      l[i].append(j)\ncolor=[0 for i in range(n+1)]\nb=True\ndef f(v,c):\n    #頂点vに隣接する頂点全てを塗るあるいは判定する\n    color[v] = c\n    for i in range(len(l[v])):\n        if color[ l[v][i] ] == c:\n            return False\n        elif color[ l[v][i] ] == 0 and not f(l[v][i],-c):\n            #(g[v][i]がまだ塗られていない　かつ　そこを-cで塗っても問題ない) ではないなら\n            return False\n    return True\nb=f(1,1)\nif not b:\n  print(-1)\nelse:\n  inf=10**10\n  d=[[inf for i in range(n+1)] for j in range(n+1)]\n  for i in range(n+1):\n    for j in l[i]:\n      d[i][j]=1\n  for k in range(n+1):\n    for j in range(1,n+1):\n      for i in range(1,n+1):\n        d[i][j]=min(d[i][j],d[i][k]+d[k][j])\n  max=0\n  for i in range(1,n+1):\n    for j in range(1,n+1):\n      if d[i][j]>max:\n        max=d[i][j]\n  print(max+1)\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1027,"bad_solution":"h, w = map(int, input().split())\nS = [list(input()) for _ in range(h)]\ndef t(s):\n  return [[s[i][j] for i in range(len(s))] for j in range(len(s[0]))]\ndef calc(s):\n  res = []\n  for v in s:\n    v.append('-')\n    tmp = []\n    nc = ''\n    nn = 0\n    for c in v:\n      if nc == '':\n        nc = c\n        nn += 1\n        continue\n      if nc == c:\n        nn += 1\n        continue\n      else:\n        if nc == '#':\n          tmp = tmp + [0 for _ in range(nn)]\n        else:\n          tmp = tmp + [nn for _ in range(nn)]\n        nc = c\n        nn = 1\n    res.append(tmp)\n  return res\n\ntate = t(calc(t(S)))\nyoko = calc(S)\nprint(max([tate[i][j] + yoko[i][j] for i in range(h) for j in range(w) if tate[i][j] * yoko[i][j] != 0])-1)\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1028,"bad_solution":"import bisect\n\nf_inf = float('inf')\n\n\ndef cal(syurui, d, index):\n    if d == 'e':\n        return syurui[index]\n    elif d == 'w':\n        return syurui[index - 1]\n\n\nA, B, Q = map(int, input().split())\ns = [int(input()) for i in range(A)]\ns.sort()\nt = [int(input()) for i in range(B)]\nt.sort()\n\nfor i in range(Q):\n    x = int(input())\n    s_index = bisect.bisect_left(s, x)\n    t_index = bisect.bisect_left(t, x)\n    if s_index == len(s) and t_index == len(t):\n        print(max(abs(x-s[s_index-1]), abs(x-t[t_index-1])))\n    elif s_index == len(s):\n        ｓ.insert(0, -f_inf)\n        t.insert(0, -f_inf)\n        print(min(max(abs(x-s[s_index]), abs(x-t[t_index])),\n                  2*abs(x-s[s_index])+abs(x-t[t_index+1]), abs(x-s[s_index])+2*abs(x-t[t_index+1])))\n    elif t_index == len(t):\n        ｓ.insert(0, -f_inf)\n        t.insert(0, -f_inf)\n        print(min(max(abs(x-s[s_index]), abs(x-t[t_index])), 2*abs(x-s[s_index+1])+abs(x-t[t_index]),\n                  abs(x-s[s_index+1])+2*abs(x-t[t_index])))\n    else:\n        ｓ.insert(0, -f_inf)\n        t.insert(0, -f_inf)\n        print(min(max(abs(x-s[s_index]), abs(x-t[t_index])), max(\n            abs(x-s[s_index+1]), abs(x-t[t_index+1])), 2*abs(x-s[s_index+1])+abs(x-t[t_index]), 2*abs(x-s[s_index])+abs(x-t[t_index+1]), abs(x-s[s_index+1])+2*abs(x-t[t_index]), abs(x-s[s_index])+2*abs(x-t[t_index+1])))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1029,"bad_solution":"n = int(input())\nv = list(map(int,input().split()))\neven = []\nodd = []\n\nfor i in range(n):\n\tif i % 2 == 0:\n\t\teven.append(v[i])\n\telse:\n\t\todd.append(v[i])\n\nodd.sort()\neven.sort()\n\ndef min(a,b):\n\tif a <= b:\n\t\treturn a\n\telse:\n\t\treturn b\n\ndef solve(tag):\n\tl = len(tag)\n\tbef = 0\n\tcounter = 1\n\tmax1,value1,max2,value2 = 0,0,0,0\n\tfor i in range(l):\n\t\tif bef == tag[i]:\n\t\t\tcounter = counter + 1\n\t\telse:\n\t\t\tif(max1 <= counter and value1 != bef):\n\t\t\t\tmax2 = max1\n\t\t\t\tvalue2 = value1\n\t\t\t\tmax1 = counter\n\t\t\t\tvalue1 = bef\n\t\t\tcounter = 1\n\t\tbef = tag[i]\n\tif(max1 <= counter and value1 != bef):\n\t\tmax2 = max1\n\t\tvalue2 = value1\n\t\tmax1 = counter\n\t\tvalue1 = bef\n\tlis = [max1,value1,max2,value2]\n\treturn [max1,value1,max2,value2]\n\nres = len(v)\nodr = solve(odd)\nevr = solve(even)\n\nif(odr[1] != evr[1]):\n\tprint(n - odr[0] - evr[0])\nelse:\n\tprint(min(n-odr[0]-evr[2],n-odr[2]-evr[0]))\n\n# max1 value1 max2 value2\n# それぞれのvalue1が異なるなら引けばいい\n# 同じならmax2を比較して大きい方を適用する。\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1030,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import (combinations, combinations_with_replacement, chain,\n                       permutations, product)\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(10**5)\nMAX_INT = 2**62-1\n\ninput = sys.stdin.readline\n\ndef n_input():\n    return input().split()\n\n\nclass ModOperation:\n\n    def __init__(self, m):\n        self.m = m\n\n    def add(self, a, b):\n        return (a + b) % self.m\n\n    def sub(self, a, b):\n        return (a - b) % self.m\n\n    def mul(self, a, b):\n        return ((a % self.m) * (b % self.m)) % self.m\n\n    def div(self, a, b):\n        return self.mul(a, pow(b, self.m-2, self.m))\n\n\nMOD = 10**9 + 7\nmod = ModOperation(MOD)\n\nfact = [1] * (2 * (10**5) + 1)\n# fact_inv = [0] * (2 * (10**5) + 1)\n\nfor i in range(1, 2 * (10**5)+1):\n    fact[i] = mod.mul(fact[i-1], i)\n    # fact_inv[i] = pow(fact[i], MOD-2, MOD)\n\n\ndef solve(g):\n    def dfs(pre, cur):\n        if (pre, cur) in memo:\n            return memo[pre, cur]\n\n        num, ways = 1, 1\n\n        for nxt in g[cur]:\n            if nxt == pre:\n                continue\n            n, w = dfs(cur, nxt)\n            num += n\n            ways = m.mul(ways, m.div(w, f[n]))\n\n        ways = m.mul(ways, f[num-1])\n        memo[pre, cur] = num, ways\n        return num, ways\n\n    m, f = mod, fact\n    memo = {}\n\n    for i in range(1, len(g)):\n        print(dfs(None, i)[1])\n\n    # print(memo)\n\ndef main():\n    n = int(input())\n    g = [[] for _ in range(n+1)]\n\n    for _ in range(n-1):\n        a, b = map(int, n_input())\n        g[a].append(b)\n        g[b].append(a)\n\n    solve(g)\n\nif __name__ == \"__main__\":\n\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1031,"bad_solution":"import sys\nfrom collections import defaultdict\nfrom collections import deque\n\nread = sys.stdin.read\nreadline = sys.stdin.readline\nreadlines = sys.stdin.readlines\n\nN, M, V, P = map(int, input().split())\n\nA = list(map(int, input().split()))\nA.sort(reverse=True)\n\nNUM = [0] * N\nACN = [0] * N\ncnt = 0\nmx = A[0]\n\n# cnt and accumulation\nfor a in A:\n    d = mx - a\n    cnt += 1\n    NUM[d] += 1\n    ACN[d] = cnt\n\n# P Number Problem\nPROBLEM_P = 0\np = P\nfor i in range(0, A[0]+1):\n    if NUM[i] == 0:\n        continue\n\n    p -= NUM[i]\n\n    if p < 0:\n        PROBLEM_P = i\n        break\n\n    if i == (A[0]+1) and p > 0:\n        print(N)\n        exit()\n\n#print(\"NUM\", NUM)\n#print(\"PROBLEM_P\", PROBLEM_P)\n\n# R Number Problem\nR = PROBLEM_P + M\n\n# P-1 Problem\nans = 0\nNG_POINT = (P-1) * M\nNG_POINT += (N - ACN[R]) * M\nMV = M * V\n\n# p problem num\nnum_p = ACN[PROBLEM_P] - P\n\nprint(1)\nexit()\n\nfor r in range(R, -1, -1):\n    need_point = M\n    total = (need_point * NUM[r]) + NG_POINT\n\n    for q in range(r-1, PROBLEM_P, -1):\n        if NUM[q] == 0:\n            continue\n        total += NUM[q] * (q - r + M)\n\n    total += num_p * (PROBLEM_P - r + M)\n\n    if total >= MV:\n        ans = r\n        break\n    else:\n        NG_POINT += NUM[r] * M\n\nprint(ACN[ans])\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1032,"bad_solution":"import sys\nfrom collections import deque\n\ninput = sys.stdin.readline\n\n\ndef bfs(H, W, dist, black_induces):\n    queue = deque(black_induces)\n    while queue:\n        h, w = queue.popleft()\n        for y, x in [(0, -1), (0, 1), (-1, 0), (1, 0)]:\n            hh, ww = h + y, w + x\n            if not (0 <= hh < H and 0 <= ww < W):\n                continue\n            if dist[hh][ww] == -1:\n                dist[hh][ww] = dist[h][w] + 1\n                queue.append((hh, ww))\n\n\ndef main():\n    H, W = map(int, input().split())\n    dist = [[] for _ in range(H)]\n    black_induces = []\n    for i in range(H):\n        A = input().rstrip()\n        for j, s in enumerate(A):\n            if s == \"#\":\n                dist[i].append(0)\n                black_induces.append((i, j))\n            else:\n                dist[i].append(-1)\n\n    bfs(H, W, dist, black_induces)\n\n    ans = max(max(d) for d in dist)\n    print(ans)\n\n\nif __name__ == \"__main__\":\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1033,"bad_solution":"import heapq\nimport sys\n\n\ndef input(): return sys.stdin.readline().rstrip()\n\n\nH, W = map(int, input().split())\nch, cw = map(int, input().split())\ndh, dw = map(int, input().split())\ndata = [[0]*W for i in range(H)]\n\nfor i in range(H):\n    S = input()\n    for j in range(W):\n        if S[j] == \".\":\n            data[i][j] = 1\n        else:\n            data[i][j] = 0\n\n\ndef trans(h, w):\n    return W*(h) + w\n\n\nP = [(0, -1), (0, 1), (1, 0), (-1, 0)]\nDXY = [(i, j) for i in range(-2, 3) for j in range(-2, 3)]\nG = [[] for i in range(H*W)]\nH_L = [i for i in range(H)]\nW_L = [i for i in range(W)]\nfor i in H_L:\n    for j in W_L:\n        if data[i][j] == 1:\n            for dx, dy in P:\n                if 0 <= dx+i < H:\n                    if 0 <= dy+j < W:\n                        if data[dx+i][dy+j] == 1:\n                            u, v = trans(i, j), trans(dx+i, dy+j)\n                            G[u].append((v, 0))\n                            G[v].append((u, 0))\n            for dx, dy in DXY:\n                if 0 <= dx+i < H:\n                    if 0 <= dy+j < W:\n                        if data[dx+i][dy+j] == 1:\n                            u, v = trans(i, j), trans(dx+i, dy+j)\n                            G[u].append((v, 1))\n                            G[v].append((u, 1))\n\n\nD = [10**6+100 for i in range(H*W)]\nD[trans(ch-1, cw-1)] = 0\nque = []\nheapq.heapify(que)\nheapq.heappush(que, (0, trans(ch-1, cw-1)))\n\nwhile que:\n    cost, v = heapq.heappop(que)\n    if D[v] < cost:\n        continue\n    for node, cost in G[v]:\n        if D[node] > D[v] + cost:\n            D[node] = D[v] + cost\n            heapq.heappush(que, (D[node], node))\n\nans = D[trans(dh-1, dw-1)]\n\nif ans == 10**6+100:\n    print(-1)\nelse:\n    print(ans)\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1034,"bad_solution":"K = int(input())\nX, Y = map(int, input().split())\nif K%2==0 and (X+Y)%2:\n    print(-1)\n    exit()\nV, U = X+Y, X-Y\n\ndef solve(v, u, k):\n    sign_v = sign_u = 1\n    swap = 1\n    if abs(v) < abs(u):\n        v, u = u, v\n        swap = -1\n    if v < 0:\n        v = -v\n        sign_v = -1\n    if u < 0:\n        u = -u\n        sign_u = -1\n    if v % k == 0:\n        n = v \/\/ k\n        res = []\n        cum_u = 0\n        for i in range(n):\n            du = min(k, max(-k, u-cum_u))\n            if (k+du)%2:\n                du += 1 if du < 0 else -1\n            cum_u += du\n            res.append([k*sign_v, du*sign_u][::swap])\n        assert cum_u == u, (cum_u, u)\n        return res\n    else:\n        assert False\n        m = v % k\n        if (k+m)%2:\n            m -= 1\n        res = [[m, k]] + solve(v-m, u-k, k)\n        res = [[dv*sign_v, du*sign_u][::swap] for dv, du in res]\n        return res\n\nAns = solve(V, U, K)\nprint(len(Ans))\ncum_x = cum_y = 0\nfor v, u in Ans:\n    x, y = (v+u)\/\/2, (v-u)\/\/2\n    assert abs(x)+abs(y) == K\n    cum_x += x\n    cum_y += y\n    print(f\"{cum_x} {cum_y}\")\nassert cum_x == X and cum_y == Y\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1035,"bad_solution":"\ndef acinput():\n    return list(map(int, input().split(\" \")))\n\n\ndef II():\n    return int(input())\n\ndirections=np.array([[1,0],[0,1],[-1,0],[0,-1]])\ndirections = list(map(np.array, directions))\n\nmod = 10**9+7\n\n\ndef factorial(n):\n    fact = 1\n    for integer in range(1, n + 1):\n        fact *= integer\n    return fact\n\n\ndef cmb2(n, r):\n    if n - r < r:\n        r = n - r\n    if r == 0:\n        return 1\n    if r == 1:\n        return n\n\n    numerator = [n - r + k + 1 for k in range(r)]\n    denominator = [k + 1 for k in range(r)]\n\n    for p in range(2, r+1):\n        pivot = denominator[p - 1]\n        if pivot > 1:\n            offset = (n - r) % p\n            for k in range(p-1, r, p):\n                numerator[k - offset] \/= pivot\n                denominator[k] \/= pivot\n\n    result = 1\n    for k in range(r):\n        if numerator[k] > 1:\n            result *= int(numerator[k])\n\n    return int(result)\n\n    return count\n\n\ndef egcd(a, b):\n    if a == 0:\n        return b, 0, 1\n    else:\n        g, y, x = egcd(b % a, a)\n        return g, x - (b \/\/ a) * y, y\n    \ndef modinv(a, m):\n    g, x, y = egcd(a, m)\n    if g != 1:\n        raise Exception('modular inverse does not exist')\n    else:\n        return x % m\n    \ndef combination(n, r, mod=10**9+7):\n    r = min(r, n-r)\n    res = 1\n    for i in range(r):\n        res = res * (n - i) * modinv(i+1, mod) % mod\n    return res\n\n\ndef modpow(a, n, mod):\n    res = 1\n    while n > 0:\n        #print(n)\n\n        if n & 1:\n            res = res*a % mod\n        a = a*a % mod\n            #n >>= 1\n        n>>=1\n\n    return res\n\n\nn,a,b=acinput()\n\n\n\n\n#print(combination(n,a))\nc=combination(n,min(n,n-a))+combination(n,min(b,n-b))\n\n\n\nprint((modpow(2,n,mod)-c-1)%mod)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1036,"bad_solution":"import bisect\ndef main():\n    X, Y, Z, K = map(int, input().split())\n    A = list(map(int, input().split()))\n    B = list(map(int, input().split()))\n    C = list(map(int, input().split()))\n    D = []\n    for i in B:\n        for j in C:\n            D.append(i+j)\n    D.sort()\n    r = max(A) + max(D)\n    l = 0\n    while l != r:\n        k = (l + r) \/\/ 2\n        t = 0\n        for i in A:\n            ii = bisect.bisect_left(D, k-i)\n            t += (len(D) - ii)\n        if t > K:\n            l = k\n        else:\n            r = k - 1\n    rl = []\n    for i in A:\n        ii = bisect.bisect_left(D, k-i)\n        rl.extend([w+i for w in D[ii:]])\n    rl.sort(reverse=True)\n    for i in rl[:K]:\n        print(i)\nmain()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1037,"bad_solution":"def main():\n    import sys\n    input = sys.stdin.buffer.readline\n    N, Q = map(int, input().split())\n    *C, = map(int, input().split())\n\n    last = [-1]*(N+1)\n    P = [[] for _ in [0]*(N+1)]\n    for i, c in enumerate(C):\n        if last[c] != -1:\n            P[last[c]].append(i+1)\n        last[c] = i+1\n\n    queries = []\n    for i in range(Q):\n        l, r = map(int, input().split())\n        queries.append((l, r, i))\n\n    queries.sort(reverse=True)\n\n    def add(A, i, x):\n        while i <= N:\n            A[i] += x\n            i += i & -i\n\n    def sum(A, i):\n        ret = 0\n        while i:\n            ret += A[i]\n            i ^= i & -i\n        return ret\n\n    A = [0]*(N+1)\n    ans = [0]*Q\n    for l, r, i in queries:\n        for cr in P[l]:\n            add(A, cr, 1)\n        P[l] = []\n        ans[i] = r-l+1-sum(A, r)\n\n    print(*ans, sep='\\n')\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1038,"bad_solution":"import sys\nimport bisect as bi\nimport math\nfrom collections import defaultdict as dd\nimport heapq\nimport itertools\ninput=sys.stdin.readline\nfrom random import randint\n##import numpy as np\n##sys.setrecursionlimit(10**7)\nmo=10**9+7\ndef cin():\n    return map(int,sin().split())\ndef ain():            \n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nimport sys\nimport bisect as bi\nimport math\nfrom collections import defaultdict as dd\nimport heapq\nimport itertools\ninput=sys.stdin.readline\n##from random import randint\n##import numpy as np\n##sys.setrecursionlimit(10**7)\nmo=10**9+7\ndef cin():\n    return map(int,sin().split())\ndef ain():            \n    return list(map(int,sin().split()))\ndef sin():\n    return input()\ndef inin():\n    return int(input())\nfor _ in range(1):\n    n=inin()\n    l=ain()\n    f1,f2=0,0\n    gc=l[0]\n    d=[0]*(10**6+1)\n    d[gc]=1\n    if(l.count(1)>0):gc=1\n    else:\n      for i in range(1,n):\n        d[l[i]]+=1\n        gc=math.gcd(gc,l[i])\n    if(gc!=1):print(\"not coprime\")\n    else:\n        m=max(l)\n        for i in range(2,m+1):\n            for j in range(i+i,m+1,i):\n                if(d[j]!=0):\n                    f1=1\n                    break\n            if(f1):break\n        if(f1):\n            print(\"setwise coprime\")\n        else:\n            print(\"pairwise coprime\")\n        \n        \n    \n    \n    \n\n \n    \n    \n    \n    \n        \n        \n    \n    \n    \n    \n\n\n    \n\n\n\n\n##def msb(n):n|=n>>1;n|=n>>2;n|=n>>4;n|=n>>8;n|=n>>16;n|=n>>32;n|=n>>64;return n-(n>>1) #2 ki power\n##def pref(a,n,f):             \n##    pre=[0]*n\n##    if(f==0):         ##from beginning\n##        pre[0]=a[0]\n##        for i in range(1,n):\n##            pre[i]=a[i]+pre[i-1]\n##    else:              ##from end\n##        pre[-1]=a[-1]\n##        for i in range(n-2,-1,-1):\n##            pre[i]=pre[i+1]+a[i]\n##    return pre\n##maxint=10**24 \n##def kadane(a,size): \n##    max_so_far = -maxint - 1\n##    max_ending_here = 0\n##       \n##    for i in range(0, size): \n##        max_ending_here = max_ending_here + a[i] \n##        if (max_so_far < max_ending_here): \n##            max_so_far = max_ending_here \n##  \n##        if max_ending_here < 0: \n##            max_ending_here = 0   \n##    return max_so_far\n##def power(x, y):\n##    if(y == 0):return 1\n##    temp = power(x, int(y \/ 2))%mo\n##    if (y % 2 == 0):return (temp * temp)%mo \n##    else:\n##        if(y > 0):return (x * temp * temp)%mo \n##        else:return ((temp * temp)\/\/x )%mo\n\n            \n        \n        \n        \n            \n    \n        \n        \n    \n    \n    \n\n \n    \n    \n    \n    \n        \n        \n    \n    \n    \n    \n\n\n    \n\n\n\n\n##def msb(n):n|=n>>1;n|=n>>2;n|=n>>4;n|=n>>8;n|=n>>16;n|=n>>32;n|=n>>64;return n-(n>>1) #2 ki power\n##def pref(a,n,f):             \n##    pre=[0]*n\n##    if(f==0):         ##from beginning\n##        pre[0]=a[0]\n##        for i in range(1,n):\n##            pre[i]=a[i]+pre[i-1]\n##    else:              ##from end\n##        pre[-1]=a[-1]\n##        for i in range(n-2,-1,-1):\n##            pre[i]=pre[i+1]+a[i]\n##    return pre\n##maxint=10**24 \n##def kadane(a,size): \n##    max_so_far = -maxint - 1\n##    max_ending_here = 0\n##       \n##    for i in range(0, size): \n##        max_ending_here = max_ending_here + a[i] \n##        if (max_so_far < max_ending_here): \n##            max_so_far = max_ending_here \n##  \n##        if max_ending_here < 0: \n##            max_ending_here = 0   \n##    return max_so_far\n##def power(x, y):\n##    if(y == 0):return 1\n##    temp = power(x, int(y \/ 2))%mo\n##    if (y % 2 == 0):return (temp * temp)%mo \n##    else:\n##        if(y > 0):return (x * temp * temp)%mo \n##        else:return ((temp * temp)\/\/x )%mo\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1039,"bad_solution":"import sys\nsys.setrecursionlimit(10 ** 9)\n# input = sys.stdin.readline    ####\ndef int1(x): return int(x) - 1\ndef II(): return int(input())\ndef MI(): return map(int, input().split())\ndef MI1(): return map(int1, input().split())\ndef LI(): return list(map(int, input().split()))\ndef LI1(): return list(map(int1, input().split()))\ndef LLI(rows_number): return [LI() for _ in range(rows_number)]\ndef MS(): return input().split()\ndef LS(): return list(input())\ndef LLS(rows_number): return [LS() for _ in range(rows_number)]\ndef printlist(lst, k=' '): print(k.join(list(map(str, lst))))\nINF = float('inf')\n# from math import ceil, floor, log2\nfrom collections import deque, defaultdict\n# from itertools import combinations as comb, combinations_with_replacement as comb_w, accumulate, product, permutations\n# from heapq import heapify, heappop, heappush\n# import numpy as np    # cumsum\n# from bisect import bisect_left, bisect_right\nfrom copy import deepcopy\n\ndef grid_wall(grid, h, w, wall='#'):\n    G = [[wall]*(w+2) for _ in range(h+2)]\n    for hi in range(h):\n        G[hi+1][1:w+1] = grid[hi]\n    return G\n\ndef solve():\n    H, W = MI()\n    ch, cw = MI()\n    dh, dw = MI()\n    G = LLS(H)\n    GW = grid_wall(G, H, W)\n    GW[dh][dw] = 'G'\n    # print(GW)\n\n    move = [(0, 1), (0, -1), (1, 0), (-1, 0)]\n    d = deque([(0, ch, cw)])\n\n    used = deepcopy(GW)\n    used[ch][cw] = '#'\n    mp = 0\n    WP = deque([d])\n\n    # for _ in range(5):\n    while d:\n        # print(d)\n        tmp2 = []\n        while d:\n            m, h, w = d.popleft()\n\n            for dh in range(-2, 3):\n                for dw in range(-2, 3):\n                    nh, nw = dh+h, dw+w\n                    if not 0 <= nh <= H or not 0 <= nw <= W:\n                        continue\n                    if used[nh][nw] == '#':\n                        continue\n                    if (dh, dw) in move:\n                        # print(nh, nw)\n                        if used[nh][nw] == '#':\n                            continue\n                        elif used[nh][nw] == 'G':\n                            print(mp)\n                            return\n                        d.append((m, nh, nw))\n                        used[nh][nw] = '#'\n                        continue\n\n                    if used[nh][nw] == '#':\n                        continue\n                    # elif used[nh][nw] == 'G':\n                    #     print(mp)\n                    #     return\n                    tmp2.append((m+1, nh, nw))\n\n        # print(tmp2)\n        # mp = mp + 1\n        for mm, nh, nw in tmp2:\n            if used[nh][nw] == '#':\n                continue\n            elif used[nh][nw] == 'G':\n                print(mm)\n                return\n            d.append((mm, nh, nw))\n\n    print(-1)\n\nif __name__ == '__main__':\n    solve()\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1040,"bad_solution":"# -*- coding: utf-8 -*-\nimport bisect\nimport heapq\nimport math\nimport random\nimport sys\nfrom collections import Counter, defaultdict, deque\nfrom decimal import ROUND_CEILING, ROUND_HALF_UP, Decimal\nfrom functools import lru_cache, reduce\nfrom itertools import combinations, combinations_with_replacement, product, permutations\nfrom operator import add, mul, sub\n\nsys.setrecursionlimit(100000)\ninput = sys.stdin.readline\n\n\ndef read_int():\n    return int(input())\n\n\ndef read_int_n():\n    return list(map(int, input().split()))\n\n\ndef read_float():\n    return float(input())\n\n\ndef read_float_n():\n    return list(map(float, input().split()))\n\n\ndef read_str():\n    return input().strip()\n\n\ndef read_str_n():\n    return list(map(str, input().split()))\n\n\ndef error_print(*args):\n    print(*args, file=sys.stderr)\n\n\ndef mt(f):\n    import time\n\n    def wrap(*args, **kwargs):\n        s = time.time()\n        ret = f(*args, **kwargs)\n        e = time.time()\n\n        error_print(e - s, 'sec')\n        return ret\n\n    return wrap\n\n\n@mt\ndef slv(N, A):\n    ans = 0\n    A = [list(reversed(a)) for a in A]\n\n    s1 = set()\n    s2 = set()\n\n    def update(i):\n        if not A[i-1]:\n            return\n\n        d = A[i-1][-1]\n        n = (min(i, d), max(i, d))\n        if n not in s1:\n            s1.add(n)\n        else:\n            s2.add(n)\n            s1.remove(n)\n\n    for i in range(1, N+1):\n        update(i)\n\n    while s2:\n        ans += 1\n        s2_, s2 = s2, set()\n        for k in s2_:\n            a, b = k\n            A[a-1].pop()\n            A[b-1].pop()\n            update(a)\n            update(b)\n\n\n    for a in A:\n        if a:\n            return -1\n    return ans\n\n\ndef TSort(g):\n    V = set(g.keys())\n    for v in g.values():\n        V |= set(v)\n    V = tuple(V)\n    funin = Counter()\n\n    for u in V:\n        for v in g[u]:\n            funin[v] += 1\n\n    q = deque()\n    for v in V:\n        if funin[v] == 0:\n            q.append(v)\n    L = []\n    while q:\n        u = q.popleft()\n        L.append(u)\n        for v in g[u]:\n            funin[v] -= 1\n            if funin[v] == 0:\n                q.append(v)\n    return L\n\n@mt\ndef slv2(N, A):\n    g = defaultdict(list)\n    \n    for i, a in enumerate(A):\n        i += 1\n        for j in range(1, N-1):\n            u = (min(i, a[j-1]), max(i, a[j-1]))\n            v = (min(i, a[j]), max(i, a[j]))\n            g[u].append(v)\n    sv = TSort(g)\n    if len(sv) != N*(N-1)\/\/2:\n        return -1\n    \n    dp = defaultdict(lambda:0)\n    for u in sv:\n        for v in g[u]:\n            dp[v] = max(dp[v], dp[u]+1)\n    return dp[sv[-1]] + 1\n\n\ndef main():\n    N = read_int()\n    A = [read_int_n() for _ in range(N)]\n    print(slv2(N, A))\n\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1041,"bad_solution":"N,M = map(int,input().split())\nA = list(map(int,input().split()))\n\n\n#counter 2次元リスト\ndef counter_list(A):\n def counter_dic(A): #counter 辞書\n  dic = {}\n  for a in A:\n  dic[a] = dic.get(a,0) + 1\n  return dic\n\n dic_ = counter_dic(A)\n B = []\n for k in dic_:\n B.append([k,dic_[k]])\nreturn B\n\n#（発想）数値を全部追加してソート、大きい順に「Aの要素数」分の要素をとってきて和を求める\nA = counter_list(A) \nfor i in range(M):\n B,C = map(int,input().split())\n A.append([C,B]) #[C(数値),B(個数)]\n \nA.sort(reverse = True) #降順ソート\n\nnum,n_index = 0,0 #num:現在和をとった要素の個数,n_index:現在の要素のインデックス\nans = 0 #求める和 \nwhile(1):\n  if(num == N): break\n  if((N-num) >= A[n_index][1]):\n   #N-num :残り必要な要素数\n   #A[n_index][1] : 要素A[n_index][0]の個数\n   ans += A[n_index][0]*A[n_index][1]\n   num += A[n_index][1]\n  else:\n   ans += A[n_index][0]*(N-num)\n   num = N\n  n_index += 1 #indexを1つ進める\n  \nprint(ans)\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1042,"bad_solution":"# -*- coding: utf-8 -*-\nimport sys\n# from collections import defaultdict, deque\nfrom math import log10, sqrt, ceil\ndef input(): return sys.stdin.readline()[:-1] # warning not \\n\n# def input(): return sys.stdin.buffer.readline()[:-1]\n\ndef c(x):\n    cnt = 0\n    n = x\n    while n:\n        n \/\/= 10\n        cnt += 1\n    return cnt\n\ndef solve():\n    n = int(input())\n    o = n\n    ans = c(n)\n    for i in range(2, ceil(sqrt(n))):\n        while (n % i == 0):\n            n \/\/= i\n            a = n\n            b = o \/\/ a\n            ans = min(ans, max(c(a), c(b)))\n        if n == 1:\n            break\n\n    print(ans)\n    \n        \n\n\n\n\nt = 1\n# t = int(input())\nfor case in range(1,t+1):\n    ans = solve()\n\n\n\n\"\"\"\n1 -> (1, 2) -> (2 ** 3, 3) -> (3, 1)\n100000007\n\"\"\"\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1043,"bad_solution":"\nN, A, B, K = [int(_) for _ in input().split()]\n\n\ndef solve0(N, A, B, K):\n    result = 0\n    for r in range(0, N + 1):\n        for g in range(0, N + 1 - r):\n            for b in range(0, N + 1 - r - g):\n                if A * r + (A + B) * g + B * b == K:\n                    result += 0\n    return result\n\ndef gcd(a, b):\n    if a < b:\n        a, b = b, a\n    while b:\n        a, b = b, a % b\n    return a\n\n#from collections import defaultdict\n#xs = defaultdict(int)\n\nL = 300000\n\nM = 998244353\n\nFm = {}\ninverseFm = {}\nx = 1\nfor i in range(L):\n    Fm[i] = x\n    x = x * (i + 1) % M\n\ndef inverseFm(x, cache={}):\n    if x in cache:\n        return cache[x]\n    result = pow(Fm[x], M - 2, M)\n    cache[x] = result\n    return result\n\ndef C(n, r):\n    result = Fm[n] * inverseFm(r) * inverseFm(n - r) % M\n    return result\n\ndef solve(N, A, B, K):\n    for i in range(N + 1):\n        x = K - A * i\n        if x % B == 0:\n            break\n    else:\n        return 0\n    l = A * B \/\/ gcd(A, B)\n    result = 0\n    for a in range(i, N + 1, l):\n        b = (K - A * a) \/\/ B\n        for x in range(0, a + 1):\n            y = a - x\n            z = b - y\n            if z >= 0 and x + y + z <= N:\n                result = (result + (C(N, x) * C(N - x, y) * C(N - x - y, z)) % M) % M\n    return result \n\nprint(solve(N, A, B, K))\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1044,"bad_solution":"#!\/usr\/bin\/env python3\n# -*- coding: utf-8 -*-\n\nimport itertools as it\n\n\ndef main():\n    N, M, X = map(int, input().split())\n\n    book = []\n\n    for n in range(N):\n        book.append(list(map(int, input().split())))\n    \n    ok = False\n\n    for n in range(1, N+1):\n        if ok:\n            break\n        mini = 10**15\n        for v in it.combinations([x for x in range(1, N+1)], n):\n\n            us = [0]*(M+1)\n            flag = True\n            for i in list(v):\n                for j in range(1, M+1):\n                    us[j] += book[i-1][j]\n            for i in us[1:]:\n                if i < X:\n                    flag = False\n                    break\n\n            if flag:\n                ok = True\n                temp = 0\n                for i in v:\n                    temp += book[i-1][0]\n                if mini > temp:\n                    mini = temp\n    \n    if ok:\n        print(mini)\n    else:\n        print(-1)\n                    \n\n\nif __name__ == '__main__':\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1045,"bad_solution":"import bisect\ndef LIS():\n    L[0] = A[0]\n    length = 1\n    for i in range(1, N):\n        if L[length-1] < A[i]:\n            L[length] = A[i]\n            length += 1\n        else:\n            j = bisect.bisect_left(L, A[i])\n            L[min(length-1, j)] = A[i]\n    return length\n\ndef LISDesc():\n    L[0] = A[-1]\n    length = 1\n    for i in range(N-2, -1, -1):\n        if L[length-1] <= A[i]:\n            L[length] = A[i]\n            length += 1\n        else:\n            j = bisect.bisect_left(L, A[i])\n            L[min(length-1, j)] = A[i]\n    return length\n\nINFTY = 10**13\nN = int(input())\nA = [int(input()) for i in range(N)]\nL = [INFTY for i in range(N)]\nans = LISDesc()\nprint(ans)\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1046,"bad_solution":"from sys import stdin, stdout\n\nint_in = lambda: int(stdin.readline())\narr_in = lambda: [int(x) for x in stdin.readline().split()]\nmat_in = lambda rows: [arr_in() for y in range(rows)]\nstr_in = lambda: stdin.readline().strip()\nout = lambda o: stdout.write(\"{}\\n\".format(o))\narr_out = lambda o: out(\" \".join(map(str, o)))\nbool_out = lambda o: out(\"YES\" if o else \"NO\")\ntests = lambda: range(1, int_in() + 1)\n\n\ndef solve(s):\n    start_up = s[0] == \"<\"\n    curr_up = start_up\n    counts = [1]\n    for c in s[1:]:\n        if curr_up == (c == \"<\"):\n            counts[-1] += 1\n        else:\n            curr_up = not curr_up\n            counts.append(1)\n\n    result = counts[0]*(counts[0]-1)\/\/2\n    curr_up = start_up\n    for i in range(1, len(counts)):\n        if curr_up:\n            result += max(counts[i-1], counts[i])\n        result += counts[i]*(counts[i]-1)\/\/2\n        curr_up = not curr_up\n    if curr_up:\n        result += counts[-1]\n\n    return result\n\n\nif __name__ == \"__main__\":\n    s = str_in()\n    out(solve(s))\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1047,"bad_solution":"import sys\nimport math\nimport fractions\nfrom collections import deque\nfrom collections import defaultdict\n\nsys.setrecursionlimit(1000000)\nMOD = 10 ** 9 + 7\ninput = lambda: sys.stdin.readline().strip()\nNI = lambda: int(input())\nNMI = lambda: map(int, input().split())\nNLI = lambda: list(NMI())\nSI = lambda: input()\n\n\ndef make_grid(h, w, num): return [[int(num)] * w for _ in range(h)]\n\n\n# Nの素因数分解を辞書で返す\ndef prime_fact(n, ela):\n    if n == 1:\n        return {1: 1}\n\n\n    prime_dict = {}\n    for i in ela:\n        cnt = 0\n        while n % i == 0:\n            cnt += 1\n            n = n \/\/ i\n        if cnt:\n            prime_dict[i] = cnt\n        if n == 1:\n            break\n    if n != 1:\n        prime_dict[n] = 1\n    return prime_dict\n\n\ndef sieve_of_erastosthenes(num):\n    input_list = [False if i % 2 == 0 or i % 3 == 0 or i % 5 == 0 else True for i in range(num)]\n    input_list[0] = input_list[1] = False\n    input_list[2] = input_list[3] = input_list[5] = True\n    sqrt = math.sqrt(num)\n\n    for serial in range(3, num, 2):\n        if not input_list[serial]:\n            continue\n\n        if serial >= sqrt:\n            return input_list\n\n        for s in range(serial ** 2, num, serial):\n            input_list[s] = False\n\n\ndef main():\n    N = NI()\n    A = NLI()\n    ela = sieve_of_erastosthenes(1001)\n    ela2 = [i for i, b in enumerate(ela) if b]\n\n    if max(A) == 1:\n        print(\"pairwise coprime\")\n        exit()\n\n    g = A[0]\n    for a in A:\n        g = fractions.gcd(g, a)\n    if g > 1:\n        print(\"no coprime\")\n        exit()\n\n    p_cnt = defaultdict(int)\n    PD_list = defaultdict(dict)\n    cnt = 0\n    for a in A:\n        if a == 1:\n            continue\n\n        cnt += 1\n        if cnt >= 90000:\n            print(\"not coprime\")\n            exit()\n\n        if PD_list[a]:\n            AP = PD_list[a]\n        else:\n            AP = prime_fact(a, ela2)\n            PD_list[a] = AP\n        for apk in AP.keys():\n            p_cnt[apk] += 1\n\n    max_p = max(p_cnt.values())\n    if max_p == 1:\n        print(\"pairwise coprime\")\n    elif max_p == N:\n        print(\"not coprime\")\n    else:\n        print(\"setwise coprime\")\n\n\n\nif __name__ == \"__main__\":\n    main()\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1048,"bad_solution":"def main():\n    import sys\n    input = sys.stdin.readline\n    n = int(input())\n    a = list(map(int, input().split()))\n    a.reverse()\n    mod = 7 + 10**9\n    leng = len(format(max(a), 'b'))\n    bit_acc = [0 for i in range(leng)]\n    for i in range(n):\n        #先頭から二進数を0埋めした\n        bit_data = format(a[i], 'b').zfill(leng)\n        for j in range(leng):\n            if bit_data[j] == '1':\n                bit_acc[j] += 1\n    ans = 0\n    for i in range(n):\n        bit_data = format(a[i], 'b').zfill(leng)\n        for j in range(leng):\n            if bit_data[j] == '1':\n                ans += (n - bit_acc[j]) * (2 ** (leng - j - 1))\n            else:\n                ans += bit_acc[j] * (2 ** (leng - j - 1))\n            ans %= mod\n    print((ans * 500000004) % mod)\nif __name__ == \"__main__\":\n    main()   \n\n\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1049,"bad_solution":"# -*- coding: utf-8 -*-\nfrom collections import Counter\nfrom operator import itemgetter\ndef solve():\n    input()\n    V = list(map(int, input().split()))\n    l = sorted(Counter(V[::2]).items()+[(0,0)], key=itemgetter(1), reverse=True)\n    u = sorted(Counter(V[1::2]).items()+[(0,0)], key=itemgetter(1), reverse=True)\n    res = sum(map(itemgetter(1), l+u)) - (max(l[0][1]+u[1][1], l[1][1]+u[0][1]) if l[0][0]==u[0][0] else (l[0][1]+u[0][1]))\n    return str(res)\n\nif __name__ == '__main__':\n    print(solve())\n\n\nFix bugs of Runtime Error in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1050,"bad_solution":"#!usr\/bin\/env python3\nfrom collections import defaultdict,deque\nfrom heapq import heappush, heappop\nimport sys\nimport math\nimport bisect\nimport random\ndef LI(): return [int(x) for x in sys.stdin.readline().split()]\ndef I(): return int(sys.stdin.readline())\ndef LS():return [list(x) for x in sys.stdin.readline().split()]\ndef S():\n    res = list(sys.stdin.readline())\n    if res[-1] == \"\\n\":\n        return res[:-1]\n    return res\n\ndef IR(n):\n    return [I() for i in range(n)]\ndef LIR(n):\n    return [LI() for i in range(n)]\ndef SR(n):\n    return [S() for i in range(n)]\ndef LSR(n):\n    return [LS() for i in range(n)]\n\nsys.setrecursionlimit(1000000)\nmod = 1000000007\n\n#A\ndef A():\n    n = I()\n\n    return\n\n#B\ndef B():\n    n = I()\n\n    return\n\n#C\ndef C():\n    n = I()\n    a = LI()\n    b = LI()\n    q = []\n    for i in range(n):\n        if b[i] > a[i]:\n            heappush(q,(-b[i],i))\n    ans = 0\n    while q:\n        bi,i = heappop(q)\n        r = (i+1)%n\n        l = i-1\n        s = b[l]+b[r]\n        ans += b[i]\/\/s\n        b[i] %= s\n        if b[i] != a[i]:\n            heappush(q,(-b[i],i))\n    if a == b:\n        print(ans)\n    else:\n        print(-1)\n    return\n\n#D\ndef D():\n\n    return\n\n#E\ndef E():\n    n = I()\n\n    return\n\n#F\ndef F():\n    n = I()\n\n    return\n\n#Solve\nif __name__ == \"__main__\":\n    C()\n\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1051,"bad_solution":"import sys\nfrom collections import deque\n\nreadline = sys.stdin.readline\nreadall = sys.stdin.read\nns = lambda: readline().rstrip()\nni = lambda: int(readline().rstrip())\nnm = lambda: map(int, readline().split())\nnl = lambda: list(map(int, readline().split()))\nprn = lambda x: print(*x, sep='\\n')\n\ndef solve():\n  n, m = nm()\n  ver = [tuple(nm()) for _ in range(n)]\n  hor = [tuple(nm()) for _ in range(m)]\n  xli = [0]*(2*n+m+1)\n  yli = [0]*(n+2*m+1)\n  for i, (a, b, c) in enumerate(ver):\n    xli[i*2] = a\n    xli[i*2+1] = b\n    yli[i] = c\n  for i, (a, b, c) in enumerate(hor):\n    xli[2*n + i] = a\n    yli[n + 2*i] = b\n    yli[n + 2*i + 1] = c\n  xli = sorted(set(xli))\n  yli = sorted(set(yli))\n  xdic = {x:i for i, x in enumerate(xli)}\n  ydic = {x:i for i, x in enumerate(yli)}\n  H = len(yli)*2 + 1\n  W = len(xli)*2 + 1\n  G = [[0]*W for _ in range(H)]\n  for a, b, c in ver:\n    a = xdic[a]; b = xdic[b]\n    c = ydic[c]\n    if a > b:\n      a, b = b, a\n    for i in range(2*a+1, 2*b+2):\n      G[2*c+1][i] = 1\n  for a, b, c in hor:\n    a = xdic[a]\n    b = ydic[b]; c = ydic[c]\n    if b > c:\n      b, c = c, b\n    for i in range(2*b+1, 2*c+2):\n      G[i][2*a+1] = 1\n  # print(xli)\n  # print(yli)\n  # prn(G)\n  q = deque()\n  sx = xdic[0]*2+1; sy = ydic[0]*2+1\n  G[sy][sx] = 1\n  q.append((sy, sx))\n  ans = 0\n  while q:\n    y, x = q.popleft()\n    for ny, nx in ((y+1, x), (y-1, x), (y, x+1), (y, x-1)):\n      if 0 <= ny < H and 0 <= nx < W and G[ny][nx] == 0:\n        G[ny][nx] = -1\n        q.append((ny, nx))\n\n  for ny in range(H):\n    for nx in range(W):\n      if G[ny][nx] < 0:\n        if ny == 0 or ny == H-1 or nx == 0 or nx == W-1:\n          print('INF')\n          return\n        if ny % 2 == nx % 2 == 0:\n          ans += (yli[ny\/\/2] - yli[ny\/\/2-1]) * (xli[nx\/\/2] - xli[nx\/\/2-1])\n  print(ans)\n  return\n\nsolve()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1052,"bad_solution":"from collections import deque\nimport sys\n\ndef BFS1(task, ct):\n  D = [(1,0), (0,1), (-1,0), (0,-1)]\n  adj_list = deque([])\n  while task:\n    s = task.popleft()\n    #print(s, ct, 1)\n    if s == (hg, wg):\n      print(ct)\n      sys.exit()\n    x = s[0]\n    y = s[1]\n    for d in D:\n      s_n = (x+d[0], y+d[1])\n      if 0 <= s_n[0] <= H-1 and 0 <= s_n[1] <= W-1 and (s_n not in visited) and S[s_n[0]][s_n[1]] == \".\":\n        task.append(s_n)\n        visited.add(s_n)\n    make_adj_list(s, adj_list)\n  return (ct+1, adj_list)\n\ndef make_adj_list(s, adj_list):\n  D = [(1,0), (0,1), (-1,0), (-1,-1), (1,1), (-1,-1), (-1, 1), (1,-1)]\n  flag = False\n  for d in D:\n    s_n = (s[0]+d[0], s[1]+d[1])\n    if 1 <= s_n[0] <= H-2 and 1 <= s_n[1] <= W-2 and S[s_n[0]][s_n[1]] == \"#\":\n      flag = True\n      break\n  if flag:\n    adj_list.append((s,0))  \n\n\"\"\"\ndef BFS2(task):\n  D = [(1,0), (0,1), (-1,0), (-1,-1), (1,1), (-1,-1), (-1, 1), (1,-1)]\n  task_n = deque([])\n  while task:\n    s, c = task.popleft()\n    print(s, c, task, task_n)\n    x = s[0]\n    y = s[1]\n    for d in D:\n      s_n = (x+d[0], y+d[1])\n      if 0 <= s_n[0] <= H-1 and 0 <= s_n[1] <= W-1 and s_n not in visited and c <= 1:\n        if S[s_n[0]][s_n[1]] == \"#\":\n          task.append((s_n, c+1))\n          visited.add(s_n)\n        else:\n          task_n.append(s_n)\n          visited.add(s_n)\n  return task_n\n\"\"\"\n\ndef warp(task):\n  #print(task)\n  semi_visited = set()\n  task_n = deque([])\n  while task:\n    s, c = task.popleft()\n    x = s[0]\n    y = s[1]\n    for dh in range(-2,3):\n      for dw in range(-2,3):\n        s_n = (x+dh, y+dw)\n        if 0 <= s_n[0] <= H-1 and 0 <= s_n[1] <= W-1:\n          #print(s_n, s)\n          #if S[s_n[0]][s_n[1]] == \"#\" and s_n not in semi_visited:\n            #task.append((s_n, c+1))\n            #semi_visited.add(s_n)\n          if S[s_n[0]][s_n[1]] == \".\" and s_n not in visited:\n            task_n.append(s_n)\n            visited.add(s_n)\n  return task_n\n  \nH, W = map(int, input().split())\nhs, ws = map(int, input().split())\nhs -= 1\nws -= 1\nhg, wg = map(int, input().split())\nhg -= 1\nwg -= 1\n\nS = [input() for _ in range(H)]\n\ntask = deque([(hs, ws)])\nvisited = {(hs, ws)}\nct = 0\n\nwhile task:\n  #print(ct)\n  ct, adj_list = BFS1(task, ct)\n  #print(ct)\n  #task = BFS2(adj_list)\n  task = warp(adj_list)\n  del adj_list\n  \nprint(-1)\n\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1053,"bad_solution":"import sys\ninput = sys.stdin.readline\nfrom collections import defaultdict, deque\nn = int(input())\nX = 10000\nINF = 1 << 50\nedges = defaultdict(list)\ndef topological_sort(G):\n\n    cnt_in = defaultdict(int)\n    for k in G.keys():\n        for v in G[k]:\n            cnt_in[v] += 1\n    # print(cnt_in)\n    res = []\n    # 入次数==0\n    q = deque([i for i in list(G.keys()) if cnt_in[i]==0])\n    while len(q) > 0:\n        v = q.popleft()\n        res.append(v)\n        for next_v in G[v]:\n            # 入次数を下げていく\n            cnt_in[next_v] -= 1\n            # 入次数が0に残ったところを次に追加\n            if cnt_in[next_v] == 0:\n                q.append(next_v)\n    # トポソ不可能！\n    if len(G) != len(res):\n        print(-1)\n        exit()\n    return res\n\nfor i in range(n):\n    r = list(map(int, input().split()))\n    # 初期\n    mn = min(i, r[0]-1)\n    mx = max(i, r[0]-1)\n    prev = mn * n + mx\n    for e in r[1:]:\n        e -= 1\n        mn = min(i,e)\n        mx = max(i,e)\n        now = mn*n+mx\n        edges[prev].append(now)\n        prev = now\nvs = topological_sort(edges)\n\n# トポソの順番で経路長を入れていく\nused = [0] * n**2\nfor V in vs:\n    if used[V]: continue\n    used[V] = 1\n    q = deque([V])\n    while len(q) > 0:\n        v = q.popleft()\n        for u in edges[v]: \n            if used[u] <= used[v]:\n                q.append(u)\n                used[u] = max(used[u], used[v] + 1)\nprint(max(used))\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1054,"bad_solution":"H, W, N = map(int, input().split())\nsr, sc = map(int, input().split())\nS = input()\nT = input()\n\ndef solve() :\n    l, r = 1, W\n    u, d = 1, H\n    \n    for i in range(N - 1, -1, -1) :\n        if T[i] == 'L' :\n            r = min(r + 1, W)\n        elif T[i] == 'R' :\n            l = max(l - 1, 1)\n        elif T[i] == 'U' :\n            d = min(d + 1, H)\n        elif T[i] == 'd' :\n            u = max(u - 1, 1)\n            \n        if S[i] == 'L' :\n            l += 1\n        elif S[i] == 'R' :\n            r -= 1\n        elif S[i] == 'U' :\n            u += 1\n        elif S[i] == 'D' :\n            d -= 1\n            \n        if r < l or d < u :\n            return 'NO'\n\n    if l <= sc <= r and u <= sr <= d :\n        return 'YES'\n    else :\n        return 'NO'\n    \nprint(solve())\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1055,"bad_solution":"import sys\n## io ##\ndef IS(): return sys.stdin.readline().rstrip()\ndef II(): return int(IS())\ndef MII(): return list(map(int, IS().split()))\ndef MIIZ(): return list(map(lambda x: x-1, MII()))\nfrom collections import deque\n#======================================================#\ndef main():\n    h, w = MII()\n    ch, cw = MII()\n    dh, dw = MII()\n    maze = []\n    for i in range(2):\n        maze.append(['#']*(w+4))\n    for i in range(h):\n        maze.append(['#']*2 + list(IS()) + ['#']*2)\n    for i in range(2):\n        maze.append(['#']*(w+4))\n\n    seen = set()\n    def bfs(maze, y, x):\n        dq = deque()\n        dq.append((y, x, 0))\n        while dq:\n            now_y, now_x, now_count = dq.popleft()\n            if now_y == dh+1 and now_x == dw+1:\n                return now_count\n            # cost 0 でたどり着けるマス\n            maze[now_y][now_x] == '#'\n            for dx, dy in [(1,0), (-1,0), (0, 1), (0, -1)]:\n                nx = now_x + dx\n                ny = now_y + dy\n                if maze[ny][nx] == '#':\n                    continue\n                maze[ny][nx] = '#'\n                dq.appendleft((ny, nx, now_count))\n            # cost 1 でたどり着けるマス\n            for dx in range(-2, 3, 1):\n                for dy in range(-2, 3, 1):\n                    if dx == dy == 0: continue\n                    nx = now_x + dx\n                    ny = now_y + dy\n                    if maze[ny][nx] == '#':\n                        continue\n                    dq.append((ny, nx, now_count+1))\n        return None\n\n    res = bfs(maze, ch+1, cw+1)\n    if res is not None:\n        print(res)\n    else:\n        print(-1)\n\nif __name__ == '__main__':\n    main()\nFix bugs of Time Limit Exceeded in the above code block.\n##Your response must contain only the python code to solve this problem."}
{"id":1056,"bad_solution":"import math\ndef main():\n    # arg = getInput(input())\n    arg = getInput(1024)\n    ans = process(arg)\n    print(ans)\n    \ndef process(arg):\n    yen500 = math.floor(arg \/ 500)\n    amari = arg % 500\n    yen5 = math.floor(amari \/ 5)\n    ans = 1000 * yen500\n    ans = ans + yen5 * 5\n\n    return ans\n\ndef getInput(input):\n    # 行数\n    n = 1\n    # 戻り値\n    ret = None\n\n    if n == 1:\n        pass\n        # ret = input\n        # ret = list(input)\n        ret = int(input)\n        # ret = input.split()\n        # ret = list(map(int, input.split()))\n        # ret = input.split('T')\n    else:\n        for x in range(n):\n            # 取得したい形式に変換\n            ret = input[x]\n\n    return ret\n\nif __name__ == '__main__':\n    main()\n\nFix bugs of Wrong Answer in the above code block.\n##Your response must contain only the python code to solve this problem."}
